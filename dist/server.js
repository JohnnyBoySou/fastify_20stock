var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// src/generated/prisma/runtime/library.js
var require_library = __commonJS({
  "src/generated/prisma/runtime/library.js"(exports2, module2) {
    "use strict";
    var yu = Object.create;
    var jt = Object.defineProperty;
    var bu = Object.getOwnPropertyDescriptor;
    var Eu = Object.getOwnPropertyNames;
    var wu = Object.getPrototypeOf;
    var xu = Object.prototype.hasOwnProperty;
    var Do = (e, r) => () => (e && (r = e(e = 0)), r);
    var ue = (e, r) => () => (r || e((r = { exports: {} }).exports, r), r.exports);
    var tr = (e, r) => {
      for (var t in r) jt(e, t, { get: r[t], enumerable: true });
    };
    var Oo = (e, r, t, n) => {
      if (r && typeof r == "object" || typeof r == "function") for (let i of Eu(r)) !xu.call(e, i) && i !== t && jt(e, i, { get: () => r[i], enumerable: !(n = bu(r, i)) || n.enumerable });
      return e;
    };
    var O = (e, r, t) => (t = e != null ? yu(wu(e)) : {}, Oo(r || !e || !e.__esModule ? jt(t, "default", { value: e, enumerable: true }) : t, e));
    var vu = (e) => Oo(jt({}, "__esModule", { value: true }), e);
    var hi = ue((_g, is) => {
      "use strict";
      is.exports = (e, r = process.argv) => {
        let t = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--", n = r.indexOf(t + e), i = r.indexOf("--");
        return n !== -1 && (i === -1 || n < i);
      };
    });
    var as = ue((Ng, ss) => {
      "use strict";
      var Fc = require("os"), os = require("tty"), de = hi(), { env: G } = process, Qe;
      de("no-color") || de("no-colors") || de("color=false") || de("color=never") ? Qe = 0 : (de("color") || de("colors") || de("color=true") || de("color=always")) && (Qe = 1);
      "FORCE_COLOR" in G && (G.FORCE_COLOR === "true" ? Qe = 1 : G.FORCE_COLOR === "false" ? Qe = 0 : Qe = G.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(G.FORCE_COLOR, 10), 3));
      function yi(e) {
        return e === 0 ? false : { level: e, hasBasic: true, has256: e >= 2, has16m: e >= 3 };
      }
      function bi(e, r) {
        if (Qe === 0) return 0;
        if (de("color=16m") || de("color=full") || de("color=truecolor")) return 3;
        if (de("color=256")) return 2;
        if (e && !r && Qe === void 0) return 0;
        let t = Qe || 0;
        if (G.TERM === "dumb") return t;
        if (process.platform === "win32") {
          let n = Fc.release().split(".");
          return Number(n[0]) >= 10 && Number(n[2]) >= 10586 ? Number(n[2]) >= 14931 ? 3 : 2 : 1;
        }
        if ("CI" in G) return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((n) => n in G) || G.CI_NAME === "codeship" ? 1 : t;
        if ("TEAMCITY_VERSION" in G) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(G.TEAMCITY_VERSION) ? 1 : 0;
        if (G.COLORTERM === "truecolor") return 3;
        if ("TERM_PROGRAM" in G) {
          let n = parseInt((G.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
          switch (G.TERM_PROGRAM) {
            case "iTerm.app":
              return n >= 3 ? 3 : 2;
            case "Apple_Terminal":
              return 2;
          }
        }
        return /-256(color)?$/i.test(G.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(G.TERM) || "COLORTERM" in G ? 1 : t;
      }
      function Mc(e) {
        let r = bi(e, e && e.isTTY);
        return yi(r);
      }
      ss.exports = { supportsColor: Mc, stdout: yi(bi(true, os.isatty(1))), stderr: yi(bi(true, os.isatty(2))) };
    });
    var cs = ue((Lg, us) => {
      "use strict";
      var $c = as(), br = hi();
      function ls(e) {
        if (/^\d{3,4}$/.test(e)) {
          let t = /(\d{1,2})(\d{2})/.exec(e) || [];
          return { major: 0, minor: parseInt(t[1], 10), patch: parseInt(t[2], 10) };
        }
        let r = (e || "").split(".").map((t) => parseInt(t, 10));
        return { major: r[0], minor: r[1], patch: r[2] };
      }
      function Ei(e) {
        let { CI: r, FORCE_HYPERLINK: t, NETLIFY: n, TEAMCITY_VERSION: i, TERM_PROGRAM: o, TERM_PROGRAM_VERSION: s, VTE_VERSION: a, TERM: l } = process.env;
        if (t) return !(t.length > 0 && parseInt(t, 10) === 0);
        if (br("no-hyperlink") || br("no-hyperlinks") || br("hyperlink=false") || br("hyperlink=never")) return false;
        if (br("hyperlink=true") || br("hyperlink=always") || n) return true;
        if (!$c.supportsColor(e) || e && !e.isTTY) return false;
        if ("WT_SESSION" in process.env) return true;
        if (process.platform === "win32" || r || i) return false;
        if (o) {
          let u = ls(s || "");
          switch (o) {
            case "iTerm.app":
              return u.major === 3 ? u.minor >= 1 : u.major > 3;
            case "WezTerm":
              return u.major >= 20200620;
            case "vscode":
              return u.major > 1 || u.major === 1 && u.minor >= 72;
            case "ghostty":
              return true;
          }
        }
        if (a) {
          if (a === "0.50.0") return false;
          let u = ls(a);
          return u.major > 0 || u.minor >= 50;
        }
        switch (l) {
          case "alacritty":
            return true;
        }
        return false;
      }
      us.exports = { supportsHyperlink: Ei, stdout: Ei(process.stdout), stderr: Ei(process.stderr) };
    });
    var ps = ue((Kg, qc) => {
      qc.exports = { name: "@prisma/internals", version: "6.16.2", description: "This package is intended for Prisma's internal use", main: "dist/index.js", types: "dist/index.d.ts", repository: { type: "git", url: "https://github.com/prisma/prisma.git", directory: "packages/internals" }, homepage: "https://www.prisma.io", author: "Tim Suchanek <suchanek@prisma.io>", bugs: "https://github.com/prisma/prisma/issues", license: "Apache-2.0", scripts: { dev: "DEV=true tsx helpers/build.ts", build: "tsx helpers/build.ts", test: "dotenv -e ../../.db.env -- jest --silent", prepublishOnly: "pnpm run build" }, files: ["README.md", "dist", "!**/libquery_engine*", "!dist/get-generators/engines/*", "scripts"], devDependencies: { "@babel/helper-validator-identifier": "7.25.9", "@opentelemetry/api": "1.9.0", "@swc/core": "1.11.5", "@swc/jest": "0.2.37", "@types/babel__helper-validator-identifier": "7.15.2", "@types/jest": "29.5.14", "@types/node": "18.19.76", "@types/resolve": "1.20.6", archiver: "6.0.2", "checkpoint-client": "1.1.33", "cli-truncate": "4.0.0", dotenv: "16.5.0", empathic: "2.0.0", "escape-string-regexp": "5.0.0", execa: "5.1.1", "fast-glob": "3.3.3", "find-up": "7.0.0", "fp-ts": "2.16.9", "fs-extra": "11.3.0", "fs-jetpack": "5.1.0", "global-directory": "4.0.0", globby: "11.1.0", "identifier-regex": "1.0.0", "indent-string": "4.0.0", "is-windows": "1.0.2", "is-wsl": "3.1.0", jest: "29.7.0", "jest-junit": "16.0.0", kleur: "4.1.5", "mock-stdin": "1.0.0", "new-github-issue-url": "0.2.1", "node-fetch": "3.3.2", "npm-packlist": "5.1.3", open: "7.4.2", "p-map": "4.0.0", resolve: "1.22.10", "string-width": "7.2.0", "strip-indent": "4.0.0", "temp-dir": "2.0.0", tempy: "1.0.1", "terminal-link": "4.0.0", tmp: "0.2.3", "ts-pattern": "5.6.2", "ts-toolbelt": "9.6.0", typescript: "5.4.5", yarn: "1.22.22" }, dependencies: { "@prisma/config": "workspace:*", "@prisma/debug": "workspace:*", "@prisma/dmmf": "workspace:*", "@prisma/driver-adapter-utils": "workspace:*", "@prisma/engines": "workspace:*", "@prisma/fetch-engine": "workspace:*", "@prisma/generator": "workspace:*", "@prisma/generator-helper": "workspace:*", "@prisma/get-platform": "workspace:*", "@prisma/prisma-schema-wasm": "6.16.0-7.1c57fdcd7e44b29b9313256c76699e91c3ac3c43", "@prisma/schema-engine-wasm": "6.16.0-7.1c57fdcd7e44b29b9313256c76699e91c3ac3c43", "@prisma/schema-files-loader": "workspace:*", arg: "5.0.2", prompts: "2.4.2" }, peerDependencies: { typescript: ">=5.1.0" }, peerDependenciesMeta: { typescript: { optional: true } }, sideEffects: false };
    });
    var Ti = ue((gh, Qc) => {
      Qc.exports = { name: "@prisma/engines-version", version: "6.16.0-7.1c57fdcd7e44b29b9313256c76699e91c3ac3c43", main: "index.js", types: "index.d.ts", license: "Apache-2.0", author: "Tim Suchanek <suchanek@prisma.io>", prisma: { enginesVersion: "1c57fdcd7e44b29b9313256c76699e91c3ac3c43" }, repository: { type: "git", url: "https://github.com/prisma/engines-wrapper.git", directory: "packages/engines-version" }, devDependencies: { "@types/node": "18.19.76", typescript: "4.9.5" }, files: ["index.js", "index.d.ts"], scripts: { build: "tsc -d" } };
    });
    var on = ue((nn) => {
      "use strict";
      Object.defineProperty(nn, "__esModule", { value: true });
      nn.enginesVersion = void 0;
      nn.enginesVersion = Ti().prisma.enginesVersion;
    });
    var hs = ue((Ih, gs) => {
      "use strict";
      gs.exports = (e) => {
        let r = e.match(/^[ \t]*(?=\S)/gm);
        return r ? r.reduce((t, n) => Math.min(t, n.length), 1 / 0) : 0;
      };
    });
    var Di = ue((kh, Es) => {
      "use strict";
      Es.exports = (e, r = 1, t) => {
        if (t = { indent: " ", includeEmptyLines: false, ...t }, typeof e != "string") throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof e}\``);
        if (typeof r != "number") throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof r}\``);
        if (typeof t.indent != "string") throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof t.indent}\``);
        if (r === 0) return e;
        let n = t.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
        return e.replace(n, t.indent.repeat(r));
      };
    });
    var vs = ue((jh, tp) => {
      tp.exports = { name: "dotenv", version: "16.5.0", description: "Loads environment variables from .env file", main: "lib/main.js", types: "lib/main.d.ts", exports: { ".": { types: "./lib/main.d.ts", require: "./lib/main.js", default: "./lib/main.js" }, "./config": "./config.js", "./config.js": "./config.js", "./lib/env-options": "./lib/env-options.js", "./lib/env-options.js": "./lib/env-options.js", "./lib/cli-options": "./lib/cli-options.js", "./lib/cli-options.js": "./lib/cli-options.js", "./package.json": "./package.json" }, scripts: { "dts-check": "tsc --project tests/types/tsconfig.json", lint: "standard", pretest: "npm run lint && npm run dts-check", test: "tap run --allow-empty-coverage --disable-coverage --timeout=60000", "test:coverage": "tap run --show-full-coverage --timeout=60000 --coverage-report=lcov", prerelease: "npm test", release: "standard-version" }, repository: { type: "git", url: "git://github.com/motdotla/dotenv.git" }, homepage: "https://github.com/motdotla/dotenv#readme", funding: "https://dotenvx.com", keywords: ["dotenv", "env", ".env", "environment", "variables", "config", "settings"], readmeFilename: "README.md", license: "BSD-2-Clause", devDependencies: { "@types/node": "^18.11.3", decache: "^4.6.2", sinon: "^14.0.1", standard: "^17.0.0", "standard-version": "^9.5.0", tap: "^19.2.0", typescript: "^4.8.4" }, engines: { node: ">=12" }, browser: { fs: false } };
    });
    var As = ue((Bh, _e4) => {
      "use strict";
      var Fi = require("fs"), Mi = require("path"), np = require("os"), ip = require("crypto"), op = vs(), Ts = op.version, sp = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
      function ap(e) {
        let r = {}, t = e.toString();
        t = t.replace(/\r\n?/mg, `
`);
        let n;
        for (; (n = sp.exec(t)) != null; ) {
          let i = n[1], o = n[2] || "";
          o = o.trim();
          let s = o[0];
          o = o.replace(/^(['"`])([\s\S]*)\1$/mg, "$2"), s === '"' && (o = o.replace(/\\n/g, `
`), o = o.replace(/\\r/g, "\r")), r[i] = o;
        }
        return r;
      }
      function lp(e) {
        let r = Rs(e), t = B.configDotenv({ path: r });
        if (!t.parsed) {
          let s = new Error(`MISSING_DATA: Cannot parse ${r} for an unknown reason`);
          throw s.code = "MISSING_DATA", s;
        }
        let n = Ss(e).split(","), i = n.length, o;
        for (let s = 0; s < i; s++) try {
          let a = n[s].trim(), l = cp(t, a);
          o = B.decrypt(l.ciphertext, l.key);
          break;
        } catch (a) {
          if (s + 1 >= i) throw a;
        }
        return B.parse(o);
      }
      function up(e) {
        console.log(`[dotenv@${Ts}][WARN] ${e}`);
      }
      function ot(e) {
        console.log(`[dotenv@${Ts}][DEBUG] ${e}`);
      }
      function Ss(e) {
        return e && e.DOTENV_KEY && e.DOTENV_KEY.length > 0 ? e.DOTENV_KEY : process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0 ? process.env.DOTENV_KEY : "";
      }
      function cp(e, r) {
        let t;
        try {
          t = new URL(r);
        } catch (a) {
          if (a.code === "ERR_INVALID_URL") {
            let l = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
            throw l.code = "INVALID_DOTENV_KEY", l;
          }
          throw a;
        }
        let n = t.password;
        if (!n) {
          let a = new Error("INVALID_DOTENV_KEY: Missing key part");
          throw a.code = "INVALID_DOTENV_KEY", a;
        }
        let i = t.searchParams.get("environment");
        if (!i) {
          let a = new Error("INVALID_DOTENV_KEY: Missing environment part");
          throw a.code = "INVALID_DOTENV_KEY", a;
        }
        let o = `DOTENV_VAULT_${i.toUpperCase()}`, s = e.parsed[o];
        if (!s) {
          let a = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${o} in your .env.vault file.`);
          throw a.code = "NOT_FOUND_DOTENV_ENVIRONMENT", a;
        }
        return { ciphertext: s, key: n };
      }
      function Rs(e) {
        let r = null;
        if (e && e.path && e.path.length > 0) if (Array.isArray(e.path)) for (let t of e.path) Fi.existsSync(t) && (r = t.endsWith(".vault") ? t : `${t}.vault`);
        else r = e.path.endsWith(".vault") ? e.path : `${e.path}.vault`;
        else r = Mi.resolve(process.cwd(), ".env.vault");
        return Fi.existsSync(r) ? r : null;
      }
      function Ps(e) {
        return e[0] === "~" ? Mi.join(np.homedir(), e.slice(1)) : e;
      }
      function pp(e) {
        !!(e && e.debug) && ot("Loading env from encrypted .env.vault");
        let t = B._parseVault(e), n = process.env;
        return e && e.processEnv != null && (n = e.processEnv), B.populate(n, t, e), { parsed: t };
      }
      function dp(e) {
        let r = Mi.resolve(process.cwd(), ".env"), t = "utf8", n = !!(e && e.debug);
        e && e.encoding ? t = e.encoding : n && ot("No encoding is specified. UTF-8 is used by default");
        let i = [r];
        if (e && e.path) if (!Array.isArray(e.path)) i = [Ps(e.path)];
        else {
          i = [];
          for (let l of e.path) i.push(Ps(l));
        }
        let o, s = {};
        for (let l of i) try {
          let u = B.parse(Fi.readFileSync(l, { encoding: t }));
          B.populate(s, u, e);
        } catch (u) {
          n && ot(`Failed to load ${l} ${u.message}`), o = u;
        }
        let a = process.env;
        return e && e.processEnv != null && (a = e.processEnv), B.populate(a, s, e), o ? { parsed: s, error: o } : { parsed: s };
      }
      function mp(e) {
        if (Ss(e).length === 0) return B.configDotenv(e);
        let r = Rs(e);
        return r ? B._configVault(e) : (up(`You set DOTENV_KEY but you are missing a .env.vault file at ${r}. Did you forget to build it?`), B.configDotenv(e));
      }
      function fp(e, r) {
        let t = Buffer.from(r.slice(-64), "hex"), n = Buffer.from(e, "base64"), i = n.subarray(0, 12), o = n.subarray(-16);
        n = n.subarray(12, -16);
        try {
          let s = ip.createDecipheriv("aes-256-gcm", t, i);
          return s.setAuthTag(o), `${s.update(n)}${s.final()}`;
        } catch (s) {
          let a = s instanceof RangeError, l = s.message === "Invalid key length", u = s.message === "Unsupported state or unable to authenticate data";
          if (a || l) {
            let c = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
            throw c.code = "INVALID_DOTENV_KEY", c;
          } else if (u) {
            let c = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
            throw c.code = "DECRYPTION_FAILED", c;
          } else throw s;
        }
      }
      function gp(e, r, t = {}) {
        let n = !!(t && t.debug), i = !!(t && t.override);
        if (typeof r != "object") {
          let o = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
          throw o.code = "OBJECT_REQUIRED", o;
        }
        for (let o of Object.keys(r)) Object.prototype.hasOwnProperty.call(e, o) ? (i === true && (e[o] = r[o]), n && ot(i === true ? `"${o}" is already defined and WAS overwritten` : `"${o}" is already defined and was NOT overwritten`)) : e[o] = r[o];
      }
      var B = { configDotenv: dp, _configVault: pp, _parseVault: lp, config: mp, decrypt: fp, parse: ap, populate: gp };
      _e4.exports.configDotenv = B.configDotenv;
      _e4.exports._configVault = B._configVault;
      _e4.exports._parseVault = B._parseVault;
      _e4.exports.config = B.config;
      _e4.exports.decrypt = B.decrypt;
      _e4.exports.parse = B.parse;
      _e4.exports.populate = B.populate;
      _e4.exports = B;
    });
    var Os = ue((Kh, cn) => {
      "use strict";
      cn.exports = (e = {}) => {
        let r;
        if (e.repoUrl) r = e.repoUrl;
        else if (e.user && e.repo) r = `https://github.com/${e.user}/${e.repo}`;
        else throw new Error("You need to specify either the `repoUrl` option or both the `user` and `repo` options");
        let t = new URL(`${r}/issues/new`), n = ["body", "title", "labels", "template", "milestone", "assignee", "projects"];
        for (let i of n) {
          let o = e[i];
          if (o !== void 0) {
            if (i === "labels" || i === "projects") {
              if (!Array.isArray(o)) throw new TypeError(`The \`${i}\` option should be an array`);
              o = o.join(",");
            }
            t.searchParams.set(i, o);
          }
        }
        return t.toString();
      };
      cn.exports.default = cn.exports;
    });
    var Ki = ue((vb, ea) => {
      "use strict";
      ea.exports = /* @__PURE__ */ (function() {
        function e(r, t, n, i, o) {
          return r < t || n < t ? r > n ? n + 1 : r + 1 : i === o ? t : t + 1;
        }
        return function(r, t) {
          if (r === t) return 0;
          if (r.length > t.length) {
            var n = r;
            r = t, t = n;
          }
          for (var i = r.length, o = t.length; i > 0 && r.charCodeAt(i - 1) === t.charCodeAt(o - 1); ) i--, o--;
          for (var s = 0; s < i && r.charCodeAt(s) === t.charCodeAt(s); ) s++;
          if (i -= s, o -= s, i === 0 || o < 3) return o;
          var a = 0, l, u, c, p, d, f, h, g, I, T, S, b, D = [];
          for (l = 0; l < i; l++) D.push(l + 1), D.push(r.charCodeAt(s + l));
          for (var me = D.length - 1; a < o - 3; ) for (I = t.charCodeAt(s + (u = a)), T = t.charCodeAt(s + (c = a + 1)), S = t.charCodeAt(s + (p = a + 2)), b = t.charCodeAt(s + (d = a + 3)), f = a += 4, l = 0; l < me; l += 2) h = D[l], g = D[l + 1], u = e(h, u, c, I, g), c = e(u, c, p, T, g), p = e(c, p, d, S, g), f = e(p, d, f, b, g), D[l] = f, d = p, p = c, c = u, u = h;
          for (; a < o; ) for (I = t.charCodeAt(s + (u = a)), f = ++a, l = 0; l < me; l += 2) h = D[l], D[l] = f = e(h, u, f, I, D[l + 1]), u = h;
          return f;
        };
      })();
    });
    var oa = Do(() => {
      "use strict";
    });
    var sa = Do(() => {
      "use strict";
    });
    var jf = {};
    tr(jf, { DMMF: () => ct, Debug: () => N, Decimal: () => Fe, Extensions: () => ni, MetricsClient: () => Lr, PrismaClientInitializationError: () => P, PrismaClientKnownRequestError: () => z, PrismaClientRustPanicError: () => ae, PrismaClientUnknownRequestError: () => V, PrismaClientValidationError: () => Z, Public: () => ii, Sql: () => ie, createParam: () => va, defineDmmfProperty: () => Ca, deserializeJsonResponse: () => Vr, deserializeRawResult: () => Xn, dmmfToRuntimeDataModel: () => Ns, empty: () => Oa, getPrismaClient: () => fu, getRuntime: () => Kn, join: () => Da, makeStrictEnum: () => gu, makeTypedQueryFactory: () => Ia, objectEnumValues: () => On, raw: () => no, serializeJsonQuery: () => $n, skip: () => Mn, sqltag: () => io, warnEnvConflicts: () => hu, warnOnce: () => at });
    module2.exports = vu(jf);
    var ni = {};
    tr(ni, { defineExtension: () => ko, getExtensionContext: () => _o });
    function ko(e) {
      return typeof e == "function" ? e : (r) => r.$extends(e);
    }
    function _o(e) {
      return e;
    }
    var ii = {};
    tr(ii, { validator: () => No });
    function No(...e) {
      return (r) => r;
    }
    var Bt = {};
    tr(Bt, { $: () => qo, bgBlack: () => ku, bgBlue: () => Fu, bgCyan: () => $u, bgGreen: () => Nu, bgMagenta: () => Mu, bgRed: () => _u, bgWhite: () => qu, bgYellow: () => Lu, black: () => Cu, blue: () => nr, bold: () => W, cyan: () => De, dim: () => Ce, gray: () => Hr, green: () => qe, grey: () => Ou, hidden: () => Ru, inverse: () => Su, italic: () => Tu, magenta: () => Iu, red: () => ce, reset: () => Pu, strikethrough: () => Au, underline: () => Y, white: () => Du, yellow: () => Ie });
    var oi;
    var Lo;
    var Fo;
    var Mo;
    var $o = true;
    typeof process < "u" && ({ FORCE_COLOR: oi, NODE_DISABLE_COLORS: Lo, NO_COLOR: Fo, TERM: Mo } = process.env || {}, $o = process.stdout && process.stdout.isTTY);
    var qo = { enabled: !Lo && Fo == null && Mo !== "dumb" && (oi != null && oi !== "0" || $o) };
    function F(e, r) {
      let t = new RegExp(`\\x1b\\[${r}m`, "g"), n = `\x1B[${e}m`, i = `\x1B[${r}m`;
      return function(o) {
        return !qo.enabled || o == null ? o : n + (~("" + o).indexOf(i) ? o.replace(t, i + n) : o) + i;
      };
    }
    var Pu = F(0, 0);
    var W = F(1, 22);
    var Ce = F(2, 22);
    var Tu = F(3, 23);
    var Y = F(4, 24);
    var Su = F(7, 27);
    var Ru = F(8, 28);
    var Au = F(9, 29);
    var Cu = F(30, 39);
    var ce = F(31, 39);
    var qe = F(32, 39);
    var Ie = F(33, 39);
    var nr = F(34, 39);
    var Iu = F(35, 39);
    var De = F(36, 39);
    var Du = F(37, 39);
    var Hr = F(90, 39);
    var Ou = F(90, 39);
    var ku = F(40, 49);
    var _u = F(41, 49);
    var Nu = F(42, 49);
    var Lu = F(43, 49);
    var Fu = F(44, 49);
    var Mu = F(45, 49);
    var $u = F(46, 49);
    var qu = F(47, 49);
    var Vu = 100;
    var Vo = ["green", "yellow", "blue", "magenta", "cyan", "red"];
    var Yr = [];
    var jo = Date.now();
    var ju = 0;
    var si = typeof process < "u" ? process.env : {};
    globalThis.DEBUG ?? (globalThis.DEBUG = si.DEBUG ?? "");
    globalThis.DEBUG_COLORS ?? (globalThis.DEBUG_COLORS = si.DEBUG_COLORS ? si.DEBUG_COLORS === "true" : true);
    var zr = { enable(e) {
      typeof e == "string" && (globalThis.DEBUG = e);
    }, disable() {
      let e = globalThis.DEBUG;
      return globalThis.DEBUG = "", e;
    }, enabled(e) {
      let r = globalThis.DEBUG.split(",").map((i) => i.replace(/[.+?^${}()|[\]\\]/g, "\\$&")), t = r.some((i) => i === "" || i[0] === "-" ? false : e.match(RegExp(i.split("*").join(".*") + "$"))), n = r.some((i) => i === "" || i[0] !== "-" ? false : e.match(RegExp(i.slice(1).split("*").join(".*") + "$")));
      return t && !n;
    }, log: (...e) => {
      let [r, t, ...n] = e;
      (console.warn ?? console.log)(`${r} ${t}`, ...n);
    }, formatters: {} };
    function Bu(e) {
      let r = { color: Vo[ju++ % Vo.length], enabled: zr.enabled(e), namespace: e, log: zr.log, extend: () => {
      } }, t = (...n) => {
        let { enabled: i, namespace: o, color: s, log: a } = r;
        if (n.length !== 0 && Yr.push([o, ...n]), Yr.length > Vu && Yr.shift(), zr.enabled(o) || i) {
          let l = n.map((c) => typeof c == "string" ? c : Uu(c)), u = `+${Date.now() - jo}ms`;
          jo = Date.now(), globalThis.DEBUG_COLORS ? a(Bt[s](W(o)), ...l, Bt[s](u)) : a(o, ...l, u);
        }
      };
      return new Proxy(t, { get: (n, i) => r[i], set: (n, i, o) => r[i] = o });
    }
    var N = new Proxy(Bu, { get: (e, r) => zr[r], set: (e, r, t) => zr[r] = t });
    function Uu(e, r = 2) {
      let t = /* @__PURE__ */ new Set();
      return JSON.stringify(e, (n, i) => {
        if (typeof i == "object" && i !== null) {
          if (t.has(i)) return "[Circular *]";
          t.add(i);
        } else if (typeof i == "bigint") return i.toString();
        return i;
      }, r);
    }
    function Bo(e = 7500) {
      let r = Yr.map(([t, ...n]) => `${t} ${n.map((i) => typeof i == "string" ? i : JSON.stringify(i)).join(" ")}`).join(`
`);
      return r.length < e ? r : r.slice(-e);
    }
    function Uo() {
      Yr.length = 0;
    }
    var gr = N;
    var Go = O(require("fs"));
    function ai() {
      let e = process.env.PRISMA_QUERY_ENGINE_LIBRARY;
      if (!(e && Go.default.existsSync(e)) && process.arch === "ia32") throw new Error('The default query engine type (Node-API, "library") is currently not supported for 32bit Node. Please set `engineType = "binary"` in the "generator" block of your "schema.prisma" file (or use the environment variables "PRISMA_CLIENT_ENGINE_TYPE=binary" and/or "PRISMA_CLI_QUERY_ENGINE_TYPE=binary".)');
    }
    var li = ["darwin", "darwin-arm64", "debian-openssl-1.0.x", "debian-openssl-1.1.x", "debian-openssl-3.0.x", "rhel-openssl-1.0.x", "rhel-openssl-1.1.x", "rhel-openssl-3.0.x", "linux-arm64-openssl-1.1.x", "linux-arm64-openssl-1.0.x", "linux-arm64-openssl-3.0.x", "linux-arm-openssl-1.1.x", "linux-arm-openssl-1.0.x", "linux-arm-openssl-3.0.x", "linux-musl", "linux-musl-openssl-3.0.x", "linux-musl-arm64-openssl-1.1.x", "linux-musl-arm64-openssl-3.0.x", "linux-nixos", "linux-static-x64", "linux-static-arm64", "windows", "freebsd11", "freebsd12", "freebsd13", "freebsd14", "freebsd15", "openbsd", "netbsd", "arm"];
    var Ut = "libquery_engine";
    function Gt(e, r) {
      let t = r === "url";
      return e.includes("windows") ? t ? "query_engine.dll.node" : `query_engine-${e}.dll.node` : e.includes("darwin") ? t ? `${Ut}.dylib.node` : `${Ut}-${e}.dylib.node` : t ? `${Ut}.so.node` : `${Ut}-${e}.so.node`;
    }
    var Ko = O(require("child_process"));
    var mi = O(require("fs/promises"));
    var Ht = O(require("os"));
    var Oe = Symbol.for("@ts-pattern/matcher");
    var Gu = Symbol.for("@ts-pattern/isVariadic");
    var Wt = "@ts-pattern/anonymous-select-key";
    var ui = (e) => !!(e && typeof e == "object");
    var Qt = (e) => e && !!e[Oe];
    var Ee = (e, r, t) => {
      if (Qt(e)) {
        let n = e[Oe](), { matched: i, selections: o } = n.match(r);
        return i && o && Object.keys(o).forEach((s) => t(s, o[s])), i;
      }
      if (ui(e)) {
        if (!ui(r)) return false;
        if (Array.isArray(e)) {
          if (!Array.isArray(r)) return false;
          let n = [], i = [], o = [];
          for (let s of e.keys()) {
            let a = e[s];
            Qt(a) && a[Gu] ? o.push(a) : o.length ? i.push(a) : n.push(a);
          }
          if (o.length) {
            if (o.length > 1) throw new Error("Pattern error: Using `...P.array(...)` several times in a single pattern is not allowed.");
            if (r.length < n.length + i.length) return false;
            let s = r.slice(0, n.length), a = i.length === 0 ? [] : r.slice(-i.length), l = r.slice(n.length, i.length === 0 ? 1 / 0 : -i.length);
            return n.every((u, c) => Ee(u, s[c], t)) && i.every((u, c) => Ee(u, a[c], t)) && (o.length === 0 || Ee(o[0], l, t));
          }
          return e.length === r.length && e.every((s, a) => Ee(s, r[a], t));
        }
        return Reflect.ownKeys(e).every((n) => {
          let i = e[n];
          return (n in r || Qt(o = i) && o[Oe]().matcherType === "optional") && Ee(i, r[n], t);
          var o;
        });
      }
      return Object.is(r, e);
    };
    var Ge = (e) => {
      var r, t, n;
      return ui(e) ? Qt(e) ? (r = (t = (n = e[Oe]()).getSelectionKeys) == null ? void 0 : t.call(n)) != null ? r : [] : Array.isArray(e) ? Zr(e, Ge) : Zr(Object.values(e), Ge) : [];
    };
    var Zr = (e, r) => e.reduce((t, n) => t.concat(r(n)), []);
    function pe(e) {
      return Object.assign(e, { optional: () => Qu(e), and: (r) => q(e, r), or: (r) => Wu(e, r), select: (r) => r === void 0 ? Qo(e) : Qo(r, e) });
    }
    function Qu(e) {
      return pe({ [Oe]: () => ({ match: (r) => {
        let t = {}, n = (i, o) => {
          t[i] = o;
        };
        return r === void 0 ? (Ge(e).forEach((i) => n(i, void 0)), { matched: true, selections: t }) : { matched: Ee(e, r, n), selections: t };
      }, getSelectionKeys: () => Ge(e), matcherType: "optional" }) });
    }
    function q(...e) {
      return pe({ [Oe]: () => ({ match: (r) => {
        let t = {}, n = (i, o) => {
          t[i] = o;
        };
        return { matched: e.every((i) => Ee(i, r, n)), selections: t };
      }, getSelectionKeys: () => Zr(e, Ge), matcherType: "and" }) });
    }
    function Wu(...e) {
      return pe({ [Oe]: () => ({ match: (r) => {
        let t = {}, n = (i, o) => {
          t[i] = o;
        };
        return Zr(e, Ge).forEach((i) => n(i, void 0)), { matched: e.some((i) => Ee(i, r, n)), selections: t };
      }, getSelectionKeys: () => Zr(e, Ge), matcherType: "or" }) });
    }
    function A(e) {
      return { [Oe]: () => ({ match: (r) => ({ matched: !!e(r) }) }) };
    }
    function Qo(...e) {
      let r = typeof e[0] == "string" ? e[0] : void 0, t = e.length === 2 ? e[1] : typeof e[0] == "string" ? void 0 : e[0];
      return pe({ [Oe]: () => ({ match: (n) => {
        let i = { [r ?? Wt]: n };
        return { matched: t === void 0 || Ee(t, n, (o, s) => {
          i[o] = s;
        }), selections: i };
      }, getSelectionKeys: () => [r ?? Wt].concat(t === void 0 ? [] : Ge(t)) }) });
    }
    function ye(e) {
      return typeof e == "number";
    }
    function Ve(e) {
      return typeof e == "string";
    }
    function je(e) {
      return typeof e == "bigint";
    }
    var eg = pe(A(function(e) {
      return true;
    }));
    var Be = (e) => Object.assign(pe(e), { startsWith: (r) => {
      return Be(q(e, (t = r, A((n) => Ve(n) && n.startsWith(t)))));
      var t;
    }, endsWith: (r) => {
      return Be(q(e, (t = r, A((n) => Ve(n) && n.endsWith(t)))));
      var t;
    }, minLength: (r) => Be(q(e, ((t) => A((n) => Ve(n) && n.length >= t))(r))), length: (r) => Be(q(e, ((t) => A((n) => Ve(n) && n.length === t))(r))), maxLength: (r) => Be(q(e, ((t) => A((n) => Ve(n) && n.length <= t))(r))), includes: (r) => {
      return Be(q(e, (t = r, A((n) => Ve(n) && n.includes(t)))));
      var t;
    }, regex: (r) => {
      return Be(q(e, (t = r, A((n) => Ve(n) && !!n.match(t)))));
      var t;
    } });
    var rg = Be(A(Ve));
    var be = (e) => Object.assign(pe(e), { between: (r, t) => be(q(e, ((n, i) => A((o) => ye(o) && n <= o && i >= o))(r, t))), lt: (r) => be(q(e, ((t) => A((n) => ye(n) && n < t))(r))), gt: (r) => be(q(e, ((t) => A((n) => ye(n) && n > t))(r))), lte: (r) => be(q(e, ((t) => A((n) => ye(n) && n <= t))(r))), gte: (r) => be(q(e, ((t) => A((n) => ye(n) && n >= t))(r))), int: () => be(q(e, A((r) => ye(r) && Number.isInteger(r)))), finite: () => be(q(e, A((r) => ye(r) && Number.isFinite(r)))), positive: () => be(q(e, A((r) => ye(r) && r > 0))), negative: () => be(q(e, A((r) => ye(r) && r < 0))) });
    var tg = be(A(ye));
    var Ue = (e) => Object.assign(pe(e), { between: (r, t) => Ue(q(e, ((n, i) => A((o) => je(o) && n <= o && i >= o))(r, t))), lt: (r) => Ue(q(e, ((t) => A((n) => je(n) && n < t))(r))), gt: (r) => Ue(q(e, ((t) => A((n) => je(n) && n > t))(r))), lte: (r) => Ue(q(e, ((t) => A((n) => je(n) && n <= t))(r))), gte: (r) => Ue(q(e, ((t) => A((n) => je(n) && n >= t))(r))), positive: () => Ue(q(e, A((r) => je(r) && r > 0))), negative: () => Ue(q(e, A((r) => je(r) && r < 0))) });
    var ng = Ue(A(je));
    var ig = pe(A(function(e) {
      return typeof e == "boolean";
    }));
    var og = pe(A(function(e) {
      return typeof e == "symbol";
    }));
    var sg = pe(A(function(e) {
      return e == null;
    }));
    var ag = pe(A(function(e) {
      return e != null;
    }));
    var ci = class extends Error {
      constructor(r) {
        let t;
        try {
          t = JSON.stringify(r);
        } catch {
          t = r;
        }
        super(`Pattern matching error: no pattern matches value ${t}`), this.input = void 0, this.input = r;
      }
    };
    var pi = { matched: false, value: void 0 };
    function hr(e) {
      return new di(e, pi);
    }
    var di = class e {
      constructor(r, t) {
        this.input = void 0, this.state = void 0, this.input = r, this.state = t;
      }
      with(...r) {
        if (this.state.matched) return this;
        let t = r[r.length - 1], n = [r[0]], i;
        r.length === 3 && typeof r[1] == "function" ? i = r[1] : r.length > 2 && n.push(...r.slice(1, r.length - 1));
        let o = false, s = {}, a = (u, c) => {
          o = true, s[u] = c;
        }, l = !n.some((u) => Ee(u, this.input, a)) || i && !i(this.input) ? pi : { matched: true, value: t(o ? Wt in s ? s[Wt] : s : this.input, this.input) };
        return new e(this.input, l);
      }
      when(r, t) {
        if (this.state.matched) return this;
        let n = !!r(this.input);
        return new e(this.input, n ? { matched: true, value: t(this.input, this.input) } : pi);
      }
      otherwise(r) {
        return this.state.matched ? this.state.value : r(this.input);
      }
      exhaustive() {
        if (this.state.matched) return this.state.value;
        throw new ci(this.input);
      }
      run() {
        return this.exhaustive();
      }
      returnType() {
        return this;
      }
    };
    var Ho = require("util");
    var Ju = { warn: Ie("prisma:warn") };
    var Ku = { warn: () => !process.env.PRISMA_DISABLE_WARNINGS };
    function Jt(e, ...r) {
      Ku.warn() && console.warn(`${Ju.warn} ${e}`, ...r);
    }
    var Hu = (0, Ho.promisify)(Ko.default.exec);
    var ee = gr("prisma:get-platform");
    var Yu = ["1.0.x", "1.1.x", "3.0.x"];
    async function Yo() {
      let e = Ht.default.platform(), r = process.arch;
      if (e === "freebsd") {
        let s = await Yt("freebsd-version");
        if (s && s.trim().length > 0) {
          let l = /^(\d+)\.?/.exec(s);
          if (l) return { platform: "freebsd", targetDistro: `freebsd${l[1]}`, arch: r };
        }
      }
      if (e !== "linux") return { platform: e, arch: r };
      let t = await Zu(), n = await sc(), i = ec({ arch: r, archFromUname: n, familyDistro: t.familyDistro }), { libssl: o } = await rc(i);
      return { platform: "linux", libssl: o, arch: r, archFromUname: n, ...t };
    }
    function zu(e) {
      let r = /^ID="?([^"\n]*)"?$/im, t = /^ID_LIKE="?([^"\n]*)"?$/im, n = r.exec(e), i = n && n[1] && n[1].toLowerCase() || "", o = t.exec(e), s = o && o[1] && o[1].toLowerCase() || "", a = hr({ id: i, idLike: s }).with({ id: "alpine" }, ({ id: l }) => ({ targetDistro: "musl", familyDistro: l, originalDistro: l })).with({ id: "raspbian" }, ({ id: l }) => ({ targetDistro: "arm", familyDistro: "debian", originalDistro: l })).with({ id: "nixos" }, ({ id: l }) => ({ targetDistro: "nixos", originalDistro: l, familyDistro: "nixos" })).with({ id: "debian" }, { id: "ubuntu" }, ({ id: l }) => ({ targetDistro: "debian", familyDistro: "debian", originalDistro: l })).with({ id: "rhel" }, { id: "centos" }, { id: "fedora" }, ({ id: l }) => ({ targetDistro: "rhel", familyDistro: "rhel", originalDistro: l })).when(({ idLike: l }) => l.includes("debian") || l.includes("ubuntu"), ({ id: l }) => ({ targetDistro: "debian", familyDistro: "debian", originalDistro: l })).when(({ idLike: l }) => i === "arch" || l.includes("arch"), ({ id: l }) => ({ targetDistro: "debian", familyDistro: "arch", originalDistro: l })).when(({ idLike: l }) => l.includes("centos") || l.includes("fedora") || l.includes("rhel") || l.includes("suse"), ({ id: l }) => ({ targetDistro: "rhel", familyDistro: "rhel", originalDistro: l })).otherwise(({ id: l }) => ({ targetDistro: void 0, familyDistro: void 0, originalDistro: l }));
      return ee(`Found distro info:
${JSON.stringify(a, null, 2)}`), a;
    }
    async function Zu() {
      let e = "/etc/os-release";
      try {
        let r = await mi.default.readFile(e, { encoding: "utf-8" });
        return zu(r);
      } catch {
        return { targetDistro: void 0, familyDistro: void 0, originalDistro: void 0 };
      }
    }
    function Xu(e) {
      let r = /^OpenSSL\s(\d+\.\d+)\.\d+/.exec(e);
      if (r) {
        let t = `${r[1]}.x`;
        return zo(t);
      }
    }
    function Wo(e) {
      let r = /libssl\.so\.(\d)(\.\d)?/.exec(e);
      if (r) {
        let t = `${r[1]}${r[2] ?? ".0"}.x`;
        return zo(t);
      }
    }
    function zo(e) {
      let r = (() => {
        if (Xo(e)) return e;
        let t = e.split(".");
        return t[1] = "0", t.join(".");
      })();
      if (Yu.includes(r)) return r;
    }
    function ec(e) {
      return hr(e).with({ familyDistro: "musl" }, () => (ee('Trying platform-specific paths for "alpine"'), ["/lib", "/usr/lib"])).with({ familyDistro: "debian" }, ({ archFromUname: r }) => (ee('Trying platform-specific paths for "debian" (and "ubuntu")'), [`/usr/lib/${r}-linux-gnu`, `/lib/${r}-linux-gnu`])).with({ familyDistro: "rhel" }, () => (ee('Trying platform-specific paths for "rhel"'), ["/lib64", "/usr/lib64"])).otherwise(({ familyDistro: r, arch: t, archFromUname: n }) => (ee(`Don't know any platform-specific paths for "${r}" on ${t} (${n})`), []));
    }
    async function rc(e) {
      let r = 'grep -v "libssl.so.0"', t = await Jo(e);
      if (t) {
        ee(`Found libssl.so file using platform-specific paths: ${t}`);
        let o = Wo(t);
        if (ee(`The parsed libssl version is: ${o}`), o) return { libssl: o, strategy: "libssl-specific-path" };
      }
      ee('Falling back to "ldconfig" and other generic paths');
      let n = await Yt(`ldconfig -p | sed "s/.*=>s*//" | sed "s|.*/||" | grep libssl | sort | ${r}`);
      if (n || (n = await Jo(["/lib64", "/usr/lib64", "/lib", "/usr/lib"])), n) {
        ee(`Found libssl.so file using "ldconfig" or other generic paths: ${n}`);
        let o = Wo(n);
        if (ee(`The parsed libssl version is: ${o}`), o) return { libssl: o, strategy: "ldconfig" };
      }
      let i = await Yt("openssl version -v");
      if (i) {
        ee(`Found openssl binary with version: ${i}`);
        let o = Xu(i);
        if (ee(`The parsed openssl version is: ${o}`), o) return { libssl: o, strategy: "openssl-binary" };
      }
      return ee("Couldn't find any version of libssl or OpenSSL in the system"), {};
    }
    async function Jo(e) {
      for (let r of e) {
        let t = await tc(r);
        if (t) return t;
      }
    }
    async function tc(e) {
      try {
        return (await mi.default.readdir(e)).find((t) => t.startsWith("libssl.so.") && !t.startsWith("libssl.so.0"));
      } catch (r) {
        if (r.code === "ENOENT") return;
        throw r;
      }
    }
    async function ir() {
      let { binaryTarget: e } = await Zo();
      return e;
    }
    function nc(e) {
      return e.binaryTarget !== void 0;
    }
    async function fi() {
      let { memoized: e, ...r } = await Zo();
      return r;
    }
    var Kt = {};
    async function Zo() {
      if (nc(Kt)) return Promise.resolve({ ...Kt, memoized: true });
      let e = await Yo(), r = ic(e);
      return Kt = { ...e, binaryTarget: r }, { ...Kt, memoized: false };
    }
    function ic(e) {
      let { platform: r, arch: t, archFromUname: n, libssl: i, targetDistro: o, familyDistro: s, originalDistro: a } = e;
      r === "linux" && !["x64", "arm64"].includes(t) && Jt(`Prisma only officially supports Linux on amd64 (x86_64) and arm64 (aarch64) system architectures (detected "${t}" instead). If you are using your own custom Prisma engines, you can ignore this warning, as long as you've compiled the engines for your system architecture "${n}".`);
      let l = "1.1.x";
      if (r === "linux" && i === void 0) {
        let c = hr({ familyDistro: s }).with({ familyDistro: "debian" }, () => "Please manually install OpenSSL via `apt-get update -y && apt-get install -y openssl` and try installing Prisma again. If you're running Prisma on Docker, add this command to your Dockerfile, or switch to an image that already has OpenSSL installed.").otherwise(() => "Please manually install OpenSSL and try installing Prisma again.");
        Jt(`Prisma failed to detect the libssl/openssl version to use, and may not work as expected. Defaulting to "openssl-${l}".
${c}`);
      }
      let u = "debian";
      if (r === "linux" && o === void 0 && ee(`Distro is "${a}". Falling back to Prisma engines built for "${u}".`), r === "darwin" && t === "arm64") return "darwin-arm64";
      if (r === "darwin") return "darwin";
      if (r === "win32") return "windows";
      if (r === "freebsd") return o;
      if (r === "openbsd") return "openbsd";
      if (r === "netbsd") return "netbsd";
      if (r === "linux" && o === "nixos") return "linux-nixos";
      if (r === "linux" && t === "arm64") return `${o === "musl" ? "linux-musl-arm64" : "linux-arm64"}-openssl-${i || l}`;
      if (r === "linux" && t === "arm") return `linux-arm-openssl-${i || l}`;
      if (r === "linux" && o === "musl") {
        let c = "linux-musl";
        return !i || Xo(i) ? c : `${c}-openssl-${i}`;
      }
      return r === "linux" && o && i ? `${o}-openssl-${i}` : (r !== "linux" && Jt(`Prisma detected unknown OS "${r}" and may not work as expected. Defaulting to "linux".`), i ? `${u}-openssl-${i}` : o ? `${o}-openssl-${l}` : `${u}-openssl-${l}`);
    }
    async function oc(e) {
      try {
        return await e();
      } catch {
        return;
      }
    }
    function Yt(e) {
      return oc(async () => {
        let r = await Hu(e);
        return ee(`Command "${e}" successfully returned "${r.stdout}"`), r.stdout;
      });
    }
    async function sc() {
      return typeof Ht.default.machine == "function" ? Ht.default.machine() : (await Yt("uname -m"))?.trim();
    }
    function Xo(e) {
      return e.startsWith("1.");
    }
    var Xt = {};
    tr(Xt, { beep: () => kc, clearScreen: () => Cc, clearTerminal: () => Ic, cursorBackward: () => mc, cursorDown: () => pc, cursorForward: () => dc, cursorGetPosition: () => hc, cursorHide: () => Ec, cursorLeft: () => ts, cursorMove: () => cc, cursorNextLine: () => yc, cursorPrevLine: () => bc, cursorRestorePosition: () => gc, cursorSavePosition: () => fc, cursorShow: () => wc, cursorTo: () => uc, cursorUp: () => rs, enterAlternativeScreen: () => Dc, eraseDown: () => Tc, eraseEndLine: () => vc, eraseLine: () => ns, eraseLines: () => xc, eraseScreen: () => gi, eraseStartLine: () => Pc, eraseUp: () => Sc, exitAlternativeScreen: () => Oc, iTerm: () => Lc, image: () => Nc, link: () => _c, scrollDown: () => Ac, scrollUp: () => Rc });
    var Zt = O(require("process"), 1);
    var zt = globalThis.window?.document !== void 0;
    var gg = globalThis.process?.versions?.node !== void 0;
    var hg = globalThis.process?.versions?.bun !== void 0;
    var yg = globalThis.Deno?.version?.deno !== void 0;
    var bg = globalThis.process?.versions?.electron !== void 0;
    var Eg = globalThis.navigator?.userAgent?.includes("jsdom") === true;
    var wg = typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
    var xg = typeof DedicatedWorkerGlobalScope < "u" && globalThis instanceof DedicatedWorkerGlobalScope;
    var vg = typeof SharedWorkerGlobalScope < "u" && globalThis instanceof SharedWorkerGlobalScope;
    var Pg = typeof ServiceWorkerGlobalScope < "u" && globalThis instanceof ServiceWorkerGlobalScope;
    var Xr = globalThis.navigator?.userAgentData?.platform;
    var Tg = Xr === "macOS" || globalThis.navigator?.platform === "MacIntel" || globalThis.navigator?.userAgent?.includes(" Mac ") === true || globalThis.process?.platform === "darwin";
    var Sg = Xr === "Windows" || globalThis.navigator?.platform === "Win32" || globalThis.process?.platform === "win32";
    var Rg = Xr === "Linux" || globalThis.navigator?.platform?.startsWith("Linux") === true || globalThis.navigator?.userAgent?.includes(" Linux ") === true || globalThis.process?.platform === "linux";
    var Ag = Xr === "iOS" || globalThis.navigator?.platform === "MacIntel" && globalThis.navigator?.maxTouchPoints > 1 || /iPad|iPhone|iPod/.test(globalThis.navigator?.platform);
    var Cg = Xr === "Android" || globalThis.navigator?.platform === "Android" || globalThis.navigator?.userAgent?.includes(" Android ") === true || globalThis.process?.platform === "android";
    var C = "\x1B[";
    var rt = "\x1B]";
    var yr = "\x07";
    var et = ";";
    var es = !zt && Zt.default.env.TERM_PROGRAM === "Apple_Terminal";
    var ac = !zt && Zt.default.platform === "win32";
    var lc = zt ? () => {
      throw new Error("`process.cwd()` only works in Node.js, not the browser.");
    } : Zt.default.cwd;
    var uc = (e, r) => {
      if (typeof e != "number") throw new TypeError("The `x` argument is required");
      return typeof r != "number" ? C + (e + 1) + "G" : C + (r + 1) + et + (e + 1) + "H";
    };
    var cc = (e, r) => {
      if (typeof e != "number") throw new TypeError("The `x` argument is required");
      let t = "";
      return e < 0 ? t += C + -e + "D" : e > 0 && (t += C + e + "C"), r < 0 ? t += C + -r + "A" : r > 0 && (t += C + r + "B"), t;
    };
    var rs = (e = 1) => C + e + "A";
    var pc = (e = 1) => C + e + "B";
    var dc = (e = 1) => C + e + "C";
    var mc = (e = 1) => C + e + "D";
    var ts = C + "G";
    var fc = es ? "\x1B7" : C + "s";
    var gc = es ? "\x1B8" : C + "u";
    var hc = C + "6n";
    var yc = C + "E";
    var bc = C + "F";
    var Ec = C + "?25l";
    var wc = C + "?25h";
    var xc = (e) => {
      let r = "";
      for (let t = 0; t < e; t++) r += ns + (t < e - 1 ? rs() : "");
      return e && (r += ts), r;
    };
    var vc = C + "K";
    var Pc = C + "1K";
    var ns = C + "2K";
    var Tc = C + "J";
    var Sc = C + "1J";
    var gi = C + "2J";
    var Rc = C + "S";
    var Ac = C + "T";
    var Cc = "\x1Bc";
    var Ic = ac ? `${gi}${C}0f` : `${gi}${C}3J${C}H`;
    var Dc = C + "?1049h";
    var Oc = C + "?1049l";
    var kc = yr;
    var _c = (e, r) => [rt, "8", et, et, r, yr, e, rt, "8", et, et, yr].join("");
    var Nc = (e, r = {}) => {
      let t = `${rt}1337;File=inline=1`;
      return r.width && (t += `;width=${r.width}`), r.height && (t += `;height=${r.height}`), r.preserveAspectRatio === false && (t += ";preserveAspectRatio=0"), t + ":" + Buffer.from(e).toString("base64") + yr;
    };
    var Lc = { setCwd: (e = lc()) => `${rt}50;CurrentDir=${e}${yr}`, annotation(e, r = {}) {
      let t = `${rt}1337;`, n = r.x !== void 0, i = r.y !== void 0;
      if ((n || i) && !(n && i && r.length !== void 0)) throw new Error("`x`, `y` and `length` must be defined when `x` or `y` is defined");
      return e = e.replaceAll("|", ""), t += r.isHidden ? "AddHiddenAnnotation=" : "AddAnnotation=", r.length > 0 ? t += (n ? [e, r.length, r.x, r.y] : [r.length, e]).join("|") : t += e, t + yr;
    } };
    var en = O(cs(), 1);
    function or(e, r, { target: t = "stdout", ...n } = {}) {
      return en.default[t] ? Xt.link(e, r) : n.fallback === false ? e : typeof n.fallback == "function" ? n.fallback(e, r) : `${e} (\u200B${r}\u200B)`;
    }
    or.isSupported = en.default.stdout;
    or.stderr = (e, r, t = {}) => or(e, r, { target: "stderr", ...t });
    or.stderr.isSupported = en.default.stderr;
    function wi(e) {
      return or(e, e, { fallback: Y });
    }
    var Vc = ps();
    var xi = Vc.version;
    function Er(e) {
      let r = jc();
      return r || (e?.config.engineType === "library" ? "library" : e?.config.engineType === "binary" ? "binary" : e?.config.engineType === "client" ? "client" : Bc());
    }
    function jc() {
      let e = process.env.PRISMA_CLIENT_ENGINE_TYPE;
      return e === "library" ? "library" : e === "binary" ? "binary" : e === "client" ? "client" : void 0;
    }
    function Bc() {
      return "library";
    }
    function vi(e) {
      return e.name === "DriverAdapterError" && typeof e.cause == "object";
    }
    function rn(e) {
      return { ok: true, value: e, map(r) {
        return rn(r(e));
      }, flatMap(r) {
        return r(e);
      } };
    }
    function sr(e) {
      return { ok: false, error: e, map() {
        return sr(e);
      }, flatMap() {
        return sr(e);
      } };
    }
    var ds = N("driver-adapter-utils");
    var Pi = class {
      constructor() {
        __publicField(this, "registeredErrors", []);
      }
      consumeError(r) {
        return this.registeredErrors[r];
      }
      registerNewError(r) {
        let t = 0;
        for (; this.registeredErrors[t] !== void 0; ) t++;
        return this.registeredErrors[t] = { error: r }, t;
      }
    };
    var tn = (e, r = new Pi()) => {
      let t = { adapterName: e.adapterName, errorRegistry: r, queryRaw: ke(r, e.queryRaw.bind(e)), executeRaw: ke(r, e.executeRaw.bind(e)), executeScript: ke(r, e.executeScript.bind(e)), dispose: ke(r, e.dispose.bind(e)), provider: e.provider, startTransaction: async (...n) => (await ke(r, e.startTransaction.bind(e))(...n)).map((o) => Uc(r, o)) };
      return e.getConnectionInfo && (t.getConnectionInfo = Gc(r, e.getConnectionInfo.bind(e))), t;
    };
    var Uc = (e, r) => ({ adapterName: r.adapterName, provider: r.provider, options: r.options, queryRaw: ke(e, r.queryRaw.bind(r)), executeRaw: ke(e, r.executeRaw.bind(r)), commit: ke(e, r.commit.bind(r)), rollback: ke(e, r.rollback.bind(r)) });
    function ke(e, r) {
      return async (...t) => {
        try {
          return rn(await r(...t));
        } catch (n) {
          if (ds("[error@wrapAsync]", n), vi(n)) return sr(n.cause);
          let i = e.registerNewError(n);
          return sr({ kind: "GenericJs", id: i });
        }
      };
    }
    function Gc(e, r) {
      return (...t) => {
        try {
          return rn(r(...t));
        } catch (n) {
          if (ds("[error@wrapSync]", n), vi(n)) return sr(n.cause);
          let i = e.registerNewError(n);
          return sr({ kind: "GenericJs", id: i });
        }
      };
    }
    var Wc = O(on());
    var M = O(require("path"));
    var Jc = O(on());
    var wh = N("prisma:engines");
    function ms() {
      return M.default.join(__dirname, "../");
    }
    M.default.join(__dirname, "../query-engine-darwin");
    M.default.join(__dirname, "../query-engine-darwin-arm64");
    M.default.join(__dirname, "../query-engine-debian-openssl-1.0.x");
    M.default.join(__dirname, "../query-engine-debian-openssl-1.1.x");
    M.default.join(__dirname, "../query-engine-debian-openssl-3.0.x");
    M.default.join(__dirname, "../query-engine-linux-static-x64");
    M.default.join(__dirname, "../query-engine-linux-static-arm64");
    M.default.join(__dirname, "../query-engine-rhel-openssl-1.0.x");
    M.default.join(__dirname, "../query-engine-rhel-openssl-1.1.x");
    M.default.join(__dirname, "../query-engine-rhel-openssl-3.0.x");
    M.default.join(__dirname, "../libquery_engine-darwin.dylib.node");
    M.default.join(__dirname, "../libquery_engine-darwin-arm64.dylib.node");
    M.default.join(__dirname, "../libquery_engine-debian-openssl-1.0.x.so.node");
    M.default.join(__dirname, "../libquery_engine-debian-openssl-1.1.x.so.node");
    M.default.join(__dirname, "../libquery_engine-debian-openssl-3.0.x.so.node");
    M.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-1.0.x.so.node");
    M.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-1.1.x.so.node");
    M.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-3.0.x.so.node");
    M.default.join(__dirname, "../libquery_engine-linux-musl.so.node");
    M.default.join(__dirname, "../libquery_engine-linux-musl-openssl-3.0.x.so.node");
    M.default.join(__dirname, "../libquery_engine-rhel-openssl-1.0.x.so.node");
    M.default.join(__dirname, "../libquery_engine-rhel-openssl-1.1.x.so.node");
    M.default.join(__dirname, "../libquery_engine-rhel-openssl-3.0.x.so.node");
    M.default.join(__dirname, "../query_engine-windows.dll.node");
    var Si = O(require("fs"));
    var fs2 = gr("chmodPlusX");
    function Ri(e) {
      if (process.platform === "win32") return;
      let r = Si.default.statSync(e), t = r.mode | 64 | 8 | 1;
      if (r.mode === t) {
        fs2(`Execution permissions of ${e} are fine`);
        return;
      }
      let n = t.toString(8).slice(-3);
      fs2(`Have to call chmodPlusX on ${e}`), Si.default.chmodSync(e, n);
    }
    function Ai(e) {
      let r = e.e, t = (a) => `Prisma cannot find the required \`${a}\` system library in your system`, n = r.message.includes("cannot open shared object file"), i = `Please refer to the documentation about Prisma's system requirements: ${wi("https://pris.ly/d/system-requirements")}`, o = `Unable to require(\`${Ce(e.id)}\`).`, s = hr({ message: r.message, code: r.code }).with({ code: "ENOENT" }, () => "File does not exist.").when(({ message: a }) => n && a.includes("libz"), () => `${t("libz")}. Please install it and try again.`).when(({ message: a }) => n && a.includes("libgcc_s"), () => `${t("libgcc_s")}. Please install it and try again.`).when(({ message: a }) => n && a.includes("libssl"), () => {
        let a = e.platformInfo.libssl ? `openssl-${e.platformInfo.libssl}` : "openssl";
        return `${t("libssl")}. Please install ${a} and try again.`;
      }).when(({ message: a }) => a.includes("GLIBC"), () => `Prisma has detected an incompatible version of the \`glibc\` C standard library installed in your system. This probably means your system may be too old to run Prisma. ${i}`).when(({ message: a }) => e.platformInfo.platform === "linux" && a.includes("symbol not found"), () => `The Prisma engines are not compatible with your system ${e.platformInfo.originalDistro} on (${e.platformInfo.archFromUname}) which uses the \`${e.platformInfo.binaryTarget}\` binaryTarget by default. ${i}`).otherwise(() => `The Prisma engines do not seem to be compatible with your system. ${i}`);
      return `${o}
${s}

Details: ${r.message}`;
    }
    var ys = O(hs(), 1);
    function Ci(e) {
      let r = (0, ys.default)(e);
      if (r === 0) return e;
      let t = new RegExp(`^[ \\t]{${r}}`, "gm");
      return e.replace(t, "");
    }
    var bs = "prisma+postgres";
    var sn = `${bs}:`;
    function an(e) {
      return e?.toString().startsWith(`${sn}//`) ?? false;
    }
    function Ii(e) {
      if (!an(e)) return false;
      let { host: r } = new URL(e);
      return r.includes("localhost") || r.includes("127.0.0.1") || r.includes("[::1]");
    }
    var ws = O(Di());
    function ki(e) {
      return String(new Oi(e));
    }
    var Oi = class {
      constructor(r) {
        this.config = r;
      }
      toString() {
        let { config: r } = this, t = r.provider.fromEnvVar ? `env("${r.provider.fromEnvVar}")` : r.provider.value, n = JSON.parse(JSON.stringify({ provider: t, binaryTargets: Kc(r.binaryTargets) }));
        return `generator ${r.name} {
${(0, ws.default)(Hc(n), 2)}
}`;
      }
    };
    function Kc(e) {
      let r;
      if (e.length > 0) {
        let t = e.find((n) => n.fromEnvVar !== null);
        t ? r = `env("${t.fromEnvVar}")` : r = e.map((n) => n.native ? "native" : n.value);
      } else r = void 0;
      return r;
    }
    function Hc(e) {
      let r = Object.keys(e).reduce((t, n) => Math.max(t, n.length), 0);
      return Object.entries(e).map(([t, n]) => `${t.padEnd(r)} = ${Yc(n)}`).join(`
`);
    }
    function Yc(e) {
      return JSON.parse(JSON.stringify(e, (r, t) => Array.isArray(t) ? `[${t.map((n) => JSON.stringify(n)).join(", ")}]` : JSON.stringify(t)));
    }
    var nt = {};
    tr(nt, { error: () => Xc, info: () => Zc, log: () => zc, query: () => ep, should: () => xs, tags: () => tt, warn: () => _i });
    var tt = { error: ce("prisma:error"), warn: Ie("prisma:warn"), info: De("prisma:info"), query: nr("prisma:query") };
    var xs = { warn: () => !process.env.PRISMA_DISABLE_WARNINGS };
    function zc(...e) {
      console.log(...e);
    }
    function _i(e, ...r) {
      xs.warn() && console.warn(`${tt.warn} ${e}`, ...r);
    }
    function Zc(e, ...r) {
      console.info(`${tt.info} ${e}`, ...r);
    }
    function Xc(e, ...r) {
      console.error(`${tt.error} ${e}`, ...r);
    }
    function ep(e, ...r) {
      console.log(`${tt.query} ${e}`, ...r);
    }
    function ln(e, r) {
      if (!e) throw new Error(`${r}. This should never happen. If you see this error, please, open an issue at https://pris.ly/prisma-prisma-bug-report`);
    }
    function ar(e, r) {
      throw new Error(r);
    }
    function Ni({ onlyFirst: e = false } = {}) {
      let t = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?(?:\\u0007|\\u001B\\u005C|\\u009C))", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"].join("|");
      return new RegExp(t, e ? void 0 : "g");
    }
    var rp = Ni();
    function wr(e) {
      if (typeof e != "string") throw new TypeError(`Expected a \`string\`, got \`${typeof e}\``);
      return e.replace(rp, "");
    }
    var it = O(require("path"));
    function Li(e) {
      return it.default.sep === it.default.posix.sep ? e : e.split(it.default.sep).join(it.default.posix.sep);
    }
    var qi = O(As());
    var un = O(require("fs"));
    var xr = O(require("path"));
    function Cs(e) {
      let r = e.ignoreProcessEnv ? {} : process.env, t = (n) => n.match(/(.?\${(?:[a-zA-Z0-9_]+)?})/g)?.reduce(function(o, s) {
        let a = /(.?)\${([a-zA-Z0-9_]+)?}/g.exec(s);
        if (!a) return o;
        let l = a[1], u, c;
        if (l === "\\") c = a[0], u = c.replace("\\$", "$");
        else {
          let p = a[2];
          c = a[0].substring(l.length), u = Object.hasOwnProperty.call(r, p) ? r[p] : e.parsed[p] || "", u = t(u);
        }
        return o.replace(c, u);
      }, n) ?? n;
      for (let n in e.parsed) {
        let i = Object.hasOwnProperty.call(r, n) ? r[n] : e.parsed[n];
        e.parsed[n] = t(i);
      }
      for (let n in e.parsed) r[n] = e.parsed[n];
      return e;
    }
    var $i = gr("prisma:tryLoadEnv");
    function st({ rootEnvPath: e, schemaEnvPath: r }, t = { conflictCheck: "none" }) {
      let n = Is(e);
      t.conflictCheck !== "none" && hp(n, r, t.conflictCheck);
      let i = null;
      return Ds(n?.path, r) || (i = Is(r)), !n && !i && $i("No Environment variables loaded"), i?.dotenvResult.error ? console.error(ce(W("Schema Env Error: ")) + i.dotenvResult.error) : { message: [n?.message, i?.message].filter(Boolean).join(`
`), parsed: { ...n?.dotenvResult?.parsed, ...i?.dotenvResult?.parsed } };
    }
    function hp(e, r, t) {
      let n = e?.dotenvResult.parsed, i = !Ds(e?.path, r);
      if (n && r && i && un.default.existsSync(r)) {
        let o = qi.default.parse(un.default.readFileSync(r)), s = [];
        for (let a in o) n[a] === o[a] && s.push(a);
        if (s.length > 0) {
          let a = xr.default.relative(process.cwd(), e.path), l = xr.default.relative(process.cwd(), r);
          if (t === "error") {
            let u = `There is a conflict between env var${s.length > 1 ? "s" : ""} in ${Y(a)} and ${Y(l)}
Conflicting env vars:
${s.map((c) => `  ${W(c)}`).join(`
`)}

We suggest to move the contents of ${Y(l)} to ${Y(a)} to consolidate your env vars.
`;
            throw new Error(u);
          } else if (t === "warn") {
            let u = `Conflict for env var${s.length > 1 ? "s" : ""} ${s.map((c) => W(c)).join(", ")} in ${Y(a)} and ${Y(l)}
Env vars from ${Y(l)} overwrite the ones from ${Y(a)}
      `;
            console.warn(`${Ie("warn(prisma)")} ${u}`);
          }
        }
      }
    }
    function Is(e) {
      if (yp(e)) {
        $i(`Environment variables loaded from ${e}`);
        let r = qi.default.config({ path: e, debug: process.env.DOTENV_CONFIG_DEBUG ? true : void 0 });
        return { dotenvResult: Cs(r), message: Ce(`Environment variables loaded from ${xr.default.relative(process.cwd(), e)}`), path: e };
      } else $i(`Environment variables not found at ${e}`);
      return null;
    }
    function Ds(e, r) {
      return e && r && xr.default.resolve(e) === xr.default.resolve(r);
    }
    function yp(e) {
      return !!(e && un.default.existsSync(e));
    }
    function Vi(e, r) {
      return Object.prototype.hasOwnProperty.call(e, r);
    }
    function pn(e, r) {
      let t = {};
      for (let n of Object.keys(e)) t[n] = r(e[n], n);
      return t;
    }
    function ji(e, r) {
      if (e.length === 0) return;
      let t = e[0];
      for (let n = 1; n < e.length; n++) r(t, e[n]) < 0 && (t = e[n]);
      return t;
    }
    function x(e, r) {
      Object.defineProperty(e, "name", { value: r, configurable: true });
    }
    var ks = /* @__PURE__ */ new Set();
    var at = (e, r, ...t) => {
      ks.has(e) || (ks.add(e), _i(r, ...t));
    };
    var P = class e extends Error {
      constructor(r, t, n) {
        super(r);
        __publicField(this, "clientVersion");
        __publicField(this, "errorCode");
        __publicField(this, "retryable");
        this.name = "PrismaClientInitializationError", this.clientVersion = t, this.errorCode = n, Error.captureStackTrace(e);
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientInitializationError";
      }
    };
    x(P, "PrismaClientInitializationError");
    var z = class extends Error {
      constructor(r, { code: t, clientVersion: n, meta: i, batchRequestIdx: o }) {
        super(r);
        __publicField(this, "code");
        __publicField(this, "meta");
        __publicField(this, "clientVersion");
        __publicField(this, "batchRequestIdx");
        this.name = "PrismaClientKnownRequestError", this.code = t, this.clientVersion = n, this.meta = i, Object.defineProperty(this, "batchRequestIdx", { value: o, enumerable: false, writable: true });
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientKnownRequestError";
      }
    };
    x(z, "PrismaClientKnownRequestError");
    var ae = class extends Error {
      constructor(r, t) {
        super(r);
        __publicField(this, "clientVersion");
        this.name = "PrismaClientRustPanicError", this.clientVersion = t;
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientRustPanicError";
      }
    };
    x(ae, "PrismaClientRustPanicError");
    var V = class extends Error {
      constructor(r, { clientVersion: t, batchRequestIdx: n }) {
        super(r);
        __publicField(this, "clientVersion");
        __publicField(this, "batchRequestIdx");
        this.name = "PrismaClientUnknownRequestError", this.clientVersion = t, Object.defineProperty(this, "batchRequestIdx", { value: n, writable: true, enumerable: false });
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientUnknownRequestError";
      }
    };
    x(V, "PrismaClientUnknownRequestError");
    var Z = class extends Error {
      constructor(r, { clientVersion: t }) {
        super(r);
        __publicField(this, "name", "PrismaClientValidationError");
        __publicField(this, "clientVersion");
        this.clientVersion = t;
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientValidationError";
      }
    };
    x(Z, "PrismaClientValidationError");
    var we = class {
      constructor() {
        __publicField(this, "_map", /* @__PURE__ */ new Map());
      }
      get(r) {
        return this._map.get(r)?.value;
      }
      set(r, t) {
        this._map.set(r, { value: t });
      }
      getOrCreate(r, t) {
        let n = this._map.get(r);
        if (n) return n.value;
        let i = t();
        return this.set(r, i), i;
      }
    };
    function We(e) {
      return e.substring(0, 1).toLowerCase() + e.substring(1);
    }
    function _s(e, r) {
      let t = {};
      for (let n of e) {
        let i = n[r];
        t[i] = n;
      }
      return t;
    }
    function lt(e) {
      let r;
      return { get() {
        return r || (r = { value: e() }), r.value;
      } };
    }
    function Ns(e) {
      return { models: Bi(e.models), enums: Bi(e.enums), types: Bi(e.types) };
    }
    function Bi(e) {
      let r = {};
      for (let { name: t, ...n } of e) r[t] = n;
      return r;
    }
    function vr(e) {
      return e instanceof Date || Object.prototype.toString.call(e) === "[object Date]";
    }
    function mn(e) {
      return e.toString() !== "Invalid Date";
    }
    var Pr = 9e15;
    var Ye = 1e9;
    var Ui = "0123456789abcdef";
    var hn = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
    var yn = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
    var Gi = { precision: 20, rounding: 4, modulo: 1, toExpNeg: -7, toExpPos: 21, minE: -Pr, maxE: Pr, crypto: false };
    var $s;
    var Ne;
    var w = true;
    var En = "[DecimalError] ";
    var He = En + "Invalid argument: ";
    var qs = En + "Precision limit exceeded";
    var Vs = En + "crypto unavailable";
    var js = "[object Decimal]";
    var X = Math.floor;
    var U = Math.pow;
    var bp = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
    var Ep = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
    var wp = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
    var Bs = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
    var fe = 1e7;
    var E = 7;
    var xp = 9007199254740991;
    var vp = hn.length - 1;
    var Qi = yn.length - 1;
    var m = { toStringTag: js };
    m.absoluteValue = m.abs = function() {
      var e = new this.constructor(this);
      return e.s < 0 && (e.s = 1), y(e);
    };
    m.ceil = function() {
      return y(new this.constructor(this), this.e + 1, 2);
    };
    m.clampedTo = m.clamp = function(e, r) {
      var t, n = this, i = n.constructor;
      if (e = new i(e), r = new i(r), !e.s || !r.s) return new i(NaN);
      if (e.gt(r)) throw Error(He + r);
      return t = n.cmp(e), t < 0 ? e : n.cmp(r) > 0 ? r : new i(n);
    };
    m.comparedTo = m.cmp = function(e) {
      var r, t, n, i, o = this, s = o.d, a = (e = new o.constructor(e)).d, l = o.s, u = e.s;
      if (!s || !a) return !l || !u ? NaN : l !== u ? l : s === a ? 0 : !s ^ l < 0 ? 1 : -1;
      if (!s[0] || !a[0]) return s[0] ? l : a[0] ? -u : 0;
      if (l !== u) return l;
      if (o.e !== e.e) return o.e > e.e ^ l < 0 ? 1 : -1;
      for (n = s.length, i = a.length, r = 0, t = n < i ? n : i; r < t; ++r) if (s[r] !== a[r]) return s[r] > a[r] ^ l < 0 ? 1 : -1;
      return n === i ? 0 : n > i ^ l < 0 ? 1 : -1;
    };
    m.cosine = m.cos = function() {
      var e, r, t = this, n = t.constructor;
      return t.d ? t.d[0] ? (e = n.precision, r = n.rounding, n.precision = e + Math.max(t.e, t.sd()) + E, n.rounding = 1, t = Pp(n, Js(n, t)), n.precision = e, n.rounding = r, y(Ne == 2 || Ne == 3 ? t.neg() : t, e, r, true)) : new n(1) : new n(NaN);
    };
    m.cubeRoot = m.cbrt = function() {
      var e, r, t, n, i, o, s, a, l, u, c = this, p = c.constructor;
      if (!c.isFinite() || c.isZero()) return new p(c);
      for (w = false, o = c.s * U(c.s * c, 1 / 3), !o || Math.abs(o) == 1 / 0 ? (t = J(c.d), e = c.e, (o = (e - t.length + 1) % 3) && (t += o == 1 || o == -2 ? "0" : "00"), o = U(t, 1 / 3), e = X((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2)), o == 1 / 0 ? t = "5e" + e : (t = o.toExponential(), t = t.slice(0, t.indexOf("e") + 1) + e), n = new p(t), n.s = c.s) : n = new p(o.toString()), s = (e = p.precision) + 3; ; ) if (a = n, l = a.times(a).times(a), u = l.plus(c), n = L(u.plus(c).times(a), u.plus(l), s + 2, 1), J(a.d).slice(0, s) === (t = J(n.d)).slice(0, s)) if (t = t.slice(s - 3, s + 1), t == "9999" || !i && t == "4999") {
        if (!i && (y(a, e + 1, 0), a.times(a).times(a).eq(c))) {
          n = a;
          break;
        }
        s += 4, i = 1;
      } else {
        (!+t || !+t.slice(1) && t.charAt(0) == "5") && (y(n, e + 1, 1), r = !n.times(n).times(n).eq(c));
        break;
      }
      return w = true, y(n, e, p.rounding, r);
    };
    m.decimalPlaces = m.dp = function() {
      var e, r = this.d, t = NaN;
      if (r) {
        if (e = r.length - 1, t = (e - X(this.e / E)) * E, e = r[e], e) for (; e % 10 == 0; e /= 10) t--;
        t < 0 && (t = 0);
      }
      return t;
    };
    m.dividedBy = m.div = function(e) {
      return L(this, new this.constructor(e));
    };
    m.dividedToIntegerBy = m.divToInt = function(e) {
      var r = this, t = r.constructor;
      return y(L(r, new t(e), 0, 1, 1), t.precision, t.rounding);
    };
    m.equals = m.eq = function(e) {
      return this.cmp(e) === 0;
    };
    m.floor = function() {
      return y(new this.constructor(this), this.e + 1, 3);
    };
    m.greaterThan = m.gt = function(e) {
      return this.cmp(e) > 0;
    };
    m.greaterThanOrEqualTo = m.gte = function(e) {
      var r = this.cmp(e);
      return r == 1 || r === 0;
    };
    m.hyperbolicCosine = m.cosh = function() {
      var e, r, t, n, i, o = this, s = o.constructor, a = new s(1);
      if (!o.isFinite()) return new s(o.s ? 1 / 0 : NaN);
      if (o.isZero()) return a;
      t = s.precision, n = s.rounding, s.precision = t + Math.max(o.e, o.sd()) + 4, s.rounding = 1, i = o.d.length, i < 32 ? (e = Math.ceil(i / 3), r = (1 / xn(4, e)).toString()) : (e = 16, r = "2.3283064365386962890625e-10"), o = Tr(s, 1, o.times(r), new s(1), true);
      for (var l, u = e, c = new s(8); u--; ) l = o.times(o), o = a.minus(l.times(c.minus(l.times(c))));
      return y(o, s.precision = t, s.rounding = n, true);
    };
    m.hyperbolicSine = m.sinh = function() {
      var e, r, t, n, i = this, o = i.constructor;
      if (!i.isFinite() || i.isZero()) return new o(i);
      if (r = o.precision, t = o.rounding, o.precision = r + Math.max(i.e, i.sd()) + 4, o.rounding = 1, n = i.d.length, n < 3) i = Tr(o, 2, i, i, true);
      else {
        e = 1.4 * Math.sqrt(n), e = e > 16 ? 16 : e | 0, i = i.times(1 / xn(5, e)), i = Tr(o, 2, i, i, true);
        for (var s, a = new o(5), l = new o(16), u = new o(20); e--; ) s = i.times(i), i = i.times(a.plus(s.times(l.times(s).plus(u))));
      }
      return o.precision = r, o.rounding = t, y(i, r, t, true);
    };
    m.hyperbolicTangent = m.tanh = function() {
      var e, r, t = this, n = t.constructor;
      return t.isFinite() ? t.isZero() ? new n(t) : (e = n.precision, r = n.rounding, n.precision = e + 7, n.rounding = 1, L(t.sinh(), t.cosh(), n.precision = e, n.rounding = r)) : new n(t.s);
    };
    m.inverseCosine = m.acos = function() {
      var e = this, r = e.constructor, t = e.abs().cmp(1), n = r.precision, i = r.rounding;
      return t !== -1 ? t === 0 ? e.isNeg() ? xe(r, n, i) : new r(0) : new r(NaN) : e.isZero() ? xe(r, n + 4, i).times(0.5) : (r.precision = n + 6, r.rounding = 1, e = new r(1).minus(e).div(e.plus(1)).sqrt().atan(), r.precision = n, r.rounding = i, e.times(2));
    };
    m.inverseHyperbolicCosine = m.acosh = function() {
      var e, r, t = this, n = t.constructor;
      return t.lte(1) ? new n(t.eq(1) ? 0 : NaN) : t.isFinite() ? (e = n.precision, r = n.rounding, n.precision = e + Math.max(Math.abs(t.e), t.sd()) + 4, n.rounding = 1, w = false, t = t.times(t).minus(1).sqrt().plus(t), w = true, n.precision = e, n.rounding = r, t.ln()) : new n(t);
    };
    m.inverseHyperbolicSine = m.asinh = function() {
      var e, r, t = this, n = t.constructor;
      return !t.isFinite() || t.isZero() ? new n(t) : (e = n.precision, r = n.rounding, n.precision = e + 2 * Math.max(Math.abs(t.e), t.sd()) + 6, n.rounding = 1, w = false, t = t.times(t).plus(1).sqrt().plus(t), w = true, n.precision = e, n.rounding = r, t.ln());
    };
    m.inverseHyperbolicTangent = m.atanh = function() {
      var e, r, t, n, i = this, o = i.constructor;
      return i.isFinite() ? i.e >= 0 ? new o(i.abs().eq(1) ? i.s / 0 : i.isZero() ? i : NaN) : (e = o.precision, r = o.rounding, n = i.sd(), Math.max(n, e) < 2 * -i.e - 1 ? y(new o(i), e, r, true) : (o.precision = t = n - i.e, i = L(i.plus(1), new o(1).minus(i), t + e, 1), o.precision = e + 4, o.rounding = 1, i = i.ln(), o.precision = e, o.rounding = r, i.times(0.5))) : new o(NaN);
    };
    m.inverseSine = m.asin = function() {
      var e, r, t, n, i = this, o = i.constructor;
      return i.isZero() ? new o(i) : (r = i.abs().cmp(1), t = o.precision, n = o.rounding, r !== -1 ? r === 0 ? (e = xe(o, t + 4, n).times(0.5), e.s = i.s, e) : new o(NaN) : (o.precision = t + 6, o.rounding = 1, i = i.div(new o(1).minus(i.times(i)).sqrt().plus(1)).atan(), o.precision = t, o.rounding = n, i.times(2)));
    };
    m.inverseTangent = m.atan = function() {
      var e, r, t, n, i, o, s, a, l, u = this, c = u.constructor, p = c.precision, d = c.rounding;
      if (u.isFinite()) {
        if (u.isZero()) return new c(u);
        if (u.abs().eq(1) && p + 4 <= Qi) return s = xe(c, p + 4, d).times(0.25), s.s = u.s, s;
      } else {
        if (!u.s) return new c(NaN);
        if (p + 4 <= Qi) return s = xe(c, p + 4, d).times(0.5), s.s = u.s, s;
      }
      for (c.precision = a = p + 10, c.rounding = 1, t = Math.min(28, a / E + 2 | 0), e = t; e; --e) u = u.div(u.times(u).plus(1).sqrt().plus(1));
      for (w = false, r = Math.ceil(a / E), n = 1, l = u.times(u), s = new c(u), i = u; e !== -1; ) if (i = i.times(l), o = s.minus(i.div(n += 2)), i = i.times(l), s = o.plus(i.div(n += 2)), s.d[r] !== void 0) for (e = r; s.d[e] === o.d[e] && e--; ) ;
      return t && (s = s.times(2 << t - 1)), w = true, y(s, c.precision = p, c.rounding = d, true);
    };
    m.isFinite = function() {
      return !!this.d;
    };
    m.isInteger = m.isInt = function() {
      return !!this.d && X(this.e / E) > this.d.length - 2;
    };
    m.isNaN = function() {
      return !this.s;
    };
    m.isNegative = m.isNeg = function() {
      return this.s < 0;
    };
    m.isPositive = m.isPos = function() {
      return this.s > 0;
    };
    m.isZero = function() {
      return !!this.d && this.d[0] === 0;
    };
    m.lessThan = m.lt = function(e) {
      return this.cmp(e) < 0;
    };
    m.lessThanOrEqualTo = m.lte = function(e) {
      return this.cmp(e) < 1;
    };
    m.logarithm = m.log = function(e) {
      var r, t, n, i, o, s, a, l, u = this, c = u.constructor, p = c.precision, d = c.rounding, f = 5;
      if (e == null) e = new c(10), r = true;
      else {
        if (e = new c(e), t = e.d, e.s < 0 || !t || !t[0] || e.eq(1)) return new c(NaN);
        r = e.eq(10);
      }
      if (t = u.d, u.s < 0 || !t || !t[0] || u.eq(1)) return new c(t && !t[0] ? -1 / 0 : u.s != 1 ? NaN : t ? 0 : 1 / 0);
      if (r) if (t.length > 1) o = true;
      else {
        for (i = t[0]; i % 10 === 0; ) i /= 10;
        o = i !== 1;
      }
      if (w = false, a = p + f, s = Ke(u, a), n = r ? bn(c, a + 10) : Ke(e, a), l = L(s, n, a, 1), ut(l.d, i = p, d)) do
        if (a += 10, s = Ke(u, a), n = r ? bn(c, a + 10) : Ke(e, a), l = L(s, n, a, 1), !o) {
          +J(l.d).slice(i + 1, i + 15) + 1 == 1e14 && (l = y(l, p + 1, 0));
          break;
        }
      while (ut(l.d, i += 10, d));
      return w = true, y(l, p, d);
    };
    m.minus = m.sub = function(e) {
      var r, t, n, i, o, s, a, l, u, c, p, d, f = this, h = f.constructor;
      if (e = new h(e), !f.d || !e.d) return !f.s || !e.s ? e = new h(NaN) : f.d ? e.s = -e.s : e = new h(e.d || f.s !== e.s ? f : NaN), e;
      if (f.s != e.s) return e.s = -e.s, f.plus(e);
      if (u = f.d, d = e.d, a = h.precision, l = h.rounding, !u[0] || !d[0]) {
        if (d[0]) e.s = -e.s;
        else if (u[0]) e = new h(f);
        else return new h(l === 3 ? -0 : 0);
        return w ? y(e, a, l) : e;
      }
      if (t = X(e.e / E), c = X(f.e / E), u = u.slice(), o = c - t, o) {
        for (p = o < 0, p ? (r = u, o = -o, s = d.length) : (r = d, t = c, s = u.length), n = Math.max(Math.ceil(a / E), s) + 2, o > n && (o = n, r.length = 1), r.reverse(), n = o; n--; ) r.push(0);
        r.reverse();
      } else {
        for (n = u.length, s = d.length, p = n < s, p && (s = n), n = 0; n < s; n++) if (u[n] != d[n]) {
          p = u[n] < d[n];
          break;
        }
        o = 0;
      }
      for (p && (r = u, u = d, d = r, e.s = -e.s), s = u.length, n = d.length - s; n > 0; --n) u[s++] = 0;
      for (n = d.length; n > o; ) {
        if (u[--n] < d[n]) {
          for (i = n; i && u[--i] === 0; ) u[i] = fe - 1;
          --u[i], u[n] += fe;
        }
        u[n] -= d[n];
      }
      for (; u[--s] === 0; ) u.pop();
      for (; u[0] === 0; u.shift()) --t;
      return u[0] ? (e.d = u, e.e = wn(u, t), w ? y(e, a, l) : e) : new h(l === 3 ? -0 : 0);
    };
    m.modulo = m.mod = function(e) {
      var r, t = this, n = t.constructor;
      return e = new n(e), !t.d || !e.s || e.d && !e.d[0] ? new n(NaN) : !e.d || t.d && !t.d[0] ? y(new n(t), n.precision, n.rounding) : (w = false, n.modulo == 9 ? (r = L(t, e.abs(), 0, 3, 1), r.s *= e.s) : r = L(t, e, 0, n.modulo, 1), r = r.times(e), w = true, t.minus(r));
    };
    m.naturalExponential = m.exp = function() {
      return Wi(this);
    };
    m.naturalLogarithm = m.ln = function() {
      return Ke(this);
    };
    m.negated = m.neg = function() {
      var e = new this.constructor(this);
      return e.s = -e.s, y(e);
    };
    m.plus = m.add = function(e) {
      var r, t, n, i, o, s, a, l, u, c, p = this, d = p.constructor;
      if (e = new d(e), !p.d || !e.d) return !p.s || !e.s ? e = new d(NaN) : p.d || (e = new d(e.d || p.s === e.s ? p : NaN)), e;
      if (p.s != e.s) return e.s = -e.s, p.minus(e);
      if (u = p.d, c = e.d, a = d.precision, l = d.rounding, !u[0] || !c[0]) return c[0] || (e = new d(p)), w ? y(e, a, l) : e;
      if (o = X(p.e / E), n = X(e.e / E), u = u.slice(), i = o - n, i) {
        for (i < 0 ? (t = u, i = -i, s = c.length) : (t = c, n = o, s = u.length), o = Math.ceil(a / E), s = o > s ? o + 1 : s + 1, i > s && (i = s, t.length = 1), t.reverse(); i--; ) t.push(0);
        t.reverse();
      }
      for (s = u.length, i = c.length, s - i < 0 && (i = s, t = c, c = u, u = t), r = 0; i; ) r = (u[--i] = u[i] + c[i] + r) / fe | 0, u[i] %= fe;
      for (r && (u.unshift(r), ++n), s = u.length; u[--s] == 0; ) u.pop();
      return e.d = u, e.e = wn(u, n), w ? y(e, a, l) : e;
    };
    m.precision = m.sd = function(e) {
      var r, t = this;
      if (e !== void 0 && e !== !!e && e !== 1 && e !== 0) throw Error(He + e);
      return t.d ? (r = Us(t.d), e && t.e + 1 > r && (r = t.e + 1)) : r = NaN, r;
    };
    m.round = function() {
      var e = this, r = e.constructor;
      return y(new r(e), e.e + 1, r.rounding);
    };
    m.sine = m.sin = function() {
      var e, r, t = this, n = t.constructor;
      return t.isFinite() ? t.isZero() ? new n(t) : (e = n.precision, r = n.rounding, n.precision = e + Math.max(t.e, t.sd()) + E, n.rounding = 1, t = Sp(n, Js(n, t)), n.precision = e, n.rounding = r, y(Ne > 2 ? t.neg() : t, e, r, true)) : new n(NaN);
    };
    m.squareRoot = m.sqrt = function() {
      var e, r, t, n, i, o, s = this, a = s.d, l = s.e, u = s.s, c = s.constructor;
      if (u !== 1 || !a || !a[0]) return new c(!u || u < 0 && (!a || a[0]) ? NaN : a ? s : 1 / 0);
      for (w = false, u = Math.sqrt(+s), u == 0 || u == 1 / 0 ? (r = J(a), (r.length + l) % 2 == 0 && (r += "0"), u = Math.sqrt(r), l = X((l + 1) / 2) - (l < 0 || l % 2), u == 1 / 0 ? r = "5e" + l : (r = u.toExponential(), r = r.slice(0, r.indexOf("e") + 1) + l), n = new c(r)) : n = new c(u.toString()), t = (l = c.precision) + 3; ; ) if (o = n, n = o.plus(L(s, o, t + 2, 1)).times(0.5), J(o.d).slice(0, t) === (r = J(n.d)).slice(0, t)) if (r = r.slice(t - 3, t + 1), r == "9999" || !i && r == "4999") {
        if (!i && (y(o, l + 1, 0), o.times(o).eq(s))) {
          n = o;
          break;
        }
        t += 4, i = 1;
      } else {
        (!+r || !+r.slice(1) && r.charAt(0) == "5") && (y(n, l + 1, 1), e = !n.times(n).eq(s));
        break;
      }
      return w = true, y(n, l, c.rounding, e);
    };
    m.tangent = m.tan = function() {
      var e, r, t = this, n = t.constructor;
      return t.isFinite() ? t.isZero() ? new n(t) : (e = n.precision, r = n.rounding, n.precision = e + 10, n.rounding = 1, t = t.sin(), t.s = 1, t = L(t, new n(1).minus(t.times(t)).sqrt(), e + 10, 0), n.precision = e, n.rounding = r, y(Ne == 2 || Ne == 4 ? t.neg() : t, e, r, true)) : new n(NaN);
    };
    m.times = m.mul = function(e) {
      var r, t, n, i, o, s, a, l, u, c = this, p = c.constructor, d = c.d, f = (e = new p(e)).d;
      if (e.s *= c.s, !d || !d[0] || !f || !f[0]) return new p(!e.s || d && !d[0] && !f || f && !f[0] && !d ? NaN : !d || !f ? e.s / 0 : e.s * 0);
      for (t = X(c.e / E) + X(e.e / E), l = d.length, u = f.length, l < u && (o = d, d = f, f = o, s = l, l = u, u = s), o = [], s = l + u, n = s; n--; ) o.push(0);
      for (n = u; --n >= 0; ) {
        for (r = 0, i = l + n; i > n; ) a = o[i] + f[n] * d[i - n - 1] + r, o[i--] = a % fe | 0, r = a / fe | 0;
        o[i] = (o[i] + r) % fe | 0;
      }
      for (; !o[--s]; ) o.pop();
      return r ? ++t : o.shift(), e.d = o, e.e = wn(o, t), w ? y(e, p.precision, p.rounding) : e;
    };
    m.toBinary = function(e, r) {
      return Ji(this, 2, e, r);
    };
    m.toDecimalPlaces = m.toDP = function(e, r) {
      var t = this, n = t.constructor;
      return t = new n(t), e === void 0 ? t : (ne(e, 0, Ye), r === void 0 ? r = n.rounding : ne(r, 0, 8), y(t, e + t.e + 1, r));
    };
    m.toExponential = function(e, r) {
      var t, n = this, i = n.constructor;
      return e === void 0 ? t = ve(n, true) : (ne(e, 0, Ye), r === void 0 ? r = i.rounding : ne(r, 0, 8), n = y(new i(n), e + 1, r), t = ve(n, true, e + 1)), n.isNeg() && !n.isZero() ? "-" + t : t;
    };
    m.toFixed = function(e, r) {
      var t, n, i = this, o = i.constructor;
      return e === void 0 ? t = ve(i) : (ne(e, 0, Ye), r === void 0 ? r = o.rounding : ne(r, 0, 8), n = y(new o(i), e + i.e + 1, r), t = ve(n, false, e + n.e + 1)), i.isNeg() && !i.isZero() ? "-" + t : t;
    };
    m.toFraction = function(e) {
      var r, t, n, i, o, s, a, l, u, c, p, d, f = this, h = f.d, g = f.constructor;
      if (!h) return new g(f);
      if (u = t = new g(1), n = l = new g(0), r = new g(n), o = r.e = Us(h) - f.e - 1, s = o % E, r.d[0] = U(10, s < 0 ? E + s : s), e == null) e = o > 0 ? r : u;
      else {
        if (a = new g(e), !a.isInt() || a.lt(u)) throw Error(He + a);
        e = a.gt(r) ? o > 0 ? r : u : a;
      }
      for (w = false, a = new g(J(h)), c = g.precision, g.precision = o = h.length * E * 2; p = L(a, r, 0, 1, 1), i = t.plus(p.times(n)), i.cmp(e) != 1; ) t = n, n = i, i = u, u = l.plus(p.times(i)), l = i, i = r, r = a.minus(p.times(i)), a = i;
      return i = L(e.minus(t), n, 0, 1, 1), l = l.plus(i.times(u)), t = t.plus(i.times(n)), l.s = u.s = f.s, d = L(u, n, o, 1).minus(f).abs().cmp(L(l, t, o, 1).minus(f).abs()) < 1 ? [u, n] : [l, t], g.precision = c, w = true, d;
    };
    m.toHexadecimal = m.toHex = function(e, r) {
      return Ji(this, 16, e, r);
    };
    m.toNearest = function(e, r) {
      var t = this, n = t.constructor;
      if (t = new n(t), e == null) {
        if (!t.d) return t;
        e = new n(1), r = n.rounding;
      } else {
        if (e = new n(e), r === void 0 ? r = n.rounding : ne(r, 0, 8), !t.d) return e.s ? t : e;
        if (!e.d) return e.s && (e.s = t.s), e;
      }
      return e.d[0] ? (w = false, t = L(t, e, 0, r, 1).times(e), w = true, y(t)) : (e.s = t.s, t = e), t;
    };
    m.toNumber = function() {
      return +this;
    };
    m.toOctal = function(e, r) {
      return Ji(this, 8, e, r);
    };
    m.toPower = m.pow = function(e) {
      var r, t, n, i, o, s, a = this, l = a.constructor, u = +(e = new l(e));
      if (!a.d || !e.d || !a.d[0] || !e.d[0]) return new l(U(+a, u));
      if (a = new l(a), a.eq(1)) return a;
      if (n = l.precision, o = l.rounding, e.eq(1)) return y(a, n, o);
      if (r = X(e.e / E), r >= e.d.length - 1 && (t = u < 0 ? -u : u) <= xp) return i = Gs(l, a, t, n), e.s < 0 ? new l(1).div(i) : y(i, n, o);
      if (s = a.s, s < 0) {
        if (r < e.d.length - 1) return new l(NaN);
        if ((e.d[r] & 1) == 0 && (s = 1), a.e == 0 && a.d[0] == 1 && a.d.length == 1) return a.s = s, a;
      }
      return t = U(+a, u), r = t == 0 || !isFinite(t) ? X(u * (Math.log("0." + J(a.d)) / Math.LN10 + a.e + 1)) : new l(t + "").e, r > l.maxE + 1 || r < l.minE - 1 ? new l(r > 0 ? s / 0 : 0) : (w = false, l.rounding = a.s = 1, t = Math.min(12, (r + "").length), i = Wi(e.times(Ke(a, n + t)), n), i.d && (i = y(i, n + 5, 1), ut(i.d, n, o) && (r = n + 10, i = y(Wi(e.times(Ke(a, r + t)), r), r + 5, 1), +J(i.d).slice(n + 1, n + 15) + 1 == 1e14 && (i = y(i, n + 1, 0)))), i.s = s, w = true, l.rounding = o, y(i, n, o));
    };
    m.toPrecision = function(e, r) {
      var t, n = this, i = n.constructor;
      return e === void 0 ? t = ve(n, n.e <= i.toExpNeg || n.e >= i.toExpPos) : (ne(e, 1, Ye), r === void 0 ? r = i.rounding : ne(r, 0, 8), n = y(new i(n), e, r), t = ve(n, e <= n.e || n.e <= i.toExpNeg, e)), n.isNeg() && !n.isZero() ? "-" + t : t;
    };
    m.toSignificantDigits = m.toSD = function(e, r) {
      var t = this, n = t.constructor;
      return e === void 0 ? (e = n.precision, r = n.rounding) : (ne(e, 1, Ye), r === void 0 ? r = n.rounding : ne(r, 0, 8)), y(new n(t), e, r);
    };
    m.toString = function() {
      var e = this, r = e.constructor, t = ve(e, e.e <= r.toExpNeg || e.e >= r.toExpPos);
      return e.isNeg() && !e.isZero() ? "-" + t : t;
    };
    m.truncated = m.trunc = function() {
      return y(new this.constructor(this), this.e + 1, 1);
    };
    m.valueOf = m.toJSON = function() {
      var e = this, r = e.constructor, t = ve(e, e.e <= r.toExpNeg || e.e >= r.toExpPos);
      return e.isNeg() ? "-" + t : t;
    };
    function J(e) {
      var r, t, n, i = e.length - 1, o = "", s = e[0];
      if (i > 0) {
        for (o += s, r = 1; r < i; r++) n = e[r] + "", t = E - n.length, t && (o += Je(t)), o += n;
        s = e[r], n = s + "", t = E - n.length, t && (o += Je(t));
      } else if (s === 0) return "0";
      for (; s % 10 === 0; ) s /= 10;
      return o + s;
    }
    function ne(e, r, t) {
      if (e !== ~~e || e < r || e > t) throw Error(He + e);
    }
    function ut(e, r, t, n) {
      var i, o, s, a;
      for (o = e[0]; o >= 10; o /= 10) --r;
      return --r < 0 ? (r += E, i = 0) : (i = Math.ceil((r + 1) / E), r %= E), o = U(10, E - r), a = e[i] % o | 0, n == null ? r < 3 ? (r == 0 ? a = a / 100 | 0 : r == 1 && (a = a / 10 | 0), s = t < 4 && a == 99999 || t > 3 && a == 49999 || a == 5e4 || a == 0) : s = (t < 4 && a + 1 == o || t > 3 && a + 1 == o / 2) && (e[i + 1] / o / 100 | 0) == U(10, r - 2) - 1 || (a == o / 2 || a == 0) && (e[i + 1] / o / 100 | 0) == 0 : r < 4 ? (r == 0 ? a = a / 1e3 | 0 : r == 1 ? a = a / 100 | 0 : r == 2 && (a = a / 10 | 0), s = (n || t < 4) && a == 9999 || !n && t > 3 && a == 4999) : s = ((n || t < 4) && a + 1 == o || !n && t > 3 && a + 1 == o / 2) && (e[i + 1] / o / 1e3 | 0) == U(10, r - 3) - 1, s;
    }
    function fn(e, r, t) {
      for (var n, i = [0], o, s = 0, a = e.length; s < a; ) {
        for (o = i.length; o--; ) i[o] *= r;
        for (i[0] += Ui.indexOf(e.charAt(s++)), n = 0; n < i.length; n++) i[n] > t - 1 && (i[n + 1] === void 0 && (i[n + 1] = 0), i[n + 1] += i[n] / t | 0, i[n] %= t);
      }
      return i.reverse();
    }
    function Pp(e, r) {
      var t, n, i;
      if (r.isZero()) return r;
      n = r.d.length, n < 32 ? (t = Math.ceil(n / 3), i = (1 / xn(4, t)).toString()) : (t = 16, i = "2.3283064365386962890625e-10"), e.precision += t, r = Tr(e, 1, r.times(i), new e(1));
      for (var o = t; o--; ) {
        var s = r.times(r);
        r = s.times(s).minus(s).times(8).plus(1);
      }
      return e.precision -= t, r;
    }
    var L = /* @__PURE__ */ (function() {
      function e(n, i, o) {
        var s, a = 0, l = n.length;
        for (n = n.slice(); l--; ) s = n[l] * i + a, n[l] = s % o | 0, a = s / o | 0;
        return a && n.unshift(a), n;
      }
      function r(n, i, o, s) {
        var a, l;
        if (o != s) l = o > s ? 1 : -1;
        else for (a = l = 0; a < o; a++) if (n[a] != i[a]) {
          l = n[a] > i[a] ? 1 : -1;
          break;
        }
        return l;
      }
      function t(n, i, o, s) {
        for (var a = 0; o--; ) n[o] -= a, a = n[o] < i[o] ? 1 : 0, n[o] = a * s + n[o] - i[o];
        for (; !n[0] && n.length > 1; ) n.shift();
      }
      return function(n, i, o, s, a, l) {
        var u, c, p, d, f, h, g, I, T, S, b, D, me, se, Kr, j, te, Ae, K, fr, Vt = n.constructor, ti = n.s == i.s ? 1 : -1, H = n.d, k = i.d;
        if (!H || !H[0] || !k || !k[0]) return new Vt(!n.s || !i.s || (H ? k && H[0] == k[0] : !k) ? NaN : H && H[0] == 0 || !k ? ti * 0 : ti / 0);
        for (l ? (f = 1, c = n.e - i.e) : (l = fe, f = E, c = X(n.e / f) - X(i.e / f)), K = k.length, te = H.length, T = new Vt(ti), S = T.d = [], p = 0; k[p] == (H[p] || 0); p++) ;
        if (k[p] > (H[p] || 0) && c--, o == null ? (se = o = Vt.precision, s = Vt.rounding) : a ? se = o + (n.e - i.e) + 1 : se = o, se < 0) S.push(1), h = true;
        else {
          if (se = se / f + 2 | 0, p = 0, K == 1) {
            for (d = 0, k = k[0], se++; (p < te || d) && se--; p++) Kr = d * l + (H[p] || 0), S[p] = Kr / k | 0, d = Kr % k | 0;
            h = d || p < te;
          } else {
            for (d = l / (k[0] + 1) | 0, d > 1 && (k = e(k, d, l), H = e(H, d, l), K = k.length, te = H.length), j = K, b = H.slice(0, K), D = b.length; D < K; ) b[D++] = 0;
            fr = k.slice(), fr.unshift(0), Ae = k[0], k[1] >= l / 2 && ++Ae;
            do
              d = 0, u = r(k, b, K, D), u < 0 ? (me = b[0], K != D && (me = me * l + (b[1] || 0)), d = me / Ae | 0, d > 1 ? (d >= l && (d = l - 1), g = e(k, d, l), I = g.length, D = b.length, u = r(g, b, I, D), u == 1 && (d--, t(g, K < I ? fr : k, I, l))) : (d == 0 && (u = d = 1), g = k.slice()), I = g.length, I < D && g.unshift(0), t(b, g, D, l), u == -1 && (D = b.length, u = r(k, b, K, D), u < 1 && (d++, t(b, K < D ? fr : k, D, l))), D = b.length) : u === 0 && (d++, b = [0]), S[p++] = d, u && b[0] ? b[D++] = H[j] || 0 : (b = [H[j]], D = 1);
            while ((j++ < te || b[0] !== void 0) && se--);
            h = b[0] !== void 0;
          }
          S[0] || S.shift();
        }
        if (f == 1) T.e = c, $s = h;
        else {
          for (p = 1, d = S[0]; d >= 10; d /= 10) p++;
          T.e = p + c * f - 1, y(T, a ? o + T.e + 1 : o, s, h);
        }
        return T;
      };
    })();
    function y(e, r, t, n) {
      var i, o, s, a, l, u, c, p, d, f = e.constructor;
      e: if (r != null) {
        if (p = e.d, !p) return e;
        for (i = 1, a = p[0]; a >= 10; a /= 10) i++;
        if (o = r - i, o < 0) o += E, s = r, c = p[d = 0], l = c / U(10, i - s - 1) % 10 | 0;
        else if (d = Math.ceil((o + 1) / E), a = p.length, d >= a) if (n) {
          for (; a++ <= d; ) p.push(0);
          c = l = 0, i = 1, o %= E, s = o - E + 1;
        } else break e;
        else {
          for (c = a = p[d], i = 1; a >= 10; a /= 10) i++;
          o %= E, s = o - E + i, l = s < 0 ? 0 : c / U(10, i - s - 1) % 10 | 0;
        }
        if (n = n || r < 0 || p[d + 1] !== void 0 || (s < 0 ? c : c % U(10, i - s - 1)), u = t < 4 ? (l || n) && (t == 0 || t == (e.s < 0 ? 3 : 2)) : l > 5 || l == 5 && (t == 4 || n || t == 6 && (o > 0 ? s > 0 ? c / U(10, i - s) : 0 : p[d - 1]) % 10 & 1 || t == (e.s < 0 ? 8 : 7)), r < 1 || !p[0]) return p.length = 0, u ? (r -= e.e + 1, p[0] = U(10, (E - r % E) % E), e.e = -r || 0) : p[0] = e.e = 0, e;
        if (o == 0 ? (p.length = d, a = 1, d--) : (p.length = d + 1, a = U(10, E - o), p[d] = s > 0 ? (c / U(10, i - s) % U(10, s) | 0) * a : 0), u) for (; ; ) if (d == 0) {
          for (o = 1, s = p[0]; s >= 10; s /= 10) o++;
          for (s = p[0] += a, a = 1; s >= 10; s /= 10) a++;
          o != a && (e.e++, p[0] == fe && (p[0] = 1));
          break;
        } else {
          if (p[d] += a, p[d] != fe) break;
          p[d--] = 0, a = 1;
        }
        for (o = p.length; p[--o] === 0; ) p.pop();
      }
      return w && (e.e > f.maxE ? (e.d = null, e.e = NaN) : e.e < f.minE && (e.e = 0, e.d = [0])), e;
    }
    function ve(e, r, t) {
      if (!e.isFinite()) return Ws(e);
      var n, i = e.e, o = J(e.d), s = o.length;
      return r ? (t && (n = t - s) > 0 ? o = o.charAt(0) + "." + o.slice(1) + Je(n) : s > 1 && (o = o.charAt(0) + "." + o.slice(1)), o = o + (e.e < 0 ? "e" : "e+") + e.e) : i < 0 ? (o = "0." + Je(-i - 1) + o, t && (n = t - s) > 0 && (o += Je(n))) : i >= s ? (o += Je(i + 1 - s), t && (n = t - i - 1) > 0 && (o = o + "." + Je(n))) : ((n = i + 1) < s && (o = o.slice(0, n) + "." + o.slice(n)), t && (n = t - s) > 0 && (i + 1 === s && (o += "."), o += Je(n))), o;
    }
    function wn(e, r) {
      var t = e[0];
      for (r *= E; t >= 10; t /= 10) r++;
      return r;
    }
    function bn(e, r, t) {
      if (r > vp) throw w = true, t && (e.precision = t), Error(qs);
      return y(new e(hn), r, 1, true);
    }
    function xe(e, r, t) {
      if (r > Qi) throw Error(qs);
      return y(new e(yn), r, t, true);
    }
    function Us(e) {
      var r = e.length - 1, t = r * E + 1;
      if (r = e[r], r) {
        for (; r % 10 == 0; r /= 10) t--;
        for (r = e[0]; r >= 10; r /= 10) t++;
      }
      return t;
    }
    function Je(e) {
      for (var r = ""; e--; ) r += "0";
      return r;
    }
    function Gs(e, r, t, n) {
      var i, o = new e(1), s = Math.ceil(n / E + 4);
      for (w = false; ; ) {
        if (t % 2 && (o = o.times(r), Fs(o.d, s) && (i = true)), t = X(t / 2), t === 0) {
          t = o.d.length - 1, i && o.d[t] === 0 && ++o.d[t];
          break;
        }
        r = r.times(r), Fs(r.d, s);
      }
      return w = true, o;
    }
    function Ls(e) {
      return e.d[e.d.length - 1] & 1;
    }
    function Qs(e, r, t) {
      for (var n, i, o = new e(r[0]), s = 0; ++s < r.length; ) {
        if (i = new e(r[s]), !i.s) {
          o = i;
          break;
        }
        n = o.cmp(i), (n === t || n === 0 && o.s === t) && (o = i);
      }
      return o;
    }
    function Wi(e, r) {
      var t, n, i, o, s, a, l, u = 0, c = 0, p = 0, d = e.constructor, f = d.rounding, h = d.precision;
      if (!e.d || !e.d[0] || e.e > 17) return new d(e.d ? e.d[0] ? e.s < 0 ? 0 : 1 / 0 : 1 : e.s ? e.s < 0 ? 0 : e : NaN);
      for (r == null ? (w = false, l = h) : l = r, a = new d(0.03125); e.e > -2; ) e = e.times(a), p += 5;
      for (n = Math.log(U(2, p)) / Math.LN10 * 2 + 5 | 0, l += n, t = o = s = new d(1), d.precision = l; ; ) {
        if (o = y(o.times(e), l, 1), t = t.times(++c), a = s.plus(L(o, t, l, 1)), J(a.d).slice(0, l) === J(s.d).slice(0, l)) {
          for (i = p; i--; ) s = y(s.times(s), l, 1);
          if (r == null) if (u < 3 && ut(s.d, l - n, f, u)) d.precision = l += 10, t = o = a = new d(1), c = 0, u++;
          else return y(s, d.precision = h, f, w = true);
          else return d.precision = h, s;
        }
        s = a;
      }
    }
    function Ke(e, r) {
      var t, n, i, o, s, a, l, u, c, p, d, f = 1, h = 10, g = e, I = g.d, T = g.constructor, S = T.rounding, b = T.precision;
      if (g.s < 0 || !I || !I[0] || !g.e && I[0] == 1 && I.length == 1) return new T(I && !I[0] ? -1 / 0 : g.s != 1 ? NaN : I ? 0 : g);
      if (r == null ? (w = false, c = b) : c = r, T.precision = c += h, t = J(I), n = t.charAt(0), Math.abs(o = g.e) < 15e14) {
        for (; n < 7 && n != 1 || n == 1 && t.charAt(1) > 3; ) g = g.times(e), t = J(g.d), n = t.charAt(0), f++;
        o = g.e, n > 1 ? (g = new T("0." + t), o++) : g = new T(n + "." + t.slice(1));
      } else return u = bn(T, c + 2, b).times(o + ""), g = Ke(new T(n + "." + t.slice(1)), c - h).plus(u), T.precision = b, r == null ? y(g, b, S, w = true) : g;
      for (p = g, l = s = g = L(g.minus(1), g.plus(1), c, 1), d = y(g.times(g), c, 1), i = 3; ; ) {
        if (s = y(s.times(d), c, 1), u = l.plus(L(s, new T(i), c, 1)), J(u.d).slice(0, c) === J(l.d).slice(0, c)) if (l = l.times(2), o !== 0 && (l = l.plus(bn(T, c + 2, b).times(o + ""))), l = L(l, new T(f), c, 1), r == null) if (ut(l.d, c - h, S, a)) T.precision = c += h, u = s = g = L(p.minus(1), p.plus(1), c, 1), d = y(g.times(g), c, 1), i = a = 1;
        else return y(l, T.precision = b, S, w = true);
        else return T.precision = b, l;
        l = u, i += 2;
      }
    }
    function Ws(e) {
      return String(e.s * e.s / 0);
    }
    function gn(e, r) {
      var t, n, i;
      for ((t = r.indexOf(".")) > -1 && (r = r.replace(".", "")), (n = r.search(/e/i)) > 0 ? (t < 0 && (t = n), t += +r.slice(n + 1), r = r.substring(0, n)) : t < 0 && (t = r.length), n = 0; r.charCodeAt(n) === 48; n++) ;
      for (i = r.length; r.charCodeAt(i - 1) === 48; --i) ;
      if (r = r.slice(n, i), r) {
        if (i -= n, e.e = t = t - n - 1, e.d = [], n = (t + 1) % E, t < 0 && (n += E), n < i) {
          for (n && e.d.push(+r.slice(0, n)), i -= E; n < i; ) e.d.push(+r.slice(n, n += E));
          r = r.slice(n), n = E - r.length;
        } else n -= i;
        for (; n--; ) r += "0";
        e.d.push(+r), w && (e.e > e.constructor.maxE ? (e.d = null, e.e = NaN) : e.e < e.constructor.minE && (e.e = 0, e.d = [0]));
      } else e.e = 0, e.d = [0];
      return e;
    }
    function Tp(e, r) {
      var t, n, i, o, s, a, l, u, c;
      if (r.indexOf("_") > -1) {
        if (r = r.replace(/(\d)_(?=\d)/g, "$1"), Bs.test(r)) return gn(e, r);
      } else if (r === "Infinity" || r === "NaN") return +r || (e.s = NaN), e.e = NaN, e.d = null, e;
      if (Ep.test(r)) t = 16, r = r.toLowerCase();
      else if (bp.test(r)) t = 2;
      else if (wp.test(r)) t = 8;
      else throw Error(He + r);
      for (o = r.search(/p/i), o > 0 ? (l = +r.slice(o + 1), r = r.substring(2, o)) : r = r.slice(2), o = r.indexOf("."), s = o >= 0, n = e.constructor, s && (r = r.replace(".", ""), a = r.length, o = a - o, i = Gs(n, new n(t), o, o * 2)), u = fn(r, t, fe), c = u.length - 1, o = c; u[o] === 0; --o) u.pop();
      return o < 0 ? new n(e.s * 0) : (e.e = wn(u, c), e.d = u, w = false, s && (e = L(e, i, a * 4)), l && (e = e.times(Math.abs(l) < 54 ? U(2, l) : Le.pow(2, l))), w = true, e);
    }
    function Sp(e, r) {
      var t, n = r.d.length;
      if (n < 3) return r.isZero() ? r : Tr(e, 2, r, r);
      t = 1.4 * Math.sqrt(n), t = t > 16 ? 16 : t | 0, r = r.times(1 / xn(5, t)), r = Tr(e, 2, r, r);
      for (var i, o = new e(5), s = new e(16), a = new e(20); t--; ) i = r.times(r), r = r.times(o.plus(i.times(s.times(i).minus(a))));
      return r;
    }
    function Tr(e, r, t, n, i) {
      var o, s, a, l, u = 1, c = e.precision, p = Math.ceil(c / E);
      for (w = false, l = t.times(t), a = new e(n); ; ) {
        if (s = L(a.times(l), new e(r++ * r++), c, 1), a = i ? n.plus(s) : n.minus(s), n = L(s.times(l), new e(r++ * r++), c, 1), s = a.plus(n), s.d[p] !== void 0) {
          for (o = p; s.d[o] === a.d[o] && o--; ) ;
          if (o == -1) break;
        }
        o = a, a = n, n = s, s = o, u++;
      }
      return w = true, s.d.length = p + 1, s;
    }
    function xn(e, r) {
      for (var t = e; --r; ) t *= e;
      return t;
    }
    function Js(e, r) {
      var t, n = r.s < 0, i = xe(e, e.precision, 1), o = i.times(0.5);
      if (r = r.abs(), r.lte(o)) return Ne = n ? 4 : 1, r;
      if (t = r.divToInt(i), t.isZero()) Ne = n ? 3 : 2;
      else {
        if (r = r.minus(t.times(i)), r.lte(o)) return Ne = Ls(t) ? n ? 2 : 3 : n ? 4 : 1, r;
        Ne = Ls(t) ? n ? 1 : 4 : n ? 3 : 2;
      }
      return r.minus(i).abs();
    }
    function Ji(e, r, t, n) {
      var i, o, s, a, l, u, c, p, d, f = e.constructor, h = t !== void 0;
      if (h ? (ne(t, 1, Ye), n === void 0 ? n = f.rounding : ne(n, 0, 8)) : (t = f.precision, n = f.rounding), !e.isFinite()) c = Ws(e);
      else {
        for (c = ve(e), s = c.indexOf("."), h ? (i = 2, r == 16 ? t = t * 4 - 3 : r == 8 && (t = t * 3 - 2)) : i = r, s >= 0 && (c = c.replace(".", ""), d = new f(1), d.e = c.length - s, d.d = fn(ve(d), 10, i), d.e = d.d.length), p = fn(c, 10, i), o = l = p.length; p[--l] == 0; ) p.pop();
        if (!p[0]) c = h ? "0p+0" : "0";
        else {
          if (s < 0 ? o-- : (e = new f(e), e.d = p, e.e = o, e = L(e, d, t, n, 0, i), p = e.d, o = e.e, u = $s), s = p[t], a = i / 2, u = u || p[t + 1] !== void 0, u = n < 4 ? (s !== void 0 || u) && (n === 0 || n === (e.s < 0 ? 3 : 2)) : s > a || s === a && (n === 4 || u || n === 6 && p[t - 1] & 1 || n === (e.s < 0 ? 8 : 7)), p.length = t, u) for (; ++p[--t] > i - 1; ) p[t] = 0, t || (++o, p.unshift(1));
          for (l = p.length; !p[l - 1]; --l) ;
          for (s = 0, c = ""; s < l; s++) c += Ui.charAt(p[s]);
          if (h) {
            if (l > 1) if (r == 16 || r == 8) {
              for (s = r == 16 ? 4 : 3, --l; l % s; l++) c += "0";
              for (p = fn(c, i, r), l = p.length; !p[l - 1]; --l) ;
              for (s = 1, c = "1."; s < l; s++) c += Ui.charAt(p[s]);
            } else c = c.charAt(0) + "." + c.slice(1);
            c = c + (o < 0 ? "p" : "p+") + o;
          } else if (o < 0) {
            for (; ++o; ) c = "0" + c;
            c = "0." + c;
          } else if (++o > l) for (o -= l; o--; ) c += "0";
          else o < l && (c = c.slice(0, o) + "." + c.slice(o));
        }
        c = (r == 16 ? "0x" : r == 2 ? "0b" : r == 8 ? "0o" : "") + c;
      }
      return e.s < 0 ? "-" + c : c;
    }
    function Fs(e, r) {
      if (e.length > r) return e.length = r, true;
    }
    function Rp(e) {
      return new this(e).abs();
    }
    function Ap(e) {
      return new this(e).acos();
    }
    function Cp(e) {
      return new this(e).acosh();
    }
    function Ip(e, r) {
      return new this(e).plus(r);
    }
    function Dp(e) {
      return new this(e).asin();
    }
    function Op(e) {
      return new this(e).asinh();
    }
    function kp(e) {
      return new this(e).atan();
    }
    function _p(e) {
      return new this(e).atanh();
    }
    function Np(e, r) {
      e = new this(e), r = new this(r);
      var t, n = this.precision, i = this.rounding, o = n + 4;
      return !e.s || !r.s ? t = new this(NaN) : !e.d && !r.d ? (t = xe(this, o, 1).times(r.s > 0 ? 0.25 : 0.75), t.s = e.s) : !r.d || e.isZero() ? (t = r.s < 0 ? xe(this, n, i) : new this(0), t.s = e.s) : !e.d || r.isZero() ? (t = xe(this, o, 1).times(0.5), t.s = e.s) : r.s < 0 ? (this.precision = o, this.rounding = 1, t = this.atan(L(e, r, o, 1)), r = xe(this, o, 1), this.precision = n, this.rounding = i, t = e.s < 0 ? t.minus(r) : t.plus(r)) : t = this.atan(L(e, r, o, 1)), t;
    }
    function Lp(e) {
      return new this(e).cbrt();
    }
    function Fp(e) {
      return y(e = new this(e), e.e + 1, 2);
    }
    function Mp(e, r, t) {
      return new this(e).clamp(r, t);
    }
    function $p(e) {
      if (!e || typeof e != "object") throw Error(En + "Object expected");
      var r, t, n, i = e.defaults === true, o = ["precision", 1, Ye, "rounding", 0, 8, "toExpNeg", -Pr, 0, "toExpPos", 0, Pr, "maxE", 0, Pr, "minE", -Pr, 0, "modulo", 0, 9];
      for (r = 0; r < o.length; r += 3) if (t = o[r], i && (this[t] = Gi[t]), (n = e[t]) !== void 0) if (X(n) === n && n >= o[r + 1] && n <= o[r + 2]) this[t] = n;
      else throw Error(He + t + ": " + n);
      if (t = "crypto", i && (this[t] = Gi[t]), (n = e[t]) !== void 0) if (n === true || n === false || n === 0 || n === 1) if (n) if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes)) this[t] = true;
      else throw Error(Vs);
      else this[t] = false;
      else throw Error(He + t + ": " + n);
      return this;
    }
    function qp(e) {
      return new this(e).cos();
    }
    function Vp(e) {
      return new this(e).cosh();
    }
    function Ks(e) {
      var r, t, n;
      function i(o) {
        var s, a, l, u = this;
        if (!(u instanceof i)) return new i(o);
        if (u.constructor = i, Ms(o)) {
          u.s = o.s, w ? !o.d || o.e > i.maxE ? (u.e = NaN, u.d = null) : o.e < i.minE ? (u.e = 0, u.d = [0]) : (u.e = o.e, u.d = o.d.slice()) : (u.e = o.e, u.d = o.d ? o.d.slice() : o.d);
          return;
        }
        if (l = typeof o, l === "number") {
          if (o === 0) {
            u.s = 1 / o < 0 ? -1 : 1, u.e = 0, u.d = [0];
            return;
          }
          if (o < 0 ? (o = -o, u.s = -1) : u.s = 1, o === ~~o && o < 1e7) {
            for (s = 0, a = o; a >= 10; a /= 10) s++;
            w ? s > i.maxE ? (u.e = NaN, u.d = null) : s < i.minE ? (u.e = 0, u.d = [0]) : (u.e = s, u.d = [o]) : (u.e = s, u.d = [o]);
            return;
          }
          if (o * 0 !== 0) {
            o || (u.s = NaN), u.e = NaN, u.d = null;
            return;
          }
          return gn(u, o.toString());
        }
        if (l === "string") return (a = o.charCodeAt(0)) === 45 ? (o = o.slice(1), u.s = -1) : (a === 43 && (o = o.slice(1)), u.s = 1), Bs.test(o) ? gn(u, o) : Tp(u, o);
        if (l === "bigint") return o < 0 ? (o = -o, u.s = -1) : u.s = 1, gn(u, o.toString());
        throw Error(He + o);
      }
      if (i.prototype = m, i.ROUND_UP = 0, i.ROUND_DOWN = 1, i.ROUND_CEIL = 2, i.ROUND_FLOOR = 3, i.ROUND_HALF_UP = 4, i.ROUND_HALF_DOWN = 5, i.ROUND_HALF_EVEN = 6, i.ROUND_HALF_CEIL = 7, i.ROUND_HALF_FLOOR = 8, i.EUCLID = 9, i.config = i.set = $p, i.clone = Ks, i.isDecimal = Ms, i.abs = Rp, i.acos = Ap, i.acosh = Cp, i.add = Ip, i.asin = Dp, i.asinh = Op, i.atan = kp, i.atanh = _p, i.atan2 = Np, i.cbrt = Lp, i.ceil = Fp, i.clamp = Mp, i.cos = qp, i.cosh = Vp, i.div = jp, i.exp = Bp, i.floor = Up, i.hypot = Gp, i.ln = Qp, i.log = Wp, i.log10 = Kp, i.log2 = Jp, i.max = Hp, i.min = Yp, i.mod = zp, i.mul = Zp, i.pow = Xp, i.random = ed, i.round = rd, i.sign = td, i.sin = nd, i.sinh = id, i.sqrt = od, i.sub = sd, i.sum = ad, i.tan = ld, i.tanh = ud, i.trunc = cd, e === void 0 && (e = {}), e && e.defaults !== true) for (n = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], r = 0; r < n.length; ) e.hasOwnProperty(t = n[r++]) || (e[t] = this[t]);
      return i.config(e), i;
    }
    function jp(e, r) {
      return new this(e).div(r);
    }
    function Bp(e) {
      return new this(e).exp();
    }
    function Up(e) {
      return y(e = new this(e), e.e + 1, 3);
    }
    function Gp() {
      var e, r, t = new this(0);
      for (w = false, e = 0; e < arguments.length; ) if (r = new this(arguments[e++]), r.d) t.d && (t = t.plus(r.times(r)));
      else {
        if (r.s) return w = true, new this(1 / 0);
        t = r;
      }
      return w = true, t.sqrt();
    }
    function Ms(e) {
      return e instanceof Le || e && e.toStringTag === js || false;
    }
    function Qp(e) {
      return new this(e).ln();
    }
    function Wp(e, r) {
      return new this(e).log(r);
    }
    function Jp(e) {
      return new this(e).log(2);
    }
    function Kp(e) {
      return new this(e).log(10);
    }
    function Hp() {
      return Qs(this, arguments, -1);
    }
    function Yp() {
      return Qs(this, arguments, 1);
    }
    function zp(e, r) {
      return new this(e).mod(r);
    }
    function Zp(e, r) {
      return new this(e).mul(r);
    }
    function Xp(e, r) {
      return new this(e).pow(r);
    }
    function ed(e) {
      var r, t, n, i, o = 0, s = new this(1), a = [];
      if (e === void 0 ? e = this.precision : ne(e, 1, Ye), n = Math.ceil(e / E), this.crypto) if (crypto.getRandomValues) for (r = crypto.getRandomValues(new Uint32Array(n)); o < n; ) i = r[o], i >= 429e7 ? r[o] = crypto.getRandomValues(new Uint32Array(1))[0] : a[o++] = i % 1e7;
      else if (crypto.randomBytes) {
        for (r = crypto.randomBytes(n *= 4); o < n; ) i = r[o] + (r[o + 1] << 8) + (r[o + 2] << 16) + ((r[o + 3] & 127) << 24), i >= 214e7 ? crypto.randomBytes(4).copy(r, o) : (a.push(i % 1e7), o += 4);
        o = n / 4;
      } else throw Error(Vs);
      else for (; o < n; ) a[o++] = Math.random() * 1e7 | 0;
      for (n = a[--o], e %= E, n && e && (i = U(10, E - e), a[o] = (n / i | 0) * i); a[o] === 0; o--) a.pop();
      if (o < 0) t = 0, a = [0];
      else {
        for (t = -1; a[0] === 0; t -= E) a.shift();
        for (n = 1, i = a[0]; i >= 10; i /= 10) n++;
        n < E && (t -= E - n);
      }
      return s.e = t, s.d = a, s;
    }
    function rd(e) {
      return y(e = new this(e), e.e + 1, this.rounding);
    }
    function td(e) {
      return e = new this(e), e.d ? e.d[0] ? e.s : 0 * e.s : e.s || NaN;
    }
    function nd(e) {
      return new this(e).sin();
    }
    function id(e) {
      return new this(e).sinh();
    }
    function od(e) {
      return new this(e).sqrt();
    }
    function sd(e, r) {
      return new this(e).sub(r);
    }
    function ad() {
      var e = 0, r = arguments, t = new this(r[e]);
      for (w = false; t.s && ++e < r.length; ) t = t.plus(r[e]);
      return w = true, y(t, this.precision, this.rounding);
    }
    function ld(e) {
      return new this(e).tan();
    }
    function ud(e) {
      return new this(e).tanh();
    }
    function cd(e) {
      return y(e = new this(e), e.e + 1, 1);
    }
    m[Symbol.for("nodejs.util.inspect.custom")] = m.toString;
    m[Symbol.toStringTag] = "Decimal";
    var Le = m.constructor = Ks(Gi);
    hn = new Le(hn);
    yn = new Le(yn);
    var Fe = Le;
    function Sr(e) {
      return Le.isDecimal(e) ? true : e !== null && typeof e == "object" && typeof e.s == "number" && typeof e.e == "number" && typeof e.toFixed == "function" && Array.isArray(e.d);
    }
    var ct = {};
    tr(ct, { ModelAction: () => Rr, datamodelEnumToSchemaEnum: () => pd });
    function pd(e) {
      return { name: e.name, values: e.values.map((r) => r.name) };
    }
    var Rr = ((b) => (b.findUnique = "findUnique", b.findUniqueOrThrow = "findUniqueOrThrow", b.findFirst = "findFirst", b.findFirstOrThrow = "findFirstOrThrow", b.findMany = "findMany", b.create = "create", b.createMany = "createMany", b.createManyAndReturn = "createManyAndReturn", b.update = "update", b.updateMany = "updateMany", b.updateManyAndReturn = "updateManyAndReturn", b.upsert = "upsert", b.delete = "delete", b.deleteMany = "deleteMany", b.groupBy = "groupBy", b.count = "count", b.aggregate = "aggregate", b.findRaw = "findRaw", b.aggregateRaw = "aggregateRaw", b))(Rr || {});
    var Xs = O(Di());
    var Zs = O(require("fs"));
    var Hs = { keyword: De, entity: De, value: (e) => W(nr(e)), punctuation: nr, directive: De, function: De, variable: (e) => W(nr(e)), string: (e) => W(qe(e)), boolean: Ie, number: De, comment: Hr };
    var dd = (e) => e;
    var vn = {};
    var md = 0;
    var v = { manual: vn.Prism && vn.Prism.manual, disableWorkerMessageHandler: vn.Prism && vn.Prism.disableWorkerMessageHandler, util: { encode: function(e) {
      if (e instanceof ge) {
        let r = e;
        return new ge(r.type, v.util.encode(r.content), r.alias);
      } else return Array.isArray(e) ? e.map(v.util.encode) : e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
    }, type: function(e) {
      return Object.prototype.toString.call(e).slice(8, -1);
    }, objId: function(e) {
      return e.__id || Object.defineProperty(e, "__id", { value: ++md }), e.__id;
    }, clone: function e(r, t) {
      let n, i, o = v.util.type(r);
      switch (t = t || {}, o) {
        case "Object":
          if (i = v.util.objId(r), t[i]) return t[i];
          n = {}, t[i] = n;
          for (let s in r) r.hasOwnProperty(s) && (n[s] = e(r[s], t));
          return n;
        case "Array":
          return i = v.util.objId(r), t[i] ? t[i] : (n = [], t[i] = n, r.forEach(function(s, a) {
            n[a] = e(s, t);
          }), n);
        default:
          return r;
      }
    } }, languages: { extend: function(e, r) {
      let t = v.util.clone(v.languages[e]);
      for (let n in r) t[n] = r[n];
      return t;
    }, insertBefore: function(e, r, t, n) {
      n = n || v.languages;
      let i = n[e], o = {};
      for (let a in i) if (i.hasOwnProperty(a)) {
        if (a == r) for (let l in t) t.hasOwnProperty(l) && (o[l] = t[l]);
        t.hasOwnProperty(a) || (o[a] = i[a]);
      }
      let s = n[e];
      return n[e] = o, v.languages.DFS(v.languages, function(a, l) {
        l === s && a != e && (this[a] = o);
      }), o;
    }, DFS: function e(r, t, n, i) {
      i = i || {};
      let o = v.util.objId;
      for (let s in r) if (r.hasOwnProperty(s)) {
        t.call(r, s, r[s], n || s);
        let a = r[s], l = v.util.type(a);
        l === "Object" && !i[o(a)] ? (i[o(a)] = true, e(a, t, null, i)) : l === "Array" && !i[o(a)] && (i[o(a)] = true, e(a, t, s, i));
      }
    } }, plugins: {}, highlight: function(e, r, t) {
      let n = { code: e, grammar: r, language: t };
      return v.hooks.run("before-tokenize", n), n.tokens = v.tokenize(n.code, n.grammar), v.hooks.run("after-tokenize", n), ge.stringify(v.util.encode(n.tokens), n.language);
    }, matchGrammar: function(e, r, t, n, i, o, s) {
      for (let g in t) {
        if (!t.hasOwnProperty(g) || !t[g]) continue;
        if (g == s) return;
        let I = t[g];
        I = v.util.type(I) === "Array" ? I : [I];
        for (let T = 0; T < I.length; ++T) {
          let S = I[T], b = S.inside, D = !!S.lookbehind, me = !!S.greedy, se = 0, Kr = S.alias;
          if (me && !S.pattern.global) {
            let j = S.pattern.toString().match(/[imuy]*$/)[0];
            S.pattern = RegExp(S.pattern.source, j + "g");
          }
          S = S.pattern || S;
          for (let j = n, te = i; j < r.length; te += r[j].length, ++j) {
            let Ae = r[j];
            if (r.length > e.length) return;
            if (Ae instanceof ge) continue;
            if (me && j != r.length - 1) {
              S.lastIndex = te;
              var p = S.exec(e);
              if (!p) break;
              var c = p.index + (D ? p[1].length : 0), d = p.index + p[0].length, a = j, l = te;
              for (let k = r.length; a < k && (l < d || !r[a].type && !r[a - 1].greedy); ++a) l += r[a].length, c >= l && (++j, te = l);
              if (r[j] instanceof ge) continue;
              u = a - j, Ae = e.slice(te, l), p.index -= te;
            } else {
              S.lastIndex = 0;
              var p = S.exec(Ae), u = 1;
            }
            if (!p) {
              if (o) break;
              continue;
            }
            D && (se = p[1] ? p[1].length : 0);
            var c = p.index + se, p = p[0].slice(se), d = c + p.length, f = Ae.slice(0, c), h = Ae.slice(d);
            let K = [j, u];
            f && (++j, te += f.length, K.push(f));
            let fr = new ge(g, b ? v.tokenize(p, b) : p, Kr, p, me);
            if (K.push(fr), h && K.push(h), Array.prototype.splice.apply(r, K), u != 1 && v.matchGrammar(e, r, t, j, te, true, g), o) break;
          }
        }
      }
    }, tokenize: function(e, r) {
      let t = [e], n = r.rest;
      if (n) {
        for (let i in n) r[i] = n[i];
        delete r.rest;
      }
      return v.matchGrammar(e, t, r, 0, 0, false), t;
    }, hooks: { all: {}, add: function(e, r) {
      let t = v.hooks.all;
      t[e] = t[e] || [], t[e].push(r);
    }, run: function(e, r) {
      let t = v.hooks.all[e];
      if (!(!t || !t.length)) for (var n = 0, i; i = t[n++]; ) i(r);
    } }, Token: ge };
    v.languages.clike = { comment: [{ pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: true }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }], string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: true }, "class-name": { pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i, lookbehind: true, inside: { punctuation: /[.\\]/ } }, keyword: /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/, boolean: /\b(?:true|false)\b/, function: /\w+(?=\()/, number: /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i, operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/, punctuation: /[{}[\];(),.:]/ };
    v.languages.javascript = v.languages.extend("clike", { "class-name": [v.languages.clike["class-name"], { pattern: /(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/, lookbehind: true }], keyword: [{ pattern: /((?:^|})\s*)(?:catch|finally)\b/, lookbehind: true }, { pattern: /(^|[^.])\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/, lookbehind: true }], number: /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/, function: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/, operator: /-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/ });
    v.languages.javascript["class-name"][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;
    v.languages.insertBefore("javascript", "keyword", { regex: { pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=\s*($|[\r\n,.;})\]]))/, lookbehind: true, greedy: true }, "function-variable": { pattern: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/, alias: "function" }, parameter: [{ pattern: /(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/, lookbehind: true, inside: v.languages.javascript }, { pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=>)/i, inside: v.languages.javascript }, { pattern: /(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=>)/, lookbehind: true, inside: v.languages.javascript }, { pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/, lookbehind: true, inside: v.languages.javascript }], constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/ });
    v.languages.markup && v.languages.markup.tag.addInlined("script", "javascript");
    v.languages.js = v.languages.javascript;
    v.languages.typescript = v.languages.extend("javascript", { keyword: /\b(?:abstract|as|async|await|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|is|keyof|let|module|namespace|new|null|of|package|private|protected|public|readonly|return|require|set|static|super|switch|this|throw|try|type|typeof|var|void|while|with|yield)\b/, builtin: /\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\b/ });
    v.languages.ts = v.languages.typescript;
    function ge(e, r, t, n, i) {
      this.type = e, this.content = r, this.alias = t, this.length = (n || "").length | 0, this.greedy = !!i;
    }
    ge.stringify = function(e, r) {
      return typeof e == "string" ? e : Array.isArray(e) ? e.map(function(t) {
        return ge.stringify(t, r);
      }).join("") : fd(e.type)(e.content);
    };
    function fd(e) {
      return Hs[e] || dd;
    }
    function Ys(e) {
      return gd(e, v.languages.javascript);
    }
    function gd(e, r) {
      return v.tokenize(e, r).map((n) => ge.stringify(n)).join("");
    }
    function zs(e) {
      return Ci(e);
    }
    var Pn = class e {
      constructor(r, t) {
        __publicField(this, "firstLineNumber");
        __publicField(this, "lines");
        this.firstLineNumber = r, this.lines = t;
      }
      static read(r) {
        let t;
        try {
          t = Zs.default.readFileSync(r, "utf-8");
        } catch {
          return null;
        }
        return e.fromContent(t);
      }
      static fromContent(r) {
        let t = r.split(/\r?\n/);
        return new e(1, t);
      }
      get lastLineNumber() {
        return this.firstLineNumber + this.lines.length - 1;
      }
      mapLineAt(r, t) {
        if (r < this.firstLineNumber || r > this.lines.length + this.firstLineNumber) return this;
        let n = r - this.firstLineNumber, i = [...this.lines];
        return i[n] = t(i[n]), new e(this.firstLineNumber, i);
      }
      mapLines(r) {
        return new e(this.firstLineNumber, this.lines.map((t, n) => r(t, this.firstLineNumber + n)));
      }
      lineAt(r) {
        return this.lines[r - this.firstLineNumber];
      }
      prependSymbolAt(r, t) {
        return this.mapLines((n, i) => i === r ? `${t} ${n}` : `  ${n}`);
      }
      slice(r, t) {
        let n = this.lines.slice(r - 1, t).join(`
`);
        return new e(r, zs(n).split(`
`));
      }
      highlight() {
        let r = Ys(this.toString());
        return new e(this.firstLineNumber, r.split(`
`));
      }
      toString() {
        return this.lines.join(`
`);
      }
    };
    var hd = { red: ce, gray: Hr, dim: Ce, bold: W, underline: Y, highlightSource: (e) => e.highlight() };
    var yd = { red: (e) => e, gray: (e) => e, dim: (e) => e, bold: (e) => e, underline: (e) => e, highlightSource: (e) => e };
    function bd({ message: e, originalMethod: r, isPanic: t, callArguments: n }) {
      return { functionName: `prisma.${r}()`, message: e, isPanic: t ?? false, callArguments: n };
    }
    function Ed({ callsite: e, message: r, originalMethod: t, isPanic: n, callArguments: i }, o) {
      let s = bd({ message: r, originalMethod: t, isPanic: n, callArguments: i });
      if (!e || typeof window < "u" || process.env.NODE_ENV === "production") return s;
      let a = e.getLocation();
      if (!a || !a.lineNumber || !a.columnNumber) return s;
      let l = Math.max(1, a.lineNumber - 3), u = Pn.read(a.fileName)?.slice(l, a.lineNumber), c = u?.lineAt(a.lineNumber);
      if (u && c) {
        let p = xd(c), d = wd(c);
        if (!d) return s;
        s.functionName = `${d.code})`, s.location = a, n || (u = u.mapLineAt(a.lineNumber, (h) => h.slice(0, d.openingBraceIndex))), u = o.highlightSource(u);
        let f = String(u.lastLineNumber).length;
        if (s.contextLines = u.mapLines((h, g) => o.gray(String(g).padStart(f)) + " " + h).mapLines((h) => o.dim(h)).prependSymbolAt(a.lineNumber, o.bold(o.red("\u2192"))), i) {
          let h = p + f + 1;
          h += 2, s.callArguments = (0, Xs.default)(i, h).slice(h);
        }
      }
      return s;
    }
    function wd(e) {
      let r = Object.keys(Rr).join("|"), n = new RegExp(String.raw`\.(${r})\(`).exec(e);
      if (n) {
        let i = n.index + n[0].length, o = e.lastIndexOf(" ", n.index) + 1;
        return { code: e.slice(o, i), openingBraceIndex: i };
      }
      return null;
    }
    function xd(e) {
      let r = 0;
      for (let t = 0; t < e.length; t++) {
        if (e.charAt(t) !== " ") return r;
        r++;
      }
      return r;
    }
    function vd({ functionName: e, location: r, message: t, isPanic: n, contextLines: i, callArguments: o }, s) {
      let a = [""], l = r ? " in" : ":";
      if (n ? (a.push(s.red(`Oops, an unknown error occurred! This is ${s.bold("on us")}, you did nothing wrong.`)), a.push(s.red(`It occurred in the ${s.bold(`\`${e}\``)} invocation${l}`))) : a.push(s.red(`Invalid ${s.bold(`\`${e}\``)} invocation${l}`)), r && a.push(s.underline(Pd(r))), i) {
        a.push("");
        let u = [i.toString()];
        o && (u.push(o), u.push(s.dim(")"))), a.push(u.join("")), o && a.push("");
      } else a.push(""), o && a.push(o), a.push("");
      return a.push(t), a.join(`
`);
    }
    function Pd(e) {
      let r = [e.fileName];
      return e.lineNumber && r.push(String(e.lineNumber)), e.columnNumber && r.push(String(e.columnNumber)), r.join(":");
    }
    function Tn(e) {
      let r = e.showColors ? hd : yd, t;
      return t = Ed(e, r), vd(t, r);
    }
    var la = O(Ki());
    function na(e, r, t) {
      let n = ia(e), i = Td(n), o = Rd(i);
      o ? Sn(o, r, t) : r.addErrorMessage(() => "Unknown error");
    }
    function ia(e) {
      return e.errors.flatMap((r) => r.kind === "Union" ? ia(r) : [r]);
    }
    function Td(e) {
      let r = /* @__PURE__ */ new Map(), t = [];
      for (let n of e) {
        if (n.kind !== "InvalidArgumentType") {
          t.push(n);
          continue;
        }
        let i = `${n.selectionPath.join(".")}:${n.argumentPath.join(".")}`, o = r.get(i);
        o ? r.set(i, { ...n, argument: { ...n.argument, typeNames: Sd(o.argument.typeNames, n.argument.typeNames) } }) : r.set(i, n);
      }
      return t.push(...r.values()), t;
    }
    function Sd(e, r) {
      return [...new Set(e.concat(r))];
    }
    function Rd(e) {
      return ji(e, (r, t) => {
        let n = ra(r), i = ra(t);
        return n !== i ? n - i : ta(r) - ta(t);
      });
    }
    function ra(e) {
      let r = 0;
      return Array.isArray(e.selectionPath) && (r += e.selectionPath.length), Array.isArray(e.argumentPath) && (r += e.argumentPath.length), r;
    }
    function ta(e) {
      switch (e.kind) {
        case "InvalidArgumentValue":
        case "ValueTooLarge":
          return 20;
        case "InvalidArgumentType":
          return 10;
        case "RequiredArgumentMissing":
          return -10;
        default:
          return 0;
      }
    }
    var le = class {
      constructor(r, t) {
        __publicField(this, "isRequired", false);
        this.name = r;
        this.value = t;
      }
      makeRequired() {
        return this.isRequired = true, this;
      }
      write(r) {
        let { colors: { green: t } } = r.context;
        r.addMarginSymbol(t(this.isRequired ? "+" : "?")), r.write(t(this.name)), this.isRequired || r.write(t("?")), r.write(t(": ")), typeof this.value == "string" ? r.write(t(this.value)) : r.write(this.value);
      }
    };
    sa();
    var Ar = class {
      constructor(r = 0, t) {
        __publicField(this, "lines", []);
        __publicField(this, "currentLine", "");
        __publicField(this, "currentIndent", 0);
        __publicField(this, "marginSymbol");
        __publicField(this, "afterNextNewLineCallback");
        this.context = t;
        this.currentIndent = r;
      }
      write(r) {
        return typeof r == "string" ? this.currentLine += r : r.write(this), this;
      }
      writeJoined(r, t, n = (i, o) => o.write(i)) {
        let i = t.length - 1;
        for (let o = 0; o < t.length; o++) n(t[o], this), o !== i && this.write(r);
        return this;
      }
      writeLine(r) {
        return this.write(r).newLine();
      }
      newLine() {
        this.lines.push(this.indentedCurrentLine()), this.currentLine = "", this.marginSymbol = void 0;
        let r = this.afterNextNewLineCallback;
        return this.afterNextNewLineCallback = void 0, r?.(), this;
      }
      withIndent(r) {
        return this.indent(), r(this), this.unindent(), this;
      }
      afterNextNewline(r) {
        return this.afterNextNewLineCallback = r, this;
      }
      indent() {
        return this.currentIndent++, this;
      }
      unindent() {
        return this.currentIndent > 0 && this.currentIndent--, this;
      }
      addMarginSymbol(r) {
        return this.marginSymbol = r, this;
      }
      toString() {
        return this.lines.concat(this.indentedCurrentLine()).join(`
`);
      }
      getCurrentLineLength() {
        return this.currentLine.length;
      }
      indentedCurrentLine() {
        let r = this.currentLine.padStart(this.currentLine.length + 2 * this.currentIndent);
        return this.marginSymbol ? this.marginSymbol + r.slice(1) : r;
      }
    };
    oa();
    var Rn = class {
      constructor(r) {
        this.value = r;
      }
      write(r) {
        r.write(this.value);
      }
      markAsError() {
        this.value.markAsError();
      }
    };
    var An = (e) => e;
    var Cn = { bold: An, red: An, green: An, dim: An, enabled: false };
    var aa = { bold: W, red: ce, green: qe, dim: Ce, enabled: true };
    var Cr = { write(e) {
      e.writeLine(",");
    } };
    var Pe = class {
      constructor(r) {
        __publicField(this, "isUnderlined", false);
        __publicField(this, "color", (r) => r);
        this.contents = r;
      }
      underline() {
        return this.isUnderlined = true, this;
      }
      setColor(r) {
        return this.color = r, this;
      }
      write(r) {
        let t = r.getCurrentLineLength();
        r.write(this.color(this.contents)), this.isUnderlined && r.afterNextNewline(() => {
          r.write(" ".repeat(t)).writeLine(this.color("~".repeat(this.contents.length)));
        });
      }
    };
    var ze = class {
      constructor() {
        __publicField(this, "hasError", false);
      }
      markAsError() {
        return this.hasError = true, this;
      }
    };
    var Ir = class extends ze {
      constructor() {
        super(...arguments);
        __publicField(this, "items", []);
      }
      addItem(r) {
        return this.items.push(new Rn(r)), this;
      }
      getField(r) {
        return this.items[r];
      }
      getPrintWidth() {
        return this.items.length === 0 ? 2 : Math.max(...this.items.map((t) => t.value.getPrintWidth())) + 2;
      }
      write(r) {
        if (this.items.length === 0) {
          this.writeEmpty(r);
          return;
        }
        this.writeWithItems(r);
      }
      writeEmpty(r) {
        let t = new Pe("[]");
        this.hasError && t.setColor(r.context.colors.red).underline(), r.write(t);
      }
      writeWithItems(r) {
        let { colors: t } = r.context;
        r.writeLine("[").withIndent(() => r.writeJoined(Cr, this.items).newLine()).write("]"), this.hasError && r.afterNextNewline(() => {
          r.writeLine(t.red("~".repeat(this.getPrintWidth())));
        });
      }
      asObject() {
      }
    };
    var Dr = class e extends ze {
      constructor() {
        super(...arguments);
        __publicField(this, "fields", {});
        __publicField(this, "suggestions", []);
      }
      addField(r) {
        this.fields[r.name] = r;
      }
      addSuggestion(r) {
        this.suggestions.push(r);
      }
      getField(r) {
        return this.fields[r];
      }
      getDeepField(r) {
        let [t, ...n] = r, i = this.getField(t);
        if (!i) return;
        let o = i;
        for (let s of n) {
          let a;
          if (o.value instanceof e ? a = o.value.getField(s) : o.value instanceof Ir && (a = o.value.getField(Number(s))), !a) return;
          o = a;
        }
        return o;
      }
      getDeepFieldValue(r) {
        return r.length === 0 ? this : this.getDeepField(r)?.value;
      }
      hasField(r) {
        return !!this.getField(r);
      }
      removeAllFields() {
        this.fields = {};
      }
      removeField(r) {
        delete this.fields[r];
      }
      getFields() {
        return this.fields;
      }
      isEmpty() {
        return Object.keys(this.fields).length === 0;
      }
      getFieldValue(r) {
        return this.getField(r)?.value;
      }
      getDeepSubSelectionValue(r) {
        let t = this;
        for (let n of r) {
          if (!(t instanceof e)) return;
          let i = t.getSubSelectionValue(n);
          if (!i) return;
          t = i;
        }
        return t;
      }
      getDeepSelectionParent(r) {
        let t = this.getSelectionParent();
        if (!t) return;
        let n = t;
        for (let i of r) {
          let o = n.value.getFieldValue(i);
          if (!o || !(o instanceof e)) return;
          let s = o.getSelectionParent();
          if (!s) return;
          n = s;
        }
        return n;
      }
      getSelectionParent() {
        let r = this.getField("select")?.value.asObject();
        if (r) return { kind: "select", value: r };
        let t = this.getField("include")?.value.asObject();
        if (t) return { kind: "include", value: t };
      }
      getSubSelectionValue(r) {
        return this.getSelectionParent()?.value.fields[r].value;
      }
      getPrintWidth() {
        let r = Object.values(this.fields);
        return r.length == 0 ? 2 : Math.max(...r.map((n) => n.getPrintWidth())) + 2;
      }
      write(r) {
        let t = Object.values(this.fields);
        if (t.length === 0 && this.suggestions.length === 0) {
          this.writeEmpty(r);
          return;
        }
        this.writeWithContents(r, t);
      }
      asObject() {
        return this;
      }
      writeEmpty(r) {
        let t = new Pe("{}");
        this.hasError && t.setColor(r.context.colors.red).underline(), r.write(t);
      }
      writeWithContents(r, t) {
        r.writeLine("{").withIndent(() => {
          r.writeJoined(Cr, [...t, ...this.suggestions]).newLine();
        }), r.write("}"), this.hasError && r.afterNextNewline(() => {
          r.writeLine(r.context.colors.red("~".repeat(this.getPrintWidth())));
        });
      }
    };
    var Q = class extends ze {
      constructor(t) {
        super();
        this.text = t;
      }
      getPrintWidth() {
        return this.text.length;
      }
      write(t) {
        let n = new Pe(this.text);
        this.hasError && n.underline().setColor(t.context.colors.red), t.write(n);
      }
      asObject() {
      }
    };
    var pt = class {
      constructor() {
        __publicField(this, "fields", []);
      }
      addField(r, t) {
        return this.fields.push({ write(n) {
          let { green: i, dim: o } = n.context.colors;
          n.write(i(o(`${r}: ${t}`))).addMarginSymbol(i(o("+")));
        } }), this;
      }
      write(r) {
        let { colors: { green: t } } = r.context;
        r.writeLine(t("{")).withIndent(() => {
          r.writeJoined(Cr, this.fields).newLine();
        }).write(t("}")).addMarginSymbol(t("+"));
      }
    };
    function Sn(e, r, t) {
      switch (e.kind) {
        case "MutuallyExclusiveFields":
          Ad(e, r);
          break;
        case "IncludeOnScalar":
          Cd(e, r);
          break;
        case "EmptySelection":
          Id(e, r, t);
          break;
        case "UnknownSelectionField":
          _d(e, r);
          break;
        case "InvalidSelectionValue":
          Nd(e, r);
          break;
        case "UnknownArgument":
          Ld(e, r);
          break;
        case "UnknownInputField":
          Fd(e, r);
          break;
        case "RequiredArgumentMissing":
          Md(e, r);
          break;
        case "InvalidArgumentType":
          $d(e, r);
          break;
        case "InvalidArgumentValue":
          qd(e, r);
          break;
        case "ValueTooLarge":
          Vd(e, r);
          break;
        case "SomeFieldsMissing":
          jd(e, r);
          break;
        case "TooManyFieldsGiven":
          Bd(e, r);
          break;
        case "Union":
          na(e, r, t);
          break;
        default:
          throw new Error("not implemented: " + e.kind);
      }
    }
    function Ad(e, r) {
      let t = r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
      t && (t.getField(e.firstField)?.markAsError(), t.getField(e.secondField)?.markAsError()), r.addErrorMessage((n) => `Please ${n.bold("either")} use ${n.green(`\`${e.firstField}\``)} or ${n.green(`\`${e.secondField}\``)}, but ${n.red("not both")} at the same time.`);
    }
    function Cd(e, r) {
      let [t, n] = Or(e.selectionPath), i = e.outputType, o = r.arguments.getDeepSelectionParent(t)?.value;
      if (o && (o.getField(n)?.markAsError(), i)) for (let s of i.fields) s.isRelation && o.addSuggestion(new le(s.name, "true"));
      r.addErrorMessage((s) => {
        let a = `Invalid scalar field ${s.red(`\`${n}\``)} for ${s.bold("include")} statement`;
        return i ? a += ` on model ${s.bold(i.name)}. ${dt(s)}` : a += ".", a += `
Note that ${s.bold("include")} statements only accept relation fields.`, a;
      });
    }
    function Id(e, r, t) {
      let n = r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
      if (n) {
        let i = n.getField("omit")?.value.asObject();
        if (i) {
          Dd(e, r, i);
          return;
        }
        if (n.hasField("select")) {
          Od(e, r);
          return;
        }
      }
      if (t?.[We(e.outputType.name)]) {
        kd(e, r);
        return;
      }
      r.addErrorMessage(() => `Unknown field at "${e.selectionPath.join(".")} selection"`);
    }
    function Dd(e, r, t) {
      t.removeAllFields();
      for (let n of e.outputType.fields) t.addSuggestion(new le(n.name, "false"));
      r.addErrorMessage((n) => `The ${n.red("omit")} statement includes every field of the model ${n.bold(e.outputType.name)}. At least one field must be included in the result`);
    }
    function Od(e, r) {
      let t = e.outputType, n = r.arguments.getDeepSelectionParent(e.selectionPath)?.value, i = n?.isEmpty() ?? false;
      n && (n.removeAllFields(), pa(n, t)), r.addErrorMessage((o) => i ? `The ${o.red("`select`")} statement for type ${o.bold(t.name)} must not be empty. ${dt(o)}` : `The ${o.red("`select`")} statement for type ${o.bold(t.name)} needs ${o.bold("at least one truthy value")}.`);
    }
    function kd(e, r) {
      let t = new pt();
      for (let i of e.outputType.fields) i.isRelation || t.addField(i.name, "false");
      let n = new le("omit", t).makeRequired();
      if (e.selectionPath.length === 0) r.arguments.addSuggestion(n);
      else {
        let [i, o] = Or(e.selectionPath), a = r.arguments.getDeepSelectionParent(i)?.value.asObject()?.getField(o);
        if (a) {
          let l = a?.value.asObject() ?? new Dr();
          l.addSuggestion(n), a.value = l;
        }
      }
      r.addErrorMessage((i) => `The global ${i.red("omit")} configuration excludes every field of the model ${i.bold(e.outputType.name)}. At least one field must be included in the result`);
    }
    function _d(e, r) {
      let t = da(e.selectionPath, r);
      if (t.parentKind !== "unknown") {
        t.field.markAsError();
        let n = t.parent;
        switch (t.parentKind) {
          case "select":
            pa(n, e.outputType);
            break;
          case "include":
            Ud(n, e.outputType);
            break;
          case "omit":
            Gd(n, e.outputType);
            break;
        }
      }
      r.addErrorMessage((n) => {
        let i = [`Unknown field ${n.red(`\`${t.fieldName}\``)}`];
        return t.parentKind !== "unknown" && i.push(`for ${n.bold(t.parentKind)} statement`), i.push(`on model ${n.bold(`\`${e.outputType.name}\``)}.`), i.push(dt(n)), i.join(" ");
      });
    }
    function Nd(e, r) {
      let t = da(e.selectionPath, r);
      t.parentKind !== "unknown" && t.field.value.markAsError(), r.addErrorMessage((n) => `Invalid value for selection field \`${n.red(t.fieldName)}\`: ${e.underlyingError}`);
    }
    function Ld(e, r) {
      let t = e.argumentPath[0], n = r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
      n && (n.getField(t)?.markAsError(), Qd(n, e.arguments)), r.addErrorMessage((i) => ua(i, t, e.arguments.map((o) => o.name)));
    }
    function Fd(e, r) {
      let [t, n] = Or(e.argumentPath), i = r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
      if (i) {
        i.getDeepField(e.argumentPath)?.markAsError();
        let o = i.getDeepFieldValue(t)?.asObject();
        o && ma(o, e.inputType);
      }
      r.addErrorMessage((o) => ua(o, n, e.inputType.fields.map((s) => s.name)));
    }
    function ua(e, r, t) {
      let n = [`Unknown argument \`${e.red(r)}\`.`], i = Jd(r, t);
      return i && n.push(`Did you mean \`${e.green(i)}\`?`), t.length > 0 && n.push(dt(e)), n.join(" ");
    }
    function Md(e, r) {
      let t;
      r.addErrorMessage((l) => t?.value instanceof Q && t.value.text === "null" ? `Argument \`${l.green(o)}\` must not be ${l.red("null")}.` : `Argument \`${l.green(o)}\` is missing.`);
      let n = r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
      if (!n) return;
      let [i, o] = Or(e.argumentPath), s = new pt(), a = n.getDeepFieldValue(i)?.asObject();
      if (a) {
        if (t = a.getField(o), t && a.removeField(o), e.inputTypes.length === 1 && e.inputTypes[0].kind === "object") {
          for (let l of e.inputTypes[0].fields) s.addField(l.name, l.typeNames.join(" | "));
          a.addSuggestion(new le(o, s).makeRequired());
        } else {
          let l = e.inputTypes.map(ca).join(" | ");
          a.addSuggestion(new le(o, l).makeRequired());
        }
        if (e.dependentArgumentPath) {
          n.getDeepField(e.dependentArgumentPath)?.markAsError();
          let [, l] = Or(e.dependentArgumentPath);
          r.addErrorMessage((u) => `Argument \`${u.green(o)}\` is required because argument \`${u.green(l)}\` was provided.`);
        }
      }
    }
    function ca(e) {
      return e.kind === "list" ? `${ca(e.elementType)}[]` : e.name;
    }
    function $d(e, r) {
      let t = e.argument.name, n = r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
      n && n.getDeepFieldValue(e.argumentPath)?.markAsError(), r.addErrorMessage((i) => {
        let o = In("or", e.argument.typeNames.map((s) => i.green(s)));
        return `Argument \`${i.bold(t)}\`: Invalid value provided. Expected ${o}, provided ${i.red(e.inferredType)}.`;
      });
    }
    function qd(e, r) {
      let t = e.argument.name, n = r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
      n && n.getDeepFieldValue(e.argumentPath)?.markAsError(), r.addErrorMessage((i) => {
        let o = [`Invalid value for argument \`${i.bold(t)}\``];
        if (e.underlyingError && o.push(`: ${e.underlyingError}`), o.push("."), e.argument.typeNames.length > 0) {
          let s = In("or", e.argument.typeNames.map((a) => i.green(a)));
          o.push(` Expected ${s}.`);
        }
        return o.join("");
      });
    }
    function Vd(e, r) {
      let t = e.argument.name, n = r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject(), i;
      if (n) {
        let s = n.getDeepField(e.argumentPath)?.value;
        s?.markAsError(), s instanceof Q && (i = s.text);
      }
      r.addErrorMessage((o) => {
        let s = ["Unable to fit value"];
        return i && s.push(o.red(i)), s.push(`into a 64-bit signed integer for field \`${o.bold(t)}\``), s.join(" ");
      });
    }
    function jd(e, r) {
      let t = e.argumentPath[e.argumentPath.length - 1], n = r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
      if (n) {
        let i = n.getDeepFieldValue(e.argumentPath)?.asObject();
        i && ma(i, e.inputType);
      }
      r.addErrorMessage((i) => {
        let o = [`Argument \`${i.bold(t)}\` of type ${i.bold(e.inputType.name)} needs`];
        return e.constraints.minFieldCount === 1 ? e.constraints.requiredFields ? o.push(`${i.green("at least one of")} ${In("or", e.constraints.requiredFields.map((s) => `\`${i.bold(s)}\``))} arguments.`) : o.push(`${i.green("at least one")} argument.`) : o.push(`${i.green(`at least ${e.constraints.minFieldCount}`)} arguments.`), o.push(dt(i)), o.join(" ");
      });
    }
    function Bd(e, r) {
      let t = e.argumentPath[e.argumentPath.length - 1], n = r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject(), i = [];
      if (n) {
        let o = n.getDeepFieldValue(e.argumentPath)?.asObject();
        o && (o.markAsError(), i = Object.keys(o.getFields()));
      }
      r.addErrorMessage((o) => {
        let s = [`Argument \`${o.bold(t)}\` of type ${o.bold(e.inputType.name)} needs`];
        return e.constraints.minFieldCount === 1 && e.constraints.maxFieldCount == 1 ? s.push(`${o.green("exactly one")} argument,`) : e.constraints.maxFieldCount == 1 ? s.push(`${o.green("at most one")} argument,`) : s.push(`${o.green(`at most ${e.constraints.maxFieldCount}`)} arguments,`), s.push(`but you provided ${In("and", i.map((a) => o.red(a)))}. Please choose`), e.constraints.maxFieldCount === 1 ? s.push("one.") : s.push(`${e.constraints.maxFieldCount}.`), s.join(" ");
      });
    }
    function pa(e, r) {
      for (let t of r.fields) e.hasField(t.name) || e.addSuggestion(new le(t.name, "true"));
    }
    function Ud(e, r) {
      for (let t of r.fields) t.isRelation && !e.hasField(t.name) && e.addSuggestion(new le(t.name, "true"));
    }
    function Gd(e, r) {
      for (let t of r.fields) !e.hasField(t.name) && !t.isRelation && e.addSuggestion(new le(t.name, "true"));
    }
    function Qd(e, r) {
      for (let t of r) e.hasField(t.name) || e.addSuggestion(new le(t.name, t.typeNames.join(" | ")));
    }
    function da(e, r) {
      let [t, n] = Or(e), i = r.arguments.getDeepSubSelectionValue(t)?.asObject();
      if (!i) return { parentKind: "unknown", fieldName: n };
      let o = i.getFieldValue("select")?.asObject(), s = i.getFieldValue("include")?.asObject(), a = i.getFieldValue("omit")?.asObject(), l = o?.getField(n);
      return o && l ? { parentKind: "select", parent: o, field: l, fieldName: n } : (l = s?.getField(n), s && l ? { parentKind: "include", field: l, parent: s, fieldName: n } : (l = a?.getField(n), a && l ? { parentKind: "omit", field: l, parent: a, fieldName: n } : { parentKind: "unknown", fieldName: n }));
    }
    function ma(e, r) {
      if (r.kind === "object") for (let t of r.fields) e.hasField(t.name) || e.addSuggestion(new le(t.name, t.typeNames.join(" | ")));
    }
    function Or(e) {
      let r = [...e], t = r.pop();
      if (!t) throw new Error("unexpected empty path");
      return [r, t];
    }
    function dt({ green: e, enabled: r }) {
      return "Available options are " + (r ? `listed in ${e("green")}` : "marked with ?") + ".";
    }
    function In(e, r) {
      if (r.length === 1) return r[0];
      let t = [...r], n = t.pop();
      return `${t.join(", ")} ${e} ${n}`;
    }
    var Wd = 3;
    function Jd(e, r) {
      let t = 1 / 0, n;
      for (let i of r) {
        let o = (0, la.default)(e, i);
        o > Wd || o < t && (t = o, n = i);
      }
      return n;
    }
    var mt = class {
      constructor(r, t, n, i, o) {
        __publicField(this, "modelName");
        __publicField(this, "name");
        __publicField(this, "typeName");
        __publicField(this, "isList");
        __publicField(this, "isEnum");
        this.modelName = r, this.name = t, this.typeName = n, this.isList = i, this.isEnum = o;
      }
      _toGraphQLInputType() {
        let r = this.isList ? "List" : "", t = this.isEnum ? "Enum" : "";
        return `${r}${t}${this.typeName}FieldRefInput<${this.modelName}>`;
      }
    };
    function kr(e) {
      return e instanceof mt;
    }
    var Dn = Symbol();
    var Yi = /* @__PURE__ */ new WeakMap();
    var Me = class {
      constructor(r) {
        r === Dn ? Yi.set(this, `Prisma.${this._getName()}`) : Yi.set(this, `new Prisma.${this._getNamespace()}.${this._getName()}()`);
      }
      _getName() {
        return this.constructor.name;
      }
      toString() {
        return Yi.get(this);
      }
    };
    var ft = class extends Me {
      _getNamespace() {
        return "NullTypes";
      }
    };
    var _e, _a2;
    var gt = (_a2 = class extends ft {
      constructor() {
        super(...arguments);
        __privateAdd(this, _e);
      }
    }, _e = new WeakMap(), _a2);
    zi(gt, "DbNull");
    var _e2, _a3;
    var ht = (_a3 = class extends ft {
      constructor() {
        super(...arguments);
        __privateAdd(this, _e2);
      }
    }, _e2 = new WeakMap(), _a3);
    zi(ht, "JsonNull");
    var _e3, _a4;
    var yt = (_a4 = class extends ft {
      constructor() {
        super(...arguments);
        __privateAdd(this, _e3);
      }
    }, _e3 = new WeakMap(), _a4);
    zi(yt, "AnyNull");
    var On = { classes: { DbNull: gt, JsonNull: ht, AnyNull: yt }, instances: { DbNull: new gt(Dn), JsonNull: new ht(Dn), AnyNull: new yt(Dn) } };
    function zi(e, r) {
      Object.defineProperty(e, "name", { value: r, configurable: true });
    }
    var fa = ": ";
    var kn = class {
      constructor(r, t) {
        __publicField(this, "hasError", false);
        this.name = r;
        this.value = t;
      }
      markAsError() {
        this.hasError = true;
      }
      getPrintWidth() {
        return this.name.length + this.value.getPrintWidth() + fa.length;
      }
      write(r) {
        let t = new Pe(this.name);
        this.hasError && t.underline().setColor(r.context.colors.red), r.write(t).write(fa).write(this.value);
      }
    };
    var Zi = class {
      constructor(r) {
        __publicField(this, "arguments");
        __publicField(this, "errorMessages", []);
        this.arguments = r;
      }
      write(r) {
        r.write(this.arguments);
      }
      addErrorMessage(r) {
        this.errorMessages.push(r);
      }
      renderAllMessages(r) {
        return this.errorMessages.map((t) => t(r)).join(`
`);
      }
    };
    function _r(e) {
      return new Zi(ga(e));
    }
    function ga(e) {
      let r = new Dr();
      for (let [t, n] of Object.entries(e)) {
        let i = new kn(t, ha(n));
        r.addField(i);
      }
      return r;
    }
    function ha(e) {
      if (typeof e == "string") return new Q(JSON.stringify(e));
      if (typeof e == "number" || typeof e == "boolean") return new Q(String(e));
      if (typeof e == "bigint") return new Q(`${e}n`);
      if (e === null) return new Q("null");
      if (e === void 0) return new Q("undefined");
      if (Sr(e)) return new Q(`new Prisma.Decimal("${e.toFixed()}")`);
      if (e instanceof Uint8Array) return Buffer.isBuffer(e) ? new Q(`Buffer.alloc(${e.byteLength})`) : new Q(`new Uint8Array(${e.byteLength})`);
      if (e instanceof Date) {
        let r = mn(e) ? e.toISOString() : "Invalid Date";
        return new Q(`new Date("${r}")`);
      }
      return e instanceof Me ? new Q(`Prisma.${e._getName()}`) : kr(e) ? new Q(`prisma.${We(e.modelName)}.$fields.${e.name}`) : Array.isArray(e) ? Kd(e) : typeof e == "object" ? ga(e) : new Q(Object.prototype.toString.call(e));
    }
    function Kd(e) {
      let r = new Ir();
      for (let t of e) r.addItem(ha(t));
      return r;
    }
    function _n(e, r) {
      let t = r === "pretty" ? aa : Cn, n = e.renderAllMessages(t), i = new Ar(0, { colors: t }).write(e).toString();
      return { message: n, args: i };
    }
    function Nn({ args: e, errors: r, errorFormat: t, callsite: n, originalMethod: i, clientVersion: o, globalOmit: s }) {
      let a = _r(e);
      for (let p of r) Sn(p, a, s);
      let { message: l, args: u } = _n(a, t), c = Tn({ message: l, callsite: n, originalMethod: i, showColors: t === "pretty", callArguments: u });
      throw new Z(c, { clientVersion: o });
    }
    function Te(e) {
      return e.replace(/^./, (r) => r.toLowerCase());
    }
    function ba(e, r, t) {
      let n = Te(t);
      return !r.result || !(r.result.$allModels || r.result[n]) ? e : Hd({ ...e, ...ya(r.name, e, r.result.$allModels), ...ya(r.name, e, r.result[n]) });
    }
    function Hd(e) {
      let r = new we(), t = (n, i) => r.getOrCreate(n, () => i.has(n) ? [n] : (i.add(n), e[n] ? e[n].needs.flatMap((o) => t(o, i)) : [n]));
      return pn(e, (n) => ({ ...n, needs: t(n.name, /* @__PURE__ */ new Set()) }));
    }
    function ya(e, r, t) {
      return t ? pn(t, ({ needs: n, compute: i }, o) => ({ name: o, needs: n ? Object.keys(n).filter((s) => n[s]) : [], compute: Yd(r, o, i) })) : {};
    }
    function Yd(e, r, t) {
      let n = e?.[r]?.compute;
      return n ? (i) => t({ ...i, [r]: n(i) }) : t;
    }
    function Ea(e, r) {
      if (!r) return e;
      let t = { ...e };
      for (let n of Object.values(r)) if (e[n.name]) for (let i of n.needs) t[i] = true;
      return t;
    }
    function wa(e, r) {
      if (!r) return e;
      let t = { ...e };
      for (let n of Object.values(r)) if (!e[n.name]) for (let i of n.needs) delete t[i];
      return t;
    }
    var Ln = class {
      constructor(r, t) {
        __publicField(this, "computedFieldsCache", new we());
        __publicField(this, "modelExtensionsCache", new we());
        __publicField(this, "queryCallbacksCache", new we());
        __publicField(this, "clientExtensions", lt(() => this.extension.client ? { ...this.previous?.getAllClientExtensions(), ...this.extension.client } : this.previous?.getAllClientExtensions()));
        __publicField(this, "batchCallbacks", lt(() => {
          let r = this.previous?.getAllBatchQueryCallbacks() ?? [], t = this.extension.query?.$__internalBatch;
          return t ? r.concat(t) : r;
        }));
        this.extension = r;
        this.previous = t;
      }
      getAllComputedFields(r) {
        return this.computedFieldsCache.getOrCreate(r, () => ba(this.previous?.getAllComputedFields(r), this.extension, r));
      }
      getAllClientExtensions() {
        return this.clientExtensions.get();
      }
      getAllModelExtensions(r) {
        return this.modelExtensionsCache.getOrCreate(r, () => {
          let t = Te(r);
          return !this.extension.model || !(this.extension.model[t] || this.extension.model.$allModels) ? this.previous?.getAllModelExtensions(r) : { ...this.previous?.getAllModelExtensions(r), ...this.extension.model.$allModels, ...this.extension.model[t] };
        });
      }
      getAllQueryCallbacks(r, t) {
        return this.queryCallbacksCache.getOrCreate(`${r}:${t}`, () => {
          let n = this.previous?.getAllQueryCallbacks(r, t) ?? [], i = [], o = this.extension.query;
          return !o || !(o[r] || o.$allModels || o[t] || o.$allOperations) ? n : (o[r] !== void 0 && (o[r][t] !== void 0 && i.push(o[r][t]), o[r].$allOperations !== void 0 && i.push(o[r].$allOperations)), r !== "$none" && o.$allModels !== void 0 && (o.$allModels[t] !== void 0 && i.push(o.$allModels[t]), o.$allModels.$allOperations !== void 0 && i.push(o.$allModels.$allOperations)), o[t] !== void 0 && i.push(o[t]), o.$allOperations !== void 0 && i.push(o.$allOperations), n.concat(i));
        });
      }
      getAllBatchQueryCallbacks() {
        return this.batchCallbacks.get();
      }
    };
    var Nr = class e {
      constructor(r) {
        this.head = r;
      }
      static empty() {
        return new e();
      }
      static single(r) {
        return new e(new Ln(r));
      }
      isEmpty() {
        return this.head === void 0;
      }
      append(r) {
        return new e(new Ln(r, this.head));
      }
      getAllComputedFields(r) {
        return this.head?.getAllComputedFields(r);
      }
      getAllClientExtensions() {
        return this.head?.getAllClientExtensions();
      }
      getAllModelExtensions(r) {
        return this.head?.getAllModelExtensions(r);
      }
      getAllQueryCallbacks(r, t) {
        return this.head?.getAllQueryCallbacks(r, t) ?? [];
      }
      getAllBatchQueryCallbacks() {
        return this.head?.getAllBatchQueryCallbacks() ?? [];
      }
    };
    var Fn = class {
      constructor(r) {
        this.name = r;
      }
    };
    function xa(e) {
      return e instanceof Fn;
    }
    function va(e) {
      return new Fn(e);
    }
    var Pa = Symbol();
    var bt = class {
      constructor(r) {
        if (r !== Pa) throw new Error("Skip instance can not be constructed directly");
      }
      ifUndefined(r) {
        return r === void 0 ? Mn : r;
      }
    };
    var Mn = new bt(Pa);
    function Se(e) {
      return e instanceof bt;
    }
    var zd = { findUnique: "findUnique", findUniqueOrThrow: "findUniqueOrThrow", findFirst: "findFirst", findFirstOrThrow: "findFirstOrThrow", findMany: "findMany", count: "aggregate", create: "createOne", createMany: "createMany", createManyAndReturn: "createManyAndReturn", update: "updateOne", updateMany: "updateMany", updateManyAndReturn: "updateManyAndReturn", upsert: "upsertOne", delete: "deleteOne", deleteMany: "deleteMany", executeRaw: "executeRaw", queryRaw: "queryRaw", aggregate: "aggregate", groupBy: "groupBy", runCommandRaw: "runCommandRaw", findRaw: "findRaw", aggregateRaw: "aggregateRaw" };
    var Ta = "explicitly `undefined` values are not allowed";
    function $n({ modelName: e, action: r, args: t, runtimeDataModel: n, extensions: i = Nr.empty(), callsite: o, clientMethod: s, errorFormat: a, clientVersion: l, previewFeatures: u, globalOmit: c }) {
      let p = new Xi({ runtimeDataModel: n, modelName: e, action: r, rootArgs: t, callsite: o, extensions: i, selectionPath: [], argumentPath: [], originalMethod: s, errorFormat: a, clientVersion: l, previewFeatures: u, globalOmit: c });
      return { modelName: e, action: zd[r], query: Et(t, p) };
    }
    function Et({ select: e, include: r, ...t } = {}, n) {
      let i = t.omit;
      return delete t.omit, { arguments: Ra(t, n), selection: Zd(e, r, i, n) };
    }
    function Zd(e, r, t, n) {
      return e ? (r ? n.throwValidationError({ kind: "MutuallyExclusiveFields", firstField: "include", secondField: "select", selectionPath: n.getSelectionPath() }) : t && n.throwValidationError({ kind: "MutuallyExclusiveFields", firstField: "omit", secondField: "select", selectionPath: n.getSelectionPath() }), tm(e, n)) : Xd(n, r, t);
    }
    function Xd(e, r, t) {
      let n = {};
      return e.modelOrType && !e.isRawAction() && (n.$composites = true, n.$scalars = true), r && em(n, r, e), rm(n, t, e), n;
    }
    function em(e, r, t) {
      for (let [n, i] of Object.entries(r)) {
        if (Se(i)) continue;
        let o = t.nestSelection(n);
        if (eo(i, o), i === false || i === void 0) {
          e[n] = false;
          continue;
        }
        let s = t.findField(n);
        if (s && s.kind !== "object" && t.throwValidationError({ kind: "IncludeOnScalar", selectionPath: t.getSelectionPath().concat(n), outputType: t.getOutputTypeDescription() }), s) {
          e[n] = Et(i === true ? {} : i, o);
          continue;
        }
        if (i === true) {
          e[n] = true;
          continue;
        }
        e[n] = Et(i, o);
      }
    }
    function rm(e, r, t) {
      let n = t.getComputedFields(), i = { ...t.getGlobalOmit(), ...r }, o = wa(i, n);
      for (let [s, a] of Object.entries(o)) {
        if (Se(a)) continue;
        eo(a, t.nestSelection(s));
        let l = t.findField(s);
        n?.[s] && !l || (e[s] = !a);
      }
    }
    function tm(e, r) {
      let t = {}, n = r.getComputedFields(), i = Ea(e, n);
      for (let [o, s] of Object.entries(i)) {
        if (Se(s)) continue;
        let a = r.nestSelection(o);
        eo(s, a);
        let l = r.findField(o);
        if (!(n?.[o] && !l)) {
          if (s === false || s === void 0 || Se(s)) {
            t[o] = false;
            continue;
          }
          if (s === true) {
            l?.kind === "object" ? t[o] = Et({}, a) : t[o] = true;
            continue;
          }
          t[o] = Et(s, a);
        }
      }
      return t;
    }
    function Sa(e, r) {
      if (e === null) return null;
      if (typeof e == "string" || typeof e == "number" || typeof e == "boolean") return e;
      if (typeof e == "bigint") return { $type: "BigInt", value: String(e) };
      if (vr(e)) {
        if (mn(e)) return { $type: "DateTime", value: e.toISOString() };
        r.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: r.getSelectionPath(), argumentPath: r.getArgumentPath(), argument: { name: r.getArgumentName(), typeNames: ["Date"] }, underlyingError: "Provided Date object is invalid" });
      }
      if (xa(e)) return { $type: "Param", value: e.name };
      if (kr(e)) return { $type: "FieldRef", value: { _ref: e.name, _container: e.modelName } };
      if (Array.isArray(e)) return nm(e, r);
      if (ArrayBuffer.isView(e)) {
        let { buffer: t, byteOffset: n, byteLength: i } = e;
        return { $type: "Bytes", value: Buffer.from(t, n, i).toString("base64") };
      }
      if (im(e)) return e.values;
      if (Sr(e)) return { $type: "Decimal", value: e.toFixed() };
      if (e instanceof Me) {
        if (e !== On.instances[e._getName()]) throw new Error("Invalid ObjectEnumValue");
        return { $type: "Enum", value: e._getName() };
      }
      if (om(e)) return e.toJSON();
      if (typeof e == "object") return Ra(e, r);
      r.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: r.getSelectionPath(), argumentPath: r.getArgumentPath(), argument: { name: r.getArgumentName(), typeNames: [] }, underlyingError: `We could not serialize ${Object.prototype.toString.call(e)} value. Serialize the object to JSON or implement a ".toJSON()" method on it` });
    }
    function Ra(e, r) {
      if (e.$type) return { $type: "Raw", value: e };
      let t = {};
      for (let n in e) {
        let i = e[n], o = r.nestArgument(n);
        Se(i) || (i !== void 0 ? t[n] = Sa(i, o) : r.isPreviewFeatureOn("strictUndefinedChecks") && r.throwValidationError({ kind: "InvalidArgumentValue", argumentPath: o.getArgumentPath(), selectionPath: r.getSelectionPath(), argument: { name: r.getArgumentName(), typeNames: [] }, underlyingError: Ta }));
      }
      return t;
    }
    function nm(e, r) {
      let t = [];
      for (let n = 0; n < e.length; n++) {
        let i = r.nestArgument(String(n)), o = e[n];
        if (o === void 0 || Se(o)) {
          let s = o === void 0 ? "undefined" : "Prisma.skip";
          r.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: i.getSelectionPath(), argumentPath: i.getArgumentPath(), argument: { name: `${r.getArgumentName()}[${n}]`, typeNames: [] }, underlyingError: `Can not use \`${s}\` value within array. Use \`null\` or filter out \`${s}\` values` });
        }
        t.push(Sa(o, i));
      }
      return t;
    }
    function im(e) {
      return typeof e == "object" && e !== null && e.__prismaRawParameters__ === true;
    }
    function om(e) {
      return typeof e == "object" && e !== null && typeof e.toJSON == "function";
    }
    function eo(e, r) {
      e === void 0 && r.isPreviewFeatureOn("strictUndefinedChecks") && r.throwValidationError({ kind: "InvalidSelectionValue", selectionPath: r.getSelectionPath(), underlyingError: Ta });
    }
    var Xi = class e {
      constructor(r) {
        __publicField(this, "modelOrType");
        this.params = r;
        this.params.modelName && (this.modelOrType = this.params.runtimeDataModel.models[this.params.modelName] ?? this.params.runtimeDataModel.types[this.params.modelName]);
      }
      throwValidationError(r) {
        Nn({ errors: [r], originalMethod: this.params.originalMethod, args: this.params.rootArgs ?? {}, callsite: this.params.callsite, errorFormat: this.params.errorFormat, clientVersion: this.params.clientVersion, globalOmit: this.params.globalOmit });
      }
      getSelectionPath() {
        return this.params.selectionPath;
      }
      getArgumentPath() {
        return this.params.argumentPath;
      }
      getArgumentName() {
        return this.params.argumentPath[this.params.argumentPath.length - 1];
      }
      getOutputTypeDescription() {
        if (!(!this.params.modelName || !this.modelOrType)) return { name: this.params.modelName, fields: this.modelOrType.fields.map((r) => ({ name: r.name, typeName: "boolean", isRelation: r.kind === "object" })) };
      }
      isRawAction() {
        return ["executeRaw", "queryRaw", "runCommandRaw", "findRaw", "aggregateRaw"].includes(this.params.action);
      }
      isPreviewFeatureOn(r) {
        return this.params.previewFeatures.includes(r);
      }
      getComputedFields() {
        if (this.params.modelName) return this.params.extensions.getAllComputedFields(this.params.modelName);
      }
      findField(r) {
        return this.modelOrType?.fields.find((t) => t.name === r);
      }
      nestSelection(r) {
        let t = this.findField(r), n = t?.kind === "object" ? t.type : void 0;
        return new e({ ...this.params, modelName: n, selectionPath: this.params.selectionPath.concat(r) });
      }
      getGlobalOmit() {
        return this.params.modelName && this.shouldApplyGlobalOmit() ? this.params.globalOmit?.[We(this.params.modelName)] ?? {} : {};
      }
      shouldApplyGlobalOmit() {
        switch (this.params.action) {
          case "findFirst":
          case "findFirstOrThrow":
          case "findUniqueOrThrow":
          case "findMany":
          case "upsert":
          case "findUnique":
          case "createManyAndReturn":
          case "create":
          case "update":
          case "updateManyAndReturn":
          case "delete":
            return true;
          case "executeRaw":
          case "aggregateRaw":
          case "runCommandRaw":
          case "findRaw":
          case "createMany":
          case "deleteMany":
          case "groupBy":
          case "updateMany":
          case "count":
          case "aggregate":
          case "queryRaw":
            return false;
          default:
            ar(this.params.action, "Unknown action");
        }
      }
      nestArgument(r) {
        return new e({ ...this.params, argumentPath: this.params.argumentPath.concat(r) });
      }
    };
    function Aa(e) {
      if (!e._hasPreviewFlag("metrics")) throw new Z("`metrics` preview feature must be enabled in order to access metrics API", { clientVersion: e._clientVersion });
    }
    var Lr = class {
      constructor(r) {
        __publicField(this, "_client");
        this._client = r;
      }
      prometheus(r) {
        return Aa(this._client), this._client._engine.metrics({ format: "prometheus", ...r });
      }
      json(r) {
        return Aa(this._client), this._client._engine.metrics({ format: "json", ...r });
      }
    };
    function Ca(e, r) {
      let t = lt(() => sm(r));
      Object.defineProperty(e, "dmmf", { get: () => t.get() });
    }
    function sm(e) {
      return { datamodel: { models: ro(e.models), enums: ro(e.enums), types: ro(e.types) } };
    }
    function ro(e) {
      return Object.entries(e).map(([r, t]) => ({ name: r, ...t }));
    }
    var to = /* @__PURE__ */ new WeakMap();
    var qn = "$$PrismaTypedSql";
    var wt = class {
      constructor(r, t) {
        to.set(this, { sql: r, values: t }), Object.defineProperty(this, qn, { value: qn });
      }
      get sql() {
        return to.get(this).sql;
      }
      get values() {
        return to.get(this).values;
      }
    };
    function Ia(e) {
      return (...r) => new wt(e, r);
    }
    function Vn(e) {
      return e != null && e[qn] === qn;
    }
    var cu = O(Ti());
    var pu = require("async_hooks");
    var du = require("events");
    var mu = O(require("fs"));
    var ri = O(require("path"));
    var ie = class e {
      constructor(r, t) {
        if (r.length - 1 !== t.length) throw r.length === 0 ? new TypeError("Expected at least 1 string") : new TypeError(`Expected ${r.length} strings to have ${r.length - 1} values`);
        let n = t.reduce((s, a) => s + (a instanceof e ? a.values.length : 1), 0);
        this.values = new Array(n), this.strings = new Array(n + 1), this.strings[0] = r[0];
        let i = 0, o = 0;
        for (; i < t.length; ) {
          let s = t[i++], a = r[i];
          if (s instanceof e) {
            this.strings[o] += s.strings[0];
            let l = 0;
            for (; l < s.values.length; ) this.values[o++] = s.values[l++], this.strings[o] = s.strings[l];
            this.strings[o] += a;
          } else this.values[o++] = s, this.strings[o] = a;
        }
      }
      get sql() {
        let r = this.strings.length, t = 1, n = this.strings[0];
        for (; t < r; ) n += `?${this.strings[t++]}`;
        return n;
      }
      get statement() {
        let r = this.strings.length, t = 1, n = this.strings[0];
        for (; t < r; ) n += `:${t}${this.strings[t++]}`;
        return n;
      }
      get text() {
        let r = this.strings.length, t = 1, n = this.strings[0];
        for (; t < r; ) n += `$${t}${this.strings[t++]}`;
        return n;
      }
      inspect() {
        return { sql: this.sql, statement: this.statement, text: this.text, values: this.values };
      }
    };
    function Da(e, r = ",", t = "", n = "") {
      if (e.length === 0) throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");
      return new ie([t, ...Array(e.length - 1).fill(r), n], e);
    }
    function no(e) {
      return new ie([e], []);
    }
    var Oa = no("");
    function io(e, ...r) {
      return new ie(e, r);
    }
    function xt(e) {
      return { getKeys() {
        return Object.keys(e);
      }, getPropertyValue(r) {
        return e[r];
      } };
    }
    function re(e, r) {
      return { getKeys() {
        return [e];
      }, getPropertyValue() {
        return r();
      } };
    }
    function lr(e) {
      let r = new we();
      return { getKeys() {
        return e.getKeys();
      }, getPropertyValue(t) {
        return r.getOrCreate(t, () => e.getPropertyValue(t));
      }, getPropertyDescriptor(t) {
        return e.getPropertyDescriptor?.(t);
      } };
    }
    var jn = { enumerable: true, configurable: true, writable: true };
    function Bn(e) {
      let r = new Set(e);
      return { getPrototypeOf: () => Object.prototype, getOwnPropertyDescriptor: () => jn, has: (t, n) => r.has(n), set: (t, n, i) => r.add(n) && Reflect.set(t, n, i), ownKeys: () => [...r] };
    }
    var ka = Symbol.for("nodejs.util.inspect.custom");
    function he(e, r) {
      let t = am(r), n = /* @__PURE__ */ new Set(), i = new Proxy(e, { get(o, s) {
        if (n.has(s)) return o[s];
        let a = t.get(s);
        return a ? a.getPropertyValue(s) : o[s];
      }, has(o, s) {
        if (n.has(s)) return true;
        let a = t.get(s);
        return a ? a.has?.(s) ?? true : Reflect.has(o, s);
      }, ownKeys(o) {
        let s = _a(Reflect.ownKeys(o), t), a = _a(Array.from(t.keys()), t);
        return [.../* @__PURE__ */ new Set([...s, ...a, ...n])];
      }, set(o, s, a) {
        return t.get(s)?.getPropertyDescriptor?.(s)?.writable === false ? false : (n.add(s), Reflect.set(o, s, a));
      }, getOwnPropertyDescriptor(o, s) {
        let a = Reflect.getOwnPropertyDescriptor(o, s);
        if (a && !a.configurable) return a;
        let l = t.get(s);
        return l ? l.getPropertyDescriptor ? { ...jn, ...l?.getPropertyDescriptor(s) } : jn : a;
      }, defineProperty(o, s, a) {
        return n.add(s), Reflect.defineProperty(o, s, a);
      }, getPrototypeOf: () => Object.prototype });
      return i[ka] = function() {
        let o = { ...this };
        return delete o[ka], o;
      }, i;
    }
    function am(e) {
      let r = /* @__PURE__ */ new Map();
      for (let t of e) {
        let n = t.getKeys();
        for (let i of n) r.set(i, t);
      }
      return r;
    }
    function _a(e, r) {
      return e.filter((t) => r.get(t)?.has?.(t) ?? true);
    }
    function Fr(e) {
      return { getKeys() {
        return e;
      }, has() {
        return false;
      }, getPropertyValue() {
      } };
    }
    function Mr(e, r) {
      return { batch: e, transaction: r?.kind === "batch" ? { isolationLevel: r.options.isolationLevel } : void 0 };
    }
    function Na(e) {
      if (e === void 0) return "";
      let r = _r(e);
      return new Ar(0, { colors: Cn }).write(r).toString();
    }
    var lm = "P2037";
    function $r({ error: e, user_facing_error: r }, t, n) {
      return r.error_code ? new z(um(r, n), { code: r.error_code, clientVersion: t, meta: r.meta, batchRequestIdx: r.batch_request_idx }) : new V(e, { clientVersion: t, batchRequestIdx: r.batch_request_idx });
    }
    function um(e, r) {
      let t = e.message;
      return (r === "postgresql" || r === "postgres" || r === "mysql") && e.error_code === lm && (t += `
Prisma Accelerate has built-in connection pooling to prevent such errors: https://pris.ly/client/error-accelerate`), t;
    }
    var vt = "<unknown>";
    function La(e) {
      var r = e.split(`
`);
      return r.reduce(function(t, n) {
        var i = dm(n) || fm(n) || ym(n) || xm(n) || Em(n);
        return i && t.push(i), t;
      }, []);
    }
    var cm = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|rsc|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
    var pm = /\((\S*)(?::(\d+))(?::(\d+))\)/;
    function dm(e) {
      var r = cm.exec(e);
      if (!r) return null;
      var t = r[2] && r[2].indexOf("native") === 0, n = r[2] && r[2].indexOf("eval") === 0, i = pm.exec(r[2]);
      return n && i != null && (r[2] = i[1], r[3] = i[2], r[4] = i[3]), { file: t ? null : r[2], methodName: r[1] || vt, arguments: t ? [r[2]] : [], lineNumber: r[3] ? +r[3] : null, column: r[4] ? +r[4] : null };
    }
    var mm = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|rsc|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
    function fm(e) {
      var r = mm.exec(e);
      return r ? { file: r[2], methodName: r[1] || vt, arguments: [], lineNumber: +r[3], column: r[4] ? +r[4] : null } : null;
    }
    var gm = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|rsc|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
    var hm = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
    function ym(e) {
      var r = gm.exec(e);
      if (!r) return null;
      var t = r[3] && r[3].indexOf(" > eval") > -1, n = hm.exec(r[3]);
      return t && n != null && (r[3] = n[1], r[4] = n[2], r[5] = null), { file: r[3], methodName: r[1] || vt, arguments: r[2] ? r[2].split(",") : [], lineNumber: r[4] ? +r[4] : null, column: r[5] ? +r[5] : null };
    }
    var bm = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;
    function Em(e) {
      var r = bm.exec(e);
      return r ? { file: r[3], methodName: r[1] || vt, arguments: [], lineNumber: +r[4], column: r[5] ? +r[5] : null } : null;
    }
    var wm = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;
    function xm(e) {
      var r = wm.exec(e);
      return r ? { file: r[2], methodName: r[1] || vt, arguments: [], lineNumber: +r[3], column: r[4] ? +r[4] : null } : null;
    }
    var oo = class {
      getLocation() {
        return null;
      }
    };
    var so = class {
      constructor() {
        __publicField(this, "_error");
        this._error = new Error();
      }
      getLocation() {
        let r = this._error.stack;
        if (!r) return null;
        let n = La(r).find((i) => {
          if (!i.file) return false;
          let o = Li(i.file);
          return o !== "<anonymous>" && !o.includes("@prisma") && !o.includes("/packages/client/src/runtime/") && !o.endsWith("/runtime/binary.js") && !o.endsWith("/runtime/library.js") && !o.endsWith("/runtime/edge.js") && !o.endsWith("/runtime/edge-esm.js") && !o.startsWith("internal/") && !i.methodName.includes("new ") && !i.methodName.includes("getCallSite") && !i.methodName.includes("Proxy.") && i.methodName.split(".").length < 4;
        });
        return !n || !n.file ? null : { fileName: n.file, lineNumber: n.lineNumber, columnNumber: n.column };
      }
    };
    function Ze(e) {
      return e === "minimal" ? typeof $EnabledCallSite == "function" && e !== "minimal" ? new $EnabledCallSite() : new oo() : new so();
    }
    var Fa = { _avg: true, _count: true, _sum: true, _min: true, _max: true };
    function qr(e = {}) {
      let r = Pm(e);
      return Object.entries(r).reduce((n, [i, o]) => (Fa[i] !== void 0 ? n.select[i] = { select: o } : n[i] = o, n), { select: {} });
    }
    function Pm(e = {}) {
      return typeof e._count == "boolean" ? { ...e, _count: { _all: e._count } } : e;
    }
    function Un(e = {}) {
      return (r) => (typeof e._count == "boolean" && (r._count = r._count._all), r);
    }
    function Ma(e, r) {
      let t = Un(e);
      return r({ action: "aggregate", unpacker: t, argsMapper: qr })(e);
    }
    function Tm(e = {}) {
      let { select: r, ...t } = e;
      return typeof r == "object" ? qr({ ...t, _count: r }) : qr({ ...t, _count: { _all: true } });
    }
    function Sm(e = {}) {
      return typeof e.select == "object" ? (r) => Un(e)(r)._count : (r) => Un(e)(r)._count._all;
    }
    function $a(e, r) {
      return r({ action: "count", unpacker: Sm(e), argsMapper: Tm })(e);
    }
    function Rm(e = {}) {
      let r = qr(e);
      if (Array.isArray(r.by)) for (let t of r.by) typeof t == "string" && (r.select[t] = true);
      else typeof r.by == "string" && (r.select[r.by] = true);
      return r;
    }
    function Am(e = {}) {
      return (r) => (typeof e?._count == "boolean" && r.forEach((t) => {
        t._count = t._count._all;
      }), r);
    }
    function qa(e, r) {
      return r({ action: "groupBy", unpacker: Am(e), argsMapper: Rm })(e);
    }
    function Va(e, r, t) {
      if (r === "aggregate") return (n) => Ma(n, t);
      if (r === "count") return (n) => $a(n, t);
      if (r === "groupBy") return (n) => qa(n, t);
    }
    function ja(e, r) {
      let t = r.fields.filter((i) => !i.relationName), n = _s(t, "name");
      return new Proxy({}, { get(i, o) {
        if (o in i || typeof o == "symbol") return i[o];
        let s = n[o];
        if (s) return new mt(e, o, s.type, s.isList, s.kind === "enum");
      }, ...Bn(Object.keys(n)) });
    }
    var Ba = (e) => Array.isArray(e) ? e : e.split(".");
    var ao = (e, r) => Ba(r).reduce((t, n) => t && t[n], e);
    var Ua = (e, r, t) => Ba(r).reduceRight((n, i, o, s) => Object.assign({}, ao(e, s.slice(0, o)), { [i]: n }), t);
    function Cm(e, r) {
      return e === void 0 || r === void 0 ? [] : [...r, "select", e];
    }
    function Im(e, r, t) {
      return r === void 0 ? e ?? {} : Ua(r, t, e || true);
    }
    function lo(e, r, t, n, i, o) {
      let a = e._runtimeDataModel.models[r].fields.reduce((l, u) => ({ ...l, [u.name]: u }), {});
      return (l) => {
        let u = Ze(e._errorFormat), c = Cm(n, i), p = Im(l, o, c), d = t({ dataPath: c, callsite: u })(p), f = Dm(e, r);
        return new Proxy(d, { get(h, g) {
          if (!f.includes(g)) return h[g];
          let T = [a[g].type, t, g], S = [c, p];
          return lo(e, ...T, ...S);
        }, ...Bn([...f, ...Object.getOwnPropertyNames(d)]) });
      };
    }
    function Dm(e, r) {
      return e._runtimeDataModel.models[r].fields.filter((t) => t.kind === "object").map((t) => t.name);
    }
    var Om = ["findUnique", "findUniqueOrThrow", "findFirst", "findFirstOrThrow", "create", "update", "upsert", "delete"];
    var km = ["aggregate", "count", "groupBy"];
    function uo(e, r) {
      let t = e._extensions.getAllModelExtensions(r) ?? {}, n = [_m(e, r), Lm(e, r), xt(t), re("name", () => r), re("$name", () => r), re("$parent", () => e._appliedParent)];
      return he({}, n);
    }
    function _m(e, r) {
      let t = Te(r), n = Object.keys(Rr).concat("count");
      return { getKeys() {
        return n;
      }, getPropertyValue(i) {
        let o = i, s = (a) => (l) => {
          let u = Ze(e._errorFormat);
          return e._createPrismaPromise((c) => {
            let p = { args: l, dataPath: [], action: o, model: r, clientMethod: `${t}.${i}`, jsModelName: t, transaction: c, callsite: u };
            return e._request({ ...p, ...a });
          }, { action: o, args: l, model: r });
        };
        return Om.includes(o) ? lo(e, r, s) : Nm(i) ? Va(e, i, s) : s({});
      } };
    }
    function Nm(e) {
      return km.includes(e);
    }
    function Lm(e, r) {
      return lr(re("fields", () => {
        let t = e._runtimeDataModel.models[r];
        return ja(r, t);
      }));
    }
    function Ga(e) {
      return e.replace(/^./, (r) => r.toUpperCase());
    }
    var co = Symbol();
    function Pt(e) {
      let r = [Fm(e), Mm(e), re(co, () => e), re("$parent", () => e._appliedParent)], t = e._extensions.getAllClientExtensions();
      return t && r.push(xt(t)), he(e, r);
    }
    function Fm(e) {
      let r = Object.getPrototypeOf(e._originalClient), t = [...new Set(Object.getOwnPropertyNames(r))];
      return { getKeys() {
        return t;
      }, getPropertyValue(n) {
        return e[n];
      } };
    }
    function Mm(e) {
      let r = Object.keys(e._runtimeDataModel.models), t = r.map(Te), n = [...new Set(r.concat(t))];
      return lr({ getKeys() {
        return n;
      }, getPropertyValue(i) {
        let o = Ga(i);
        if (e._runtimeDataModel.models[o] !== void 0) return uo(e, o);
        if (e._runtimeDataModel.models[i] !== void 0) return uo(e, i);
      }, getPropertyDescriptor(i) {
        if (!t.includes(i)) return { enumerable: false };
      } });
    }
    function Qa(e) {
      return e[co] ? e[co] : e;
    }
    function Wa(e) {
      if (typeof e == "function") return e(this);
      if (e.client?.__AccelerateEngine) {
        let t = e.client.__AccelerateEngine;
        this._originalClient._engine = new t(this._originalClient._accelerateEngineConfig);
      }
      let r = Object.create(this._originalClient, { _extensions: { value: this._extensions.append(e) }, _appliedParent: { value: this, configurable: true }, $on: { value: void 0 } });
      return Pt(r);
    }
    function Ja({ result: e, modelName: r, select: t, omit: n, extensions: i }) {
      let o = i.getAllComputedFields(r);
      if (!o) return e;
      let s = [], a = [];
      for (let l of Object.values(o)) {
        if (n) {
          if (n[l.name]) continue;
          let u = l.needs.filter((c) => n[c]);
          u.length > 0 && a.push(Fr(u));
        } else if (t) {
          if (!t[l.name]) continue;
          let u = l.needs.filter((c) => !t[c]);
          u.length > 0 && a.push(Fr(u));
        }
        $m(e, l.needs) && s.push(qm(l, he(e, s)));
      }
      return s.length > 0 || a.length > 0 ? he(e, [...s, ...a]) : e;
    }
    function $m(e, r) {
      return r.every((t) => Vi(e, t));
    }
    function qm(e, r) {
      return lr(re(e.name, () => e.compute(r)));
    }
    function Gn({ visitor: e, result: r, args: t, runtimeDataModel: n, modelName: i }) {
      if (Array.isArray(r)) {
        for (let s = 0; s < r.length; s++) r[s] = Gn({ result: r[s], args: t, modelName: i, runtimeDataModel: n, visitor: e });
        return r;
      }
      let o = e(r, i, t) ?? r;
      return t.include && Ka({ includeOrSelect: t.include, result: o, parentModelName: i, runtimeDataModel: n, visitor: e }), t.select && Ka({ includeOrSelect: t.select, result: o, parentModelName: i, runtimeDataModel: n, visitor: e }), o;
    }
    function Ka({ includeOrSelect: e, result: r, parentModelName: t, runtimeDataModel: n, visitor: i }) {
      for (let [o, s] of Object.entries(e)) {
        if (!s || r[o] == null || Se(s)) continue;
        let l = n.models[t].fields.find((c) => c.name === o);
        if (!l || l.kind !== "object" || !l.relationName) continue;
        let u = typeof s == "object" ? s : {};
        r[o] = Gn({ visitor: i, result: r[o], args: u, modelName: l.type, runtimeDataModel: n });
      }
    }
    function Ha({ result: e, modelName: r, args: t, extensions: n, runtimeDataModel: i, globalOmit: o }) {
      return n.isEmpty() || e == null || typeof e != "object" || !i.models[r] ? e : Gn({ result: e, args: t ?? {}, modelName: r, runtimeDataModel: i, visitor: (a, l, u) => {
        let c = Te(l);
        return Ja({ result: a, modelName: c, select: u.select, omit: u.select ? void 0 : { ...o?.[c], ...u.omit }, extensions: n });
      } });
    }
    var Vm = ["$connect", "$disconnect", "$on", "$transaction", "$extends"];
    var Ya = Vm;
    function za(e) {
      if (e instanceof ie) return jm(e);
      if (Vn(e)) return Bm(e);
      if (Array.isArray(e)) {
        let t = [e[0]];
        for (let n = 1; n < e.length; n++) t[n] = Tt(e[n]);
        return t;
      }
      let r = {};
      for (let t in e) r[t] = Tt(e[t]);
      return r;
    }
    function jm(e) {
      return new ie(e.strings, e.values);
    }
    function Bm(e) {
      return new wt(e.sql, e.values);
    }
    function Tt(e) {
      if (typeof e != "object" || e == null || e instanceof Me || kr(e)) return e;
      if (Sr(e)) return new Fe(e.toFixed());
      if (vr(e)) return /* @__PURE__ */ new Date(+e);
      if (ArrayBuffer.isView(e)) return e.slice(0);
      if (Array.isArray(e)) {
        let r = e.length, t;
        for (t = Array(r); r--; ) t[r] = Tt(e[r]);
        return t;
      }
      if (typeof e == "object") {
        let r = {};
        for (let t in e) t === "__proto__" ? Object.defineProperty(r, t, { value: Tt(e[t]), configurable: true, enumerable: true, writable: true }) : r[t] = Tt(e[t]);
        return r;
      }
      ar(e, "Unknown value");
    }
    function Xa(e, r, t, n = 0) {
      return e._createPrismaPromise((i) => {
        let o = r.customDataProxyFetch;
        return "transaction" in r && i !== void 0 && (r.transaction?.kind === "batch" && r.transaction.lock.then(), r.transaction = i), n === t.length ? e._executeRequest(r) : t[n]({ model: r.model, operation: r.model ? r.action : r.clientMethod, args: za(r.args ?? {}), __internalParams: r, query: (s, a = r) => {
          let l = a.customDataProxyFetch;
          return a.customDataProxyFetch = nl(o, l), a.args = s, Xa(e, a, t, n + 1);
        } });
      });
    }
    function el(e, r) {
      let { jsModelName: t, action: n, clientMethod: i } = r, o = t ? n : i;
      if (e._extensions.isEmpty()) return e._executeRequest(r);
      let s = e._extensions.getAllQueryCallbacks(t ?? "$none", o);
      return Xa(e, r, s);
    }
    function rl(e) {
      return (r) => {
        let t = { requests: r }, n = r[0].extensions.getAllBatchQueryCallbacks();
        return n.length ? tl(t, n, 0, e) : e(t);
      };
    }
    function tl(e, r, t, n) {
      if (t === r.length) return n(e);
      let i = e.customDataProxyFetch, o = e.requests[0].transaction;
      return r[t]({ args: { queries: e.requests.map((s) => ({ model: s.modelName, operation: s.action, args: s.args })), transaction: o ? { isolationLevel: o.kind === "batch" ? o.isolationLevel : void 0 } : void 0 }, __internalParams: e, query(s, a = e) {
        let l = a.customDataProxyFetch;
        return a.customDataProxyFetch = nl(i, l), tl(a, r, t + 1, n);
      } });
    }
    var Za = (e) => e;
    function nl(e = Za, r = Za) {
      return (t) => e(r(t));
    }
    var il = N("prisma:client");
    var ol = { Vercel: "vercel", "Netlify CI": "netlify" };
    function sl({ postinstall: e, ciName: r, clientVersion: t, generator: n }) {
      if (il("checkPlatformCaching:postinstall", e), il("checkPlatformCaching:ciName", r), e === true && !(n?.output && typeof (n.output.fromEnvVar ?? n.output.value) == "string") && r && r in ol) {
        let i = `Prisma has detected that this project was built on ${r}, which caches dependencies. This leads to an outdated Prisma Client because Prisma's auto-generation isn't triggered. To fix this, make sure to run the \`prisma generate\` command during the build process.

Learn how: https://pris.ly/d/${ol[r]}-build`;
        throw console.error(i), new P(i, t);
      }
    }
    function al(e, r) {
      return e ? e.datasources ? e.datasources : e.datasourceUrl ? { [r[0]]: { url: e.datasourceUrl } } : {} : {};
    }
    var dl = O(require("fs"));
    var St = O(require("path"));
    function Qn(e) {
      let { runtimeBinaryTarget: r } = e;
      return `Add "${r}" to \`binaryTargets\` in the "schema.prisma" file and run \`prisma generate\` after saving it:

${Um(e)}`;
    }
    function Um(e) {
      let { generator: r, generatorBinaryTargets: t, runtimeBinaryTarget: n } = e, i = { fromEnvVar: null, value: n }, o = [...t, i];
      return ki({ ...r, binaryTargets: o });
    }
    function Xe(e) {
      let { runtimeBinaryTarget: r } = e;
      return `Prisma Client could not locate the Query Engine for runtime "${r}".`;
    }
    function er(e) {
      let { searchedLocations: r } = e;
      return `The following locations have been searched:
${[...new Set(r)].map((i) => `  ${i}`).join(`
`)}`;
    }
    function ll(e) {
      let { runtimeBinaryTarget: r } = e;
      return `${Xe(e)}

This happened because \`binaryTargets\` have been pinned, but the actual deployment also required "${r}".
${Qn(e)}

${er(e)}`;
    }
    function Wn(e) {
      return `We would appreciate if you could take the time to share some information with us.
Please help us by answering a few questions: https://pris.ly/${e}`;
    }
    function Jn(e) {
      let { errorStack: r } = e;
      return r?.match(/\/\.next|\/next@|\/next\//) ? `

We detected that you are using Next.js, learn how to fix this: https://pris.ly/d/engine-not-found-nextjs.` : "";
    }
    function ul(e) {
      let { queryEngineName: r } = e;
      return `${Xe(e)}${Jn(e)}

This is likely caused by a bundler that has not copied "${r}" next to the resulting bundle.
Ensure that "${r}" has been copied next to the bundle or in "${e.expectedLocation}".

${Wn("engine-not-found-bundler-investigation")}

${er(e)}`;
    }
    function cl(e) {
      let { runtimeBinaryTarget: r, generatorBinaryTargets: t } = e, n = t.find((i) => i.native);
      return `${Xe(e)}

This happened because Prisma Client was generated for "${n?.value ?? "unknown"}", but the actual deployment required "${r}".
${Qn(e)}

${er(e)}`;
    }
    function pl(e) {
      let { queryEngineName: r } = e;
      return `${Xe(e)}${Jn(e)}

This is likely caused by tooling that has not copied "${r}" to the deployment folder.
Ensure that you ran \`prisma generate\` and that "${r}" has been copied to "${e.expectedLocation}".

${Wn("engine-not-found-tooling-investigation")}

${er(e)}`;
    }
    var Gm = N("prisma:client:engines:resolveEnginePath");
    var Qm = () => new RegExp("runtime[\\\\/]library\\.m?js$");
    async function ml(e, r) {
      let t = { binary: process.env.PRISMA_QUERY_ENGINE_BINARY, library: process.env.PRISMA_QUERY_ENGINE_LIBRARY }[e] ?? r.prismaPath;
      if (t !== void 0) return t;
      let { enginePath: n, searchedLocations: i } = await Wm(e, r);
      if (Gm("enginePath", n), n !== void 0 && e === "binary" && Ri(n), n !== void 0) return r.prismaPath = n;
      let o = await ir(), s = r.generator?.binaryTargets ?? [], a = s.some((d) => d.native), l = !s.some((d) => d.value === o), u = __filename.match(Qm()) === null, c = { searchedLocations: i, generatorBinaryTargets: s, generator: r.generator, runtimeBinaryTarget: o, queryEngineName: fl(e, o), expectedLocation: St.default.relative(process.cwd(), r.dirname), errorStack: new Error().stack }, p;
      throw a && l ? p = cl(c) : l ? p = ll(c) : u ? p = ul(c) : p = pl(c), new P(p, r.clientVersion);
    }
    async function Wm(e, r) {
      let t = await ir(), n = [], i = [r.dirname, St.default.resolve(__dirname, ".."), r.generator?.output?.value ?? __dirname, St.default.resolve(__dirname, "../../../.prisma/client"), "/tmp/prisma-engines", r.cwd];
      __filename.includes("resolveEnginePath") && i.push(ms());
      for (let o of i) {
        let s = fl(e, t), a = St.default.join(o, s);
        if (n.push(o), dl.default.existsSync(a)) return { enginePath: a, searchedLocations: n };
      }
      return { enginePath: void 0, searchedLocations: n };
    }
    function fl(e, r) {
      return e === "library" ? Gt(r, "fs") : `query-engine-${r}${r === "windows" ? ".exe" : ""}`;
    }
    function gl(e) {
      return e ? e.replace(/".*"/g, '"X"').replace(/[\s:\[]([+-]?([0-9]*[.])?[0-9]+)/g, (r) => `${r[0]}5`) : "";
    }
    function hl(e) {
      return e.split(`
`).map((r) => r.replace(/^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)\s*/, "").replace(/\+\d+\s*ms$/, "")).join(`
`);
    }
    var yl = O(Os());
    function bl({ title: e, user: r = "prisma", repo: t = "prisma", template: n = "bug_report.yml", body: i }) {
      return (0, yl.default)({ user: r, repo: t, template: n, title: e, body: i });
    }
    function El({ version: e, binaryTarget: r, title: t, description: n, engineVersion: i, database: o, query: s }) {
      let a = Bo(6e3 - (s?.length ?? 0)), l = hl(wr(a)), u = n ? `# Description
\`\`\`
${n}
\`\`\`` : "", c = wr(`Hi Prisma Team! My Prisma Client just crashed. This is the report:
## Versions

| Name            | Version            |
|-----------------|--------------------|
| Node            | ${process.version?.padEnd(19)}| 
| OS              | ${r?.padEnd(19)}|
| Prisma Client   | ${e?.padEnd(19)}|
| Query Engine    | ${i?.padEnd(19)}|
| Database        | ${o?.padEnd(19)}|

${u}

## Logs
\`\`\`
${l}
\`\`\`

## Client Snippet
\`\`\`ts
// PLEASE FILL YOUR CODE SNIPPET HERE
\`\`\`

## Schema
\`\`\`prisma
// PLEASE ADD YOUR SCHEMA HERE IF POSSIBLE
\`\`\`

## Prisma Engine Query
\`\`\`
${s ? gl(s) : ""}
\`\`\`
`), p = bl({ title: t, body: c });
      return `${t}

This is a non-recoverable error which probably happens when the Prisma Query Engine has a panic.

${Y(p)}

If you want the Prisma team to look into it, please open the link above \u{1F64F}
To increase the chance of success, please post your schema and a snippet of
how you used Prisma Client in the issue. 
`;
    }
    function wl(e, r) {
      throw new Error(r);
    }
    function Jm(e) {
      return e !== null && typeof e == "object" && typeof e.$type == "string";
    }
    function Km(e, r) {
      let t = {};
      for (let n of Object.keys(e)) t[n] = r(e[n], n);
      return t;
    }
    function Vr(e) {
      return e === null ? e : Array.isArray(e) ? e.map(Vr) : typeof e == "object" ? Jm(e) ? Hm(e) : e.constructor !== null && e.constructor.name !== "Object" ? e : Km(e, Vr) : e;
    }
    function Hm({ $type: e, value: r }) {
      switch (e) {
        case "BigInt":
          return BigInt(r);
        case "Bytes": {
          let { buffer: t, byteOffset: n, byteLength: i } = Buffer.from(r, "base64");
          return new Uint8Array(t, n, i);
        }
        case "DateTime":
          return new Date(r);
        case "Decimal":
          return new Le(r);
        case "Json":
          return JSON.parse(r);
        default:
          wl(r, "Unknown tagged value");
      }
    }
    var xl = "6.16.2";
    var zm = () => globalThis.process?.release?.name === "node";
    var Zm = () => !!globalThis.Bun || !!globalThis.process?.versions?.bun;
    var Xm = () => !!globalThis.Deno;
    var ef = () => typeof globalThis.Netlify == "object";
    var rf = () => typeof globalThis.EdgeRuntime == "object";
    var tf = () => globalThis.navigator?.userAgent === "Cloudflare-Workers";
    function nf() {
      return [[ef, "netlify"], [rf, "edge-light"], [tf, "workerd"], [Xm, "deno"], [Zm, "bun"], [zm, "node"]].flatMap((t) => t[0]() ? [t[1]] : []).at(0) ?? "";
    }
    var of = { node: "Node.js", workerd: "Cloudflare Workers", deno: "Deno and Deno Deploy", netlify: "Netlify Edge Functions", "edge-light": "Edge Runtime (Vercel Edge Functions, Vercel Edge Middleware, Next.js (Pages Router) Edge API Routes, Next.js (App Router) Edge Route Handlers or Next.js Middleware)" };
    function Kn() {
      let e = nf();
      return { id: e, prettyName: of[e] || e, isEdge: ["workerd", "deno", "netlify", "edge-light"].includes(e) };
    }
    function jr({ inlineDatasources: e, overrideDatasources: r, env: t, clientVersion: n }) {
      let i, o = Object.keys(e)[0], s = e[o]?.url, a = r[o]?.url;
      if (o === void 0 ? i = void 0 : a ? i = a : s?.value ? i = s.value : s?.fromEnvVar && (i = t[s.fromEnvVar]), s?.fromEnvVar !== void 0 && i === void 0) throw new P(`error: Environment variable not found: ${s.fromEnvVar}.`, n);
      if (i === void 0) throw new P("error: Missing URL environment variable, value, or override.", n);
      return i;
    }
    var Hn = class extends Error {
      constructor(r, t) {
        super(r);
        __publicField(this, "clientVersion");
        __publicField(this, "cause");
        this.clientVersion = t.clientVersion, this.cause = t.cause;
      }
      get [Symbol.toStringTag]() {
        return this.name;
      }
    };
    var oe = class extends Hn {
      constructor(r, t) {
        super(r, t);
        __publicField(this, "isRetryable");
        this.isRetryable = t.isRetryable ?? true;
      }
    };
    function R(e, r) {
      return { ...e, isRetryable: r };
    }
    var ur = class extends oe {
      constructor(r, t) {
        super(r, R(t, false));
        __publicField(this, "name", "InvalidDatasourceError");
        __publicField(this, "code", "P6001");
      }
    };
    x(ur, "InvalidDatasourceError");
    function vl(e) {
      let r = { clientVersion: e.clientVersion }, t = Object.keys(e.inlineDatasources)[0], n = jr({ inlineDatasources: e.inlineDatasources, overrideDatasources: e.overrideDatasources, clientVersion: e.clientVersion, env: { ...e.env, ...typeof process < "u" ? process.env : {} } }), i;
      try {
        i = new URL(n);
      } catch {
        throw new ur(`Error validating datasource \`${t}\`: the URL must start with the protocol \`prisma://\``, r);
      }
      let { protocol: o, searchParams: s } = i;
      if (o !== "prisma:" && o !== sn) throw new ur(`Error validating datasource \`${t}\`: the URL must start with the protocol \`prisma://\` or \`prisma+postgres://\``, r);
      let a = s.get("api_key");
      if (a === null || a.length < 1) throw new ur(`Error validating datasource \`${t}\`: the URL must contain a valid API key`, r);
      let l = Ii(i) ? "http:" : "https:";
      process.env.TEST_CLIENT_ENGINE_REMOTE_EXECUTOR && i.searchParams.has("use_http") && (l = "http:");
      let u = new URL(i.href.replace(o, l));
      return { apiKey: a, url: u };
    }
    var Pl = O(on());
    var _Yn_instances, e_fn, _a5;
    var Yn = (_a5 = class {
      constructor({ apiKey: r, tracingHelper: t, logLevel: n, logQueries: i, engineHash: o }) {
        __privateAdd(this, _Yn_instances);
        __publicField(this, "apiKey");
        __publicField(this, "tracingHelper");
        __publicField(this, "logLevel");
        __publicField(this, "logQueries");
        __publicField(this, "engineHash");
        this.apiKey = r, this.tracingHelper = t, this.logLevel = n, this.logQueries = i, this.engineHash = o;
      }
      build({ traceparent: r, transactionId: t } = {}) {
        let n = { Accept: "application/json", Authorization: `Bearer ${this.apiKey}`, "Content-Type": "application/json", "Prisma-Engine-Hash": this.engineHash, "Prisma-Engine-Version": Pl.enginesVersion };
        this.tracingHelper.isEnabled() && (n.traceparent = r ?? this.tracingHelper.getTraceParent()), t && (n["X-Transaction-Id"] = t);
        let i = __privateMethod(this, _Yn_instances, e_fn).call(this);
        return i.length > 0 && (n["X-Capture-Telemetry"] = i.join(", ")), n;
      }
    }, _Yn_instances = new WeakSet(), e_fn = function() {
      let r = [];
      return this.tracingHelper.isEnabled() && r.push("tracing"), this.logLevel && r.push(this.logLevel), this.logQueries && r.push("query"), r;
    }, _a5);
    function sf(e) {
      return e[0] * 1e3 + e[1] / 1e6;
    }
    function po(e) {
      return new Date(sf(e));
    }
    var Br = class extends oe {
      constructor(r) {
        super("This request must be retried", R(r, true));
        __publicField(this, "name", "ForcedRetryError");
        __publicField(this, "code", "P5001");
      }
    };
    x(Br, "ForcedRetryError");
    var cr = class extends oe {
      constructor(r, t) {
        super(r, R(t, false));
        __publicField(this, "name", "NotImplementedYetError");
        __publicField(this, "code", "P5004");
      }
    };
    x(cr, "NotImplementedYetError");
    var $ = class extends oe {
      constructor(r, t) {
        super(r, t);
        __publicField(this, "response");
        this.response = t.response;
        let n = this.response.headers.get("prisma-request-id");
        if (n) {
          let i = `(The request id was: ${n})`;
          this.message = this.message + " " + i;
        }
      }
    };
    var pr = class extends $ {
      constructor(r) {
        super("Schema needs to be uploaded", R(r, true));
        __publicField(this, "name", "SchemaMissingError");
        __publicField(this, "code", "P5005");
      }
    };
    x(pr, "SchemaMissingError");
    var mo = "This request could not be understood by the server";
    var Rt = class extends $ {
      constructor(r, t, n) {
        super(t || mo, R(r, false));
        __publicField(this, "name", "BadRequestError");
        __publicField(this, "code", "P5000");
        n && (this.code = n);
      }
    };
    x(Rt, "BadRequestError");
    var At = class extends $ {
      constructor(r, t) {
        super("Engine not started: healthcheck timeout", R(r, true));
        __publicField(this, "name", "HealthcheckTimeoutError");
        __publicField(this, "code", "P5013");
        __publicField(this, "logs");
        this.logs = t;
      }
    };
    x(At, "HealthcheckTimeoutError");
    var Ct = class extends $ {
      constructor(r, t, n) {
        super(t, R(r, true));
        __publicField(this, "name", "EngineStartupError");
        __publicField(this, "code", "P5014");
        __publicField(this, "logs");
        this.logs = n;
      }
    };
    x(Ct, "EngineStartupError");
    var It = class extends $ {
      constructor(r) {
        super("Engine version is not supported", R(r, false));
        __publicField(this, "name", "EngineVersionNotSupportedError");
        __publicField(this, "code", "P5012");
      }
    };
    x(It, "EngineVersionNotSupportedError");
    var fo = "Request timed out";
    var Dt = class extends $ {
      constructor(r, t = fo) {
        super(t, R(r, false));
        __publicField(this, "name", "GatewayTimeoutError");
        __publicField(this, "code", "P5009");
      }
    };
    x(Dt, "GatewayTimeoutError");
    var af = "Interactive transaction error";
    var Ot = class extends $ {
      constructor(r, t = af) {
        super(t, R(r, false));
        __publicField(this, "name", "InteractiveTransactionError");
        __publicField(this, "code", "P5015");
      }
    };
    x(Ot, "InteractiveTransactionError");
    var lf = "Request parameters are invalid";
    var kt = class extends $ {
      constructor(r, t = lf) {
        super(t, R(r, false));
        __publicField(this, "name", "InvalidRequestError");
        __publicField(this, "code", "P5011");
      }
    };
    x(kt, "InvalidRequestError");
    var go = "Requested resource does not exist";
    var _t = class extends $ {
      constructor(r, t = go) {
        super(t, R(r, false));
        __publicField(this, "name", "NotFoundError");
        __publicField(this, "code", "P5003");
      }
    };
    x(_t, "NotFoundError");
    var ho = "Unknown server error";
    var Ur = class extends $ {
      constructor(r, t, n) {
        super(t || ho, R(r, true));
        __publicField(this, "name", "ServerError");
        __publicField(this, "code", "P5006");
        __publicField(this, "logs");
        this.logs = n;
      }
    };
    x(Ur, "ServerError");
    var yo = "Unauthorized, check your connection string";
    var Nt = class extends $ {
      constructor(r, t = yo) {
        super(t, R(r, false));
        __publicField(this, "name", "UnauthorizedError");
        __publicField(this, "code", "P5007");
      }
    };
    x(Nt, "UnauthorizedError");
    var bo = "Usage exceeded, retry again later";
    var Lt = class extends $ {
      constructor(r, t = bo) {
        super(t, R(r, true));
        __publicField(this, "name", "UsageExceededError");
        __publicField(this, "code", "P5008");
      }
    };
    x(Lt, "UsageExceededError");
    async function uf(e) {
      let r;
      try {
        r = await e.text();
      } catch {
        return { type: "EmptyError" };
      }
      try {
        let t = JSON.parse(r);
        if (typeof t == "string") switch (t) {
          case "InternalDataProxyError":
            return { type: "DataProxyError", body: t };
          default:
            return { type: "UnknownTextError", body: t };
        }
        if (typeof t == "object" && t !== null) {
          if ("is_panic" in t && "message" in t && "error_code" in t) return { type: "QueryEngineError", body: t };
          if ("EngineNotStarted" in t || "InteractiveTransactionMisrouted" in t || "InvalidRequestError" in t) {
            let n = Object.values(t)[0].reason;
            return typeof n == "string" && !["SchemaMissing", "EngineVersionNotSupported"].includes(n) ? { type: "UnknownJsonError", body: t } : { type: "DataProxyError", body: t };
          }
        }
        return { type: "UnknownJsonError", body: t };
      } catch {
        return r === "" ? { type: "EmptyError" } : { type: "UnknownTextError", body: r };
      }
    }
    async function Ft(e, r) {
      if (e.ok) return;
      let t = { clientVersion: r, response: e }, n = await uf(e);
      if (n.type === "QueryEngineError") throw new z(n.body.message, { code: n.body.error_code, clientVersion: r });
      if (n.type === "DataProxyError") {
        if (n.body === "InternalDataProxyError") throw new Ur(t, "Internal Data Proxy error");
        if ("EngineNotStarted" in n.body) {
          if (n.body.EngineNotStarted.reason === "SchemaMissing") return new pr(t);
          if (n.body.EngineNotStarted.reason === "EngineVersionNotSupported") throw new It(t);
          if ("EngineStartupError" in n.body.EngineNotStarted.reason) {
            let { msg: i, logs: o } = n.body.EngineNotStarted.reason.EngineStartupError;
            throw new Ct(t, i, o);
          }
          if ("KnownEngineStartupError" in n.body.EngineNotStarted.reason) {
            let { msg: i, error_code: o } = n.body.EngineNotStarted.reason.KnownEngineStartupError;
            throw new P(i, r, o);
          }
          if ("HealthcheckTimeout" in n.body.EngineNotStarted.reason) {
            let { logs: i } = n.body.EngineNotStarted.reason.HealthcheckTimeout;
            throw new At(t, i);
          }
        }
        if ("InteractiveTransactionMisrouted" in n.body) {
          let i = { IDParseError: "Could not parse interactive transaction ID", NoQueryEngineFoundError: "Could not find Query Engine for the specified host and transaction ID", TransactionStartError: "Could not start interactive transaction" };
          throw new Ot(t, i[n.body.InteractiveTransactionMisrouted.reason]);
        }
        if ("InvalidRequestError" in n.body) throw new kt(t, n.body.InvalidRequestError.reason);
      }
      if (e.status === 401 || e.status === 403) throw new Nt(t, Gr(yo, n));
      if (e.status === 404) return new _t(t, Gr(go, n));
      if (e.status === 429) throw new Lt(t, Gr(bo, n));
      if (e.status === 504) throw new Dt(t, Gr(fo, n));
      if (e.status >= 500) throw new Ur(t, Gr(ho, n));
      if (e.status >= 400) throw new Rt(t, Gr(mo, n));
    }
    function Gr(e, r) {
      return r.type === "EmptyError" ? e : `${e}: ${JSON.stringify(r)}`;
    }
    function Tl(e) {
      let r = Math.pow(2, e) * 50, t = Math.ceil(Math.random() * r) - Math.ceil(r / 2), n = r + t;
      return new Promise((i) => setTimeout(() => i(n), n));
    }
    var $e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    function Sl(e) {
      let r = new TextEncoder().encode(e), t = "", n = r.byteLength, i = n % 3, o = n - i, s, a, l, u, c;
      for (let p = 0; p < o; p = p + 3) c = r[p] << 16 | r[p + 1] << 8 | r[p + 2], s = (c & 16515072) >> 18, a = (c & 258048) >> 12, l = (c & 4032) >> 6, u = c & 63, t += $e[s] + $e[a] + $e[l] + $e[u];
      return i == 1 ? (c = r[o], s = (c & 252) >> 2, a = (c & 3) << 4, t += $e[s] + $e[a] + "==") : i == 2 && (c = r[o] << 8 | r[o + 1], s = (c & 64512) >> 10, a = (c & 1008) >> 4, l = (c & 15) << 2, t += $e[s] + $e[a] + $e[l] + "="), t;
    }
    function Rl(e) {
      if (!!e.generator?.previewFeatures.some((t) => t.toLowerCase().includes("metrics"))) throw new P("The `metrics` preview feature is not yet available with Accelerate.\nPlease remove `metrics` from the `previewFeatures` in your schema.\n\nMore information about Accelerate: https://pris.ly/d/accelerate", e.clientVersion);
    }
    var Al = { "@prisma/debug": "workspace:*", "@prisma/engines-version": "6.16.0-7.1c57fdcd7e44b29b9313256c76699e91c3ac3c43", "@prisma/fetch-engine": "workspace:*", "@prisma/get-platform": "workspace:*" };
    var Mt = class extends oe {
      constructor(r, t) {
        super(`Cannot fetch data from service:
${r}`, R(t, true));
        __publicField(this, "name", "RequestError");
        __publicField(this, "code", "P5010");
      }
    };
    x(Mt, "RequestError");
    async function dr(e, r, t = (n) => n) {
      let { clientVersion: n, ...i } = r, o = t(fetch);
      try {
        return await o(e, i);
      } catch (s) {
        let a = s.message ?? "Unknown error";
        throw new Mt(a, { clientVersion: n, cause: s });
      }
    }
    var pf = /^[1-9][0-9]*\.[0-9]+\.[0-9]+$/;
    var Cl = N("prisma:client:dataproxyEngine");
    async function df(e, r) {
      let t = Al["@prisma/engines-version"], n = r.clientVersion ?? "unknown";
      if (process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION || globalThis.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION) return process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION || globalThis.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION;
      if (e.includes("accelerate") && n !== "0.0.0" && n !== "in-memory") return n;
      let [i, o] = n?.split("-") ?? [];
      if (o === void 0 && pf.test(i)) return i;
      if (o !== void 0 || n === "0.0.0" || n === "in-memory") {
        let [s] = t.split("-") ?? [], [a, l, u] = s.split("."), c = mf(`<=${a}.${l}.${u}`), p = await dr(c, { clientVersion: n });
        if (!p.ok) throw new Error(`Failed to fetch stable Prisma version, unpkg.com status ${p.status} ${p.statusText}, response body: ${await p.text() || "<empty body>"}`);
        let d = await p.text();
        Cl("length of body fetched from unpkg.com", d.length);
        let f;
        try {
          f = JSON.parse(d);
        } catch (h) {
          throw console.error("JSON.parse error: body fetched from unpkg.com: ", d), h;
        }
        return f.version;
      }
      throw new cr("Only `major.minor.patch` versions are supported by Accelerate.", { clientVersion: n });
    }
    async function Il(e, r) {
      let t = await df(e, r);
      return Cl("version", t), t;
    }
    function mf(e) {
      return encodeURI(`https://unpkg.com/prisma@${e}/package.json`);
    }
    var Dl = 3;
    var $t = N("prisma:client:dataproxyEngine");
    var qt = class {
      constructor(r) {
        __publicField(this, "name", "DataProxyEngine");
        __publicField(this, "inlineSchema");
        __publicField(this, "inlineSchemaHash");
        __publicField(this, "inlineDatasources");
        __publicField(this, "config");
        __publicField(this, "logEmitter");
        __publicField(this, "env");
        __publicField(this, "clientVersion");
        __publicField(this, "engineHash");
        __publicField(this, "tracingHelper");
        __publicField(this, "remoteClientVersion");
        __publicField(this, "host");
        __publicField(this, "headerBuilder");
        __publicField(this, "startPromise");
        __publicField(this, "protocol");
        Rl(r), this.config = r, this.env = r.env, this.inlineSchema = Sl(r.inlineSchema), this.inlineDatasources = r.inlineDatasources, this.inlineSchemaHash = r.inlineSchemaHash, this.clientVersion = r.clientVersion, this.engineHash = r.engineVersion, this.logEmitter = r.logEmitter, this.tracingHelper = r.tracingHelper;
      }
      apiKey() {
        return this.headerBuilder.apiKey;
      }
      version() {
        return this.engineHash;
      }
      async start() {
        this.startPromise !== void 0 && await this.startPromise, this.startPromise = (async () => {
          let { apiKey: r, url: t } = this.getURLAndAPIKey();
          this.host = t.host, this.protocol = t.protocol, this.headerBuilder = new Yn({ apiKey: r, tracingHelper: this.tracingHelper, logLevel: this.config.logLevel ?? "error", logQueries: this.config.logQueries, engineHash: this.engineHash }), this.remoteClientVersion = await Il(this.host, this.config), $t("host", this.host), $t("protocol", this.protocol);
        })(), await this.startPromise;
      }
      async stop() {
      }
      propagateResponseExtensions(r) {
        r?.logs?.length && r.logs.forEach((t) => {
          switch (t.level) {
            case "debug":
            case "trace":
              $t(t);
              break;
            case "error":
            case "warn":
            case "info": {
              this.logEmitter.emit(t.level, { timestamp: po(t.timestamp), message: t.attributes.message ?? "", target: t.target ?? "BinaryEngine" });
              break;
            }
            case "query": {
              this.logEmitter.emit("query", { query: t.attributes.query ?? "", timestamp: po(t.timestamp), duration: t.attributes.duration_ms ?? 0, params: t.attributes.params ?? "", target: t.target ?? "BinaryEngine" });
              break;
            }
            default:
              t.level;
          }
        }), r?.traces?.length && this.tracingHelper.dispatchEngineSpans(r.traces);
      }
      onBeforeExit() {
        throw new Error('"beforeExit" hook is not applicable to the remote query engine');
      }
      async url(r) {
        return await this.start(), `${this.protocol}//${this.host}/${this.remoteClientVersion}/${this.inlineSchemaHash}/${r}`;
      }
      async uploadSchema() {
        let r = { name: "schemaUpload", internal: true };
        return this.tracingHelper.runInChildSpan(r, async () => {
          let t = await dr(await this.url("schema"), { method: "PUT", headers: this.headerBuilder.build(), body: this.inlineSchema, clientVersion: this.clientVersion });
          t.ok || $t("schema response status", t.status);
          let n = await Ft(t, this.clientVersion);
          if (n) throw this.logEmitter.emit("warn", { message: `Error while uploading schema: ${n.message}`, timestamp: /* @__PURE__ */ new Date(), target: "" }), n;
          this.logEmitter.emit("info", { message: `Schema (re)uploaded (hash: ${this.inlineSchemaHash})`, timestamp: /* @__PURE__ */ new Date(), target: "" });
        });
      }
      request(r, { traceparent: t, interactiveTransaction: n, customDataProxyFetch: i }) {
        return this.requestInternal({ body: r, traceparent: t, interactiveTransaction: n, customDataProxyFetch: i });
      }
      async requestBatch(r, { traceparent: t, transaction: n, customDataProxyFetch: i }) {
        let o = n?.kind === "itx" ? n.options : void 0, s = Mr(r, n);
        return (await this.requestInternal({ body: s, customDataProxyFetch: i, interactiveTransaction: o, traceparent: t })).map((l) => (l.extensions && this.propagateResponseExtensions(l.extensions), "errors" in l ? this.convertProtocolErrorsToClientError(l.errors) : l));
      }
      requestInternal({ body: r, traceparent: t, customDataProxyFetch: n, interactiveTransaction: i }) {
        return this.withRetry({ actionGerund: "querying", callback: async ({ logHttpCall: o }) => {
          let s = i ? `${i.payload.endpoint}/graphql` : await this.url("graphql");
          o(s);
          let a = await dr(s, { method: "POST", headers: this.headerBuilder.build({ traceparent: t, transactionId: i?.id }), body: JSON.stringify(r), clientVersion: this.clientVersion }, n);
          a.ok || $t("graphql response status", a.status), await this.handleError(await Ft(a, this.clientVersion));
          let l = await a.json();
          if (l.extensions && this.propagateResponseExtensions(l.extensions), "errors" in l) throw this.convertProtocolErrorsToClientError(l.errors);
          return "batchResult" in l ? l.batchResult : l;
        } });
      }
      async transaction(r, t, n) {
        let i = { start: "starting", commit: "committing", rollback: "rolling back" };
        return this.withRetry({ actionGerund: `${i[r]} transaction`, callback: async ({ logHttpCall: o }) => {
          if (r === "start") {
            let s = JSON.stringify({ max_wait: n.maxWait, timeout: n.timeout, isolation_level: n.isolationLevel }), a = await this.url("transaction/start");
            o(a);
            let l = await dr(a, { method: "POST", headers: this.headerBuilder.build({ traceparent: t.traceparent }), body: s, clientVersion: this.clientVersion });
            await this.handleError(await Ft(l, this.clientVersion));
            let u = await l.json(), { extensions: c } = u;
            c && this.propagateResponseExtensions(c);
            let p = u.id, d = u["data-proxy"].endpoint;
            return { id: p, payload: { endpoint: d } };
          } else {
            let s = `${n.payload.endpoint}/${r}`;
            o(s);
            let a = await dr(s, { method: "POST", headers: this.headerBuilder.build({ traceparent: t.traceparent }), clientVersion: this.clientVersion });
            await this.handleError(await Ft(a, this.clientVersion));
            let l = await a.json(), { extensions: u } = l;
            u && this.propagateResponseExtensions(u);
            return;
          }
        } });
      }
      getURLAndAPIKey() {
        return vl({ clientVersion: this.clientVersion, env: this.env, inlineDatasources: this.inlineDatasources, overrideDatasources: this.config.overrideDatasources });
      }
      metrics() {
        throw new cr("Metrics are not yet supported for Accelerate", { clientVersion: this.clientVersion });
      }
      async withRetry(r) {
        for (let t = 0; ; t++) {
          let n = (i) => {
            this.logEmitter.emit("info", { message: `Calling ${i} (n=${t})`, timestamp: /* @__PURE__ */ new Date(), target: "" });
          };
          try {
            return await r.callback({ logHttpCall: n });
          } catch (i) {
            if (!(i instanceof oe) || !i.isRetryable) throw i;
            if (t >= Dl) throw i instanceof Br ? i.cause : i;
            this.logEmitter.emit("warn", { message: `Attempt ${t + 1}/${Dl} failed for ${r.actionGerund}: ${i.message ?? "(unknown)"}`, timestamp: /* @__PURE__ */ new Date(), target: "" });
            let o = await Tl(t);
            this.logEmitter.emit("warn", { message: `Retrying after ${o}ms`, timestamp: /* @__PURE__ */ new Date(), target: "" });
          }
        }
      }
      async handleError(r) {
        if (r instanceof pr) throw await this.uploadSchema(), new Br({ clientVersion: this.clientVersion, cause: r });
        if (r) throw r;
      }
      convertProtocolErrorsToClientError(r) {
        return r.length === 1 ? $r(r[0], this.config.clientVersion, this.config.activeProvider) : new V(JSON.stringify(r), { clientVersion: this.config.clientVersion });
      }
      applyPendingMigrations() {
        throw new Error("Method not implemented.");
      }
    };
    function Ol(e) {
      if (e?.kind === "itx") return e.options.id;
    }
    var wo = O(require("os"));
    var kl = O(require("path"));
    var Eo = Symbol("PrismaLibraryEngineCache");
    function ff() {
      let e = globalThis;
      return e[Eo] === void 0 && (e[Eo] = {}), e[Eo];
    }
    function gf(e) {
      let r = ff();
      if (r[e] !== void 0) return r[e];
      let t = kl.default.toNamespacedPath(e), n = { exports: {} }, i = 0;
      return process.platform !== "win32" && (i = wo.default.constants.dlopen.RTLD_LAZY | wo.default.constants.dlopen.RTLD_DEEPBIND), process.dlopen(n, t, i), r[e] = n.exports, n.exports;
    }
    var _l = { async loadLibrary(e) {
      let r = await fi(), t = await ml("library", e);
      try {
        return e.tracingHelper.runInChildSpan({ name: "loadLibrary", internal: true }, () => gf(t));
      } catch (n) {
        let i = Ai({ e: n, platformInfo: r, id: t });
        throw new P(i, e.clientVersion);
      }
    } };
    var xo;
    var Nl = { async loadLibrary(e) {
      let { clientVersion: r, adapter: t, engineWasm: n } = e;
      if (t === void 0) throw new P(`The \`adapter\` option for \`PrismaClient\` is required in this context (${Kn().prettyName})`, r);
      if (n === void 0) throw new P("WASM engine was unexpectedly `undefined`", r);
      xo === void 0 && (xo = (async () => {
        let o = await n.getRuntime(), s = await n.getQueryEngineWasmModule();
        if (s == null) throw new P("The loaded wasm module was unexpectedly `undefined` or `null` once loaded", r);
        let a = { "./query_engine_bg.js": o }, l = new WebAssembly.Instance(s, a), u = l.exports.__wbindgen_start;
        return o.__wbg_set_wasm(l.exports), u(), o.QueryEngine;
      })());
      let i = await xo;
      return { debugPanic() {
        return Promise.reject("{}");
      }, dmmf() {
        return Promise.resolve("{}");
      }, version() {
        return { commit: "unknown", version: "unknown" };
      }, QueryEngine: i };
    } };
    var hf = "P2036";
    var Re = N("prisma:client:libraryEngine");
    function yf(e) {
      return e.item_type === "query" && "query" in e;
    }
    function bf(e) {
      return "level" in e ? e.level === "error" && e.message === "PANIC" : false;
    }
    var Ll = [...li, "native"];
    var Ef = 0xffffffffffffffffn;
    var vo = 1n;
    function wf() {
      let e = vo++;
      return vo > Ef && (vo = 1n), e;
    }
    var Qr = class {
      constructor(r, t) {
        __publicField(this, "name", "LibraryEngine");
        __publicField(this, "engine");
        __publicField(this, "libraryInstantiationPromise");
        __publicField(this, "libraryStartingPromise");
        __publicField(this, "libraryStoppingPromise");
        __publicField(this, "libraryStarted");
        __publicField(this, "executingQueryPromise");
        __publicField(this, "config");
        __publicField(this, "QueryEngineConstructor");
        __publicField(this, "libraryLoader");
        __publicField(this, "library");
        __publicField(this, "logEmitter");
        __publicField(this, "libQueryEnginePath");
        __publicField(this, "binaryTarget");
        __publicField(this, "datasourceOverrides");
        __publicField(this, "datamodel");
        __publicField(this, "logQueries");
        __publicField(this, "logLevel");
        __publicField(this, "lastQuery");
        __publicField(this, "loggerRustPanic");
        __publicField(this, "tracingHelper");
        __publicField(this, "adapterPromise");
        __publicField(this, "versionInfo");
        this.libraryLoader = t ?? _l, r.engineWasm !== void 0 && (this.libraryLoader = t ?? Nl), this.config = r, this.libraryStarted = false, this.logQueries = r.logQueries ?? false, this.logLevel = r.logLevel ?? "error", this.logEmitter = r.logEmitter, this.datamodel = r.inlineSchema, this.tracingHelper = r.tracingHelper, r.enableDebugLogs && (this.logLevel = "debug");
        let n = Object.keys(r.overrideDatasources)[0], i = r.overrideDatasources[n]?.url;
        n !== void 0 && i !== void 0 && (this.datasourceOverrides = { [n]: i }), this.libraryInstantiationPromise = this.instantiateLibrary();
      }
      wrapEngine(r) {
        return { applyPendingMigrations: r.applyPendingMigrations?.bind(r), commitTransaction: this.withRequestId(r.commitTransaction.bind(r)), connect: this.withRequestId(r.connect.bind(r)), disconnect: this.withRequestId(r.disconnect.bind(r)), metrics: r.metrics?.bind(r), query: this.withRequestId(r.query.bind(r)), rollbackTransaction: this.withRequestId(r.rollbackTransaction.bind(r)), sdlSchema: r.sdlSchema?.bind(r), startTransaction: this.withRequestId(r.startTransaction.bind(r)), trace: r.trace.bind(r), free: r.free?.bind(r) };
      }
      withRequestId(r) {
        return async (...t) => {
          let n = wf().toString();
          try {
            return await r(...t, n);
          } finally {
            if (this.tracingHelper.isEnabled()) {
              let i = await this.engine?.trace(n);
              if (i) {
                let o = JSON.parse(i);
                this.tracingHelper.dispatchEngineSpans(o.spans);
              }
            }
          }
        };
      }
      async applyPendingMigrations() {
        throw new Error("Cannot call this method from this type of engine instance");
      }
      async transaction(r, t, n) {
        await this.start();
        let i = await this.adapterPromise, o = JSON.stringify(t), s;
        if (r === "start") {
          let l = JSON.stringify({ max_wait: n.maxWait, timeout: n.timeout, isolation_level: n.isolationLevel });
          s = await this.engine?.startTransaction(l, o);
        } else r === "commit" ? s = await this.engine?.commitTransaction(n.id, o) : r === "rollback" && (s = await this.engine?.rollbackTransaction(n.id, o));
        let a = this.parseEngineResponse(s);
        if (xf(a)) {
          let l = this.getExternalAdapterError(a, i?.errorRegistry);
          throw l ? l.error : new z(a.message, { code: a.error_code, clientVersion: this.config.clientVersion, meta: a.meta });
        } else if (typeof a.message == "string") throw new V(a.message, { clientVersion: this.config.clientVersion });
        return a;
      }
      async instantiateLibrary() {
        if (Re("internalSetup"), this.libraryInstantiationPromise) return this.libraryInstantiationPromise;
        ai(), this.binaryTarget = await this.getCurrentBinaryTarget(), await this.tracingHelper.runInChildSpan("load_engine", () => this.loadEngine()), this.version();
      }
      async getCurrentBinaryTarget() {
        {
          if (this.binaryTarget) return this.binaryTarget;
          let r = await this.tracingHelper.runInChildSpan("detect_platform", () => ir());
          if (!Ll.includes(r)) throw new P(`Unknown ${ce("PRISMA_QUERY_ENGINE_LIBRARY")} ${ce(W(r))}. Possible binaryTargets: ${qe(Ll.join(", "))} or a path to the query engine library.
You may have to run ${qe("prisma generate")} for your changes to take effect.`, this.config.clientVersion);
          return r;
        }
      }
      parseEngineResponse(r) {
        if (!r) throw new V("Response from the Engine was empty", { clientVersion: this.config.clientVersion });
        try {
          return JSON.parse(r);
        } catch {
          throw new V("Unable to JSON.parse response from engine", { clientVersion: this.config.clientVersion });
        }
      }
      async loadEngine() {
        if (!this.engine) {
          this.QueryEngineConstructor || (this.library = await this.libraryLoader.loadLibrary(this.config), this.QueryEngineConstructor = this.library.QueryEngine);
          try {
            let r = new WeakRef(this);
            this.adapterPromise || (this.adapterPromise = this.config.adapter?.connect()?.then(tn));
            let t = await this.adapterPromise;
            t && Re("Using driver adapter: %O", t), this.engine = this.wrapEngine(new this.QueryEngineConstructor({ datamodel: this.datamodel, env: process.env, logQueries: this.config.logQueries ?? false, ignoreEnvVarErrors: true, datasourceOverrides: this.datasourceOverrides ?? {}, logLevel: this.logLevel, configDir: this.config.cwd, engineProtocol: "json", enableTracing: this.tracingHelper.isEnabled() }, (n) => {
              r.deref()?.logger(n);
            }, t));
          } catch (r) {
            let t = r, n = this.parseInitError(t.message);
            throw typeof n == "string" ? t : new P(n.message, this.config.clientVersion, n.error_code);
          }
        }
      }
      logger(r) {
        let t = this.parseEngineResponse(r);
        t && (t.level = t?.level.toLowerCase() ?? "unknown", yf(t) ? this.logEmitter.emit("query", { timestamp: /* @__PURE__ */ new Date(), query: t.query, params: t.params, duration: Number(t.duration_ms), target: t.module_path }) : bf(t) ? this.loggerRustPanic = new ae(Po(this, `${t.message}: ${t.reason} in ${t.file}:${t.line}:${t.column}`), this.config.clientVersion) : this.logEmitter.emit(t.level, { timestamp: /* @__PURE__ */ new Date(), message: t.message, target: t.module_path }));
      }
      parseInitError(r) {
        try {
          return JSON.parse(r);
        } catch {
        }
        return r;
      }
      parseRequestError(r) {
        try {
          return JSON.parse(r);
        } catch {
        }
        return r;
      }
      onBeforeExit() {
        throw new Error('"beforeExit" hook is not applicable to the library engine since Prisma 5.0.0, it is only relevant and implemented for the binary engine. Please add your event listener to the `process` object directly instead.');
      }
      async start() {
        if (this.libraryInstantiationPromise || (this.libraryInstantiationPromise = this.instantiateLibrary()), await this.libraryInstantiationPromise, await this.libraryStoppingPromise, this.libraryStartingPromise) return Re(`library already starting, this.libraryStarted: ${this.libraryStarted}`), this.libraryStartingPromise;
        if (this.libraryStarted) return;
        let r = async () => {
          Re("library starting");
          try {
            let t = { traceparent: this.tracingHelper.getTraceParent() };
            await this.engine?.connect(JSON.stringify(t)), this.libraryStarted = true, this.adapterPromise || (this.adapterPromise = this.config.adapter?.connect()?.then(tn)), await this.adapterPromise, Re("library started");
          } catch (t) {
            let n = this.parseInitError(t.message);
            throw typeof n == "string" ? t : new P(n.message, this.config.clientVersion, n.error_code);
          } finally {
            this.libraryStartingPromise = void 0;
          }
        };
        return this.libraryStartingPromise = this.tracingHelper.runInChildSpan("connect", r), this.libraryStartingPromise;
      }
      async stop() {
        if (await this.libraryInstantiationPromise, await this.libraryStartingPromise, await this.executingQueryPromise, this.libraryStoppingPromise) return Re("library is already stopping"), this.libraryStoppingPromise;
        if (!this.libraryStarted) {
          await (await this.adapterPromise)?.dispose(), this.adapterPromise = void 0;
          return;
        }
        let r = async () => {
          await new Promise((n) => setImmediate(n)), Re("library stopping");
          let t = { traceparent: this.tracingHelper.getTraceParent() };
          await this.engine?.disconnect(JSON.stringify(t)), this.engine?.free && this.engine.free(), this.engine = void 0, this.libraryStarted = false, this.libraryStoppingPromise = void 0, this.libraryInstantiationPromise = void 0, await (await this.adapterPromise)?.dispose(), this.adapterPromise = void 0, Re("library stopped");
        };
        return this.libraryStoppingPromise = this.tracingHelper.runInChildSpan("disconnect", r), this.libraryStoppingPromise;
      }
      version() {
        return this.versionInfo = this.library?.version(), this.versionInfo?.version ?? "unknown";
      }
      debugPanic(r) {
        return this.library?.debugPanic(r);
      }
      async request(r, { traceparent: t, interactiveTransaction: n }) {
        Re(`sending request, this.libraryStarted: ${this.libraryStarted}`);
        let i = JSON.stringify({ traceparent: t }), o = JSON.stringify(r);
        try {
          await this.start();
          let s = await this.adapterPromise;
          this.executingQueryPromise = this.engine?.query(o, i, n?.id), this.lastQuery = o;
          let a = this.parseEngineResponse(await this.executingQueryPromise);
          if (a.errors) throw a.errors.length === 1 ? this.buildQueryError(a.errors[0], s?.errorRegistry) : new V(JSON.stringify(a.errors), { clientVersion: this.config.clientVersion });
          if (this.loggerRustPanic) throw this.loggerRustPanic;
          return { data: a };
        } catch (s) {
          if (s instanceof P) throw s;
          if (s.code === "GenericFailure" && s.message?.startsWith("PANIC:")) throw new ae(Po(this, s.message), this.config.clientVersion);
          let a = this.parseRequestError(s.message);
          throw typeof a == "string" ? s : new V(`${a.message}
${a.backtrace}`, { clientVersion: this.config.clientVersion });
        }
      }
      async requestBatch(r, { transaction: t, traceparent: n }) {
        Re("requestBatch");
        let i = Mr(r, t);
        await this.start();
        let o = await this.adapterPromise;
        this.lastQuery = JSON.stringify(i), this.executingQueryPromise = this.engine?.query(this.lastQuery, JSON.stringify({ traceparent: n }), Ol(t));
        let s = await this.executingQueryPromise, a = this.parseEngineResponse(s);
        if (a.errors) throw a.errors.length === 1 ? this.buildQueryError(a.errors[0], o?.errorRegistry) : new V(JSON.stringify(a.errors), { clientVersion: this.config.clientVersion });
        let { batchResult: l, errors: u } = a;
        if (Array.isArray(l)) return l.map((c) => c.errors && c.errors.length > 0 ? this.loggerRustPanic ?? this.buildQueryError(c.errors[0], o?.errorRegistry) : { data: c });
        throw u && u.length === 1 ? new Error(u[0].error) : new Error(JSON.stringify(a));
      }
      buildQueryError(r, t) {
        if (r.user_facing_error.is_panic) return new ae(Po(this, r.user_facing_error.message), this.config.clientVersion);
        let n = this.getExternalAdapterError(r.user_facing_error, t);
        return n ? n.error : $r(r, this.config.clientVersion, this.config.activeProvider);
      }
      getExternalAdapterError(r, t) {
        if (r.error_code === hf && t) {
          let n = r.meta?.id;
          ln(typeof n == "number", "Malformed external JS error received from the engine");
          let i = t.consumeError(n);
          return ln(i, "External error with reported id was not registered"), i;
        }
      }
      async metrics(r) {
        await this.start();
        let t = await this.engine.metrics(JSON.stringify(r));
        return r.format === "prometheus" ? t : this.parseEngineResponse(t);
      }
    };
    function xf(e) {
      return typeof e == "object" && e !== null && e.error_code !== void 0;
    }
    function Po(e, r) {
      return El({ binaryTarget: e.binaryTarget, title: r, version: e.config.clientVersion, engineVersion: e.versionInfo?.commit, database: e.config.activeProvider, query: e.lastQuery });
    }
    function Fl({ url: e, adapter: r, copyEngine: t, targetBuildType: n }) {
      let i = [], o = [], s = (g) => {
        i.push({ _tag: "warning", value: g });
      }, a = (g) => {
        let I = g.join(`
`);
        o.push({ _tag: "error", value: I });
      }, l = !!e?.startsWith("prisma://"), u = an(e), c = !!r, p = l || u;
      !c && t && p && n !== "client" && n !== "wasm-compiler-edge" && s(["recommend--no-engine", "In production, we recommend using `prisma generate --no-engine` (See: `prisma generate --help`)"]);
      let d = p || !t;
      c && (d || n === "edge") && (n === "edge" ? a(["Prisma Client was configured to use the `adapter` option but it was imported via its `/edge` endpoint.", "Please either remove the `/edge` endpoint or remove the `adapter` from the Prisma Client constructor."]) : p ? a(["You've provided both a driver adapter and an Accelerate database URL. Driver adapters currently cannot connect to Accelerate.", "Please provide either a driver adapter with a direct database URL or an Accelerate URL and no driver adapter."]) : t || a(["Prisma Client was configured to use the `adapter` option but `prisma generate` was run with `--no-engine`.", "Please run `prisma generate` without `--no-engine` to be able to use Prisma Client with the adapter."]));
      let f = { accelerate: d, ppg: u, driverAdapters: c };
      function h(g) {
        return g.length > 0;
      }
      return h(o) ? { ok: false, diagnostics: { warnings: i, errors: o }, isUsing: f } : { ok: true, diagnostics: { warnings: i }, isUsing: f };
    }
    function Ml({ copyEngine: e = true }, r) {
      let t;
      try {
        t = jr({ inlineDatasources: r.inlineDatasources, overrideDatasources: r.overrideDatasources, env: { ...r.env, ...process.env }, clientVersion: r.clientVersion });
      } catch {
      }
      let { ok: n, isUsing: i, diagnostics: o } = Fl({ url: t, adapter: r.adapter, copyEngine: e, targetBuildType: "library" });
      for (let p of o.warnings) at(...p.value);
      if (!n) {
        let p = o.errors[0];
        throw new Z(p.value, { clientVersion: r.clientVersion });
      }
      let s = Er(r.generator), a = s === "library", l = s === "binary", u = s === "client", c = (i.accelerate || i.ppg) && !i.driverAdapters;
      return i.accelerate ? new qt(r) : (i.driverAdapters, a ? new Qr(r) : (i.accelerate, new Qr(r)));
    }
    function $l({ generator: e }) {
      return e?.previewFeatures ?? [];
    }
    var ql = (e) => ({ command: e });
    var Vl = (e) => e.strings.reduce((r, t, n) => `${r}@P${n}${t}`);
    function Wr(e) {
      try {
        return jl(e, "fast");
      } catch {
        return jl(e, "slow");
      }
    }
    function jl(e, r) {
      return JSON.stringify(e.map((t) => Ul(t, r)));
    }
    function Ul(e, r) {
      if (Array.isArray(e)) return e.map((t) => Ul(t, r));
      if (typeof e == "bigint") return { prisma__type: "bigint", prisma__value: e.toString() };
      if (vr(e)) return { prisma__type: "date", prisma__value: e.toJSON() };
      if (Fe.isDecimal(e)) return { prisma__type: "decimal", prisma__value: e.toJSON() };
      if (Buffer.isBuffer(e)) return { prisma__type: "bytes", prisma__value: e.toString("base64") };
      if (vf(e)) return { prisma__type: "bytes", prisma__value: Buffer.from(e).toString("base64") };
      if (ArrayBuffer.isView(e)) {
        let { buffer: t, byteOffset: n, byteLength: i } = e;
        return { prisma__type: "bytes", prisma__value: Buffer.from(t, n, i).toString("base64") };
      }
      return typeof e == "object" && r === "slow" ? Gl(e) : e;
    }
    function vf(e) {
      return e instanceof ArrayBuffer || e instanceof SharedArrayBuffer ? true : typeof e == "object" && e !== null ? e[Symbol.toStringTag] === "ArrayBuffer" || e[Symbol.toStringTag] === "SharedArrayBuffer" : false;
    }
    function Gl(e) {
      if (typeof e != "object" || e === null) return e;
      if (typeof e.toJSON == "function") return e.toJSON();
      if (Array.isArray(e)) return e.map(Bl);
      let r = {};
      for (let t of Object.keys(e)) r[t] = Bl(e[t]);
      return r;
    }
    function Bl(e) {
      return typeof e == "bigint" ? e.toString() : Gl(e);
    }
    var Pf = /^(\s*alter\s)/i;
    var Ql = N("prisma:client");
    function To(e, r, t, n) {
      if (!(e !== "postgresql" && e !== "cockroachdb") && t.length > 0 && Pf.exec(r)) throw new Error(`Running ALTER using ${n} is not supported
Using the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.

Example:
  await prisma.$executeRawUnsafe(\`ALTER USER prisma WITH PASSWORD '\${password}'\`)

More Information: https://pris.ly/d/execute-raw
`);
    }
    var So = ({ clientMethod: e, activeProvider: r }) => (t) => {
      let n = "", i;
      if (Vn(t)) n = t.sql, i = { values: Wr(t.values), __prismaRawParameters__: true };
      else if (Array.isArray(t)) {
        let [o, ...s] = t;
        n = o, i = { values: Wr(s || []), __prismaRawParameters__: true };
      } else switch (r) {
        case "sqlite":
        case "mysql": {
          n = t.sql, i = { values: Wr(t.values), __prismaRawParameters__: true };
          break;
        }
        case "cockroachdb":
        case "postgresql":
        case "postgres": {
          n = t.text, i = { values: Wr(t.values), __prismaRawParameters__: true };
          break;
        }
        case "sqlserver": {
          n = Vl(t), i = { values: Wr(t.values), __prismaRawParameters__: true };
          break;
        }
        default:
          throw new Error(`The ${r} provider does not support ${e}`);
      }
      return i?.values ? Ql(`prisma.${e}(${n}, ${i.values})`) : Ql(`prisma.${e}(${n})`), { query: n, parameters: i };
    };
    var Wl = { requestArgsToMiddlewareArgs(e) {
      return [e.strings, ...e.values];
    }, middlewareArgsToRequestArgs(e) {
      let [r, ...t] = e;
      return new ie(r, t);
    } };
    var Jl = { requestArgsToMiddlewareArgs(e) {
      return [e];
    }, middlewareArgsToRequestArgs(e) {
      return e[0];
    } };
    function Ro(e) {
      return function(t, n) {
        let i, o = (s = e) => {
          try {
            return s === void 0 || s?.kind === "itx" ? i ?? (i = Kl(t(s))) : Kl(t(s));
          } catch (a) {
            return Promise.reject(a);
          }
        };
        return { get spec() {
          return n;
        }, then(s, a) {
          return o().then(s, a);
        }, catch(s) {
          return o().catch(s);
        }, finally(s) {
          return o().finally(s);
        }, requestTransaction(s) {
          let a = o(s);
          return a.requestTransaction ? a.requestTransaction(s) : a;
        }, [Symbol.toStringTag]: "PrismaPromise" };
      };
    }
    function Kl(e) {
      return typeof e.then == "function" ? e : Promise.resolve(e);
    }
    var Tf = xi.split(".")[0];
    var Sf = { isEnabled() {
      return false;
    }, getTraceParent() {
      return "00-10-10-00";
    }, dispatchEngineSpans() {
    }, getActiveContext() {
    }, runInChildSpan(e, r) {
      return r();
    } };
    var Ao = class {
      isEnabled() {
        return this.getGlobalTracingHelper().isEnabled();
      }
      getTraceParent(r) {
        return this.getGlobalTracingHelper().getTraceParent(r);
      }
      dispatchEngineSpans(r) {
        return this.getGlobalTracingHelper().dispatchEngineSpans(r);
      }
      getActiveContext() {
        return this.getGlobalTracingHelper().getActiveContext();
      }
      runInChildSpan(r, t) {
        return this.getGlobalTracingHelper().runInChildSpan(r, t);
      }
      getGlobalTracingHelper() {
        let r = globalThis[`V${Tf}_PRISMA_INSTRUMENTATION`], t = globalThis.PRISMA_INSTRUMENTATION;
        return r?.helper ?? t?.helper ?? Sf;
      }
    };
    function Hl() {
      return new Ao();
    }
    function Yl(e, r = () => {
    }) {
      let t, n = new Promise((i) => t = i);
      return { then(i) {
        return --e === 0 && t(r()), i?.(n);
      } };
    }
    function zl(e) {
      return typeof e == "string" ? e : e.reduce((r, t) => {
        let n = typeof t == "string" ? t : t.level;
        return n === "query" ? r : r && (t === "info" || r === "info") ? "info" : n;
      }, void 0);
    }
    function zn(e) {
      return typeof e.batchRequestIdx == "number";
    }
    function Zl(e) {
      if (e.action !== "findUnique" && e.action !== "findUniqueOrThrow") return;
      let r = [];
      return e.modelName && r.push(e.modelName), e.query.arguments && r.push(Co(e.query.arguments)), r.push(Co(e.query.selection)), r.join("");
    }
    function Co(e) {
      return `(${Object.keys(e).sort().map((t) => {
        let n = e[t];
        return typeof n == "object" && n !== null ? `(${t} ${Co(n)})` : t;
      }).join(" ")})`;
    }
    var Rf = { aggregate: false, aggregateRaw: false, createMany: true, createManyAndReturn: true, createOne: true, deleteMany: true, deleteOne: true, executeRaw: true, findFirst: false, findFirstOrThrow: false, findMany: false, findRaw: false, findUnique: false, findUniqueOrThrow: false, groupBy: false, queryRaw: false, runCommandRaw: true, updateMany: true, updateManyAndReturn: true, updateOne: true, upsertOne: true };
    function Io(e) {
      return Rf[e];
    }
    var Zn = class {
      constructor(r) {
        __publicField(this, "batches");
        __publicField(this, "tickActive", false);
        this.options = r;
        this.batches = {};
      }
      request(r) {
        let t = this.options.batchBy(r);
        return t ? (this.batches[t] || (this.batches[t] = [], this.tickActive || (this.tickActive = true, process.nextTick(() => {
          this.dispatchBatches(), this.tickActive = false;
        }))), new Promise((n, i) => {
          this.batches[t].push({ request: r, resolve: n, reject: i });
        })) : this.options.singleLoader(r);
      }
      dispatchBatches() {
        for (let r in this.batches) {
          let t = this.batches[r];
          delete this.batches[r], t.length === 1 ? this.options.singleLoader(t[0].request).then((n) => {
            n instanceof Error ? t[0].reject(n) : t[0].resolve(n);
          }).catch((n) => {
            t[0].reject(n);
          }) : (t.sort((n, i) => this.options.batchOrder(n.request, i.request)), this.options.batchLoader(t.map((n) => n.request)).then((n) => {
            if (n instanceof Error) for (let i = 0; i < t.length; i++) t[i].reject(n);
            else for (let i = 0; i < t.length; i++) {
              let o = n[i];
              o instanceof Error ? t[i].reject(o) : t[i].resolve(o);
            }
          }).catch((n) => {
            for (let i = 0; i < t.length; i++) t[i].reject(n);
          }));
        }
      }
      get [Symbol.toStringTag]() {
        return "DataLoader";
      }
    };
    function mr(e, r) {
      if (r === null) return r;
      switch (e) {
        case "bigint":
          return BigInt(r);
        case "bytes": {
          let { buffer: t, byteOffset: n, byteLength: i } = Buffer.from(r, "base64");
          return new Uint8Array(t, n, i);
        }
        case "decimal":
          return new Fe(r);
        case "datetime":
        case "date":
          return new Date(r);
        case "time":
          return /* @__PURE__ */ new Date(`1970-01-01T${r}Z`);
        case "bigint-array":
          return r.map((t) => mr("bigint", t));
        case "bytes-array":
          return r.map((t) => mr("bytes", t));
        case "decimal-array":
          return r.map((t) => mr("decimal", t));
        case "datetime-array":
          return r.map((t) => mr("datetime", t));
        case "date-array":
          return r.map((t) => mr("date", t));
        case "time-array":
          return r.map((t) => mr("time", t));
        default:
          return r;
      }
    }
    function Xn(e) {
      let r = [], t = Af(e);
      for (let n = 0; n < e.rows.length; n++) {
        let i = e.rows[n], o = { ...t };
        for (let s = 0; s < i.length; s++) o[e.columns[s]] = mr(e.types[s], i[s]);
        r.push(o);
      }
      return r;
    }
    function Af(e) {
      let r = {};
      for (let t = 0; t < e.columns.length; t++) r[e.columns[t]] = null;
      return r;
    }
    var Cf = N("prisma:client:request_handler");
    var ei = class {
      constructor(r, t) {
        __publicField(this, "client");
        __publicField(this, "dataloader");
        __publicField(this, "logEmitter");
        this.logEmitter = t, this.client = r, this.dataloader = new Zn({ batchLoader: rl(async ({ requests: n, customDataProxyFetch: i }) => {
          let { transaction: o, otelParentCtx: s } = n[0], a = n.map((p) => p.protocolQuery), l = this.client._tracingHelper.getTraceParent(s), u = n.some((p) => Io(p.protocolQuery.action));
          return (await this.client._engine.requestBatch(a, { traceparent: l, transaction: If(o), containsWrite: u, customDataProxyFetch: i })).map((p, d) => {
            if (p instanceof Error) return p;
            try {
              return this.mapQueryEngineResult(n[d], p);
            } catch (f) {
              return f;
            }
          });
        }), singleLoader: async (n) => {
          let i = n.transaction?.kind === "itx" ? Xl(n.transaction) : void 0, o = await this.client._engine.request(n.protocolQuery, { traceparent: this.client._tracingHelper.getTraceParent(), interactiveTransaction: i, isWrite: Io(n.protocolQuery.action), customDataProxyFetch: n.customDataProxyFetch });
          return this.mapQueryEngineResult(n, o);
        }, batchBy: (n) => n.transaction?.id ? `transaction-${n.transaction.id}` : Zl(n.protocolQuery), batchOrder(n, i) {
          return n.transaction?.kind === "batch" && i.transaction?.kind === "batch" ? n.transaction.index - i.transaction.index : 0;
        } });
      }
      async request(r) {
        try {
          return await this.dataloader.request(r);
        } catch (t) {
          let { clientMethod: n, callsite: i, transaction: o, args: s, modelName: a } = r;
          this.handleAndLogRequestError({ error: t, clientMethod: n, callsite: i, transaction: o, args: s, modelName: a, globalOmit: r.globalOmit });
        }
      }
      mapQueryEngineResult({ dataPath: r, unpacker: t }, n) {
        let i = n?.data, o = this.unpack(i, r, t);
        return process.env.PRISMA_CLIENT_GET_TIME ? { data: o } : o;
      }
      handleAndLogRequestError(r) {
        try {
          this.handleRequestError(r);
        } catch (t) {
          throw this.logEmitter && this.logEmitter.emit("error", { message: t.message, target: r.clientMethod, timestamp: /* @__PURE__ */ new Date() }), t;
        }
      }
      handleRequestError({ error: r, clientMethod: t, callsite: n, transaction: i, args: o, modelName: s, globalOmit: a }) {
        if (Cf(r), Df(r, i)) throw r;
        if (r instanceof z && Of(r)) {
          let u = eu(r.meta);
          Nn({ args: o, errors: [u], callsite: n, errorFormat: this.client._errorFormat, originalMethod: t, clientVersion: this.client._clientVersion, globalOmit: a });
        }
        let l = r.message;
        if (n && (l = Tn({ callsite: n, originalMethod: t, isPanic: r.isPanic, showColors: this.client._errorFormat === "pretty", message: l })), l = this.sanitizeMessage(l), r.code) {
          let u = s ? { modelName: s, ...r.meta } : r.meta;
          throw new z(l, { code: r.code, clientVersion: this.client._clientVersion, meta: u, batchRequestIdx: r.batchRequestIdx });
        } else {
          if (r.isPanic) throw new ae(l, this.client._clientVersion);
          if (r instanceof V) throw new V(l, { clientVersion: this.client._clientVersion, batchRequestIdx: r.batchRequestIdx });
          if (r instanceof P) throw new P(l, this.client._clientVersion);
          if (r instanceof ae) throw new ae(l, this.client._clientVersion);
        }
        throw r.clientVersion = this.client._clientVersion, r;
      }
      sanitizeMessage(r) {
        return this.client._errorFormat && this.client._errorFormat !== "pretty" ? wr(r) : r;
      }
      unpack(r, t, n) {
        if (!r || (r.data && (r = r.data), !r)) return r;
        let i = Object.keys(r)[0], o = Object.values(r)[0], s = t.filter((u) => u !== "select" && u !== "include"), a = ao(o, s), l = i === "queryRaw" ? Xn(a) : Vr(a);
        return n ? n(l) : l;
      }
      get [Symbol.toStringTag]() {
        return "RequestHandler";
      }
    };
    function If(e) {
      if (e) {
        if (e.kind === "batch") return { kind: "batch", options: { isolationLevel: e.isolationLevel } };
        if (e.kind === "itx") return { kind: "itx", options: Xl(e) };
        ar(e, "Unknown transaction kind");
      }
    }
    function Xl(e) {
      return { id: e.id, payload: e.payload };
    }
    function Df(e, r) {
      return zn(e) && r?.kind === "batch" && e.batchRequestIdx !== r.index;
    }
    function Of(e) {
      return e.code === "P2009" || e.code === "P2012";
    }
    function eu(e) {
      if (e.kind === "Union") return { kind: "Union", errors: e.errors.map(eu) };
      if (Array.isArray(e.selectionPath)) {
        let [, ...r] = e.selectionPath;
        return { ...e, selectionPath: r };
      }
      return e;
    }
    var ru = xl;
    var su = O(Ki());
    var _ = class extends Error {
      constructor(r) {
        super(r + `
Read more at https://pris.ly/d/client-constructor`), this.name = "PrismaClientConstructorValidationError";
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientConstructorValidationError";
      }
    };
    x(_, "PrismaClientConstructorValidationError");
    var tu = ["datasources", "datasourceUrl", "errorFormat", "adapter", "log", "transactionOptions", "omit", "__internal"];
    var nu = ["pretty", "colorless", "minimal"];
    var iu = ["info", "query", "warn", "error"];
    var kf = { datasources: (e, { datasourceNames: r }) => {
      if (e) {
        if (typeof e != "object" || Array.isArray(e)) throw new _(`Invalid value ${JSON.stringify(e)} for "datasources" provided to PrismaClient constructor`);
        for (let [t, n] of Object.entries(e)) {
          if (!r.includes(t)) {
            let i = Jr(t, r) || ` Available datasources: ${r.join(", ")}`;
            throw new _(`Unknown datasource ${t} provided to PrismaClient constructor.${i}`);
          }
          if (typeof n != "object" || Array.isArray(n)) throw new _(`Invalid value ${JSON.stringify(e)} for datasource "${t}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
          if (n && typeof n == "object") for (let [i, o] of Object.entries(n)) {
            if (i !== "url") throw new _(`Invalid value ${JSON.stringify(e)} for datasource "${t}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
            if (typeof o != "string") throw new _(`Invalid value ${JSON.stringify(o)} for datasource "${t}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
          }
        }
      }
    }, adapter: (e, r) => {
      if (!e && Er(r.generator) === "client") throw new _('Using engine type "client" requires a driver adapter to be provided to PrismaClient constructor.');
      if (e !== null) {
        if (e === void 0) throw new _('"adapter" property must not be undefined, use null to conditionally disable driver adapters.');
        if (Er(r.generator) === "binary") throw new _('Cannot use a driver adapter with the "binary" Query Engine. Please use the "library" Query Engine.');
      }
    }, datasourceUrl: (e) => {
      if (typeof e < "u" && typeof e != "string") throw new _(`Invalid value ${JSON.stringify(e)} for "datasourceUrl" provided to PrismaClient constructor.
Expected string or undefined.`);
    }, errorFormat: (e) => {
      if (e) {
        if (typeof e != "string") throw new _(`Invalid value ${JSON.stringify(e)} for "errorFormat" provided to PrismaClient constructor.`);
        if (!nu.includes(e)) {
          let r = Jr(e, nu);
          throw new _(`Invalid errorFormat ${e} provided to PrismaClient constructor.${r}`);
        }
      }
    }, log: (e) => {
      if (!e) return;
      if (!Array.isArray(e)) throw new _(`Invalid value ${JSON.stringify(e)} for "log" provided to PrismaClient constructor.`);
      function r(t) {
        if (typeof t == "string" && !iu.includes(t)) {
          let n = Jr(t, iu);
          throw new _(`Invalid log level "${t}" provided to PrismaClient constructor.${n}`);
        }
      }
      for (let t of e) {
        r(t);
        let n = { level: r, emit: (i) => {
          let o = ["stdout", "event"];
          if (!o.includes(i)) {
            let s = Jr(i, o);
            throw new _(`Invalid value ${JSON.stringify(i)} for "emit" in logLevel provided to PrismaClient constructor.${s}`);
          }
        } };
        if (t && typeof t == "object") for (let [i, o] of Object.entries(t)) if (n[i]) n[i](o);
        else throw new _(`Invalid property ${i} for "log" provided to PrismaClient constructor`);
      }
    }, transactionOptions: (e) => {
      if (!e) return;
      let r = e.maxWait;
      if (r != null && r <= 0) throw new _(`Invalid value ${r} for maxWait in "transactionOptions" provided to PrismaClient constructor. maxWait needs to be greater than 0`);
      let t = e.timeout;
      if (t != null && t <= 0) throw new _(`Invalid value ${t} for timeout in "transactionOptions" provided to PrismaClient constructor. timeout needs to be greater than 0`);
    }, omit: (e, r) => {
      if (typeof e != "object") throw new _('"omit" option is expected to be an object.');
      if (e === null) throw new _('"omit" option can not be `null`');
      let t = [];
      for (let [n, i] of Object.entries(e)) {
        let o = Nf(n, r.runtimeDataModel);
        if (!o) {
          t.push({ kind: "UnknownModel", modelKey: n });
          continue;
        }
        for (let [s, a] of Object.entries(i)) {
          let l = o.fields.find((u) => u.name === s);
          if (!l) {
            t.push({ kind: "UnknownField", modelKey: n, fieldName: s });
            continue;
          }
          if (l.relationName) {
            t.push({ kind: "RelationInOmit", modelKey: n, fieldName: s });
            continue;
          }
          typeof a != "boolean" && t.push({ kind: "InvalidFieldValue", modelKey: n, fieldName: s });
        }
      }
      if (t.length > 0) throw new _(Lf(e, t));
    }, __internal: (e) => {
      if (!e) return;
      let r = ["debug", "engine", "configOverride"];
      if (typeof e != "object") throw new _(`Invalid value ${JSON.stringify(e)} for "__internal" to PrismaClient constructor`);
      for (let [t] of Object.entries(e)) if (!r.includes(t)) {
        let n = Jr(t, r);
        throw new _(`Invalid property ${JSON.stringify(t)} for "__internal" provided to PrismaClient constructor.${n}`);
      }
    } };
    function au(e, r) {
      for (let [t, n] of Object.entries(e)) {
        if (!tu.includes(t)) {
          let i = Jr(t, tu);
          throw new _(`Unknown property ${t} provided to PrismaClient constructor.${i}`);
        }
        kf[t](n, r);
      }
      if (e.datasourceUrl && e.datasources) throw new _('Can not use "datasourceUrl" and "datasources" options at the same time. Pick one of them');
    }
    function Jr(e, r) {
      if (r.length === 0 || typeof e != "string") return "";
      let t = _f(e, r);
      return t ? ` Did you mean "${t}"?` : "";
    }
    function _f(e, r) {
      if (r.length === 0) return null;
      let t = r.map((i) => ({ value: i, distance: (0, su.default)(e, i) }));
      t.sort((i, o) => i.distance < o.distance ? -1 : 1);
      let n = t[0];
      return n.distance < 3 ? n.value : null;
    }
    function Nf(e, r) {
      return ou(r.models, e) ?? ou(r.types, e);
    }
    function ou(e, r) {
      let t = Object.keys(e).find((n) => We(n) === r);
      if (t) return e[t];
    }
    function Lf(e, r) {
      let t = _r(e);
      for (let o of r) switch (o.kind) {
        case "UnknownModel":
          t.arguments.getField(o.modelKey)?.markAsError(), t.addErrorMessage(() => `Unknown model name: ${o.modelKey}.`);
          break;
        case "UnknownField":
          t.arguments.getDeepField([o.modelKey, o.fieldName])?.markAsError(), t.addErrorMessage(() => `Model "${o.modelKey}" does not have a field named "${o.fieldName}".`);
          break;
        case "RelationInOmit":
          t.arguments.getDeepField([o.modelKey, o.fieldName])?.markAsError(), t.addErrorMessage(() => 'Relations are already excluded by default and can not be specified in "omit".');
          break;
        case "InvalidFieldValue":
          t.arguments.getDeepFieldValue([o.modelKey, o.fieldName])?.markAsError(), t.addErrorMessage(() => "Omit field option value must be a boolean.");
          break;
      }
      let { message: n, args: i } = _n(t, "colorless");
      return `Error validating "omit" option:

${i}

${n}`;
    }
    function lu(e) {
      return e.length === 0 ? Promise.resolve([]) : new Promise((r, t) => {
        let n = new Array(e.length), i = null, o = false, s = 0, a = () => {
          o || (s++, s === e.length && (o = true, i ? t(i) : r(n)));
        }, l = (u) => {
          o || (o = true, t(u));
        };
        for (let u = 0; u < e.length; u++) e[u].then((c) => {
          n[u] = c, a();
        }, (c) => {
          if (!zn(c)) {
            l(c);
            return;
          }
          c.batchRequestIdx === u ? l(c) : (i || (i = c), a());
        });
      });
    }
    var rr = N("prisma:client");
    typeof globalThis == "object" && (globalThis.NODE_CLIENT = true);
    var Ff = { requestArgsToMiddlewareArgs: (e) => e, middlewareArgsToRequestArgs: (e) => e };
    var Mf = Symbol.for("prisma.client.transaction.id");
    var $f = { id: 0, nextId() {
      return ++this.id;
    } };
    function fu(e) {
      class r {
        constructor(n) {
          __publicField(this, "_originalClient", this);
          __publicField(this, "_runtimeDataModel");
          __publicField(this, "_requestHandler");
          __publicField(this, "_connectionPromise");
          __publicField(this, "_disconnectionPromise");
          __publicField(this, "_engineConfig");
          __publicField(this, "_accelerateEngineConfig");
          __publicField(this, "_clientVersion");
          __publicField(this, "_errorFormat");
          __publicField(this, "_tracingHelper");
          __publicField(this, "_previewFeatures");
          __publicField(this, "_activeProvider");
          __publicField(this, "_globalOmit");
          __publicField(this, "_extensions");
          __publicField(this, "_engine");
          __publicField(this, "_appliedParent");
          __publicField(this, "_createPrismaPromise", Ro());
          __publicField(this, "$metrics", new Lr(this));
          __publicField(this, "$extends", Wa);
          e = n?.__internal?.configOverride?.(e) ?? e, sl(e), n && au(n, e);
          let i = new du.EventEmitter().on("error", () => {
          });
          this._extensions = Nr.empty(), this._previewFeatures = $l(e), this._clientVersion = e.clientVersion ?? ru, this._activeProvider = e.activeProvider, this._globalOmit = n?.omit, this._tracingHelper = Hl();
          let o = e.relativeEnvPaths && { rootEnvPath: e.relativeEnvPaths.rootEnvPath && ri.default.resolve(e.dirname, e.relativeEnvPaths.rootEnvPath), schemaEnvPath: e.relativeEnvPaths.schemaEnvPath && ri.default.resolve(e.dirname, e.relativeEnvPaths.schemaEnvPath) }, s;
          if (n?.adapter) {
            s = n.adapter;
            let l = e.activeProvider === "postgresql" || e.activeProvider === "cockroachdb" ? "postgres" : e.activeProvider;
            if (s.provider !== l) throw new P(`The Driver Adapter \`${s.adapterName}\`, based on \`${s.provider}\`, is not compatible with the provider \`${l}\` specified in the Prisma schema.`, this._clientVersion);
            if (n.datasources || n.datasourceUrl !== void 0) throw new P("Custom datasource configuration is not compatible with Prisma Driver Adapters. Please define the database connection string directly in the Driver Adapter configuration.", this._clientVersion);
          }
          let a = !s && o && st(o, { conflictCheck: "none" }) || e.injectableEdgeEnv?.();
          try {
            let l = n ?? {}, u = l.__internal ?? {}, c = u.debug === true;
            c && N.enable("prisma:client");
            let p = ri.default.resolve(e.dirname, e.relativePath);
            mu.default.existsSync(p) || (p = e.dirname), rr("dirname", e.dirname), rr("relativePath", e.relativePath), rr("cwd", p);
            let d = u.engine || {};
            if (l.errorFormat ? this._errorFormat = l.errorFormat : process.env.NODE_ENV === "production" ? this._errorFormat = "minimal" : process.env.NO_COLOR ? this._errorFormat = "colorless" : this._errorFormat = "colorless", this._runtimeDataModel = e.runtimeDataModel, this._engineConfig = { cwd: p, dirname: e.dirname, enableDebugLogs: c, allowTriggerPanic: d.allowTriggerPanic, prismaPath: d.binaryPath ?? void 0, engineEndpoint: d.endpoint, generator: e.generator, showColors: this._errorFormat === "pretty", logLevel: l.log && zl(l.log), logQueries: l.log && !!(typeof l.log == "string" ? l.log === "query" : l.log.find((f) => typeof f == "string" ? f === "query" : f.level === "query")), env: a?.parsed ?? {}, flags: [], engineWasm: e.engineWasm, compilerWasm: e.compilerWasm, clientVersion: e.clientVersion, engineVersion: e.engineVersion, previewFeatures: this._previewFeatures, activeProvider: e.activeProvider, inlineSchema: e.inlineSchema, overrideDatasources: al(l, e.datasourceNames), inlineDatasources: e.inlineDatasources, inlineSchemaHash: e.inlineSchemaHash, tracingHelper: this._tracingHelper, transactionOptions: { maxWait: l.transactionOptions?.maxWait ?? 2e3, timeout: l.transactionOptions?.timeout ?? 5e3, isolationLevel: l.transactionOptions?.isolationLevel }, logEmitter: i, isBundled: e.isBundled, adapter: s }, this._accelerateEngineConfig = { ...this._engineConfig, accelerateUtils: { resolveDatasourceUrl: jr, getBatchRequestPayload: Mr, prismaGraphQLToJSError: $r, PrismaClientUnknownRequestError: V, PrismaClientInitializationError: P, PrismaClientKnownRequestError: z, debug: N("prisma:client:accelerateEngine"), engineVersion: cu.version, clientVersion: e.clientVersion } }, rr("clientVersion", e.clientVersion), this._engine = Ml(e, this._engineConfig), this._requestHandler = new ei(this, i), l.log) for (let f of l.log) {
              let h = typeof f == "string" ? f : f.emit === "stdout" ? f.level : null;
              h && this.$on(h, (g) => {
                nt.log(`${nt.tags[h] ?? ""}`, g.message || g.query);
              });
            }
          } catch (l) {
            throw l.clientVersion = this._clientVersion, l;
          }
          return this._appliedParent = Pt(this);
        }
        get [Symbol.toStringTag]() {
          return "PrismaClient";
        }
        $on(n, i) {
          return n === "beforeExit" ? this._engine.onBeforeExit(i) : n && this._engineConfig.logEmitter.on(n, i), this;
        }
        $connect() {
          try {
            return this._engine.start();
          } catch (n) {
            throw n.clientVersion = this._clientVersion, n;
          }
        }
        async $disconnect() {
          try {
            await this._engine.stop();
          } catch (n) {
            throw n.clientVersion = this._clientVersion, n;
          } finally {
            Uo();
          }
        }
        $executeRawInternal(n, i, o, s) {
          let a = this._activeProvider;
          return this._request({ action: "executeRaw", args: o, transaction: n, clientMethod: i, argsMapper: So({ clientMethod: i, activeProvider: a }), callsite: Ze(this._errorFormat), dataPath: [], middlewareArgsMapper: s });
        }
        $executeRaw(n, ...i) {
          return this._createPrismaPromise((o) => {
            if (n.raw !== void 0 || n.sql !== void 0) {
              let [s, a] = uu(n, i);
              return To(this._activeProvider, s.text, s.values, Array.isArray(n) ? "prisma.$executeRaw`<SQL>`" : "prisma.$executeRaw(sql`<SQL>`)"), this.$executeRawInternal(o, "$executeRaw", s, a);
            }
            throw new Z("`$executeRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw\n", { clientVersion: this._clientVersion });
          });
        }
        $executeRawUnsafe(n, ...i) {
          return this._createPrismaPromise((o) => (To(this._activeProvider, n, i, "prisma.$executeRawUnsafe(<SQL>, [...values])"), this.$executeRawInternal(o, "$executeRawUnsafe", [n, ...i])));
        }
        $runCommandRaw(n) {
          if (e.activeProvider !== "mongodb") throw new Z(`The ${e.activeProvider} provider does not support $runCommandRaw. Use the mongodb provider.`, { clientVersion: this._clientVersion });
          return this._createPrismaPromise((i) => this._request({ args: n, clientMethod: "$runCommandRaw", dataPath: [], action: "runCommandRaw", argsMapper: ql, callsite: Ze(this._errorFormat), transaction: i }));
        }
        async $queryRawInternal(n, i, o, s) {
          let a = this._activeProvider;
          return this._request({ action: "queryRaw", args: o, transaction: n, clientMethod: i, argsMapper: So({ clientMethod: i, activeProvider: a }), callsite: Ze(this._errorFormat), dataPath: [], middlewareArgsMapper: s });
        }
        $queryRaw(n, ...i) {
          return this._createPrismaPromise((o) => {
            if (n.raw !== void 0 || n.sql !== void 0) return this.$queryRawInternal(o, "$queryRaw", ...uu(n, i));
            throw new Z("`$queryRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw\n", { clientVersion: this._clientVersion });
          });
        }
        $queryRawTyped(n) {
          return this._createPrismaPromise((i) => {
            if (!this._hasPreviewFlag("typedSql")) throw new Z("`typedSql` preview feature must be enabled in order to access $queryRawTyped API", { clientVersion: this._clientVersion });
            return this.$queryRawInternal(i, "$queryRawTyped", n);
          });
        }
        $queryRawUnsafe(n, ...i) {
          return this._createPrismaPromise((o) => this.$queryRawInternal(o, "$queryRawUnsafe", [n, ...i]));
        }
        _transactionWithArray({ promises: n, options: i }) {
          let o = $f.nextId(), s = Yl(n.length), a = n.map((l, u) => {
            if (l?.[Symbol.toStringTag] !== "PrismaPromise") throw new Error("All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.");
            let c = i?.isolationLevel ?? this._engineConfig.transactionOptions.isolationLevel, p = { kind: "batch", id: o, index: u, isolationLevel: c, lock: s };
            return l.requestTransaction?.(p) ?? l;
          });
          return lu(a);
        }
        async _transactionWithCallback({ callback: n, options: i }) {
          let o = { traceparent: this._tracingHelper.getTraceParent() }, s = { maxWait: i?.maxWait ?? this._engineConfig.transactionOptions.maxWait, timeout: i?.timeout ?? this._engineConfig.transactionOptions.timeout, isolationLevel: i?.isolationLevel ?? this._engineConfig.transactionOptions.isolationLevel }, a = await this._engine.transaction("start", o, s), l;
          try {
            let u = { kind: "itx", ...a };
            l = await n(this._createItxClient(u)), await this._engine.transaction("commit", o, a);
          } catch (u) {
            throw await this._engine.transaction("rollback", o, a).catch(() => {
            }), u;
          }
          return l;
        }
        _createItxClient(n) {
          return he(Pt(he(Qa(this), [re("_appliedParent", () => this._appliedParent._createItxClient(n)), re("_createPrismaPromise", () => Ro(n)), re(Mf, () => n.id)])), [Fr(Ya)]);
        }
        $transaction(n, i) {
          let o;
          typeof n == "function" ? this._engineConfig.adapter?.adapterName === "@prisma/adapter-d1" ? o = () => {
            throw new Error("Cloudflare D1 does not support interactive transactions. We recommend you to refactor your queries with that limitation in mind, and use batch transactions with `prisma.$transactions([])` where applicable.");
          } : o = () => this._transactionWithCallback({ callback: n, options: i }) : o = () => this._transactionWithArray({ promises: n, options: i });
          let s = { name: "transaction", attributes: { method: "$transaction" } };
          return this._tracingHelper.runInChildSpan(s, o);
        }
        _request(n) {
          n.otelParentCtx = this._tracingHelper.getActiveContext();
          let i = n.middlewareArgsMapper ?? Ff, o = { args: i.requestArgsToMiddlewareArgs(n.args), dataPath: n.dataPath, runInTransaction: !!n.transaction, action: n.action, model: n.model }, s = { operation: { name: "operation", attributes: { method: o.action, model: o.model, name: o.model ? `${o.model}.${o.action}` : o.action } } }, a = async (l) => {
            let { runInTransaction: u, args: c, ...p } = l, d = { ...n, ...p };
            c && (d.args = i.middlewareArgsToRequestArgs(c)), n.transaction !== void 0 && u === false && delete d.transaction;
            let f = await el(this, d);
            return d.model ? Ha({ result: f, modelName: d.model, args: d.args, extensions: this._extensions, runtimeDataModel: this._runtimeDataModel, globalOmit: this._globalOmit }) : f;
          };
          return this._tracingHelper.runInChildSpan(s.operation, () => new pu.AsyncResource("prisma-client-request").runInAsyncScope(() => a(o)));
        }
        async _executeRequest({ args: n, clientMethod: i, dataPath: o, callsite: s, action: a, model: l, argsMapper: u, transaction: c, unpacker: p, otelParentCtx: d, customDataProxyFetch: f }) {
          try {
            n = u ? u(n) : n;
            let h = { name: "serialize" }, g = this._tracingHelper.runInChildSpan(h, () => $n({ modelName: l, runtimeDataModel: this._runtimeDataModel, action: a, args: n, clientMethod: i, callsite: s, extensions: this._extensions, errorFormat: this._errorFormat, clientVersion: this._clientVersion, previewFeatures: this._previewFeatures, globalOmit: this._globalOmit }));
            return N.enabled("prisma:client") && (rr("Prisma Client call:"), rr(`prisma.${i}(${Na(n)})`), rr("Generated request:"), rr(JSON.stringify(g, null, 2) + `
`)), c?.kind === "batch" && await c.lock, this._requestHandler.request({ protocolQuery: g, modelName: l, action: a, clientMethod: i, dataPath: o, callsite: s, args: n, extensions: this._extensions, transaction: c, unpacker: p, otelParentCtx: d, otelChildCtx: this._tracingHelper.getActiveContext(), globalOmit: this._globalOmit, customDataProxyFetch: f });
          } catch (h) {
            throw h.clientVersion = this._clientVersion, h;
          }
        }
        _hasPreviewFlag(n) {
          return !!this._engineConfig.previewFeatures?.includes(n);
        }
        $applyPendingMigrations() {
          return this._engine.applyPendingMigrations();
        }
      }
      return r;
    }
    function uu(e, r) {
      return qf(e) ? [new ie(e, r), Wl] : [e, Jl];
    }
    function qf(e) {
      return Array.isArray(e) && Array.isArray(e.raw);
    }
    var Vf = /* @__PURE__ */ new Set(["toJSON", "$$typeof", "asymmetricMatch", Symbol.iterator, Symbol.toStringTag, Symbol.isConcatSpreadable, Symbol.toPrimitive]);
    function gu(e) {
      return new Proxy(e, { get(r, t) {
        if (t in r) return r[t];
        if (!Vf.has(t)) throw new TypeError(`Invalid enum value: ${String(t)}`);
      } });
    }
    function hu(e) {
      st(e, { conflictCheck: "warn" });
    }
  }
});

// src/generated/prisma/index.js
var require_prisma = __commonJS({
  "src/generated/prisma/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var {
      PrismaClientKnownRequestError: PrismaClientKnownRequestError2,
      PrismaClientUnknownRequestError: PrismaClientUnknownRequestError2,
      PrismaClientRustPanicError: PrismaClientRustPanicError2,
      PrismaClientInitializationError: PrismaClientInitializationError2,
      PrismaClientValidationError: PrismaClientValidationError2,
      getPrismaClient: getPrismaClient2,
      sqltag: sqltag2,
      empty: empty2,
      join: join2,
      raw: raw2,
      skip: skip2,
      Decimal: Decimal3,
      Debug: Debug2,
      objectEnumValues: objectEnumValues2,
      makeStrictEnum: makeStrictEnum2,
      Extensions: Extensions2,
      warnOnce: warnOnce2,
      defineDmmfProperty: defineDmmfProperty2,
      Public: Public2,
      getRuntime: getRuntime2,
      createParam: createParam2
    } = require_library();
    var Prisma = {};
    exports2.Prisma = Prisma;
    exports2.$Enums = {};
    Prisma.prismaVersion = {
      client: "6.16.2",
      engine: "1c57fdcd7e44b29b9313256c76699e91c3ac3c43"
    };
    Prisma.PrismaClientKnownRequestError = PrismaClientKnownRequestError2;
    Prisma.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError2;
    Prisma.PrismaClientRustPanicError = PrismaClientRustPanicError2;
    Prisma.PrismaClientInitializationError = PrismaClientInitializationError2;
    Prisma.PrismaClientValidationError = PrismaClientValidationError2;
    Prisma.Decimal = Decimal3;
    Prisma.sql = sqltag2;
    Prisma.empty = empty2;
    Prisma.join = join2;
    Prisma.raw = raw2;
    Prisma.validator = Public2.validator;
    Prisma.getExtensionContext = Extensions2.getExtensionContext;
    Prisma.defineExtension = Extensions2.defineExtension;
    Prisma.DbNull = objectEnumValues2.instances.DbNull;
    Prisma.JsonNull = objectEnumValues2.instances.JsonNull;
    Prisma.AnyNull = objectEnumValues2.instances.AnyNull;
    Prisma.NullTypes = {
      DbNull: objectEnumValues2.classes.DbNull,
      JsonNull: objectEnumValues2.classes.JsonNull,
      AnyNull: objectEnumValues2.classes.AnyNull
    };
    var path3 = require("path");
    exports2.Prisma.TransactionIsolationLevel = makeStrictEnum2({
      ReadUncommitted: "ReadUncommitted",
      ReadCommitted: "ReadCommitted",
      RepeatableRead: "RepeatableRead",
      Serializable: "Serializable"
    });
    exports2.Prisma.UserScalarFieldEnum = {
      id: "id",
      email: "email",
      password: "password",
      name: "name",
      phone: "phone",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      status: "status",
      resetPasswordToken: "resetPasswordToken",
      resetPasswordCode: "resetPasswordCode",
      resetPasswordExpires: "resetPasswordExpires",
      emailVerified: "emailVerified",
      emailVerificationToken: "emailVerificationToken",
      emailVerificationCode: "emailVerificationCode",
      emailVerificationCodeExpires: "emailVerificationCodeExpires",
      lastLoginAt: "lastLoginAt",
      roles: "roles",
      theme: "theme",
      language: "language",
      currency: "currency",
      timezone: "timezone",
      dateFormat: "dateFormat",
      timeFormat: "timeFormat",
      dashboard: "dashboard"
    };
    exports2.Prisma.ProductScalarFieldEnum = {
      id: "id",
      name: "name",
      description: "description",
      unitOfMeasure: "unitOfMeasure",
      referencePrice: "referencePrice",
      supplierId: "supplierId",
      storeId: "storeId",
      stockMin: "stockMin",
      stockMax: "stockMax",
      alertPercentage: "alertPercentage",
      status: "status",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports2.Prisma.CategoryScalarFieldEnum = {
      id: "id",
      name: "name",
      description: "description",
      code: "code",
      status: "status",
      color: "color",
      icon: "icon",
      parentId: "parentId",
      storeId: "storeId",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports2.Prisma.ProductCategoryScalarFieldEnum = {
      id: "id",
      productId: "productId",
      categoryId: "categoryId",
      createdAt: "createdAt"
    };
    exports2.Prisma.SupplierScalarFieldEnum = {
      id: "id",
      corporateName: "corporateName",
      cnpj: "cnpj",
      tradeName: "tradeName",
      status: "status",
      cep: "cep",
      city: "city",
      state: "state",
      address: "address",
      storeId: "storeId",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports2.Prisma.SupplierResponsibleScalarFieldEnum = {
      id: "id",
      name: "name",
      phone: "phone",
      email: "email",
      cpf: "cpf",
      status: "status",
      supplierId: "supplierId"
    };
    exports2.Prisma.StoreScalarFieldEnum = {
      id: "id",
      ownerId: "ownerId",
      name: "name",
      cnpj: "cnpj",
      email: "email",
      phone: "phone",
      status: "status",
      cep: "cep",
      city: "city",
      state: "state",
      address: "address",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports2.Prisma.StoreUserScalarFieldEnum = {
      id: "id",
      storeId: "storeId",
      userId: "userId",
      role: "role"
    };
    exports2.Prisma.AuditLogScalarFieldEnum = {
      id: "id",
      entity: "entity",
      entityId: "entityId",
      action: "action",
      userId: "userId",
      before: "before",
      after: "after",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports2.Prisma.MovementScalarFieldEnum = {
      id: "id",
      type: "type",
      quantity: "quantity",
      storeId: "storeId",
      productId: "productId",
      supplierId: "supplierId",
      batch: "batch",
      expiration: "expiration",
      price: "price",
      note: "note",
      balanceAfter: "balanceAfter",
      verified: "verified",
      verifiedAt: "verifiedAt",
      verifiedBy: "verifiedBy",
      verificationNote: "verificationNote",
      cancelled: "cancelled",
      cancelledAt: "cancelledAt",
      cancelledBy: "cancelledBy",
      cancellationReason: "cancellationReason",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      userId: "userId"
    };
    exports2.Prisma.UserPermissionScalarFieldEnum = {
      id: "id",
      userId: "userId",
      action: "action",
      resource: "resource",
      storeId: "storeId",
      grant: "grant",
      conditions: "conditions",
      expiresAt: "expiresAt",
      reason: "reason",
      createdAt: "createdAt",
      createdBy: "createdBy"
    };
    exports2.Prisma.StorePermissionScalarFieldEnum = {
      id: "id",
      userId: "userId",
      storeId: "storeId",
      storeRole: "storeRole",
      permissions: "permissions",
      conditions: "conditions",
      expiresAt: "expiresAt",
      createdAt: "createdAt",
      createdBy: "createdBy"
    };
    exports2.Prisma.PermissionTemplateScalarFieldEnum = {
      id: "id",
      name: "name",
      description: "description",
      permissions: "permissions",
      conditions: "conditions",
      isDefault: "isDefault",
      createdAt: "createdAt",
      createdBy: "createdBy"
    };
    exports2.Prisma.PermissionAuditLogScalarFieldEnum = {
      id: "id",
      permissionId: "permissionId",
      permissionType: "permissionType",
      action: "action",
      userId: "userId",
      changes: "changes",
      reason: "reason",
      createdAt: "createdAt",
      createdBy: "createdBy"
    };
    exports2.Prisma.NotificationScalarFieldEnum = {
      id: "id",
      userId: "userId",
      title: "title",
      message: "message",
      type: "type",
      priority: "priority",
      isRead: "isRead",
      readAt: "readAt",
      data: "data",
      actionUrl: "actionUrl",
      expiresAt: "expiresAt",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports2.Prisma.ChatSessionScalarFieldEnum = {
      id: "id",
      userId: "userId",
      storeId: "storeId",
      title: "title",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports2.Prisma.ChatMessageScalarFieldEnum = {
      id: "id",
      content: "content",
      isFromUser: "isFromUser",
      sessionId: "sessionId",
      context: "context",
      options: "options",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports2.Prisma.RoadmapScalarFieldEnum = {
      id: "id",
      storeId: "storeId",
      userId: "userId",
      title: "title",
      description: "description",
      status: "status",
      startDate: "startDate",
      endDate: "endDate",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports2.Prisma.MilestoneScalarFieldEnum = {
      id: "id",
      roadmapId: "roadmapId",
      title: "title",
      description: "description",
      status: "status",
      progress: "progress",
      order: "order",
      startDate: "startDate",
      endDate: "endDate",
      completedAt: "completedAt",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports2.Prisma.MediaScalarFieldEnum = {
      id: "id",
      url: "url",
      name: "name",
      type: "type",
      size: "size",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports2.Prisma.ProductMediaScalarFieldEnum = {
      id: "id",
      productId: "productId",
      mediaId: "mediaId",
      isPrimary: "isPrimary"
    };
    exports2.Prisma.SupplierMediaScalarFieldEnum = {
      id: "id",
      supplierId: "supplierId",
      mediaId: "mediaId"
    };
    exports2.Prisma.UserMediaScalarFieldEnum = {
      id: "id",
      userId: "userId",
      mediaId: "mediaId"
    };
    exports2.Prisma.StoreMediaScalarFieldEnum = {
      id: "id",
      storeId: "storeId",
      mediaId: "mediaId"
    };
    exports2.Prisma.QuoteScalarFieldEnum = {
      id: "id",
      userId: "userId",
      title: "title",
      description: "description",
      publicId: "publicId",
      authCode: "authCode",
      status: "status",
      total: "total",
      subtotal: "subtotal",
      discount: "discount",
      interest: "interest",
      paymentType: "paymentType",
      paymentTerms: "paymentTerms",
      paymentDueDays: "paymentDueDays",
      expiresAt: "expiresAt",
      observations: "observations",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports2.Prisma.QuoteItemScalarFieldEnum = {
      id: "id",
      quoteId: "quoteId",
      productId: "productId",
      quantity: "quantity",
      unitPrice: "unitPrice",
      subtotal: "subtotal",
      discount: "discount",
      note: "note"
    };
    exports2.Prisma.QuoteInstallmentScalarFieldEnum = {
      id: "id",
      quoteId: "quoteId",
      number: "number",
      dueDate: "dueDate",
      amount: "amount",
      interest: "interest"
    };
    exports2.Prisma.CustomerScalarFieldEnum = {
      id: "id",
      userId: "userId",
      planId: "planId",
      status: "status",
      renewalDate: "renewalDate",
      trialEndsAt: "trialEndsAt",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports2.Prisma.PlanScalarFieldEnum = {
      id: "id",
      name: "name",
      description: "description",
      price: "price",
      interval: "interval",
      features: "features"
    };
    exports2.Prisma.InvoiceScalarFieldEnum = {
      id: "id",
      customerId: "customerId",
      amount: "amount",
      status: "status",
      gatewayPaymentId: "gatewayPaymentId",
      paymentDate: "paymentDate",
      createdAt: "createdAt"
    };
    exports2.Prisma.CrmStageScalarFieldEnum = {
      id: "id",
      storeId: "storeId",
      name: "name",
      color: "color",
      order: "order",
      createdAt: "createdAt"
    };
    exports2.Prisma.CrmClientScalarFieldEnum = {
      id: "id",
      storeId: "storeId",
      stageId: "stageId",
      name: "name",
      email: "email",
      phone: "phone",
      cpfCnpj: "cpfCnpj",
      notes: "notes",
      company: "company",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports2.Prisma.UserPreferencesScalarFieldEnum = {
      id: "id",
      userId: "userId",
      theme: "theme",
      primaryColor: "primaryColor",
      sidebarCollapsed: "sidebarCollapsed",
      compactMode: "compactMode",
      language: "language",
      currency: "currency",
      timezone: "timezone",
      dateFormat: "dateFormat",
      timeFormat: "timeFormat",
      numberFormat: "numberFormat",
      emailNotifications: "emailNotifications",
      pushNotifications: "pushNotifications",
      smsNotifications: "smsNotifications",
      notificationTypes: "notificationTypes",
      dashboardLayout: "dashboardLayout",
      defaultPage: "defaultPage",
      itemsPerPage: "itemsPerPage",
      defaultStoreId: "defaultStoreId",
      autoRefresh: "autoRefresh",
      refreshInterval: "refreshInterval",
      customSettings: "customSettings",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports2.Prisma.SortOrder = {
      asc: "asc",
      desc: "desc"
    };
    exports2.Prisma.NullableJsonNullValueInput = {
      DbNull: Prisma.DbNull,
      JsonNull: Prisma.JsonNull
    };
    exports2.Prisma.JsonNullValueInput = {
      JsonNull: Prisma.JsonNull
    };
    exports2.Prisma.QueryMode = {
      default: "default",
      insensitive: "insensitive"
    };
    exports2.Prisma.JsonNullValueFilter = {
      DbNull: Prisma.DbNull,
      JsonNull: Prisma.JsonNull,
      AnyNull: Prisma.AnyNull
    };
    exports2.Prisma.NullsOrder = {
      first: "first",
      last: "last"
    };
    exports2.MovementType = exports2.$Enums.MovementType = {
      ENTRADA: "ENTRADA",
      SAIDA: "SAIDA",
      PERDA: "PERDA"
    };
    exports2.LogAction = exports2.$Enums.LogAction = {
      CREATE: "CREATE",
      UPDATE: "UPDATE",
      DELETE: "DELETE"
    };
    exports2.Entity = exports2.$Enums.Entity = {
      PRODUCT: "PRODUCT",
      STORE: "STORE",
      USER: "USER"
    };
    exports2.StoreRole = exports2.$Enums.StoreRole = {
      OWNER: "OWNER",
      ADMIN: "ADMIN",
      MANAGER: "MANAGER",
      STAFF: "STAFF"
    };
    exports2.UnitOfMeasure = exports2.$Enums.UnitOfMeasure = {
      UNIDADE: "UNIDADE",
      KG: "KG",
      L: "L",
      ML: "ML",
      M: "M",
      CM: "CM",
      MM: "MM",
      UN: "UN",
      DZ: "DZ",
      CX: "CX",
      PCT: "PCT",
      KIT: "KIT",
      PAR: "PAR",
      H: "H",
      D: "D"
    };
    exports2.NotificationType = exports2.$Enums.NotificationType = {
      INFO: "INFO",
      SUCCESS: "SUCCESS",
      WARNING: "WARNING",
      ERROR: "ERROR",
      STOCK_ALERT: "STOCK_ALERT",
      MOVEMENT: "MOVEMENT",
      PERMISSION: "PERMISSION",
      SYSTEM: "SYSTEM"
    };
    exports2.NotificationPriority = exports2.$Enums.NotificationPriority = {
      LOW: "LOW",
      MEDIUM: "MEDIUM",
      HIGH: "HIGH",
      URGENT: "URGENT"
    };
    exports2.RoadmapStatus = exports2.$Enums.RoadmapStatus = {
      ACTIVE: "ACTIVE",
      COMPLETED: "COMPLETED",
      ARCHIVED: "ARCHIVED"
    };
    exports2.MilestoneStatus = exports2.$Enums.MilestoneStatus = {
      PENDING: "PENDING",
      IN_PROGRESS: "IN_PROGRESS",
      COMPLETED: "COMPLETED",
      BLOCKED: "BLOCKED"
    };
    exports2.PaymentType = exports2.$Enums.PaymentType = {
      UNDEFINED: "UNDEFINED",
      PIX: "PIX",
      BOLETO: "BOLETO",
      CREDIT_CARD: "CREDIT_CARD",
      CASH: "CASH",
      TRANSFER: "TRANSFER"
    };
    exports2.QuoteStatus = exports2.$Enums.QuoteStatus = {
      DRAFT: "DRAFT",
      PUBLISHED: "PUBLISHED",
      SENT: "SENT",
      VIEWED: "VIEWED",
      APPROVED: "APPROVED",
      REJECTED: "REJECTED",
      EXPIRED: "EXPIRED",
      CONVERTED: "CONVERTED",
      CANCELED: "CANCELED"
    };
    exports2.CustomerStatus = exports2.$Enums.CustomerStatus = {
      ACTIVE: "ACTIVE",
      INACTIVE: "INACTIVE",
      CANCELLED: "CANCELLED",
      TRIAL: "TRIAL"
    };
    exports2.PlanInterval = exports2.$Enums.PlanInterval = {
      MONTHLY: "MONTHLY",
      YEARLY: "YEARLY"
    };
    exports2.InvoiceStatus = exports2.$Enums.InvoiceStatus = {
      PENDING: "PENDING",
      PAID: "PAID",
      FAILED: "FAILED"
    };
    exports2.Prisma.ModelName = {
      User: "User",
      Product: "Product",
      Category: "Category",
      ProductCategory: "ProductCategory",
      Supplier: "Supplier",
      SupplierResponsible: "SupplierResponsible",
      Store: "Store",
      StoreUser: "StoreUser",
      AuditLog: "AuditLog",
      Movement: "Movement",
      UserPermission: "UserPermission",
      StorePermission: "StorePermission",
      PermissionTemplate: "PermissionTemplate",
      PermissionAuditLog: "PermissionAuditLog",
      Notification: "Notification",
      ChatSession: "ChatSession",
      ChatMessage: "ChatMessage",
      Roadmap: "Roadmap",
      Milestone: "Milestone",
      Media: "Media",
      ProductMedia: "ProductMedia",
      SupplierMedia: "SupplierMedia",
      UserMedia: "UserMedia",
      StoreMedia: "StoreMedia",
      Quote: "Quote",
      QuoteItem: "QuoteItem",
      QuoteInstallment: "QuoteInstallment",
      Customer: "Customer",
      Plan: "Plan",
      Invoice: "Invoice",
      CrmStage: "CrmStage",
      CrmClient: "CrmClient",
      UserPreferences: "UserPreferences"
    };
    var config = {
      "generator": {
        "name": "client",
        "provider": {
          "fromEnvVar": null,
          "value": "prisma-client-js"
        },
        "output": {
          "value": "C:\\Node\\fastify_20stock\\src\\generated\\prisma",
          "fromEnvVar": null
        },
        "config": {
          "engineType": "library"
        },
        "binaryTargets": [
          {
            "fromEnvVar": null,
            "value": "windows",
            "native": true
          }
        ],
        "previewFeatures": [],
        "sourceFilePath": "C:\\Node\\fastify_20stock\\prisma\\schema.prisma",
        "isCustomOutput": true
      },
      "relativeEnvPaths": {
        "rootEnvPath": null,
        "schemaEnvPath": "../../../.env"
      },
      "relativePath": "../../../prisma",
      "clientVersion": "6.16.2",
      "engineVersion": "1c57fdcd7e44b29b9313256c76699e91c3ac3c43",
      "datasourceNames": [
        "db"
      ],
      "activeProvider": "postgresql",
      "inlineDatasources": {
        "db": {
          "url": {
            "fromEnvVar": "DATABASE_URL",
            "value": null
          }
        }
      },
      "inlineSchema": `generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                           String    @id @default(cuid())
  email                        String    @unique
  password                     String
  name                         String?
  phone                        String?
  createdAt                    DateTime  @default(now())
  updatedAt                    DateTime  @updatedAt
  status                       Boolean   @default(true)
  resetPasswordToken           String?
  resetPasswordCode            String?
  resetPasswordExpires         DateTime?
  emailVerified                Boolean   @default(false)
  emailVerificationToken       String?
  emailVerificationCode        String?
  emailVerificationCodeExpires DateTime?
  lastLoginAt                  DateTime?
  roles                        String[]  @default(["user"])

  // User Preferences/Configurations
  theme      String @default("light") // light, dark, auto
  language   String @default("pt-BR") // pt-BR, en-US, es-ES
  currency   String @default("BRL") // BRL, USD, EUR
  timezone   String @default("America/Sao_Paulo")
  dateFormat String @default("DD/MM/YYYY") // DD/MM/YYYY, MM/DD/YYYY, YYYY-MM-DD
  timeFormat String @default("24h") // 12h, 24h
  dashboard  Json? // Configura\xE7\xF5es do dashboard (widgets, layout, etc.)

  auditLogs   AuditLog[]
  movements   Movement[]
  ownedStores Store[]     @relation("StoreOwner")
  stores      StoreUser[]

  // Granular Permissions Relations
  userPermissions            UserPermission[]
  storePermissions           StorePermission[]
  createdUserPermissions     UserPermission[]     @relation("UserPermissionCreator")
  createdStorePermissions    StorePermission[]    @relation("StorePermissionCreator")
  createdPermissionTemplates PermissionTemplate[] @relation("PermissionTemplateCreator")
  createdPermissionAudits    PermissionAuditLog[] @relation("PermissionAuditCreator")

  // Notifications
  notifications Notification[]

  // Roadmap
  roadmaps Roadmap[]

  // Media
  media UserMedia[]

  // Quotes
  quotes Quote[]

  // Customers
  customers Customer[]

  // User Preferences
  preferences UserPreferences?

  @@map("users")
}

model Product {
  id              String            @id @default(cuid())
  name            String
  description     String?
  unitOfMeasure   UnitOfMeasure
  referencePrice  Decimal           @db.Decimal(10, 2)
  supplierId      String?
  storeId         String
  stockMin        Int
  stockMax        Int
  alertPercentage Int               @db.SmallInt
  status          Boolean           @default(true)
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  store           Store             @relation(fields: [storeId], references: [id])
  supplier        Supplier?         @relation(fields: [supplierId], references: [id])
  movements       Movement[]
  categories      ProductCategory[]
  media           ProductMedia[]

  // Quotes
  quotes QuoteItem[]
}

model Category {
  id          String            @id @default(cuid())
  name        String
  description String?
  code        String?
  status      Boolean           @default(true)
  color       String?
  icon        String?
  parentId    String?
  storeId     String?
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  store       Store?            @relation(fields: [storeId], references: [id])
  parent      Category?         @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children    Category[]        @relation("CategoryHierarchy")
  products    ProductCategory[]

  @@unique([code, storeId])
}

model ProductCategory {
  id         String   @id @default(cuid())
  productId  String
  categoryId String
  createdAt  DateTime @default(now())

  product  Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  category Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@unique([productId, categoryId])
  @@map("ProductCategory")
}

model Supplier {
  id            String                @id @default(cuid())
  corporateName String
  cnpj          String
  tradeName     String?
  status        Boolean               @default(true)
  cep           String?
  city          String?
  state         String?
  address       String?
  storeId       String?
  createdAt     DateTime              @default(now())
  updatedAt     DateTime              @updatedAt
  store         Store?                @relation(fields: [storeId], references: [id])
  products      Product[]
  movements     Movement[]
  responsibles  SupplierResponsible[]
  media         SupplierMedia[]

  @@unique([cnpj, storeId])
}

model SupplierResponsible {
  id         String   @id @default(cuid())
  name       String
  phone      String?
  email      String?
  cpf        String?
  status     Boolean  @default(true)
  supplierId String
  supplier   Supplier @relation(fields: [supplierId], references: [id])
}

model Store {
  id         String      @id @default(cuid())
  ownerId    String
  name       String
  cnpj       String      @unique
  email      String?
  phone      String?
  status     Boolean     @default(true)
  cep        String?
  city       String?
  state      String?
  address    String?
  createdAt  DateTime    @default(now())
  updatedAt  DateTime    @updatedAt
  products   Product[]
  categories Category[]
  suppliers  Supplier[]
  movements  Movement[]
  owner      User        @relation("StoreOwner", fields: [ownerId], references: [id])
  users      StoreUser[]

  // Granular Permissions Relations
  userPermissions  UserPermission[]
  storePermissions StorePermission[]

  // Roadmap
  roadmaps Roadmap[]

  // Media
  media StoreMedia[]

  // CRM
  crmStages  CrmStage[]
  crmClients CrmClient[]
}

model StoreUser {
  id      String    @id @default(cuid())
  storeId String
  userId  String
  role    StoreRole @default(STAFF)
  store   Store     @relation(fields: [storeId], references: [id])
  user    User      @relation(fields: [userId], references: [id])

  @@unique([storeId, userId])
}

model AuditLog {
  id        String    @id @default(cuid())
  entity    Entity
  entityId  String
  action    LogAction
  userId    String?
  before    Json?
  after     Json?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  user      User?     @relation(fields: [userId], references: [id])
}

model Movement {
  id           String       @id @default(cuid())
  type         MovementType
  quantity     Int
  storeId      String
  productId    String
  supplierId   String? // fornecedor opcional, pode variar
  batch        String? // lote
  expiration   DateTime? // validade
  price        Decimal?     @db.Decimal(10, 2) // pre\xE7o da unidade na movimenta\xE7\xE3o
  note         String? // observa\xE7\xF5es
  balanceAfter Int? // estoque ap\xF3s a movimenta\xE7\xE3o

  // Campos de verifica\xE7\xE3o
  verified         Boolean?  @default(false)
  verifiedAt       DateTime?
  verifiedBy       String?
  verificationNote String?

  // Campos de cancelamento
  cancelled          Boolean   @default(false)
  cancelledAt        DateTime?
  cancelledBy        String?
  cancellationReason String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relacionamentos
  store    Store     @relation(fields: [storeId], references: [id])
  product  Product   @relation(fields: [productId], references: [id])
  supplier Supplier? @relation(fields: [supplierId], references: [id])
  userId   String? // quem registrou
  user     User?     @relation(fields: [userId], references: [id])
}

enum MovementType {
  ENTRADA
  SAIDA
  PERDA
}

enum LogAction {
  CREATE
  UPDATE
  DELETE
}

enum Entity {
  PRODUCT
  STORE
  USER
}

enum StoreRole {
  OWNER
  ADMIN
  MANAGER
  STAFF
}

enum UnitOfMeasure {
  UNIDADE
  KG
  L
  ML
  M
  CM
  MM
  UN
  DZ
  CX
  PCT
  KIT
  PAR
  H
  D
}

// ================================
// GRANULAR PERMISSIONS MODELS
// ================================

model UserPermission {
  id         String    @id @default(cuid())
  userId     String
  action     String // Action enum from middleware
  resource   String? // Specific resource (e.g., product:123) or * for all
  storeId    String? // Store-specific permission
  grant      Boolean   @default(true) // true = grant, false = deny
  conditions Json? // JSON conditions for when permission applies
  expiresAt  DateTime? // When permission expires (null = never)
  reason     String? // Reason for permission
  createdAt  DateTime  @default(now())
  createdBy  String // Who created this permission

  // Relations
  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  store   Store? @relation(fields: [storeId], references: [id], onDelete: Cascade)
  creator User   @relation("UserPermissionCreator", fields: [createdBy], references: [id])

  @@map("UserPermission")
}

model StorePermission {
  id          String    @id @default(cuid())
  userId      String
  storeId     String
  storeRole   StoreRole // Role within the store
  permissions Json // Array of actions permitted for this store role
  conditions  Json? // JSON conditions for when permissions apply
  expiresAt   DateTime? // When permission expires (null = never)
  createdAt   DateTime  @default(now())
  createdBy   String // Who created this permission

  // Relations
  user    User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  store   Store @relation(fields: [storeId], references: [id], onDelete: Cascade)
  creator User  @relation("StorePermissionCreator", fields: [createdBy], references: [id])

  @@unique([userId, storeId])
  @@map("StorePermission")
}

model PermissionTemplate {
  id          String   @id @default(cuid())
  name        String   @unique
  description String?
  permissions Json // Array of actions included in this template
  conditions  Json? // Default conditions for permissions in this template
  isDefault   Boolean  @default(false) // Whether this is a system default template
  createdAt   DateTime @default(now())
  createdBy   String // Who created this template

  // Relations
  creator User @relation("PermissionTemplateCreator", fields: [createdBy], references: [id])

  @@map("PermissionTemplate")
}

model PermissionAuditLog {
  id             String   @id @default(cuid())
  permissionId   String // ID of the permission that was changed
  permissionType String // 'user' or 'store'
  action         String // 'created', 'updated', 'deleted', 'expired'
  userId         String // User affected by the change
  changes        Json? // JSON of what changed (for updates)
  reason         String? // Reason for the change
  createdAt      DateTime @default(now())
  createdBy      String // Who made the change

  // Relations
  creator User @relation("PermissionAuditCreator", fields: [createdBy], references: [id])

  @@map("PermissionAuditLog")
}

model Notification {
  id        String               @id @default(cuid())
  userId    String // Usu\xE1rio que receber\xE1 a notifica\xE7\xE3o
  title     String // T\xEDtulo da notifica\xE7\xE3o
  message   String // Mensagem da notifica\xE7\xE3o
  type      NotificationType     @default(INFO) // Tipo da notifica\xE7\xE3o
  priority  NotificationPriority @default(MEDIUM) // Prioridade da notifica\xE7\xE3o
  isRead    Boolean              @default(false) // Se foi lida
  readAt    DateTime? // Quando foi lida
  data      Json? // Dados adicionais da notifica\xE7\xE3o (opcional)
  actionUrl String? // URL de a\xE7\xE3o (opcional)
  expiresAt DateTime? // Quando a notifica\xE7\xE3o expira (opcional)
  createdAt DateTime             @default(now())
  updatedAt DateTime             @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}

enum NotificationType {
  INFO // Informa\xE7\xE3o geral
  SUCCESS // Sucesso/confirma\xE7\xE3o
  WARNING // Aviso
  ERROR // Erro
  STOCK_ALERT // Alerta de estoque
  MOVEMENT // Movimenta\xE7\xE3o de estoque
  PERMISSION // Permiss\xE3o
  SYSTEM // Sistema
}

enum NotificationPriority {
  LOW // Baixa prioridade
  MEDIUM // M\xE9dia prioridade
  HIGH // Alta prioridade
  URGENT // Urgente
}

// === CHAT MODELS ===
model ChatSession {
  id        String        @id @default(cuid())
  userId    String
  storeId   String?
  title     String?
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
  messages  ChatMessage[]

  @@map("chat_sessions")
}

model ChatMessage {
  id         String   @id @default(cuid())
  content    String // Conte\xFAdo da mensagem (pergunta do usu\xE1rio OU resposta da IA)
  isFromUser Boolean  @default(true) // true = usu\xE1rio, false = IA
  sessionId  String
  context    Json? // Contexto adicional (storeId, userId, etc.)
  options    Json? // Op\xE7\xF5es do LLM (temperature, numPredict, etc.)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  session ChatSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@map("chat_messages")
}

//Roadmap Feature

model Roadmap {
  id          String        @id @default(cuid())
  storeId     String? // Roadmap pode ser associado a uma loja espec\xEDfica
  userId      String? // Ou a um usu\xE1rio (roadmap pessoal)
  title       String
  description String?
  status      RoadmapStatus @default(ACTIVE)
  startDate   DateTime?
  endDate     DateTime?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  // Relations
  store      Store?      @relation(fields: [storeId], references: [id])
  user       User?       @relation(fields: [userId], references: [id])
  milestones Milestone[]

  @@map("roadmaps")
}

model Milestone {
  id          String          @id @default(cuid())
  roadmapId   String
  title       String
  description String?
  status      MilestoneStatus @default(PENDING)
  progress    Int             @default(0) // % conclu\xEDda (0\u2013100)
  order       Int             @default(0) // posi\xE7\xE3o na timeline
  startDate   DateTime?
  endDate     DateTime?
  completedAt DateTime?
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt

  roadmap Roadmap @relation(fields: [roadmapId], references: [id], onDelete: Cascade)

  @@map("milestones")
}

enum RoadmapStatus {
  ACTIVE
  COMPLETED
  ARCHIVED
}

enum MilestoneStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  BLOCKED
}

//Upload Feature

model Media {
  id        String   @id @default(cuid())
  url       String // link p\xFAblico da imagem (ex: Cloudinary, S3, etc.)
  name      String? // nome do arquivo
  type      String? // tipo MIME (ex: image/png)
  size      Int? // tamanho em bytes
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // rela\xE7\xF5es
  productMedia  ProductMedia[]
  supplierMedia SupplierMedia[]
  userMedia     UserMedia[]
  storeMedia    StoreMedia[]

  @@map("media")
}

// tabelas de liga\xE7\xE3o (muitos-para-muitos com metadados opcionais)
model ProductMedia {
  id        String  @id @default(cuid())
  productId String
  mediaId   String
  isPrimary Boolean @default(false) // define se \xE9 a imagem principal do produto

  product Product @relation(fields: [productId], references: [id])
  media   Media   @relation(fields: [mediaId], references: [id])

  @@map("product_media")
}

model SupplierMedia {
  id         String @id @default(cuid())
  supplierId String
  mediaId    String

  supplier Supplier @relation(fields: [supplierId], references: [id])
  media    Media    @relation(fields: [mediaId], references: [id])

  @@map("supplier_media")
}

model UserMedia {
  id      String @id @default(cuid())
  userId  String
  mediaId String

  user  User  @relation(fields: [userId], references: [id])
  media Media @relation(fields: [mediaId], references: [id])

  @@map("user_media")
}

model StoreMedia {
  id      String @id @default(cuid())
  storeId String
  mediaId String

  store Store @relation(fields: [storeId], references: [id])
  media Media @relation(fields: [mediaId], references: [id])

  @@map("store_media")
}

//Quotation Feature
model Quote {
  id             String      @id @default(cuid())
  userId         String
  title          String
  description    String?
  publicId       String      @unique @default(uuid())
  authCode       String      @default(uuid()) // C\xF3digo de autoriza\xE7\xE3o para acesso p\xFAblico
  status         QuoteStatus @default(DRAFT)
  total          Decimal     @db.Decimal(10, 2)
  subtotal       Decimal     @db.Decimal(10, 2) // total antes de desconto/juros
  discount       Decimal?    @db.Decimal(10, 2)
  interest       Decimal?    @db.Decimal(10, 2) // juros somados, se houver
  paymentType    PaymentType @default(UNDEFINED)
  paymentTerms   String? // descri\xE7\xE3o livre, ex: "6x sem juros no cart\xE3o"
  paymentDueDays Int? // ex: 15 dias p/ pagamento no boleto
  expiresAt      DateTime? // validade do or\xE7amento
  observations   String? // campo livre pro usu\xE1rio
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt

  items        QuoteItem[]
  installments QuoteInstallment[]
  user         User               @relation(fields: [userId], references: [id])
}

model QuoteItem {
  id        String   @id @default(cuid())
  quoteId   String
  productId String
  quantity  Int
  unitPrice Decimal  @db.Decimal(10, 2)
  subtotal  Decimal  @db.Decimal(10, 2)
  discount  Decimal? @db.Decimal(10, 2)
  note      String?

  quote   Quote   @relation(fields: [quoteId], references: [id])
  product Product @relation(fields: [productId], references: [id])
}

model QuoteInstallment {
  id       String   @id @default(cuid())
  quoteId  String
  number   Int // ex: parcela 1, 2, 3...
  dueDate  DateTime
  amount   Decimal  @db.Decimal(10, 2)
  interest Decimal? @db.Decimal(10, 2)

  quote Quote @relation(fields: [quoteId], references: [id])
}

enum PaymentType {
  UNDEFINED
  PIX
  BOLETO
  CREDIT_CARD
  CASH
  TRANSFER
}

enum QuoteStatus {
  DRAFT // Or\xE7amento ainda em edi\xE7\xE3o (n\xE3o publicado)
  PUBLISHED // Link p\xFAblico ativo (cliente pode visualizar)
  SENT // Enviado para o cliente (por e-mail/link/WhatsApp)
  VIEWED // Cliente visualizou o or\xE7amento (tracking opcional)
  APPROVED // Cliente aprovou (pronto para virar venda)
  REJECTED // Cliente recusou
  EXPIRED // Passou da data de validade (expiresAt)
  CONVERTED // Convertido em venda / movimenta\xE7\xE3o
  CANCELED // Cancelado pelo usu\xE1rio
}

//Payment Feature
model Customer {
  id          String         @id @default(cuid())
  userId      String         @unique
  user        User           @relation(fields: [userId], references: [id])
  planId      String?
  plan        Plan?          @relation(fields: [planId], references: [id])
  status      CustomerStatus @default(ACTIVE)
  renewalDate DateTime?
  trialEndsAt DateTime?
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  invoices    Invoice[]
}

model Plan {
  id          String       @id @default(cuid())
  name        String
  description String?
  price       Decimal      @db.Decimal(10, 2)
  interval    PlanInterval // MONTHLY, YEARLY
  features    Json?
  customers   Customer[]
}

model Invoice {
  id               String        @id @default(cuid())
  customerId       String
  customer         Customer      @relation(fields: [customerId], references: [id])
  amount           Decimal       @db.Decimal(10, 2)
  status           InvoiceStatus
  gatewayPaymentId String? // ID de refer\xEAncia no Abacate Pay
  paymentDate      DateTime?
  createdAt        DateTime      @default(now())
}

enum CustomerStatus {
  ACTIVE
  INACTIVE
  CANCELLED
  TRIAL
}

enum PlanInterval {
  MONTHLY
  YEARLY
}

enum InvoiceStatus {
  PENDING
  PAID
  FAILED
}

//CRM Feature
model CrmStage {
  id        String   @id @default(cuid())
  storeId   String
  name      String
  color     String? // cor da coluna no front
  order     Int // posi\xE7\xE3o no pipeline
  createdAt DateTime @default(now())

  store   Store       @relation(fields: [storeId], references: [id])
  clients CrmClient[]

  @@map("crm_stages")
}

model CrmClient {
  id        String   @id @default(cuid())
  storeId   String
  stageId   String? // cliente est\xE1 em uma etapa
  name      String
  email     String?
  phone     String?
  cpfCnpj   String?
  notes     String?
  company   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  store Store     @relation(fields: [storeId], references: [id])
  stage CrmStage? @relation(fields: [stageId], references: [id])

  @@map("crm_clients")
}

// User Preferences Model (Alternative approach for complex configurations)
model UserPreferences {
  id     String @id @default(cuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Theme & UI Preferences
  theme            String  @default("light") // light, dark, auto
  primaryColor     String? // Cor prim\xE1ria personalizada
  sidebarCollapsed Boolean @default(false)
  compactMode      Boolean @default(false)

  // Language & Localization
  language     String @default("pt-BR")
  currency     String @default("BRL")
  timezone     String @default("America/Sao_Paulo")
  dateFormat   String @default("DD/MM/YYYY")
  timeFormat   String @default("24h")
  numberFormat String @default("pt-BR") // pt-BR, en-US

  // Notification Preferences
  emailNotifications Boolean @default(true)
  pushNotifications  Boolean @default(true)
  smsNotifications   Boolean @default(false)
  notificationTypes  Json? // Tipos espec\xEDficos de notifica\xE7\xE3o

  // Dashboard & Layout
  dashboardLayout Json? // Layout personalizado do dashboard
  defaultPage     String? // P\xE1gina inicial padr\xE3o
  itemsPerPage    Int     @default(20)

  // Business Preferences
  defaultStoreId  String? // Loja padr\xE3o para o usu\xE1rio
  autoRefresh     Boolean @default(true)
  refreshInterval Int     @default(30) // segundos

  // Advanced Settings
  customSettings Json? // Configura\xE7\xF5es personalizadas extens\xEDveis

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("user_preferences")
}
`,
      "inlineSchemaHash": "7d3ae06f0cf57ff42d55c3f70ea61dada56e31e62da7af9dc84169b82b56fe36",
      "copyEngine": true
    };
    var fs2 = require("fs");
    config.dirname = __dirname;
    if (!fs2.existsSync(path3.join(__dirname, "schema.prisma"))) {
      const alternativePaths = [
        "src/generated/prisma",
        "generated/prisma"
      ];
      const alternativePath = alternativePaths.find((altPath) => {
        return fs2.existsSync(path3.join(process.cwd(), altPath, "schema.prisma"));
      }) ?? alternativePaths[0];
      config.dirname = path3.join(process.cwd(), alternativePath);
      config.isBundled = true;
    }
    config.runtimeDataModel = JSON.parse('{"models":{"User":{"dbName":"users","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"email","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"password","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"phone","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"status","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"resetPasswordToken","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"resetPasswordCode","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"resetPasswordExpires","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"emailVerified","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"emailVerificationToken","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"emailVerificationCode","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"emailVerificationCodeExpires","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"lastLoginAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"roles","kind":"scalar","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":["user"],"isGenerated":false,"isUpdatedAt":false},{"name":"theme","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"light","isGenerated":false,"isUpdatedAt":false},{"name":"language","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"pt-BR","isGenerated":false,"isUpdatedAt":false},{"name":"currency","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"BRL","isGenerated":false,"isUpdatedAt":false},{"name":"timezone","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"America/Sao_Paulo","isGenerated":false,"isUpdatedAt":false},{"name":"dateFormat","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"DD/MM/YYYY","isGenerated":false,"isUpdatedAt":false},{"name":"timeFormat","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"24h","isGenerated":false,"isUpdatedAt":false},{"name":"dashboard","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"auditLogs","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"AuditLog","nativeType":null,"relationName":"AuditLogToUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"movements","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Movement","nativeType":null,"relationName":"MovementToUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"ownedStores","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Store","nativeType":null,"relationName":"StoreOwner","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"stores","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"StoreUser","nativeType":null,"relationName":"StoreUserToUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"userPermissions","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"UserPermission","nativeType":null,"relationName":"UserToUserPermission","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"storePermissions","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"StorePermission","nativeType":null,"relationName":"StorePermissionToUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"createdUserPermissions","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"UserPermission","nativeType":null,"relationName":"UserPermissionCreator","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"createdStorePermissions","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"StorePermission","nativeType":null,"relationName":"StorePermissionCreator","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"createdPermissionTemplates","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"PermissionTemplate","nativeType":null,"relationName":"PermissionTemplateCreator","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"createdPermissionAudits","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"PermissionAuditLog","nativeType":null,"relationName":"PermissionAuditCreator","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"notifications","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Notification","nativeType":null,"relationName":"NotificationToUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"roadmaps","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Roadmap","nativeType":null,"relationName":"RoadmapToUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"media","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"UserMedia","nativeType":null,"relationName":"UserToUserMedia","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"quotes","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Quote","nativeType":null,"relationName":"QuoteToUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"customers","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Customer","nativeType":null,"relationName":"CustomerToUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"preferences","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"UserPreferences","nativeType":null,"relationName":"UserToUserPreferences","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Product":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"description","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"unitOfMeasure","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"UnitOfMeasure","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"referencePrice","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["10","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"supplierId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"storeId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"stockMin","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"stockMax","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"alertPercentage","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":["SmallInt",[]],"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"store","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Store","nativeType":null,"relationName":"ProductToStore","relationFromFields":["storeId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"supplier","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Supplier","nativeType":null,"relationName":"ProductToSupplier","relationFromFields":["supplierId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"movements","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Movement","nativeType":null,"relationName":"MovementToProduct","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"categories","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"ProductCategory","nativeType":null,"relationName":"ProductToProductCategory","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"media","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"ProductMedia","nativeType":null,"relationName":"ProductToProductMedia","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"quotes","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"QuoteItem","nativeType":null,"relationName":"ProductToQuoteItem","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Category":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"description","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"code","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"color","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"icon","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"parentId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"storeId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"store","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Store","nativeType":null,"relationName":"CategoryToStore","relationFromFields":["storeId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"parent","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Category","nativeType":null,"relationName":"CategoryHierarchy","relationFromFields":["parentId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"children","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Category","nativeType":null,"relationName":"CategoryHierarchy","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"products","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"ProductCategory","nativeType":null,"relationName":"CategoryToProductCategory","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[["code","storeId"]],"uniqueIndexes":[{"name":null,"fields":["code","storeId"]}],"isGenerated":false},"ProductCategory":{"dbName":"ProductCategory","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"productId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"categoryId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"product","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Product","nativeType":null,"relationName":"ProductToProductCategory","relationFromFields":["productId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"category","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Category","nativeType":null,"relationName":"CategoryToProductCategory","relationFromFields":["categoryId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[["productId","categoryId"]],"uniqueIndexes":[{"name":null,"fields":["productId","categoryId"]}],"isGenerated":false},"Supplier":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"corporateName","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"cnpj","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"tradeName","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"cep","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"city","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"state","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"address","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"storeId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"store","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Store","nativeType":null,"relationName":"StoreToSupplier","relationFromFields":["storeId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"products","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Product","nativeType":null,"relationName":"ProductToSupplier","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"movements","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Movement","nativeType":null,"relationName":"MovementToSupplier","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"responsibles","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"SupplierResponsible","nativeType":null,"relationName":"SupplierToSupplierResponsible","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"media","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"SupplierMedia","nativeType":null,"relationName":"SupplierToSupplierMedia","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[["cnpj","storeId"]],"uniqueIndexes":[{"name":null,"fields":["cnpj","storeId"]}],"isGenerated":false},"SupplierResponsible":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"phone","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"email","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"cpf","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"supplierId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"supplier","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Supplier","nativeType":null,"relationName":"SupplierToSupplierResponsible","relationFromFields":["supplierId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Store":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"ownerId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"cnpj","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"email","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"phone","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"cep","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"city","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"state","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"address","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"products","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Product","nativeType":null,"relationName":"ProductToStore","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"categories","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Category","nativeType":null,"relationName":"CategoryToStore","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"suppliers","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Supplier","nativeType":null,"relationName":"StoreToSupplier","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"movements","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Movement","nativeType":null,"relationName":"MovementToStore","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"owner","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"StoreOwner","relationFromFields":["ownerId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"users","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"StoreUser","nativeType":null,"relationName":"StoreToStoreUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"userPermissions","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"UserPermission","nativeType":null,"relationName":"StoreToUserPermission","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"storePermissions","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"StorePermission","nativeType":null,"relationName":"StoreToStorePermission","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"roadmaps","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Roadmap","nativeType":null,"relationName":"RoadmapToStore","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"media","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"StoreMedia","nativeType":null,"relationName":"StoreToStoreMedia","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"crmStages","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"CrmStage","nativeType":null,"relationName":"CrmStageToStore","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"crmClients","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"CrmClient","nativeType":null,"relationName":"CrmClientToStore","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"StoreUser":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"storeId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"userId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"role","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"StoreRole","nativeType":null,"default":"STAFF","isGenerated":false,"isUpdatedAt":false},{"name":"store","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Store","nativeType":null,"relationName":"StoreToStoreUser","relationFromFields":["storeId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"user","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"StoreUserToUser","relationFromFields":["userId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[["storeId","userId"]],"uniqueIndexes":[{"name":null,"fields":["storeId","userId"]}],"isGenerated":false},"AuditLog":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"entity","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Entity","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"entityId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"action","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"LogAction","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"userId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"before","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"after","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"user","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"AuditLogToUser","relationFromFields":["userId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Movement":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"type","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"MovementType","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"quantity","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"storeId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"productId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"supplierId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"batch","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"expiration","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"price","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["10","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"note","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"balanceAfter","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"verified","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"verifiedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"verifiedBy","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"verificationNote","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"cancelled","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"cancelledAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"cancelledBy","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"cancellationReason","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"store","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Store","nativeType":null,"relationName":"MovementToStore","relationFromFields":["storeId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"product","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Product","nativeType":null,"relationName":"MovementToProduct","relationFromFields":["productId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"supplier","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Supplier","nativeType":null,"relationName":"MovementToSupplier","relationFromFields":["supplierId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"userId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"user","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"MovementToUser","relationFromFields":["userId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"UserPermission":{"dbName":"UserPermission","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"userId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"action","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"resource","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"storeId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"grant","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"conditions","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"expiresAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"reason","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"createdBy","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"user","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"UserToUserPermission","relationFromFields":["userId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"store","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Store","nativeType":null,"relationName":"StoreToUserPermission","relationFromFields":["storeId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"creator","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"UserPermissionCreator","relationFromFields":["createdBy"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"StorePermission":{"dbName":"StorePermission","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"userId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"storeId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"storeRole","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"StoreRole","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"permissions","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"conditions","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"expiresAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"createdBy","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"user","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"StorePermissionToUser","relationFromFields":["userId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"store","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Store","nativeType":null,"relationName":"StoreToStorePermission","relationFromFields":["storeId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"creator","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"StorePermissionCreator","relationFromFields":["createdBy"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[["userId","storeId"]],"uniqueIndexes":[{"name":null,"fields":["userId","storeId"]}],"isGenerated":false},"PermissionTemplate":{"dbName":"PermissionTemplate","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"description","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"permissions","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"conditions","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"isDefault","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"createdBy","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"creator","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"PermissionTemplateCreator","relationFromFields":["createdBy"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"PermissionAuditLog":{"dbName":"PermissionAuditLog","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"permissionId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"permissionType","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"action","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"userId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"changes","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"reason","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"createdBy","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"creator","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"PermissionAuditCreator","relationFromFields":["createdBy"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Notification":{"dbName":"notifications","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"userId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"title","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"message","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"type","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"NotificationType","nativeType":null,"default":"INFO","isGenerated":false,"isUpdatedAt":false},{"name":"priority","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"NotificationPriority","nativeType":null,"default":"MEDIUM","isGenerated":false,"isUpdatedAt":false},{"name":"isRead","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"readAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"data","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"actionUrl","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"expiresAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"user","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"NotificationToUser","relationFromFields":["userId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"ChatSession":{"dbName":"chat_sessions","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"userId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"storeId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"title","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"messages","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"ChatMessage","nativeType":null,"relationName":"ChatMessageToChatSession","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"ChatMessage":{"dbName":"chat_messages","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"content","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"isFromUser","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"sessionId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"context","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"options","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"session","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"ChatSession","nativeType":null,"relationName":"ChatMessageToChatSession","relationFromFields":["sessionId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Roadmap":{"dbName":"roadmaps","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"storeId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"userId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"title","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"description","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"RoadmapStatus","nativeType":null,"default":"ACTIVE","isGenerated":false,"isUpdatedAt":false},{"name":"startDate","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"endDate","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"store","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Store","nativeType":null,"relationName":"RoadmapToStore","relationFromFields":["storeId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"user","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"RoadmapToUser","relationFromFields":["userId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"milestones","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Milestone","nativeType":null,"relationName":"MilestoneToRoadmap","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Milestone":{"dbName":"milestones","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"roadmapId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"title","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"description","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"MilestoneStatus","nativeType":null,"default":"PENDING","isGenerated":false,"isUpdatedAt":false},{"name":"progress","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":null,"default":0,"isGenerated":false,"isUpdatedAt":false},{"name":"order","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":null,"default":0,"isGenerated":false,"isUpdatedAt":false},{"name":"startDate","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"endDate","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"completedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"roadmap","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Roadmap","nativeType":null,"relationName":"MilestoneToRoadmap","relationFromFields":["roadmapId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Media":{"dbName":"media","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"url","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"type","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"size","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"productMedia","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"ProductMedia","nativeType":null,"relationName":"MediaToProductMedia","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"supplierMedia","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"SupplierMedia","nativeType":null,"relationName":"MediaToSupplierMedia","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"userMedia","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"UserMedia","nativeType":null,"relationName":"MediaToUserMedia","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"storeMedia","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"StoreMedia","nativeType":null,"relationName":"MediaToStoreMedia","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"ProductMedia":{"dbName":"product_media","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"productId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"mediaId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"isPrimary","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"product","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Product","nativeType":null,"relationName":"ProductToProductMedia","relationFromFields":["productId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"media","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Media","nativeType":null,"relationName":"MediaToProductMedia","relationFromFields":["mediaId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"SupplierMedia":{"dbName":"supplier_media","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"supplierId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"mediaId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"supplier","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Supplier","nativeType":null,"relationName":"SupplierToSupplierMedia","relationFromFields":["supplierId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"media","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Media","nativeType":null,"relationName":"MediaToSupplierMedia","relationFromFields":["mediaId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"UserMedia":{"dbName":"user_media","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"userId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"mediaId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"user","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"UserToUserMedia","relationFromFields":["userId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"media","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Media","nativeType":null,"relationName":"MediaToUserMedia","relationFromFields":["mediaId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"StoreMedia":{"dbName":"store_media","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"storeId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"mediaId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"store","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Store","nativeType":null,"relationName":"StoreToStoreMedia","relationFromFields":["storeId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"media","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Media","nativeType":null,"relationName":"MediaToStoreMedia","relationFromFields":["mediaId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Quote":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"userId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"title","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"description","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"publicId","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"uuid","args":[4]},"isGenerated":false,"isUpdatedAt":false},{"name":"authCode","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"uuid","args":[4]},"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"QuoteStatus","nativeType":null,"default":"DRAFT","isGenerated":false,"isUpdatedAt":false},{"name":"total","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["10","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"subtotal","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["10","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"discount","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["10","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"interest","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["10","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"paymentType","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"PaymentType","nativeType":null,"default":"UNDEFINED","isGenerated":false,"isUpdatedAt":false},{"name":"paymentTerms","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"paymentDueDays","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"expiresAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"observations","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"items","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"QuoteItem","nativeType":null,"relationName":"QuoteToQuoteItem","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"installments","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"QuoteInstallment","nativeType":null,"relationName":"QuoteToQuoteInstallment","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"user","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"QuoteToUser","relationFromFields":["userId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"QuoteItem":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"quoteId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"productId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"quantity","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"unitPrice","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["10","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"subtotal","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["10","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"discount","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["10","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"note","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"quote","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Quote","nativeType":null,"relationName":"QuoteToQuoteItem","relationFromFields":["quoteId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"product","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Product","nativeType":null,"relationName":"ProductToQuoteItem","relationFromFields":["productId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"QuoteInstallment":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"quoteId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"number","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"dueDate","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"amount","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["10","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"interest","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["10","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"quote","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Quote","nativeType":null,"relationName":"QuoteToQuoteInstallment","relationFromFields":["quoteId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Customer":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"userId","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"user","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"CustomerToUser","relationFromFields":["userId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"planId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"plan","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Plan","nativeType":null,"relationName":"CustomerToPlan","relationFromFields":["planId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"CustomerStatus","nativeType":null,"default":"ACTIVE","isGenerated":false,"isUpdatedAt":false},{"name":"renewalDate","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"trialEndsAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"invoices","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Invoice","nativeType":null,"relationName":"CustomerToInvoice","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Plan":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"description","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"price","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["10","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"interval","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"PlanInterval","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"features","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"customers","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Customer","nativeType":null,"relationName":"CustomerToPlan","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Invoice":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"customerId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"customer","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Customer","nativeType":null,"relationName":"CustomerToInvoice","relationFromFields":["customerId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"amount","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["10","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"InvoiceStatus","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"gatewayPaymentId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"paymentDate","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"CrmStage":{"dbName":"crm_stages","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"storeId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"color","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"order","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"store","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Store","nativeType":null,"relationName":"CrmStageToStore","relationFromFields":["storeId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"clients","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"CrmClient","nativeType":null,"relationName":"CrmClientToCrmStage","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"CrmClient":{"dbName":"crm_clients","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"storeId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"stageId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"email","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"phone","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"cpfCnpj","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"notes","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"company","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"store","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Store","nativeType":null,"relationName":"CrmClientToStore","relationFromFields":["storeId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"stage","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"CrmStage","nativeType":null,"relationName":"CrmClientToCrmStage","relationFromFields":["stageId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"UserPreferences":{"dbName":"user_preferences","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"userId","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"user","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"UserToUserPreferences","relationFromFields":["userId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"theme","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"light","isGenerated":false,"isUpdatedAt":false},{"name":"primaryColor","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"sidebarCollapsed","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"compactMode","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"language","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"pt-BR","isGenerated":false,"isUpdatedAt":false},{"name":"currency","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"BRL","isGenerated":false,"isUpdatedAt":false},{"name":"timezone","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"America/Sao_Paulo","isGenerated":false,"isUpdatedAt":false},{"name":"dateFormat","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"DD/MM/YYYY","isGenerated":false,"isUpdatedAt":false},{"name":"timeFormat","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"24h","isGenerated":false,"isUpdatedAt":false},{"name":"numberFormat","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"pt-BR","isGenerated":false,"isUpdatedAt":false},{"name":"emailNotifications","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"pushNotifications","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"smsNotifications","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"notificationTypes","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"dashboardLayout","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"defaultPage","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"itemsPerPage","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":null,"default":20,"isGenerated":false,"isUpdatedAt":false},{"name":"defaultStoreId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"autoRefresh","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"refreshInterval","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":null,"default":30,"isGenerated":false,"isUpdatedAt":false},{"name":"customSettings","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false}},"enums":{"MovementType":{"values":[{"name":"ENTRADA","dbName":null},{"name":"SAIDA","dbName":null},{"name":"PERDA","dbName":null}],"dbName":null},"LogAction":{"values":[{"name":"CREATE","dbName":null},{"name":"UPDATE","dbName":null},{"name":"DELETE","dbName":null}],"dbName":null},"Entity":{"values":[{"name":"PRODUCT","dbName":null},{"name":"STORE","dbName":null},{"name":"USER","dbName":null}],"dbName":null},"StoreRole":{"values":[{"name":"OWNER","dbName":null},{"name":"ADMIN","dbName":null},{"name":"MANAGER","dbName":null},{"name":"STAFF","dbName":null}],"dbName":null},"UnitOfMeasure":{"values":[{"name":"UNIDADE","dbName":null},{"name":"KG","dbName":null},{"name":"L","dbName":null},{"name":"ML","dbName":null},{"name":"M","dbName":null},{"name":"CM","dbName":null},{"name":"MM","dbName":null},{"name":"UN","dbName":null},{"name":"DZ","dbName":null},{"name":"CX","dbName":null},{"name":"PCT","dbName":null},{"name":"KIT","dbName":null},{"name":"PAR","dbName":null},{"name":"H","dbName":null},{"name":"D","dbName":null}],"dbName":null},"NotificationType":{"values":[{"name":"INFO","dbName":null},{"name":"SUCCESS","dbName":null},{"name":"WARNING","dbName":null},{"name":"ERROR","dbName":null},{"name":"STOCK_ALERT","dbName":null},{"name":"MOVEMENT","dbName":null},{"name":"PERMISSION","dbName":null},{"name":"SYSTEM","dbName":null}],"dbName":null},"NotificationPriority":{"values":[{"name":"LOW","dbName":null},{"name":"MEDIUM","dbName":null},{"name":"HIGH","dbName":null},{"name":"URGENT","dbName":null}],"dbName":null},"RoadmapStatus":{"values":[{"name":"ACTIVE","dbName":null},{"name":"COMPLETED","dbName":null},{"name":"ARCHIVED","dbName":null}],"dbName":null},"MilestoneStatus":{"values":[{"name":"PENDING","dbName":null},{"name":"IN_PROGRESS","dbName":null},{"name":"COMPLETED","dbName":null},{"name":"BLOCKED","dbName":null}],"dbName":null},"PaymentType":{"values":[{"name":"UNDEFINED","dbName":null},{"name":"PIX","dbName":null},{"name":"BOLETO","dbName":null},{"name":"CREDIT_CARD","dbName":null},{"name":"CASH","dbName":null},{"name":"TRANSFER","dbName":null}],"dbName":null},"QuoteStatus":{"values":[{"name":"DRAFT","dbName":null},{"name":"PUBLISHED","dbName":null},{"name":"SENT","dbName":null},{"name":"VIEWED","dbName":null},{"name":"APPROVED","dbName":null},{"name":"REJECTED","dbName":null},{"name":"EXPIRED","dbName":null},{"name":"CONVERTED","dbName":null},{"name":"CANCELED","dbName":null}],"dbName":null},"CustomerStatus":{"values":[{"name":"ACTIVE","dbName":null},{"name":"INACTIVE","dbName":null},{"name":"CANCELLED","dbName":null},{"name":"TRIAL","dbName":null}],"dbName":null},"PlanInterval":{"values":[{"name":"MONTHLY","dbName":null},{"name":"YEARLY","dbName":null}],"dbName":null},"InvoiceStatus":{"values":[{"name":"PENDING","dbName":null},{"name":"PAID","dbName":null},{"name":"FAILED","dbName":null}],"dbName":null}},"types":{}}');
    defineDmmfProperty2(exports2.Prisma, config.runtimeDataModel);
    config.engineWasm = void 0;
    config.compilerWasm = void 0;
    var { warnEnvConflicts: warnEnvConflicts2 } = require_library();
    warnEnvConflicts2({
      rootEnvPath: config.relativeEnvPaths.rootEnvPath && path3.resolve(config.dirname, config.relativeEnvPaths.rootEnvPath),
      schemaEnvPath: config.relativeEnvPaths.schemaEnvPath && path3.resolve(config.dirname, config.relativeEnvPaths.schemaEnvPath)
    });
    var PrismaClient2 = getPrismaClient2(config);
    exports2.PrismaClient = PrismaClient2;
    Object.assign(exports2, Prisma);
    path3.join(__dirname, "query_engine-windows.dll.node");
    path3.join(process.cwd(), "src/generated/prisma/query_engine-windows.dll.node");
    path3.join(__dirname, "schema.prisma");
    path3.join(process.cwd(), "src/generated/prisma/schema.prisma");
  }
});

// src/plugins/prisma.ts
async function prismaPlugin(app) {
  app.decorate("prisma", prisma);
  app.addHook("onClose", async () => {
    await prisma.$disconnect();
  });
}
async function connectPrisma(app) {
  try {
    await prisma.$connect();
    console.log("\u2705 Prisma conectado com sucesso ao banco de dados");
    app.log.info("Prisma conectado com sucesso ao banco de dados");
  } catch (error) {
    app.log.error("Falha ao conectar com o banco de dados:");
    console.log("\u274C Falha ao conectar com o banco de dados:");
    console.error(error);
    process.exit(1);
  }
}
var import_prisma, prisma, db;
var init_prisma = __esm({
  "src/plugins/prisma.ts"() {
    import_prisma = __toESM(require_prisma());
    prisma = new import_prisma.PrismaClient();
    db = prisma;
  }
});

// src/features/auth/queries/auth.queries.ts
var AuthQueries;
var init_auth_queries = __esm({
  "src/features/auth/queries/auth.queries.ts"() {
    init_prisma();
    AuthQueries = {
      async getById(id) {
        const user = await prisma.user.findUnique({
          where: { id, status: true },
          select: {
            id: true,
            email: true,
            name: true,
            emailVerified: true,
            status: true,
            roles: true,
            lastLoginAt: true,
            createdAt: true,
            updatedAt: true
          }
        });
        return user;
      },
      async getByEmail(email) {
        const user = await prisma.user.findUnique({
          where: { email, status: true },
          select: {
            id: true,
            email: true,
            name: true,
            emailVerified: true,
            status: true,
            roles: true,
            lastLoginAt: true,
            createdAt: true,
            updatedAt: true
          }
        });
        return user;
      },
      async getByResetToken(token) {
        const user = await prisma.user.findFirst({
          where: {
            resetPasswordToken: token,
            resetPasswordExpires: {
              gt: /* @__PURE__ */ new Date()
            },
            status: true
          },
          select: {
            id: true,
            email: true,
            name: true,
            emailVerified: true,
            status: true,
            roles: true,
            lastLoginAt: true,
            createdAt: true,
            updatedAt: true
          }
        });
        return user;
      },
      async getByVerificationToken(token) {
        const user = await prisma.user.findFirst({
          where: {
            emailVerificationToken: token,
            emailVerified: false,
            status: true
          },
          select: {
            id: true,
            email: true,
            name: true,
            emailVerified: true,
            status: true,
            roles: true,
            lastLoginAt: true,
            createdAt: true,
            updatedAt: true
          }
        });
        return user;
      },
      async getActiveUsers() {
        const users = await prisma.user.findMany({
          where: { status: true },
          select: {
            id: true,
            email: true,
            name: true,
            emailVerified: true,
            status: true,
            roles: true,
            lastLoginAt: true,
            createdAt: true,
            updatedAt: true
          },
          orderBy: { createdAt: "desc" }
        });
        return users;
      },
      async getVerifiedUsers() {
        const users = await prisma.user.findMany({
          where: {
            status: true,
            emailVerified: true
          },
          select: {
            id: true,
            email: true,
            name: true,
            emailVerified: true,
            status: true,
            roles: true,
            lastLoginAt: true,
            createdAt: true,
            updatedAt: true
          },
          orderBy: { createdAt: "desc" }
        });
        return users;
      },
      async getUnverifiedUsers() {
        const users = await prisma.user.findMany({
          where: {
            status: true,
            emailVerified: false
          },
          select: {
            id: true,
            email: true,
            name: true,
            emailVerified: true,
            status: true,
            roles: true,
            lastLoginAt: true,
            createdAt: true,
            updatedAt: true
          },
          orderBy: { createdAt: "desc" }
        });
        return users;
      },
      async getUserStats() {
        const [
          totalUsers,
          activeUsers,
          verifiedUsers,
          unverifiedUsers,
          recentLogins
        ] = await Promise.all([
          this.prisma.user.count(),
          this.prisma.user.count({ where: { status: true } }),
          this.prisma.user.count({
            where: {
              status: true,
              emailVerified: true
            }
          }),
          this.prisma.user.count({
            where: {
              status: true,
              emailVerified: false
            }
          }),
          this.prisma.user.count({
            where: {
              status: true,
              lastLoginAt: {
                gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1e3)
                // Last 7 days
              }
            }
          })
        ]);
        return {
          totalUsers,
          activeUsers,
          verifiedUsers,
          unverifiedUsers,
          recentLogins
        };
      },
      async searchUsers(searchTerm, limit = 10) {
        const users = await prisma.user.findMany({
          where: {
            status: true,
            OR: [
              { name: { contains: searchTerm, mode: "insensitive" } },
              { email: { contains: searchTerm, mode: "insensitive" } }
            ]
          },
          select: {
            id: true,
            email: true,
            name: true,
            emailVerified: true,
            status: true,
            roles: true,
            lastLoginAt: true,
            createdAt: true,
            updatedAt: true
          },
          take: limit,
          orderBy: { createdAt: "desc" }
        });
        return users;
      },
      async getUsersWithPendingVerification() {
        const users = await prisma.user.findMany({
          where: {
            status: true,
            emailVerified: false,
            emailVerificationToken: {
              not: null
            }
          },
          select: {
            id: true,
            email: true,
            name: true,
            emailVerified: true,
            emailVerificationToken: true,
            createdAt: true
          },
          orderBy: { createdAt: "desc" }
        });
        return users;
      },
      async getUsersWithPendingReset() {
        const users = await prisma.user.findMany({
          where: {
            status: true,
            resetPasswordToken: {
              not: null
            },
            resetPasswordExpires: {
              gt: /* @__PURE__ */ new Date()
            }
          },
          select: {
            id: true,
            email: true,
            name: true,
            resetPasswordToken: true,
            resetPasswordExpires: true,
            createdAt: true
          },
          orderBy: { createdAt: "desc" }
        });
        return users;
      },
      // Verify if user exists by email
      async userExists(email) {
        const count = await prisma.user.count({
          where: { email }
        });
        return count > 0;
      },
      // Verify if email is already verified
      async isEmailVerified(email) {
        const user = await prisma.user.findUnique({
          where: { email },
          select: { emailVerified: true }
        });
        return user?.emailVerified || false;
      },
      // Get user profile for authenticated user
      async getUserProfile(userId) {
        const user = await prisma.user.findUnique({
          where: { id: userId, status: true },
          select: {
            id: true,
            email: true,
            name: true,
            emailVerified: true,
            status: true,
            roles: true,
            lastLoginAt: true,
            phone: true,
            createdAt: true,
            updatedAt: true
          }
        });
        if (!user) {
          throw new Error("User not found");
        }
        return user;
      },
      // Get store owned by user
      async getStoreByOwner(userId) {
        const store = await prisma.store.findFirst({
          where: {
            ownerId: userId,
            status: true
          },
          select: {
            id: true,
            name: true,
            cnpj: true,
            email: true,
            phone: true,
            status: true,
            cep: true,
            city: true,
            state: true,
            address: true,
            createdAt: true,
            updatedAt: true
          }
        });
        return store;
      },
      // Get user profile permissions
      async getProfilePermissions(userId, filters) {
        const { storeId, active, page = 1, limit = 10 } = filters;
        const user = await prisma.user.findUnique({
          where: { id: userId, status: true },
          select: { id: true, roles: true }
        });
        if (!user) {
          throw new Error("User not found");
        }
        const customPermissionsWhere = { userId };
        if (storeId) customPermissionsWhere.storeId = storeId;
        if (active !== void 0) {
          if (active) {
            customPermissionsWhere.OR = [
              { expiresAt: null },
              { expiresAt: { gt: /* @__PURE__ */ new Date() } }
            ];
          } else {
            customPermissionsWhere.expiresAt = { lte: /* @__PURE__ */ new Date() };
          }
        }
        const [customPermissions, customPermissionsTotal] = await Promise.all([
          prisma.userPermission.findMany({
            where: customPermissionsWhere,
            skip: (page - 1) * limit,
            take: limit,
            orderBy: { createdAt: "desc" },
            include: {
              creator: {
                select: { id: true, name: true, email: true }
              }
            }
          }),
          prisma.userPermission.count({ where: customPermissionsWhere })
        ]);
        const storePermissionsWhere = { userId };
        if (storeId) storePermissionsWhere.storeId = storeId;
        if (active !== void 0) {
          if (active) {
            storePermissionsWhere.OR = [
              { expiresAt: null },
              { expiresAt: { gt: /* @__PURE__ */ new Date() } }
            ];
          } else {
            storePermissionsWhere.expiresAt = { lte: /* @__PURE__ */ new Date() };
          }
        }
        const [storePermissions, storePermissionsTotal] = await Promise.all([
          prisma.storePermission.findMany({
            where: storePermissionsWhere,
            skip: (page - 1) * limit,
            take: limit,
            orderBy: { createdAt: "desc" },
            include: {
              store: {
                select: { id: true, name: true }
              },
              creator: {
                select: { id: true, name: true, email: true }
              }
            }
          }),
          prisma.storePermission.count({ where: storePermissionsWhere })
        ]);
        const effectivePermissions = await this.getUserEffectivePermissions(userId, { storeId });
        return {
          userId: user.id,
          userRoles: user.roles,
          storeId: storeId || null,
          effectivePermissions: effectivePermissions.effectivePermissions,
          customPermissions: customPermissions.map((p) => ({
            ...p,
            conditions: p.conditions ? JSON.parse(p.conditions) : null
          })),
          storePermissions: storePermissions.map((p) => ({
            ...p,
            permissions: JSON.parse(p.permissions),
            conditions: p.conditions ? JSON.parse(p.conditions) : null
          })),
          pagination: {
            page,
            limit,
            total: customPermissionsTotal + storePermissionsTotal,
            pages: Math.ceil((customPermissionsTotal + storePermissionsTotal) / limit)
          }
        };
      },
      // Get user effective permissions (helper method)
      async getUserEffectivePermissions(userId, context) {
        const { storeId } = context;
        const user = await prisma.user.findUnique({
          where: { id: userId },
          select: { id: true, roles: true }
        });
        if (!user) {
          throw new Error("User not found");
        }
        const customPermissions = await prisma.userPermission.findMany({
          where: {
            userId,
            ...storeId ? { storeId } : {}
          }
        });
        let storePermissions = [];
        if (storeId) {
          storePermissions = await prisma.storePermission.findMany({
            where: { userId, storeId }
          });
        }
        const effectivePermissions = [];
        if (user.roles.includes("admin")) {
          effectivePermissions.push("*");
        } else if (user.roles.includes("manager")) {
          effectivePermissions.push("read", "create", "update", "delete");
        } else if (user.roles.includes("user")) {
          effectivePermissions.push("read");
        }
        customPermissions.forEach((perm) => {
          if (perm.grant && (!perm.expiresAt || perm.expiresAt > /* @__PURE__ */ new Date())) {
            if (!effectivePermissions.includes(perm.action)) {
              effectivePermissions.push(perm.action);
            }
          }
        });
        storePermissions.forEach((perm) => {
          if (!perm.expiresAt || perm.expiresAt > /* @__PURE__ */ new Date()) {
            const permissions = JSON.parse(perm.permissions);
            permissions.forEach((action) => {
              if (!effectivePermissions.includes(action)) {
                effectivePermissions.push(action);
              }
            });
          }
        });
        return {
          userId,
          userRoles: user.roles,
          storeId,
          effectivePermissions,
          customPermissions: customPermissions.map((p) => ({
            ...p,
            conditions: p.conditions ? JSON.parse(p.conditions) : null
          })),
          storePermissions: storePermissions.map((p) => ({
            ...p,
            permissions: JSON.parse(p.permissions),
            conditions: p.conditions ? JSON.parse(p.conditions) : null
          }))
        };
      }
    };
  }
});

// src/services/email/templates/welcome.ts
var generateWelcomeEmailHTML, generateWelcomeEmailText;
var init_welcome = __esm({
  "src/services/email/templates/welcome.ts"() {
    generateWelcomeEmailHTML = (data) => {
      return `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Bem-vindo ao 25Stock</title>
      <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0; }
        .content { background: #f9f9f9; padding: 30px; border-radius: 0 0 10px 10px; }
        .button { display: inline-block; background: #667eea; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; margin: 20px 0; }
        .footer { text-align: center; margin-top: 30px; color: #666; font-size: 14px; }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="header">
          <h1>\u{1F389} Bem-vindo ao 25Stock!</h1>
          <p>Sua conta foi criada com sucesso</p>
        </div>
        <div class="content">
          <h2>Ol\xE1, ${data.name}!</h2>
          <p>\xC9 um prazer t\xEA-lo conosco no 25Stock, a plataforma completa para gest\xE3o de estoque.</p>
          <p>Com sua conta, voc\xEA poder\xE1:</p>
          <ul>
            <li>Gerenciar produtos e categorias</li>
            <li>Controlar movimenta\xE7\xF5es de estoque</li>
            <li>Gerar relat\xF3rios detalhados</li>
            <li>Colaborar com sua equipe</li>
            <li>E muito mais!</li>
          </ul>
          <p>Clique no bot\xE3o abaixo para acessar sua conta:</p>
          <a href="${data.loginUrl}" class="button">Acessar Minha Conta</a>
          <p>Se voc\xEA n\xE3o criou esta conta, pode ignorar este email.</p>
        </div>
        <div class="footer">
          <p>Este \xE9 um email autom\xE1tico, n\xE3o responda a esta mensagem.</p>
          <p>&copy; 2024 25Stock. Todos os direitos reservados.</p>
        </div>
      </div>
    </body>
    </html>
  `;
    };
    generateWelcomeEmailText = (data) => {
      return `
Bem-vindo ao 25Stock!

Ol\xE1, ${data.name}!

\xC9 um prazer t\xEA-lo conosco no 25Stock, a plataforma completa para gest\xE3o de estoque.

Com sua conta, voc\xEA poder\xE1:
- Gerenciar produtos e categorias
- Controlar movimenta\xE7\xF5es de estoque
- Gerar relat\xF3rios detalhados
- Colaborar com sua equipe
- E muito mais!

Acesse sua conta em: ${data.loginUrl}

Se voc\xEA n\xE3o criou esta conta, pode ignorar este email.

---
Este \xE9 um email autom\xE1tico, n\xE3o responda a esta mensagem.
\xA9 2024 25Stock. Todos os direitos reservados.
  `;
    };
  }
});

// src/services/email/templates/reset_password.ts
var generatePasswordResetEmailHTML, generatePasswordResetEmailText;
var init_reset_password = __esm({
  "src/services/email/templates/reset_password.ts"() {
    generatePasswordResetEmailHTML = (data) => {
      return `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Redefini\xE7\xE3o de Senha - 25Stock</title>
      <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0; }
        .content { background: #f9f9f9; padding: 30px; border-radius: 0 0 10px 10px; }
        .code-box { background: #fff; border: 2px solid #e74c3c; padding: 20px; text-align: center; border-radius: 10px; margin: 20px 0; }
        .reset-code { font-size: 32px; font-weight: bold; color: #e74c3c; letter-spacing: 5px; margin: 10px 0; }
        .warning { background: #fff3cd; border: 1px solid #ffeaa7; padding: 15px; border-radius: 5px; margin: 20px 0; }
        .footer { text-align: center; margin-top: 30px; color: #666; font-size: 14px; }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="header">
          <h1>\u{1F510} Redefini\xE7\xE3o de Senha</h1>
          <p>25Stock - Sistema de Gest\xE3o de Estoque</p>
        </div>
        <div class="content">
          <h2>Ol\xE1, ${data.name}!</h2>
          <p>Recebemos uma solicita\xE7\xE3o para redefinir a senha da sua conta no 25Stock.</p>
          <p>Use o c\xF3digo abaixo para redefinir sua senha:</p>
          <div class="code-box">
            <p style="margin: 0 0 10px 0; color: #666;">Seu c\xF3digo de redefini\xE7\xE3o:</p>
            <div class="reset-code">${data.resetCode}</div>
          </div>
          <div class="warning">
            <strong>\u26A0\uFE0F Importante:</strong>
            <ul>
              <li>Este c\xF3digo expira em ${data.expiresIn}</li>
              <li>Se voc\xEA n\xE3o solicitou esta redefini\xE7\xE3o, ignore este email</li>
              <li>Sua senha atual continuar\xE1 funcionando at\xE9 ser alterada</li>
              <li>N\xE3o compartilhe este c\xF3digo com ningu\xE9m</li>
            </ul>
          </div>
          <p>Digite este c\xF3digo na tela de redefini\xE7\xE3o de senha do aplicativo.</p>
        </div>
        <div class="footer">
          <p>Este \xE9 um email autom\xE1tico, n\xE3o responda a esta mensagem.</p>
          <p>&copy; 2024 25Stock. Todos os direitos reservados.</p>
        </div>
      </div>
    </body>
    </html>
  `;
    };
    generatePasswordResetEmailText = (data) => {
      return `
Redefini\xE7\xE3o de Senha - 25Stock

Ol\xE1, ${data.name}!

Recebemos uma solicita\xE7\xE3o para redefinir a senha da sua conta no 25Stock.

Use o c\xF3digo abaixo para redefinir sua senha:

SEU C\xD3DIGO DE REDEFINI\xC7\xC3O: ${data.resetCode}

IMPORTANTE:
- Este c\xF3digo expira em ${data.expiresIn}
- Se voc\xEA n\xE3o solicitou esta redefini\xE7\xE3o, ignore este email
- Sua senha atual continuar\xE1 funcionando at\xE9 ser alterada
- N\xE3o compartilhe este c\xF3digo com ningu\xE9m

Digite este c\xF3digo na tela de redefini\xE7\xE3o de senha do aplicativo.

---
Este \xE9 um email autom\xE1tico, n\xE3o responda a esta mensagem.
\xA9 2024 25Stock. Todos os direitos reservados.
  `;
    };
  }
});

// src/services/email/templates/stock_low.ts
var generateStockLowEmailHTML, generateStockLowEmailText;
var init_stock_low = __esm({
  "src/services/email/templates/stock_low.ts"() {
    generateStockLowEmailHTML = (data) => {
      return `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>${data.title} - 25Stock</title>
      <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0; }
        .content { background: #f9f9f9; padding: 30px; border-radius: 0 0 10px 10px; }
        .button { display: inline-block; background: #f39c12; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; margin: 20px 0; }
        .warning { background: #fff3cd; border: 1px solid #ffeaa7; padding: 15px; border-radius: 5px; margin: 20px 0; }
        .footer { text-align: center; margin-top: 30px; color: #666; font-size: 14px; }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="header">
          <h1>\u26A0\uFE0F ${data.title}</h1>
          <p>25Stock - Sistema de Gest\xE3o de Estoque</p>
        </div>
        <div class="content">
          <h2>Ol\xE1, ${data.name}!</h2>
          <div class="warning">
            <strong>\u{1F6A8} Aten\xE7\xE3o:</strong>
            <p>${data.message}</p>
          </div>
          <p>\xC9 recomendado que voc\xEA fa\xE7a um novo pedido para este produto o quanto antes para evitar a falta de estoque.</p>
          ${data.actionUrl ? `<a href="${data.actionUrl}" class="button">${data.actionText || "Ver Produto"}</a>` : ""}
        </div>
        <div class="footer">
          <p>Este \xE9 um email autom\xE1tico, n\xE3o responda a esta mensagem.</p>
          <p>&copy; 2024 25Stock. Todos os direitos reservados.</p>
        </div>
      </div>
    </body>
    </html>
  `;
    };
    generateStockLowEmailText = (data) => {
      return `
${data.title} - 25Stock

Ol\xE1, ${data.name}!

\u{1F6A8} ATEN\xC7\xC3O: ${data.message}

\xC9 recomendado que voc\xEA fa\xE7a um novo pedido para este produto o quanto antes para evitar a falta de estoque.

${data.actionUrl ? `Acesse: ${data.actionUrl}` : ""}

---
Este \xE9 um email autom\xE1tico, n\xE3o responda a esta mensagem.
\xA9 2024 25Stock. Todos os direitos reservados.
  `;
    };
  }
});

// src/services/email/templates/notification.ts
var generateNotificationEmailHTML, generateNotificationEmailText;
var init_notification = __esm({
  "src/services/email/templates/notification.ts"() {
    generateNotificationEmailHTML = (data) => {
      return `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>${data.title} - 25Stock</title>
      <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0; }
        .content { background: #f9f9f9; padding: 30px; border-radius: 0 0 10px 10px; }
        .button { display: inline-block; background: #3498db; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; margin: 20px 0; }
        .footer { text-align: center; margin-top: 30px; color: #666; font-size: 14px; }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="header">
          <h1>\u{1F4E2} ${data.title}</h1>
          <p>25Stock - Sistema de Gest\xE3o de Estoque</p>
        </div>
        <div class="content">
          <h2>Ol\xE1, ${data.name}!</h2>
          <p>${data.message}</p>
          ${data.actionUrl ? `<a href="${data.actionUrl}" class="button">${data.actionText || "Ver Detalhes"}</a>` : ""}
        </div>
        <div class="footer">
          <p>Este \xE9 um email autom\xE1tico, n\xE3o responda a esta mensagem.</p>
          <p>&copy; 2024 25Stock. Todos os direitos reservados.</p>
        </div>
      </div>
    </body>
    </html>
  `;
    };
    generateNotificationEmailText = (data) => {
      return `
${data.title} - 25Stock

Ol\xE1, ${data.name}!

${data.message}

${data.actionUrl ? `Acesse: ${data.actionUrl}` : ""}

---
Este \xE9 um email autom\xE1tico, n\xE3o responda a esta mensagem.
\xA9 2024 25Stock. Todos os direitos reservados.
  `;
    };
  }
});

// src/services/email/templates/store_invite.ts
var generateStoreInviteEmailHTML, generateStoreInviteEmailText;
var init_store_invite = __esm({
  "src/services/email/templates/store_invite.ts"() {
    generateStoreInviteEmailHTML = (data) => {
      return `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Convite para Loja - 25Stock</title>
      <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0; }
        .content { background: #f9f9f9; padding: 30px; border-radius: 0 0 10px 10px; }
        .button { display: inline-block; background: #27ae60; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; margin: 20px 0; }
        .info { background: #e8f5e8; border: 1px solid #27ae60; padding: 15px; border-radius: 5px; margin: 20px 0; }
        .footer { text-align: center; margin-top: 30px; color: #666; font-size: 14px; }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="header">
          <h1>\u{1F3EA} Convite para Loja</h1>
          <p>25Stock - Sistema de Gest\xE3o de Estoque</p>
        </div>
        <div class="content">
          <h2>Ol\xE1, ${data.name}!</h2>
          <p><strong>${data.inviterName}</strong> convidou voc\xEA para colaborar na loja <strong>"${data.storeName}"</strong> no 25Stock.</p>
          <div class="info">
            <strong>\u{1F4CB} Detalhes do Convite:</strong>
            <ul>
              <li><strong>Loja:</strong> ${data.storeName}</li>
              <li><strong>Convidado por:</strong> ${data.inviterName}</li>
              <li><strong>Expira em:</strong> ${data.expiresIn}</li>
            </ul>
          </div>
          <p>Clique no bot\xE3o abaixo para aceitar o convite:</p>
          <a href="${data.acceptUrl}" class="button">Aceitar Convite</a>
          <p>Se voc\xEA n\xE3o conhece esta pessoa ou n\xE3o deseja participar desta loja, pode ignorar este email.</p>
        </div>
        <div class="footer">
          <p>Este \xE9 um email autom\xE1tico, n\xE3o responda a esta mensagem.</p>
          <p>&copy; 2024 25Stock. Todos os direitos reservados.</p>
        </div>
      </div>
    </body>
    </html>
  `;
    };
    generateStoreInviteEmailText = (data) => {
      return `
Convite para Loja - 25Stock

Ol\xE1, ${data.name}!

${data.inviterName} convidou voc\xEA para colaborar na loja "${data.storeName}" no 25Stock.

Detalhes do Convite:
- Loja: ${data.storeName}
- Convidado por: ${data.inviterName}
- Expira em: ${data.expiresIn}

Aceite o convite em: ${data.acceptUrl}

Se voc\xEA n\xE3o conhece esta pessoa ou n\xE3o deseja participar desta loja, pode ignorar este email.

---
Este \xE9 um email autom\xE1tico, n\xE3o responda a esta mensagem.
\xA9 2024 25Stock. Todos os direitos reservados.
  `;
    };
  }
});

// src/services/email/templates/email_verification.ts
var generateEmailVerificationHTML, generateEmailVerificationText;
var init_email_verification = __esm({
  "src/services/email/templates/email_verification.ts"() {
    generateEmailVerificationHTML = (data) => {
      return `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Confirma\xE7\xE3o de Email - 25Stock</title>
      <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0; }
        .content { background: #f9f9f9; padding: 30px; border-radius: 0 0 10px 10px; }
        .code-container { background: #fff; border: 2px solid #667eea; padding: 20px; border-radius: 10px; text-align: center; margin: 20px 0; }
        .verification-code { font-size: 32px; font-weight: bold; color: #667eea; letter-spacing: 8px; margin: 10px 0; }
        .button { display: inline-block; background: #667eea; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; margin: 20px 0; }
        .warning { background: #fff3cd; border: 1px solid #ffeaa7; padding: 15px; border-radius: 5px; margin: 20px 0; }
        .footer { text-align: center; margin-top: 30px; color: #666; font-size: 14px; }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="header">
          <h1>\u{1F510} Confirma\xE7\xE3o de Email</h1>
          <p>25Stock - Sistema de Gest\xE3o de Estoque</p>
        </div>
        <div class="content">
          <h2>Ol\xE1, ${data.name}!</h2>
          <p>Bem-vindo ao 25Stock! Para confirmar sua conta, use o c\xF3digo de verifica\xE7\xE3o abaixo:</p>
          
          <div class="code-container">
            <p style="margin: 0 0 10px 0; font-size: 18px; color: #666;">Seu c\xF3digo de verifica\xE7\xE3o \xE9:</p>
            <div class="verification-code">${data.verificationCode}</div>
            <p style="margin: 10px 0 0 0; font-size: 14px; color: #666;">Este c\xF3digo expira em ${data.expiresIn}</p>
          </div>

          <p>Digite este c\xF3digo no aplicativo para confirmar seu email e ativar sua conta.</p>
          
          <div class="warning">
            <strong>\u26A0\uFE0F Importante:</strong>
            <ul>
              <li>Este c\xF3digo \xE9 v\xE1lido por ${data.expiresIn}</li>
              <li>N\xE3o compartilhe este c\xF3digo com ningu\xE9m</li>
              <li>Se voc\xEA n\xE3o solicitou esta conta, ignore este email</li>
            </ul>
          </div>

          <p>Se voc\xEA n\xE3o conseguir usar o c\xF3digo, pode solicitar um novo c\xF3digo de verifica\xE7\xE3o no aplicativo.</p>
        </div>
        <div class="footer">
          <p>Este \xE9 um email autom\xE1tico, n\xE3o responda a esta mensagem.</p>
          <p>&copy; 2024 25Stock. Todos os direitos reservados.</p>
        </div>
      </div>
    </body>
    </html>
  `;
    };
    generateEmailVerificationText = (data) => {
      return `
Confirma\xE7\xE3o de Email - 25Stock

Ol\xE1, ${data.name}!

Bem-vindo ao 25Stock! Para confirmar sua conta, use o c\xF3digo de verifica\xE7\xE3o abaixo:

C\xD3DIGO DE VERIFICA\xC7\xC3O: ${data.verificationCode}

Este c\xF3digo expira em ${data.expiresIn}

Digite este c\xF3digo no aplicativo para confirmar seu email e ativar sua conta.

IMPORTANTE:
- Este c\xF3digo \xE9 v\xE1lido por ${data.expiresIn}
- N\xE3o compartilhe este c\xF3digo com ningu\xE9m
- Se voc\xEA n\xE3o solicitou esta conta, ignore este email

Se voc\xEA n\xE3o conseguir usar o c\xF3digo, pode solicitar um novo c\xF3digo de verifica\xE7\xE3o no aplicativo.

---
Este \xE9 um email autom\xE1tico, n\xE3o responda a esta mensagem.
\xA9 2024 25Stock. Todos os direitos reservados.
  `;
    };
  }
});

// src/services/email/templates/index.ts
var init_templates = __esm({
  "src/services/email/templates/index.ts"() {
    init_welcome();
    init_reset_password();
    init_stock_low();
    init_notification();
    init_store_invite();
    init_email_verification();
  }
});

// src/services/email/email.service.ts
var import_resend, resend, EmailService;
var init_email_service = __esm({
  "src/services/email/email.service.ts"() {
    import_resend = require("resend");
    init_templates();
    resend = new import_resend.Resend(process.env.RESEND_API_KEY);
    EmailService = {
      /**
       * Envia email de boas-vindas para novos usuários
       */
      sendWelcomeEmail: async (data) => {
        try {
          const html = generateWelcomeEmailHTML(data);
          const text = generateWelcomeEmailText(data);
          const result = await resend.emails.send({
            from: process.env.FROM_EMAIL || "noreply@25stock.com",
            to: data.email,
            subject: `Bem-vindo ao 25Stock, ${data.name}!`,
            html,
            text
          });
          console.log("Welcome email sent:", result.data?.id);
          return true;
        } catch (error) {
          console.error("Error sending welcome email:", error);
          return false;
        }
      },
      /**
       * Envia email de redefinição de senha
       */
      sendPasswordResetEmail: async (data) => {
        try {
          const html = generatePasswordResetEmailHTML(data);
          const text = generatePasswordResetEmailText(data);
          const result = await resend.emails.send({
            from: process.env.FROM_EMAIL || "noreply@25stock.com",
            to: data.email,
            subject: "Redefini\xE7\xE3o de senha - 25Stock",
            html,
            text
          });
          console.log("Password reset email sent:", result.data?.id);
          return true;
        } catch (error) {
          console.error("Error sending password reset email:", error);
          return false;
        }
      },
      /**
       * Envia email de notificação
       */
      sendNotificationEmail: async (data) => {
        try {
          const html = generateNotificationEmailHTML(data);
          const text = generateNotificationEmailText(data);
          const result = await resend.emails.send({
            from: process.env.FROM_EMAIL || "noreply@25stock.com",
            to: data.email,
            subject: `Notifica\xE7\xE3o - ${data.title}`,
            html,
            text
          });
          console.log("Notification email sent:", result.data?.id);
          return true;
        } catch (error) {
          console.error("Error sending notification email:", error);
          return false;
        }
      },
      /**
       * Envia convite para loja
       */
      sendStoreInviteEmail: async (data) => {
        try {
          const html = generateStoreInviteEmailHTML(data);
          const text = generateStoreInviteEmailText(data);
          const result = await resend.emails.send({
            from: process.env.FROM_EMAIL || "noreply@25stock.com",
            to: data.email,
            subject: `Convite para loja ${data.storeName} - 25Stock`,
            html,
            text
          });
          console.log("Store invite email sent:", result.data?.id);
          return true;
        } catch (error) {
          console.error("Error sending store invite email:", error);
          return false;
        }
      },
      /**
       * Envia email de notificação de estoque baixo
       */
      sendStockLowEmail: async (data) => {
        try {
          const html = generateStockLowEmailHTML(data);
          const text = generateStockLowEmailText(data);
          const result = await resend.emails.send({
            from: process.env.FROM_EMAIL || "noreply@25stock.com",
            to: data.email,
            subject: `\u26A0\uFE0F ${data.title} - 25Stock`,
            html,
            text
          });
          console.log("Stock low email sent:", result.data?.id);
          return true;
        } catch (error) {
          console.error("Error sending stock low email:", error);
          return false;
        }
      },
      /**
       * Envia email de verificação com código de 6 dígitos
       */
      sendEmailVerification: async (data) => {
        try {
          const html = generateEmailVerificationHTML(data);
          const text = generateEmailVerificationText(data);
          const result = await resend.emails.send({
            from: process.env.FROM_EMAIL || "noreply@25stock.com",
            to: data.email,
            subject: `Confirma\xE7\xE3o de Email - 25Stock`,
            html,
            text
          });
          console.log("Email verification sent:", result.data?.id);
          return true;
        } catch (error) {
          console.error("Error sending email verification:", error);
          return false;
        }
      },
      /**
       * Envia email genérico
       */
      sendEmail: async (template) => {
        try {
          const result = await resend.emails.send({
            from: process.env.FROM_EMAIL || "noreply@25stock.com",
            to: template.to,
            subject: template.subject,
            html: template.html,
            text: template.text
          });
          console.log("Email sent:", result.data?.id);
          return true;
        } catch (error) {
          console.error("Error sending email:", error);
          return false;
        }
      }
    };
  }
});

// src/features/auth/commands/auth.commands.ts
var import_bcryptjs2, import_jsonwebtoken, import_crypto, import_google_auth_library, AuthCommands;
var init_auth_commands = __esm({
  "src/features/auth/commands/auth.commands.ts"() {
    import_bcryptjs2 = __toESM(require("bcryptjs"));
    import_jsonwebtoken = __toESM(require("jsonwebtoken"));
    import_crypto = __toESM(require("crypto"));
    init_prisma();
    init_auth_queries();
    init_email_service();
    import_google_auth_library = require("google-auth-library");
    AuthCommands = {
      async register(data) {
        const { name, email, password, phone } = data;
        const existingUser = await db.user.findUnique({
          where: { email }
        });
        if (existingUser) {
          throw new Error("User already exists with this email");
        }
        const hashedPassword = await import_bcryptjs2.default.hash(password, 12);
        const emailVerificationCode = AuthCommands.generateVerificationCode();
        const emailVerificationCodeExpires = new Date(Date.now() + 15 * 60 * 1e3);
        const emailVerificationToken = AuthCommands.generateVerificationToken();
        const user = await db.user.create({
          data: {
            name,
            email,
            phone,
            password: hashedPassword,
            emailVerificationToken,
            emailVerificationCode,
            emailVerificationCodeExpires,
            emailVerified: false
          },
          select: {
            id: true,
            name: true,
            email: true,
            phone: true,
            emailVerified: true,
            createdAt: true
          }
        });
        try {
          await EmailService.sendEmailVerification({
            name,
            email,
            verificationCode: emailVerificationCode,
            expiresIn: "15 minutos"
          });
        } catch (error) {
          console.error("Failed to send verification email:", error);
        }
        return user;
      },
      async login(data) {
        const { email, password } = data;
        const user = await db.user.findUnique({
          where: { email, status: true }
        });
        if (!user) {
          throw new Error("Invalid credentials");
        }
        const isValidPassword = await import_bcryptjs2.default.compare(password, user.password);
        if (!isValidPassword) {
          throw new Error("Invalid credentials");
        }
        if (!user.emailVerified) {
          throw new Error("Email verification required");
        }
        await db.user.update({
          where: { id: user.id },
          data: { lastLoginAt: /* @__PURE__ */ new Date() }
        });
        const store = await AuthQueries.getStoreByOwner(user.id);
        const token = AuthCommands.generateJWT({
          userId: user.id,
          email: user.email,
          roles: user.roles
        });
        return {
          user: {
            id: user.id,
            name: user.name,
            email: user.email,
            emailVerified: user.emailVerified,
            lastLoginAt: /* @__PURE__ */ new Date()
          },
          store: store || void 0,
          token
        };
      },
      async forgotPassword(email) {
        const user = await db.user.findUnique({
          where: { email, status: true }
        });
        if (!user) {
          throw new Error("User not found");
        }
        const resetCode = AuthCommands.generateVerificationCode();
        const resetExpires = new Date(Date.now() + 15 * 60 * 1e3);
        await db.user.update({
          where: { id: user.id },
          data: {
            resetPasswordCode: resetCode,
            resetPasswordExpires: resetExpires
          }
        });
        try {
          await EmailService.sendPasswordResetEmail({
            name: user.name,
            email: user.email,
            resetCode,
            expiresIn: "15 minutos"
          });
        } catch (error) {
          console.error("Failed to send reset password email:", error);
        }
        return { message: "Reset password code sent to email" };
      },
      async verifyResetCode(email, code) {
        const user = await db.user.findFirst({
          where: {
            email,
            resetPasswordCode: code,
            resetPasswordExpires: {
              gt: /* @__PURE__ */ new Date()
            }
          }
        });
        if (!user) {
          throw new Error("Invalid or expired reset code");
        }
        if (user.resetPasswordExpires && user.resetPasswordExpires < /* @__PURE__ */ new Date()) {
          throw new Error("Reset code expired");
        }
        return { message: "Reset code verified successfully" };
      },
      async resetPassword(email, code, newPassword) {
        const user = await db.user.findFirst({
          where: {
            email,
            resetPasswordCode: code,
            resetPasswordExpires: {
              gt: /* @__PURE__ */ new Date()
            }
          }
        });
        if (!user) {
          throw new Error("Invalid or expired reset code");
        }
        if (user.resetPasswordExpires && user.resetPasswordExpires < /* @__PURE__ */ new Date()) {
          throw new Error("Reset code expired");
        }
        const hashedPassword = await import_bcryptjs2.default.hash(newPassword, 12);
        await db.user.update({
          where: { id: user.id },
          data: {
            password: hashedPassword,
            resetPasswordCode: null,
            resetPasswordExpires: null
          }
        });
        return { message: "Password reset successfully" };
      },
      async verifyEmail(token) {
        const user = await db.user.findFirst({
          where: {
            emailVerificationToken: token,
            emailVerified: false
          }
        });
        if (!user) {
          throw new Error("Invalid verification token");
        }
        await db.user.update({
          where: { id: user.id },
          data: {
            emailVerified: true,
            emailVerificationToken: null
          }
        });
        return { message: "Email verified successfully" };
      },
      async verifyEmailCode(email, code) {
        const user = await db.user.findFirst({
          where: {
            email,
            emailVerificationCode: code,
            emailVerificationCodeExpires: {
              gt: /* @__PURE__ */ new Date()
            },
            emailVerified: false
          }
        });
        if (!user) {
          throw new Error("Invalid verification code");
        }
        if (user.emailVerificationCodeExpires && user.emailVerificationCodeExpires < /* @__PURE__ */ new Date()) {
          throw new Error("Verification code expired");
        }
        const updatedUser = await db.user.update({
          where: { id: user.id },
          data: {
            emailVerified: true,
            emailVerificationToken: null,
            emailVerificationCode: null,
            emailVerificationCodeExpires: null
          },
          select: {
            id: true,
            name: true,
            email: true,
            emailVerified: true,
            createdAt: true
          }
        });
        return updatedUser;
      },
      async resendVerification(email) {
        const user = await db.user.findUnique({
          where: { email, status: true }
        });
        if (!user) {
          throw new Error("User not found");
        }
        if (user.emailVerified) {
          throw new Error("Email already verified");
        }
        const emailVerificationCode = AuthCommands.generateVerificationCode();
        const emailVerificationCodeExpires = new Date(Date.now() + 15 * 60 * 1e3);
        const emailVerificationToken = AuthCommands.generateVerificationToken();
        await db.user.update({
          where: { id: user.id },
          data: {
            emailVerificationCode,
            emailVerificationCodeExpires,
            emailVerificationToken
          }
        });
        try {
          await EmailService.sendEmailVerification({
            name: user.name,
            email: user.email,
            verificationCode: emailVerificationCode,
            expiresIn: "15 minutos"
          });
        } catch (error) {
          console.error("Failed to send verification email:", error);
        }
        return { message: "Verification email sent" };
      },
      async refreshToken(userId) {
        const user = await db.user.findUnique({
          where: { id: userId, status: true }
        });
        if (!user) {
          throw new Error("User not found");
        }
        const token = AuthCommands.generateJWT({
          userId: user.id,
          email: user.email,
          roles: user.roles
        });
        return { token, message: "Token refreshed successfully" };
      },
      // Helper methods
      generateJWT(payload) {
        const secret = process.env.JWT_SECRET || "your-secret-key";
        return import_jsonwebtoken.default.sign(payload, secret, { expiresIn: "7d" });
      },
      generateResetToken() {
        return import_crypto.default.randomBytes(32).toString("hex");
      },
      generateVerificationToken() {
        return import_crypto.default.randomBytes(32).toString("hex");
      },
      generateVerificationCode() {
        return Math.floor(1e5 + Math.random() * 9e5).toString();
      },
      // Verify JWT token
      verifyToken(token) {
        const secret = process.env.JWT_SECRET || "your-secret-key";
        return import_jsonwebtoken.default.verify(token, secret);
      },
      // Extract token from Authorization header
      extractToken(authHeader) {
        if (!authHeader || !authHeader.startsWith("Bearer ")) {
          throw new Error("Invalid authorization header");
        }
        return authHeader.substring(7);
      },
      async updateProfile(userId, data) {
        const { name, email } = data;
        if (email) {
          const existingUser = await db.user.findFirst({
            where: {
              email,
              id: { not: userId }
            }
          });
          if (existingUser) {
            throw new Error("Email already exists");
          }
        }
        const updateData = {};
        if (name) updateData.name = name;
        if (email) {
          updateData.email = email;
          updateData.emailVerified = false;
          updateData.emailVerificationToken = AuthCommands.generateVerificationToken();
        }
        const user = await db.user.update({
          where: { id: userId },
          data: updateData,
          select: {
            id: true,
            email: true,
            name: true,
            emailVerified: true,
            status: true,
            roles: true,
            lastLoginAt: true,
            createdAt: true,
            updatedAt: true
          }
        });
        return user;
      },
      async googleLogin(token) {
        if (!process.env.GOOGLE_CLIENT_ID) {
          throw new Error("Google OAuth configuration missing");
        }
        const client = new import_google_auth_library.OAuth2Client(process.env.GOOGLE_CLIENT_ID);
        try {
          const ticket = await client.verifyIdToken({
            idToken: token,
            audience: process.env.GOOGLE_CLIENT_ID
          });
          const payload = ticket.getPayload();
          if (!payload || !payload.email || !payload.name) {
            throw new Error("Invalid Google token payload");
          }
          let user = await db.user.findUnique({
            where: { email: payload.email }
          });
          if (!user) {
            user = await db.user.create({
              data: {
                name: payload.name,
                email: payload.email,
                emailVerified: true,
                // Google já verifica o email
                status: true,
                roles: ["USER"],
                // Role padrão
                phone: "",
                // Campo obrigatório mas não temos do Google
                password: "",
                // Campo obrigatório mas não usamos para login Google
                lastLoginAt: /* @__PURE__ */ new Date(),
                // User preferences defaults
                theme: "light",
                language: "pt-BR",
                currency: "BRL",
                timezone: "America/Sao_Paulo",
                dateFormat: "DD/MM/YYYY",
                timeFormat: "24h",
                dashboard: null
              }
            });
          } else {
            await db.user.update({
              where: { id: user.id },
              data: { lastLoginAt: /* @__PURE__ */ new Date() }
            });
          }
          if (!user.status) {
            throw new Error("User account is disabled");
          }
          const store = await AuthQueries.getStoreByOwner(user.id);
          const jwtToken = AuthCommands.generateJWT({
            userId: user.id,
            email: user.email,
            roles: user.roles
          });
          return {
            user: {
              id: user.id,
              name: user.name,
              email: user.email,
              emailVerified: user.emailVerified,
              lastLoginAt: user.lastLoginAt
            },
            store: store || void 0,
            token: jwtToken
          };
        } catch (error) {
          console.error("Google Login Error:", error);
          if (error.message === "Google OAuth configuration missing") {
            throw new Error("Google OAuth configuration missing");
          }
          if (error.message === "Invalid Google token payload") {
            throw new Error("Invalid Google token");
          }
          if (error.message === "User account is disabled") {
            throw new Error("User account is disabled");
          }
          throw new Error("Invalid Google token");
        }
      }
    };
  }
});

// src/middlewares/auth.middleware.ts
var auth_middleware_exports = {};
__export(auth_middleware_exports, {
  authMiddleware: () => authMiddleware,
  optionalAuthMiddleware: () => optionalAuthMiddleware
});
var authMiddleware, optionalAuthMiddleware;
var init_auth_middleware = __esm({
  "src/middlewares/auth.middleware.ts"() {
    init_auth_commands();
    init_auth_queries();
    authMiddleware = async (request, reply) => {
      try {
        const authHeader = request.headers.authorization;
        if (!authHeader) {
          return reply.status(401).send({
            error: "Authorization header required"
          });
        }
        const token = AuthCommands.extractToken(authHeader);
        const payload = AuthCommands.verifyToken(token);
        const user = await AuthQueries.getUserProfile(payload.userId);
        if (!user || !user.status) {
          return reply.status(401).send({
            error: "User not found or inactive"
          });
        }
        request.user = user;
        request.token = token;
        return;
      } catch (error) {
        request.log.error(error);
        if (error.message === "Invalid authorization header") {
          return reply.status(401).send({
            error: "Invalid authorization header format"
          });
        }
        if (error.name === "JsonWebTokenError") {
          return reply.status(401).send({
            error: "Invalid token"
          });
        }
        if (error.name === "TokenExpiredError") {
          return reply.status(401).send({
            error: "Token expired"
          });
        }
        return reply.status(500).send({
          error: "Internal server error"
        });
      }
    };
    optionalAuthMiddleware = async (request, reply) => {
      try {
        const authHeader = request.headers.authorization;
        if (!authHeader) {
          return;
        }
        const token = AuthCommands.extractToken(authHeader);
        const payload = AuthCommands.verifyToken(token);
        const user = await AuthQueries.getUserProfile(payload.userId);
        if (user && user.status) {
          request.user = user;
          request.token = token;
        }
        return;
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : "Unknown error";
        request.log.warn(`Optional auth failed: ${errorMessage}`);
        return;
      }
    };
  }
});

// src/server.ts
var import_fastify = __toESM(require("fastify"));
var import_cors = __toESM(require("@fastify/cors"));
init_prisma();

// src/features/user/commands/user.commands.ts
var import_bcryptjs = __toESM(require("bcryptjs"));
init_prisma();
var UserCommands = {
  async create(data) {
    const existingUser = await db.user.findUnique({
      where: { email: data.email }
    });
    if (existingUser) {
      throw new Error("User with this email already exists");
    }
    const hashedPassword = await import_bcryptjs.default.hash(data.password, 12);
    const user = await db.user.create({
      data: {
        email: data.email,
        password: hashedPassword,
        name: data.name,
        roles: data.roles || ["user"]
      },
      select: {
        id: true,
        email: true,
        name: true,
        roles: true,
        status: true,
        createdAt: true
      }
    });
    return user;
  },
  async update(id, data) {
    const existingUser = await db.user.findUnique({
      where: { id }
    });
    if (!existingUser) {
      throw new Error("User not found");
    }
    const updateData = { ...data };
    if (updateData.password) {
      updateData.password = await import_bcryptjs.default.hash(updateData.password, 12);
    }
    if (updateData.email && updateData.email !== existingUser.email) {
      const emailExists = await db.user.findUnique({
        where: { email: updateData.email }
      });
      if (emailExists) {
        throw new Error("Email already exists");
      }
    }
    const user = await db.user.update({
      where: { id },
      data: updateData,
      select: {
        id: true,
        email: true,
        name: true,
        roles: true,
        status: true,
        emailVerified: true,
        updatedAt: true
      }
    });
    return user;
  },
  async delete(id) {
    const existingUser = await db.user.findUnique({
      where: { id }
    });
    if (!existingUser) {
      throw new Error("User not found");
    }
    await db.user.update({
      where: { id },
      data: { status: false }
    });
    return { success: true };
  },
  async verifyEmail(id) {
    const user = await db.user.update({
      where: { id },
      data: { emailVerified: true },
      select: {
        id: true,
        email: true,
        emailVerified: true,
        updatedAt: true
      }
    });
    return user;
  },
  async updateLastLogin(id) {
    await db.user.update({
      where: { id },
      data: { lastLoginAt: /* @__PURE__ */ new Date() }
    });
    return { success: true };
  }
};

// src/utils/pagination.ts
var PaginationUtils = {
  /**
   * Normaliza os parâmetros de paginação
   */
  normalizeParams(params, options = {}) {
    const {
      defaultPage = 1,
      defaultLimit = 10,
      maxLimit = 100
    } = options;
    const page = Math.max(1, params.page || defaultPage);
    const limit = Math.min(maxLimit, Math.max(1, params.limit || defaultLimit));
    const skip2 = (page - 1) * limit;
    return { page, limit, skip: skip2 };
  },
  /**
   * Cria o objeto de paginação com metadados
   */
  createPaginationMeta(page, limit, total) {
    const totalPages = Math.ceil(total / limit);
    return {
      page,
      limit,
      total,
      totalPages,
      hasNext: page < totalPages,
      hasPrev: page > 1
    };
  },
  /**
   * Executa uma consulta paginada com Prisma
   */
  async paginate(prisma2, model2, options) {
    const {
      where = {},
      select,
      include,
      orderBy = { createdAt: "desc" },
      params = {},
      paginationOptions = {}
    } = options;
    const { page, limit, skip: skip2 } = this.normalizeParams(params, paginationOptions);
    const queryOptions = {
      where,
      skip: skip2,
      take: limit,
      orderBy
    };
    if (select) {
      queryOptions.select = select;
    }
    if (include) {
      queryOptions.include = include;
    }
    const [data, total] = await Promise.all([
      prisma2[model2].findMany(queryOptions),
      prisma2[model2].count({ where })
    ]);
    return {
      data,
      pagination: this.createPaginationMeta(page, limit, total)
    };
  },
  /**
   * Cria um helper para queries específicas com paginação
   */
  createPaginatedQuery(model2, defaultOptions = {}) {
    return async (prisma2, params) => {
      const { where, ...paginationParams } = params;
      return this.paginate(prisma2, model2, {
        ...defaultOptions,
        where: where || {},
        params: paginationParams
      });
    };
  },
  /**
   * Utilitário para transformar dados paginados em formato específico
   */
  transformPaginationResult(result, dataKey, transformer) {
    const transformedData = transformer ? result.data.map(transformer) : result.data;
    return {
      [dataKey]: transformedData,
      pagination: result.pagination
    };
  }
};

// src/features/user/querys/user.query.ts
init_prisma();
var UserQueries = {
  async getById(id) {
    const user = await db.user.findUnique({
      where: { id },
      select: {
        id: true,
        email: true,
        name: true,
        roles: true,
        status: true,
        emailVerified: true,
        lastLoginAt: true,
        createdAt: true,
        updatedAt: true
      }
    });
    if (!user) {
      throw new Error("User not found");
    }
    return user;
  },
  async getByEmail(email) {
    const user = await db.user.findUnique({
      where: { email },
      select: {
        id: true,
        email: true,
        name: true,
        roles: true,
        status: true,
        emailVerified: true,
        lastLoginAt: true,
        createdAt: true,
        updatedAt: true
      }
    });
    return user;
  },
  async getByEmailWithPassword(email) {
    const user = await db.user.findUnique({
      where: { email },
      select: {
        id: true,
        email: true,
        password: true,
        name: true,
        roles: true,
        status: true,
        emailVerified: true,
        lastLoginAt: true,
        createdAt: true,
        updatedAt: true
      }
    });
    return user;
  },
  async list(filters) {
    const where = {};
    if (filters.search) {
      where.OR = [
        { email: { contains: filters.search, mode: "insensitive" } },
        { name: { contains: filters.search, mode: "insensitive" } }
      ];
    }
    if (filters.status !== void 0) {
      where.status = filters.status;
    }
    if (filters.roles && filters.roles.length > 0) {
      where.roles = {
        hasSome: filters.roles
      };
    }
    const result = await PaginationUtils.paginate(db, "user", {
      where,
      select: {
        id: true,
        email: true,
        name: true,
        roles: true,
        status: true,
        emailVerified: true,
        lastLoginAt: true,
        createdAt: true
      },
      orderBy: { createdAt: "desc" },
      params: {
        page: filters.page,
        limit: filters.limit
      },
      paginationOptions: {
        defaultPage: 1,
        defaultLimit: 10,
        maxLimit: 100
      }
    });
    return PaginationUtils.transformPaginationResult(
      result,
      "users"
    );
  },
  async getByRole(role) {
    const users = await db.user.findMany({
      where: {
        roles: {
          has: role
        },
        status: true
      },
      select: {
        id: true,
        email: true,
        name: true,
        roles: true,
        status: true,
        emailVerified: true,
        lastLoginAt: true,
        createdAt: true
      },
      orderBy: { createdAt: "desc" }
    });
    return users;
  },
  async getActive() {
    const users = await db.user.findMany({
      where: { status: true },
      select: {
        id: true,
        email: true,
        name: true,
        roles: true,
        emailVerified: true,
        lastLoginAt: true,
        createdAt: true
      },
      orderBy: { createdAt: "desc" }
    });
    return users;
  },
  async getStats() {
    const [total, active, inactive, verified, unverified] = await Promise.all([
      db.user.count(),
      db.user.count({ where: { status: true } }),
      db.user.count({ where: { status: false } }),
      db.user.count({ where: { emailVerified: true } }),
      db.user.count({ where: { emailVerified: false } })
    ]);
    return {
      total,
      active,
      inactive,
      verified,
      unverified
    };
  },
  async checkEmailExists(email) {
    const user = await db.user.findUnique({
      where: { email },
      select: { id: true }
    });
    return !!user;
  },
  async search(searchTerm, limit = 10) {
    const users = await db.user.findMany({
      where: {
        OR: [
          { email: { contains: searchTerm, mode: "insensitive" } },
          { name: { contains: searchTerm, mode: "insensitive" } }
        ],
        status: true
      },
      select: {
        id: true,
        email: true,
        name: true,
        roles: true,
        emailVerified: true
      },
      take: limit,
      orderBy: { name: "asc" }
    });
    return users;
  }
};

// src/features/user/user.controller.ts
var UserController = {
  async create(request, reply) {
    try {
      const { email, password, name, roles = ["user"] } = request.body;
      const user = await UserCommands.create({
        email,
        password,
        name,
        roles
      });
      return reply.status(201).send(user);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User with this email already exists") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      const user = await UserQueries.getById(id);
      return reply.send(user);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      const user = await UserCommands.update(id, updateData);
      return reply.send(user);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Email already exists") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      await UserCommands.delete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const {
        page = 1,
        limit = 10,
        search,
        status
      } = request.query;
      const result = await UserQueries.list({
        page,
        limit,
        search,
        status
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // Funções adicionais usando queries
  async getByEmail(request, reply) {
    try {
      const { email } = request.query;
      const user = await UserQueries.getByEmail(email);
      if (!user) {
        return reply.status(404).send({
          error: "User not found"
        });
      }
      return reply.send(user);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByRole(request, reply) {
    try {
      const { role } = request.params;
      const users = await UserQueries.getByRole(role);
      return reply.send({ users });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getActive(request, reply) {
    try {
      const users = await UserQueries.getActive();
      return reply.send({ users });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const stats = await UserQueries.getStats();
      return reply.send(stats);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { q, limit = 10 } = request.query;
      const users = await UserQueries.search(q, limit);
      return reply.send({ users });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // Funções adicionais usando commands
  async verifyEmail(request, reply) {
    try {
      const { id } = request.params;
      const user = await UserCommands.verifyEmail(id);
      return reply.send(user);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async updateLastLogin(request, reply) {
    try {
      const { id } = request.params;
      await UserCommands.updateLastLogin(id);
      return reply.send({ success: true });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/user/user.schema.ts
var createUserSchema = {
  body: {
    type: "object",
    required: ["email", "password", "name"],
    properties: {
      email: { type: "string", format: "email" },
      password: { type: "string", minLength: 6 },
      name: { type: "string", minLength: 2 },
      roles: {
        type: "array",
        items: { type: "string" },
        default: ["user"]
      }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        email: { type: "string" },
        name: { type: "string" },
        roles: { type: "array", items: { type: "string" } },
        status: { type: "boolean" },
        createdAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var getUserSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        email: { type: "string" },
        name: { type: "string" },
        roles: { type: "array", items: { type: "string" } },
        status: { type: "boolean" },
        emailVerified: { type: "boolean" },
        lastLoginAt: { type: "string", format: "date-time" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var updateUserSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      email: { type: "string", format: "email" },
      password: { type: "string", minLength: 6 },
      name: { type: "string", minLength: 2 },
      roles: { type: "array", items: { type: "string" } },
      status: { type: "boolean" },
      emailVerified: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        email: { type: "string" },
        name: { type: "string" },
        roles: { type: "array", items: { type: "string" } },
        status: { type: "boolean" },
        emailVerified: { type: "boolean" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var deleteUserSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" }
  }
};
var listUsersSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      status: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        users: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              email: { type: "string" },
              name: { type: "string" },
              roles: { type: "array", items: { type: "string" } },
              status: { type: "boolean" },
              emailVerified: { type: "boolean" },
              lastLoginAt: { type: "string", format: "date-time" },
              createdAt: { type: "string", format: "date-time" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var UserSchemas = {
  create: createUserSchema,
  get: getUserSchema,
  update: updateUserSchema,
  delete: deleteUserSchema,
  list: listUsersSchema
};

// src/features/user/user.routes.ts
async function UserRoutes(fastify2) {
  fastify2.post("/", {
    schema: UserSchemas.create,
    handler: UserController.create
  });
  fastify2.get("/", {
    schema: UserSchemas.list,
    handler: UserController.list
  });
  fastify2.get("/:id", {
    schema: UserSchemas.get,
    handler: UserController.get
  });
  fastify2.put("/:id", {
    schema: UserSchemas.update,
    handler: UserController.update
  });
  fastify2.delete("/:id", {
    schema: UserSchemas.delete,
    handler: UserController.delete
  });
  fastify2.get("/email", {
    handler: UserController.getByEmail
  });
  fastify2.get("/role/:role", {
    handler: UserController.getByRole
  });
  fastify2.get("/active", {
    handler: UserController.getActive
  });
  fastify2.get("/stats", {
    handler: UserController.getStats
  });
  fastify2.get("/search", {
    handler: UserController.search
  });
  fastify2.patch("/:id/verify-email", {
    handler: UserController.verifyEmail
  });
  fastify2.patch("/:id/last-login", {
    handler: UserController.updateLastLogin
  });
}

// src/features/auth/auth.controller.ts
init_auth_commands();
init_auth_queries();

// src/features/user-preferences/queries/user-preferences.query.ts
init_prisma();
var UserPreferencesQueries = {
  // ================================
  // GET OPERATIONS
  // ================================
  async getById(id) {
    try {
      const preferences = await db.userPreferences.findUnique({
        where: { id },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      });
      if (!preferences) {
        throw new Error("User preferences not found");
      }
      return preferences;
    } catch (error) {
      throw new Error(`Failed to get user preferences: ${error.message}`);
    }
  },
  async getByUserId(userId) {
    try {
      const preferences = await db.userPreferences.findUnique({
        where: { userId },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      });
      if (!preferences) {
        throw new Error("User preferences not found");
      }
      return preferences;
    } catch (error) {
      throw new Error(`Failed to get user preferences: ${error.message}`);
    }
  },
  async getByUserIdOrCreate(userId) {
    try {
      const user = await db.user.findUnique({
        where: { id: userId },
        select: { id: true, name: true, email: true }
      });
      if (!user) {
        throw new Error("User not found");
      }
      let preferences = await db.userPreferences.findUnique({
        where: { userId },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      });
      if (!preferences) {
        preferences = await db.userPreferences.create({
          data: {
            userId,
            theme: "light",
            language: "pt-BR",
            currency: "BRL",
            timezone: "America/Sao_Paulo",
            dateFormat: "DD/MM/YYYY",
            timeFormat: "24h",
            numberFormat: "pt-BR",
            emailNotifications: true,
            pushNotifications: true,
            smsNotifications: false,
            itemsPerPage: 20,
            autoRefresh: true,
            refreshInterval: 30
          },
          include: {
            user: {
              select: {
                id: true,
                name: true,
                email: true
              }
            }
          }
        });
      }
      return preferences;
    } catch (error) {
      throw new Error(`Failed to get or create user preferences: ${error.message}`);
    }
  },
  // ================================
  // LIST OPERATIONS
  // ================================
  async list(filters = {}) {
    try {
      const {
        page = 1,
        limit = 10,
        search,
        theme,
        language,
        currency,
        timezone,
        hasCustomSettings,
        notificationsEnabled
      } = filters;
      const skip2 = (page - 1) * limit;
      const where = {};
      if (search) {
        where.OR = [
          {
            user: {
              name: {
                contains: search,
                mode: "insensitive"
              }
            }
          },
          {
            user: {
              email: {
                contains: search,
                mode: "insensitive"
              }
            }
          }
        ];
      }
      if (theme) {
        where.theme = theme;
      }
      if (language) {
        where.language = language;
      }
      if (currency) {
        where.currency = currency;
      }
      if (timezone) {
        where.timezone = timezone;
      }
      if (hasCustomSettings !== void 0) {
        if (hasCustomSettings) {
          where.customSettings = {
            not: null
          };
        } else {
          where.customSettings = null;
        }
      }
      if (notificationsEnabled !== void 0) {
        where.emailNotifications = notificationsEnabled;
      }
      const [preferences, total] = await Promise.all([
        db.userPreferences.findMany({
          where,
          skip: skip2,
          take: limit,
          orderBy: {
            updatedAt: "desc"
          },
          include: {
            user: {
              select: {
                id: true,
                name: true,
                email: true
              }
            }
          }
        }),
        db.userPreferences.count({ where })
      ]);
      return {
        preferences,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit)
        }
      };
    } catch (error) {
      throw new Error(`Failed to list user preferences: ${error.message}`);
    }
  },
  // ================================
  // SEARCH OPERATIONS
  // ================================
  async search(searchTerm, limit = 10) {
    try {
      const preferences = await db.userPreferences.findMany({
        where: {
          OR: [
            {
              user: {
                name: {
                  contains: searchTerm,
                  mode: "insensitive"
                }
              }
            },
            {
              user: {
                email: {
                  contains: searchTerm,
                  mode: "insensitive"
                }
              }
            },
            {
              language: {
                contains: searchTerm,
                mode: "insensitive"
              }
            },
            {
              currency: {
                contains: searchTerm,
                mode: "insensitive"
              }
            }
          ]
        },
        take: limit,
        orderBy: {
          updatedAt: "desc"
        },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      });
      return preferences;
    } catch (error) {
      throw new Error(`Failed to search user preferences: ${error.message}`);
    }
  },
  // ================================
  // STATS OPERATIONS
  // ================================
  async getStats() {
    try {
      const [
        totalPreferences,
        themeStats,
        languageStats,
        currencyStats,
        itemsPerPageStats,
        notificationsStats
      ] = await Promise.all([
        db.userPreferences.count(),
        db.userPreferences.groupBy({
          by: ["theme"],
          _count: {
            theme: true
          }
        }),
        db.userPreferences.groupBy({
          by: ["language"],
          _count: {
            language: true
          }
        }),
        db.userPreferences.groupBy({
          by: ["currency"],
          _count: {
            currency: true
          }
        }),
        db.userPreferences.aggregate({
          _avg: {
            itemsPerPage: true
          }
        }),
        db.userPreferences.groupBy({
          by: ["emailNotifications"],
          _count: {
            emailNotifications: true
          }
        })
      ]);
      const themeDistribution = {
        light: 0,
        dark: 0,
        auto: 0
      };
      themeStats.forEach((stat) => {
        if (stat.theme === "light") themeDistribution.light = stat._count.theme;
        if (stat.theme === "dark") themeDistribution.dark = stat._count.theme;
        if (stat.theme === "auto") themeDistribution.auto = stat._count.theme;
      });
      const languageDistribution = {};
      languageStats.forEach((stat) => {
        languageDistribution[stat.language] = stat._count.language;
      });
      const currencyDistribution = {};
      currencyStats.forEach((stat) => {
        currencyDistribution[stat.currency] = stat._count.currency;
      });
      let notificationsEnabled = 0;
      let notificationsDisabled = 0;
      notificationsStats.forEach((stat) => {
        if (stat.emailNotifications) {
          notificationsEnabled = stat._count.emailNotifications;
        } else {
          notificationsDisabled = stat._count.emailNotifications;
        }
      });
      return {
        totalPreferences,
        themeDistribution,
        languageDistribution,
        currencyDistribution,
        averageItemsPerPage: Math.round(itemsPerPageStats._avg.itemsPerPage || 20),
        notificationsEnabled,
        notificationsDisabled
      };
    } catch (error) {
      throw new Error(`Failed to get user preferences stats: ${error.message}`);
    }
  },
  // ================================
  // FILTER OPERATIONS
  // ================================
  async getByTheme(theme) {
    try {
      const preferences = await db.userPreferences.findMany({
        where: { theme },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        },
        orderBy: {
          updatedAt: "desc"
        }
      });
      return preferences;
    } catch (error) {
      throw new Error(`Failed to get user preferences by theme: ${error.message}`);
    }
  },
  async getByLanguage(language) {
    try {
      const preferences = await db.userPreferences.findMany({
        where: { language },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        },
        orderBy: {
          updatedAt: "desc"
        }
      });
      return preferences;
    } catch (error) {
      throw new Error(`Failed to get user preferences by language: ${error.message}`);
    }
  },
  async getByCurrency(currency) {
    try {
      const preferences = await db.userPreferences.findMany({
        where: { currency },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        },
        orderBy: {
          updatedAt: "desc"
        }
      });
      return preferences;
    } catch (error) {
      throw new Error(`Failed to get user preferences by currency: ${error.message}`);
    }
  },
  async getWithCustomSettings() {
    try {
      const preferences = await db.userPreferences.findMany({
        where: {
          customSettings: {
            not: null
          }
        },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        },
        orderBy: {
          updatedAt: "desc"
        }
      });
      return preferences;
    } catch (error) {
      throw new Error(`Failed to get user preferences with custom settings: ${error.message}`);
    }
  },
  // ================================
  // VALIDATION OPERATIONS
  // ================================
  async validatePreferences(data) {
    try {
      const errors = [];
      const warnings = [];
      if (data.theme && !["light", "dark", "auto"].includes(data.theme)) {
        errors.push("Theme must be one of: light, dark, auto");
      }
      if (data.dateFormat && !["DD/MM/YYYY", "MM/DD/YYYY", "YYYY-MM-DD"].includes(data.dateFormat)) {
        errors.push("Date format must be one of: DD/MM/YYYY, MM/DD/YYYY, YYYY-MM-DD");
      }
      if (data.timeFormat && !["12h", "24h"].includes(data.timeFormat)) {
        errors.push("Time format must be one of: 12h, 24h");
      }
      if (data.itemsPerPage && (data.itemsPerPage < 5 || data.itemsPerPage > 100)) {
        warnings.push("Items per page should be between 5 and 100");
      }
      if (data.refreshInterval && (data.refreshInterval < 10 || data.refreshInterval > 300)) {
        warnings.push("Refresh interval should be between 10 and 300 seconds");
      }
      return {
        isValid: errors.length === 0,
        errors,
        warnings
      };
    } catch (error) {
      throw new Error(`Failed to validate user preferences: ${error.message}`);
    }
  }
};

// src/features/auth/auth.controller.ts
var AuthController = {
  // === AUTH CRUD ===
  async register(request, reply) {
    try {
      const { name, email, password, phone } = request.body;
      const user = await AuthCommands.register({
        name,
        email,
        phone,
        password
      });
      return reply.status(201).send({
        user,
        message: "Usu\xE1rio registrado com sucesso. Verifique seu email para o c\xF3digo de confirma\xE7\xE3o de 6 d\xEDgitos."
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "User already exists with this email") {
        return reply.status(409).send({
          error: "J\xE1 existe um usu\xE1rio com este email"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async login(request, reply) {
    try {
      const { email, password } = request.body;
      const result = await AuthCommands.login({
        email,
        password
      });
      return reply.send({
        user: result.user,
        store: result.store,
        token: result.token,
        message: "Login successful",
        preferences: await UserPreferencesQueries.getByUserIdOrCreate(result.user.id)
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invalid credentials") {
        return reply.status(401).send({
          error: error.message
        });
      }
      if (error.message === "Email verification required") {
        return reply.status(403).send({
          error: "Necess\xE1rio verificar o email"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async forgotPassword(request, reply) {
    try {
      const { email } = request.body;
      await AuthCommands.forgotPassword(email);
      return reply.send({
        message: "If the email exists, a reset password code has been sent."
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found") {
        return reply.status(404).send({
          error: "If the email exists, a reset password code has been sent."
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async verifyResetCode(request, reply) {
    try {
      const { email, code } = request.body;
      await AuthCommands.verifyResetCode(email, code);
      return reply.send({
        message: "Reset code verified successfully"
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invalid or expired reset code") {
        return reply.status(401).send({
          error: error.message
        });
      }
      if (error.message === "Reset code expired") {
        return reply.status(401).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async resetPassword(request, reply) {
    try {
      const { email, code, password } = request.body;
      await AuthCommands.resetPassword(email, code, password);
      return reply.send({
        message: "Password reset successfully"
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invalid or expired reset code") {
        return reply.status(401).send({
          error: error.message
        });
      }
      if (error.message === "Reset code expired") {
        return reply.status(401).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async verifyEmail(request, reply) {
    try {
      const { token } = request.body;
      await AuthCommands.verifyEmail(token);
      return reply.send({
        message: "Email verified successfully"
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invalid verification token") {
        return reply.status(401).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async verifyEmailCode(request, reply) {
    try {
      const { email, code } = request.body;
      const user = await AuthCommands.verifyEmailCode(email, code);
      return reply.send({
        message: "Email verified successfully",
        user: {
          id: user.id,
          name: user.name,
          email: user.email,
          emailVerified: user.emailVerified
        }
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invalid verification code" || error.message === "Verification code expired") {
        return reply.status(401).send({
          error: error.message
        });
      }
      if (error.message === "User not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async resendVerification(request, reply) {
    try {
      const { email } = request.body;
      await AuthCommands.resendVerification(email);
      return reply.send({
        message: "Verification email sent successfully"
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Email already verified") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async refreshToken(request, reply) {
    try {
      const authHeader = request.headers.authorization;
      if (!authHeader) {
        return reply.status(401).send({
          error: "Authorization header required"
        });
      }
      const token = AuthCommands.extractToken(authHeader);
      const payload = AuthCommands.verifyToken(token);
      const result = await AuthCommands.refreshToken(payload.userId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invalid authorization header" || error.message === "User not found") {
        return reply.status(401).send({
          error: "Invalid token"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async logout(request, reply) {
    try {
      return reply.send({
        message: "Logout successful"
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === QUERIES ===
  async getProfile(request, reply) {
    try {
      const authHeader = request.headers.authorization;
      if (!authHeader) {
        return reply.status(401).send({
          error: "Authorization header required"
        });
      }
      const token = AuthCommands.extractToken(authHeader);
      const payload = AuthCommands.verifyToken(token);
      const user = await AuthQueries.getUserProfile(payload.userId);
      return reply.send({ user });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invalid authorization header" || error.message === "User not found") {
        return reply.status(401).send({
          error: "Invalid token"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async updateProfile(request, reply) {
    try {
      const authHeader = request.headers.authorization;
      if (!authHeader) {
        return reply.status(401).send({
          error: "Authorization header required"
        });
      }
      const token = AuthCommands.extractToken(authHeader);
      const payload = AuthCommands.verifyToken(token);
      const { name, email } = request.body;
      if (!name && !email) {
        return reply.status(400).send({
          error: "At least one field (name or email) must be provided"
        });
      }
      const user = await AuthCommands.updateProfile(payload.userId, { name, email });
      return reply.send({
        user,
        message: "Profile updated successfully"
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invalid authorization header") {
        return reply.status(401).send({
          error: "Invalid token"
        });
      }
      if (error.message === "Email already exists") {
        return reply.status(409).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getProfilePermissions(request, reply) {
    try {
      const authHeader = request.headers.authorization;
      if (!authHeader) {
        return reply.status(401).send({
          error: "Authorization header required"
        });
      }
      const token = AuthCommands.extractToken(authHeader);
      const payload = AuthCommands.verifyToken(token);
      const { storeId, active, page, limit } = request.query;
      const permissions = await AuthQueries.getProfilePermissions(payload.userId, {
        storeId,
        active,
        page,
        limit
      });
      return reply.send(permissions);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invalid authorization header") {
        return reply.status(401).send({
          error: "Invalid token"
        });
      }
      if (error.message === "User not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getActive(request, reply) {
    try {
      const users = await AuthQueries.getActiveUsers();
      return reply.send({ users });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getVerified(request, reply) {
    try {
      const users = await AuthQueries.getVerifiedUsers();
      return reply.send({ users });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getUnverified(request, reply) {
    try {
      const users = await AuthQueries.getUnverifiedUsers();
      return reply.send({ users });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const stats = await AuthQueries.getUserStats();
      return reply.send(stats);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { q, limit = 10 } = request.query;
      const users = await AuthQueries.searchUsers(q, limit);
      return reply.send({ users });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getPendingVerification(request, reply) {
    try {
      const users = await AuthQueries.getUsersWithPendingVerification();
      return reply.send({ users });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getPendingReset(request, reply) {
    try {
      const users = await AuthQueries.getUsersWithPendingReset();
      return reply.send({ users });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async googleLogin(request, reply) {
    try {
      const { id_token } = request.body;
      const result = await AuthCommands.googleLogin(id_token);
      return reply.send({
        user: result.user,
        store: result.store,
        token: result.token,
        message: "Google login successful",
        preferences: await UserPreferencesQueries.getByUserIdOrCreate(result.user.id)
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Google OAuth configuration missing") {
        return reply.status(500).send({
          error: "Google OAuth n\xE3o configurado no servidor"
        });
      }
      if (error.message === "Invalid Google token") {
        return reply.status(401).send({
          error: "Token do Google inv\xE1lido"
        });
      }
      if (error.message === "User account is disabled") {
        return reply.status(403).send({
          error: "Conta de usu\xE1rio desabilitada"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/auth/auth.schema.ts
var registerSchema = {
  body: {
    type: "object",
    required: ["name", "email", "password"],
    properties: {
      name: {
        type: "string",
        minLength: 2,
        maxLength: 100,
        description: "User full name"
      },
      email: {
        type: "string",
        format: "email",
        description: "User email address"
      },
      password: {
        type: "string",
        minLength: 6,
        maxLength: 100,
        description: "User password (minimum 6 characters)"
      }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" },
            emailVerified: { type: "boolean" },
            createdAt: { type: "string", format: "date-time" }
          }
        },
        message: { type: "string" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    409: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var loginSchema = {
  body: {
    type: "object",
    required: ["email", "password"],
    properties: {
      email: {
        type: "string",
        format: "email",
        description: "User email address"
      },
      password: {
        type: "string",
        description: "User password"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" },
            emailVerified: { type: "boolean" },
            lastLoginAt: { type: "string", format: "date-time" }
          }
        },
        token: { type: "string" },
        message: { type: "string" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    401: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var forgotPasswordSchema = {
  body: {
    type: "object",
    required: ["email"],
    properties: {
      email: {
        type: "string",
        format: "email",
        description: "User email address"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        message: { type: "string" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var verifyResetCodeSchema = {
  body: {
    type: "object",
    required: ["email", "code"],
    properties: {
      email: {
        type: "string",
        format: "email",
        description: "User email address"
      },
      code: {
        type: "string",
        pattern: "^[0-9]{6}$",
        description: "6-digit reset code"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        message: { type: "string" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    401: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var resetPasswordSchema = {
  body: {
    type: "object",
    required: ["email", "code", "password"],
    properties: {
      email: {
        type: "string",
        format: "email",
        description: "User email address"
      },
      code: {
        type: "string",
        pattern: "^[0-9]{6}$",
        description: "6-digit reset code"
      },
      password: {
        type: "string",
        minLength: 6,
        maxLength: 100,
        description: "New password (minimum 6 characters)"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        message: { type: "string" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    401: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var verifyEmailSchema = {
  body: {
    type: "object",
    required: ["token"],
    properties: {
      token: {
        type: "string",
        description: "Email verification token"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        message: { type: "string" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    401: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var verifyEmailCodeSchema = {
  body: {
    type: "object",
    required: ["email", "code"],
    properties: {
      email: {
        type: "string",
        format: "email",
        description: "User email address"
      },
      code: {
        type: "string",
        pattern: "^[0-9]{6}$",
        description: "6-digit verification code"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        message: { type: "string" },
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" },
            emailVerified: { type: "boolean" }
          }
        }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    401: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var resendVerificationSchema = {
  body: {
    type: "object",
    required: ["email"],
    properties: {
      email: {
        type: "string",
        format: "email",
        description: "User email address"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        message: { type: "string" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var refreshTokenSchema = {
  headers: {
    type: "object",
    properties: {
      authorization: {
        type: "string",
        description: "Bearer token"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        token: { type: "string" },
        message: { type: "string" }
      }
    },
    401: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var logoutSchema = {
  headers: {
    type: "object",
    properties: {
      authorization: {
        type: "string",
        description: "Bearer token"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        message: { type: "string" }
      }
    },
    401: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var updateProfileSchema = {
  headers: {
    type: "object",
    properties: {
      authorization: {
        type: "string",
        description: "Bearer token"
      }
    }
  },
  body: {
    type: "object",
    properties: {
      name: {
        type: "string",
        minLength: 2,
        maxLength: 100,
        description: "User full name"
      },
      email: {
        type: "string",
        format: "email",
        description: "User email address"
      }
    },
    additionalProperties: false
  },
  response: {
    200: {
      type: "object",
      properties: {
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" },
            emailVerified: { type: "boolean" },
            status: { type: "boolean" },
            roles: {
              type: "array",
              items: { type: "string" }
            },
            lastLoginAt: { type: ["string", "null"], format: "date-time" },
            createdAt: { type: "string", format: "date-time" },
            updatedAt: { type: "string", format: "date-time" }
          }
        },
        message: { type: "string" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    401: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    409: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var googleLoginSchema = {
  body: {
    type: "object",
    required: ["id_token"],
    properties: {
      id_token: {
        type: "string",
        description: "Google ID token from client-side authentication"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" },
            emailVerified: { type: "boolean" },
            lastLoginAt: { type: ["string", "null"], format: "date-time" }
          }
        },
        store: {
          type: ["object", "null"],
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            cnpj: { type: "string" },
            email: { type: ["string", "null"] },
            phone: { type: ["string", "null"] },
            status: { type: "boolean" },
            cep: { type: ["string", "null"] },
            city: { type: ["string", "null"] },
            state: { type: ["string", "null"] },
            address: { type: ["string", "null"] },
            createdAt: { type: "string", format: "date-time" },
            updatedAt: { type: "string", format: "date-time" }
          }
        },
        token: { type: "string" },
        message: { type: "string" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    401: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getProfilePermissionsSchema = {
  headers: {
    type: "object",
    properties: {
      authorization: {
        type: "string",
        description: "Bearer token"
      }
    }
  },
  querystring: {
    type: "object",
    properties: {
      storeId: {
        type: "string",
        description: "Store ID to filter permissions"
      },
      active: {
        type: "boolean",
        description: "Filter active permissions only"
      },
      page: {
        type: "number",
        minimum: 1,
        default: 1,
        description: "Page number for pagination"
      },
      limit: {
        type: "number",
        minimum: 1,
        maximum: 100,
        default: 10,
        description: "Number of items per page"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        userId: { type: "string" },
        userRoles: {
          type: "array",
          items: { type: "string" }
        },
        storeId: { type: ["string", "null"] },
        effectivePermissions: {
          type: "array",
          items: { type: "string" }
        },
        customPermissions: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              action: { type: "string" },
              resource: { type: ["string", "null"] },
              storeId: { type: ["string", "null"] },
              grant: { type: "boolean" },
              conditions: { type: ["object", "null"] },
              expiresAt: { type: ["string", "null"], format: "date-time" },
              reason: { type: ["string", "null"] },
              createdAt: { type: "string", format: "date-time" },
              createdBy: { type: "string" },
              creator: {
                type: ["object", "null"],
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  email: { type: "string" }
                }
              }
            }
          }
        },
        storePermissions: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              storeId: { type: "string" },
              storeRole: { type: "string" },
              permissions: {
                type: "array",
                items: { type: "string" }
              },
              conditions: { type: ["object", "null"] },
              expiresAt: { type: ["string", "null"], format: "date-time" },
              createdAt: { type: "string", format: "date-time" },
              createdBy: { type: "string" },
              store: {
                type: ["object", "null"],
                properties: {
                  id: { type: "string" },
                  name: { type: "string" }
                }
              },
              creator: {
                type: ["object", "null"],
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  email: { type: "string" }
                }
              }
            }
          }
        },
        pagination: {
          type: ["object", "null"],
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            pages: { type: "number" }
          }
        }
      }
    },
    401: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};

// src/features/auth/auth.routes.ts
async function AuthRoutes(fastify2) {
  fastify2.post("/signup", {
    schema: registerSchema,
    handler: AuthController.register
  });
  fastify2.post("/signin", {
    schema: loginSchema,
    handler: AuthController.login
  });
  fastify2.post("/forgot-password", {
    schema: forgotPasswordSchema,
    handler: AuthController.forgotPassword
  });
  fastify2.post("/verify-reset-code", {
    schema: verifyResetCodeSchema,
    handler: AuthController.verifyResetCode
  });
  fastify2.post("/reset-password", {
    schema: resetPasswordSchema,
    handler: AuthController.resetPassword
  });
  fastify2.post("/verify-email", {
    schema: verifyEmailSchema,
    handler: AuthController.verifyEmail
  });
  fastify2.post("/verify-email-code", {
    schema: verifyEmailCodeSchema,
    handler: AuthController.verifyEmailCode
  });
  fastify2.post("/google", {
    schema: googleLoginSchema,
    handler: AuthController.googleLogin
  });
  fastify2.post("/resend-verification", {
    schema: resendVerificationSchema,
    handler: AuthController.resendVerification
  });
  fastify2.post("/refresh-token", {
    schema: refreshTokenSchema,
    handler: AuthController.refreshToken
  });
  fastify2.post("/logout", {
    schema: logoutSchema,
    handler: AuthController.logout
  });
  fastify2.get("/profile", {
    handler: AuthController.getProfile
  });
  fastify2.put("/profile", {
    schema: updateProfileSchema,
    handler: AuthController.updateProfile
  });
  fastify2.get("/profile/permissions", {
    schema: getProfilePermissionsSchema,
    handler: AuthController.getProfilePermissions
  });
  fastify2.get("/users/active", {
    handler: AuthController.getActive
  });
  fastify2.get("/users/verified", {
    handler: AuthController.getVerified
  });
  fastify2.get("/users/unverified", {
    handler: AuthController.getUnverified
  });
  fastify2.get("/stats", {
    handler: AuthController.getStats
  });
  fastify2.get("/search", {
    handler: AuthController.search
  });
  fastify2.get("/users/pending-verification", {
    handler: AuthController.getPendingVerification
  });
  fastify2.get("/users/pending-reset", {
    handler: AuthController.getPendingReset
  });
}

// src/features/product/commands/product.commands.ts
init_prisma();
var getUserStore = async (userId) => {
  const ownedStore = await db.store.findFirst({
    where: { ownerId: userId },
    select: { id: true, name: true }
  });
  if (ownedStore) {
    return ownedStore;
  }
  const storeUser = await db.storeUser.findFirst({
    where: { userId },
    include: {
      store: {
        select: { id: true, name: true }
      }
    }
  });
  if (storeUser) {
    return storeUser.store;
  }
  throw new Error("User has no associated store");
};
var ProductCommands = {
  async create(data) {
    const { categoryIds, supplierId, storeId, ...createData } = data;
    if (categoryIds && categoryIds.length > 0) {
      const existingCategories = await db.category.findMany({
        where: { id: { in: categoryIds } },
        select: { id: true }
      });
      if (existingCategories.length !== categoryIds.length) {
        const foundIds = existingCategories.map((c) => c.id);
        const notFoundIds = categoryIds.filter((id) => !foundIds.includes(id));
        throw new Error(`Categories not found: ${notFoundIds.join(", ")}`);
      }
    }
    const product = await db.product.create({
      data: {
        ...createData,
        unitOfMeasure: createData.unitOfMeasure,
        status: data.status ?? true,
        ...supplierId && { supplier: { connect: { id: supplierId } } },
        store: { connect: { id: storeId } }
      }
    });
    if (categoryIds && categoryIds.length > 0) {
      await db.productCategory.createMany({
        data: categoryIds.map((categoryId) => ({
          productId: product.id,
          categoryId
        }))
      });
    }
    return await db.product.findUnique({
      where: { id: product.id },
      include: {
        categories: {
          include: {
            category: {
              select: {
                id: true,
                name: true,
                description: true,
                code: true,
                color: true,
                icon: true
              }
            }
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true,
            cnpj: true,
            tradeName: true
          }
        },
        store: {
          select: {
            id: true,
            name: true,
            cnpj: true
          }
        }
      }
    });
  },
  async update(id, data) {
    const { categoryIds, supplierId, storeId, ...updateData } = data;
    if (categoryIds && categoryIds.length > 0) {
      const existingCategories = await db.category.findMany({
        where: { id: { in: categoryIds } },
        select: { id: true }
      });
      if (existingCategories.length !== categoryIds.length) {
        const foundIds = existingCategories.map((c) => c.id);
        const notFoundIds = categoryIds.filter((id2) => !foundIds.includes(id2));
        throw new Error(`Categories not found: ${notFoundIds.join(", ")}`);
      }
    }
    let categoryUpdate = {};
    if (categoryIds !== void 0) {
      if (categoryIds.length === 0) {
        categoryUpdate = {
          categories: {
            deleteMany: {}
          }
        };
      } else {
        categoryUpdate = {
          categories: {
            deleteMany: {},
            create: categoryIds.map((categoryId) => ({
              category: { connect: { id: categoryId } }
            }))
          }
        };
      }
    }
    return await db.product.update({
      where: { id },
      data: {
        ...updateData,
        ...updateData.unitOfMeasure && { unitOfMeasure: updateData.unitOfMeasure },
        ...supplierId !== void 0 && supplierId ? { supplier: { connect: { id: supplierId } } } : supplierId === null ? { supplier: { disconnect: true } } : {},
        ...storeId && { store: { connect: { id: storeId } } },
        ...categoryUpdate
      },
      include: {
        categories: {
          select: {
            category: {
              select: {
                id: true,
                name: true,
                description: true,
                code: true,
                color: true,
                icon: true
              }
            }
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true,
            cnpj: true,
            tradeName: true
          }
        },
        store: {
          select: {
            id: true,
            name: true,
            cnpj: true
          }
        }
      }
    });
  },
  async delete(id) {
    const product = await db.product.findUnique({
      where: { id },
      include: {
        movements: {
          select: { id: true }
        }
      }
    });
    if (!product) {
      throw new Error("Product not found");
    }
    if (product.movements.length > 0) {
      throw new Error(`Cannot delete product. It has ${product.movements.length} associated movements. Please delete the movements first or use force delete.`);
    }
    return await db.product.delete({
      where: { id }
    });
  },
  async forceDelete(id) {
    const product = await db.product.findUnique({
      where: { id }
    });
    if (!product) {
      throw new Error("Product not found");
    }
    await db.movement.deleteMany({
      where: { productId: id }
    });
    return await db.product.delete({
      where: { id }
    });
  },
  async updateStatus(id, status) {
    return await db.product.update({
      where: { id },
      data: { status },
      include: {
        categories: {
          select: {
            category: {
              select: {
                id: true,
                name: true,
                description: true,
                code: true,
                color: true,
                icon: true
              }
            }
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true,
            cnpj: true,
            tradeName: true
          }
        },
        store: {
          select: {
            id: true,
            name: true,
            cnpj: true
          }
        }
      }
    });
  },
  // === FUNÇÕES ADICIONAIS DE PRODUTO ===
  async verifySku(productId, sku) {
    const product = await db.product.findUnique({
      where: { id: productId }
    });
    if (!product) {
      throw new Error("Product not found");
    }
    const existingProduct = await db.product.findFirst({
      where: {
        id: { not: productId },
        name: sku
        // Assumindo que SKU é o nome do produto
      }
    });
    return {
      available: !existingProduct,
      message: existingProduct ? "SKU already exists" : "SKU available"
    };
  },
  async updateStock(productId, quantity, type, note, userId) {
    const product = await db.product.findUnique({
      where: { id: productId }
    });
    if (!product) {
      throw new Error("Product not found");
    }
    let newStock = 0;
    if (type === "ENTRADA") {
      newStock = quantity;
    } else {
      newStock = -quantity;
    }
    const movement = await db.movement.create({
      data: {
        type,
        quantity,
        storeId: product.storeId,
        productId,
        note,
        userId,
        balanceAfter: newStock
      },
      include: {
        supplier: {
          select: {
            id: true,
            corporateName: true,
            cnpj: true
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    return {
      product: {
        id: product.id,
        name: product.name,
        currentStock: newStock
      },
      movement
    };
  },
  async createMovement(productId, data) {
    const product = await db.product.findUnique({
      where: { id: productId }
    });
    if (!product) {
      throw new Error("Product not found");
    }
    if (data.supplierId) {
      const supplier = await db.supplier.findUnique({
        where: { id: data.supplierId }
      });
      if (!supplier) {
        throw new Error("Supplier not found");
      }
    }
    const movement = await db.movement.create({
      data: {
        type: data.type,
        quantity: data.quantity,
        storeId: product.storeId,
        productId,
        supplierId: data.supplierId,
        batch: data.batch,
        expiration: data.expiration ? new Date(data.expiration) : null,
        price: data.price,
        note: data.note,
        userId: data.userId,
        balanceAfter: data.quantity
        // Assumindo que é o estoque após a movimentação
      },
      include: {
        product: {
          select: {
            id: true,
            name: true,
            unitOfMeasure: true
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true,
            cnpj: true
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        },
        store: {
          select: {
            id: true,
            name: true,
            cnpj: true
          }
        }
      }
    });
    return movement;
  },
  async getProductStock(productId) {
    const product = await db.product.findUnique({
      where: { id: productId },
      include: {
        movements: {
          orderBy: { createdAt: "desc" },
          take: 1
        }
      }
    });
    if (!product) {
      throw new Error("Product not found");
    }
    const movements = await db.movement.findMany({
      where: { productId },
      select: {
        type: true,
        quantity: true
      }
    });
    let currentStock = 0;
    movements.forEach((movement) => {
      if (movement.type === "ENTRADA") {
        currentStock += movement.quantity;
      } else {
        currentStock -= movement.quantity;
      }
    });
    let status = "OK";
    const stockPercentage = currentStock / product.stockMax * 100;
    if (currentStock <= 0) {
      status = "CRITICAL";
    } else if (currentStock <= product.stockMin) {
      status = "LOW";
    } else if (currentStock > product.stockMax) {
      status = "OVERSTOCK";
    }
    return {
      id: product.id,
      name: product.name,
      currentStock,
      stockMin: product.stockMin,
      stockMax: product.stockMax,
      alertPercentage: product.alertPercentage,
      status,
      lastMovement: product.movements[0] ? {
        type: product.movements[0].type,
        quantity: product.movements[0].quantity,
        date: product.movements[0].createdAt
      } : null
    };
  },
  // === MÉTODOS PARA GERENCIAR CATEGORIAS DO PRODUTO ===
  async addCategories(productId, categoryIds) {
    const product = await db.product.findUnique({
      where: { id: productId }
    });
    if (!product) {
      throw new Error("Product not found");
    }
    const existingCategories = await db.category.findMany({
      where: { id: { in: categoryIds } },
      select: { id: true }
    });
    if (existingCategories.length !== categoryIds.length) {
      const foundIds = existingCategories.map((c) => c.id);
      const notFoundIds = categoryIds.filter((id) => !foundIds.includes(id));
      throw new Error(`Categories not found: ${notFoundIds.join(", ")}`);
    }
    const existingProductCategories = await db.productCategory.findMany({
      where: {
        productId,
        categoryId: { in: categoryIds }
      },
      select: { categoryId: true }
    });
    const existingCategoryIds = existingProductCategories.map((pc) => pc.categoryId);
    const newCategoryIds = categoryIds.filter((id) => !existingCategoryIds.includes(id));
    if (newCategoryIds.length === 0) {
      throw new Error("All provided categories are already associated with this product");
    }
    await db.productCategory.createMany({
      data: newCategoryIds.map((categoryId) => ({
        productId,
        categoryId
      }))
    });
    const updatedCategories = await db.productCategory.findMany({
      where: { productId },
      select: {
        category: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true,
            color: true,
            icon: true
          }
        }
      }
    });
    return {
      message: `${newCategoryIds.length} categories added successfully`,
      addedCount: newCategoryIds.length,
      categories: updatedCategories.map((pc) => pc.category)
    };
  },
  async removeCategories(productId, categoryIds) {
    const product = await db.product.findUnique({
      where: { id: productId }
    });
    if (!product) {
      throw new Error("Product not found");
    }
    const result = await db.productCategory.deleteMany({
      where: {
        productId,
        categoryId: { in: categoryIds }
      }
    });
    return {
      message: `${result.count} categories removed successfully`,
      removedCount: result.count
    };
  },
  async setCategories(productId, categoryIds) {
    const product = await db.product.findUnique({
      where: { id: productId }
    });
    if (!product) {
      throw new Error("Product not found");
    }
    if (categoryIds.length > 0) {
      const existingCategories = await db.category.findMany({
        where: { id: { in: categoryIds } },
        select: { id: true }
      });
      if (existingCategories.length !== categoryIds.length) {
        const foundIds = existingCategories.map((c) => c.id);
        const notFoundIds = categoryIds.filter((id) => !foundIds.includes(id));
        throw new Error(`Categories not found: ${notFoundIds.join(", ")}`);
      }
    }
    await db.productCategory.deleteMany({
      where: { productId }
    });
    if (categoryIds.length > 0) {
      await db.productCategory.createMany({
        data: categoryIds.map((categoryId) => ({
          productId,
          categoryId
        }))
      });
    }
    const updatedCategories = await db.productCategory.findMany({
      where: { productId },
      select: {
        category: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true,
            color: true,
            icon: true
          }
        }
      }
    });
    return {
      message: "Categories updated successfully",
      categories: updatedCategories.map((pc) => pc.category)
    };
  },
  async bulkDelete(ids) {
    if (!ids || ids.length === 0) {
      throw new Error("No product IDs provided");
    }
    const errors = [];
    let deletedCount = 0;
    for (const id of ids) {
      try {
        const product = await db.product.findUnique({
          where: { id },
          include: {
            movements: {
              select: { id: true }
            }
          }
        });
        if (!product) {
          errors.push(`Product ${id} not found`);
          continue;
        }
        if (product.movements.length > 0) {
          await db.movement.deleteMany({
            where: { productId: id }
          });
        }
        await db.product.delete({
          where: { id }
        });
        deletedCount++;
      } catch (error) {
        errors.push(`Failed to delete product ${id}: ${error.message}`);
      }
    }
    return {
      deleted: deletedCount,
      errors
    };
  }
};

// src/features/product/queries/product.queries.ts
init_prisma();
async function calculateCurrentStock(productId) {
  const movements = await db.movement.findMany({
    where: { productId },
    select: {
      type: true,
      quantity: true
    }
  });
  let currentStock = 0;
  movements.forEach((movement) => {
    if (movement.type === "ENTRADA") {
      currentStock += movement.quantity;
    } else {
      currentStock -= movement.quantity;
    }
  });
  return currentStock;
}
var ProductQueries = {
  async getById(id, storeId) {
    const product = await db.product.findUnique({
      where: { id, storeId },
      include: {
        categories: {
          select: {
            category: {
              select: {
                id: true,
                name: true,
                description: true,
                code: true,
                color: true,
                icon: true
              }
            }
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true,
            cnpj: true,
            tradeName: true
          }
        },
        store: {
          select: {
            id: true,
            name: true,
            cnpj: true
          }
        }
      }
    });
    if (!product) {
      return null;
    }
    const currentStock = await calculateCurrentStock(product.id);
    return {
      ...product,
      currentStock
    };
  },
  async list(params) {
    const { page = 1, limit = 10, search, status, categoryIds, supplierId, storeId } = params;
    const skip2 = (page - 1) * limit;
    const where = {};
    if (status !== void 0) {
      where.status = status;
    }
    if (categoryIds && categoryIds.length > 0) {
      where.categories = {
        some: {
          categoryId: { in: categoryIds }
        }
      };
    }
    if (supplierId) {
      where.supplierId = supplierId;
    }
    if (storeId) {
      where.storeId = storeId;
    }
    if (search) {
      where.OR = [
        { name: { contains: search, mode: "insensitive" } },
        { description: { contains: search, mode: "insensitive" } }
      ];
    }
    const [products, total] = await Promise.all([
      db.product.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          categories: {
            select: {
              category: {
                select: {
                  id: true,
                  name: true,
                  description: true,
                  code: true,
                  color: true,
                  icon: true
                }
              }
            }
          },
          supplier: {
            select: {
              id: true,
              corporateName: true,
              cnpj: true,
              tradeName: true
            }
          },
          store: {
            select: {
              id: true,
              name: true,
              cnpj: true
            }
          }
        }
      }),
      db.product.count({ where })
    ]);
    const itemsWithStock = await Promise.all(
      products.map(async (product) => {
        const currentStock = await calculateCurrentStock(product.id);
        return {
          ...product,
          currentStock
        };
      })
    );
    return {
      items: itemsWithStock,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async search(term, params = {}) {
    const { page = 1, limit = 10, storeId } = params;
    const skip2 = (page - 1) * limit;
    const where = {
      OR: [
        { name: { contains: term, mode: "insensitive" } },
        { description: { contains: term, mode: "insensitive" } },
        { categories: { some: { category: { name: { contains: term, mode: "insensitive" } } } } },
        { supplier: { corporateName: { contains: term, mode: "insensitive" } } },
        { supplier: { tradeName: { contains: term, mode: "insensitive" } } }
      ]
    };
    if (storeId) {
      where.storeId = storeId;
    }
    const [products, total] = await Promise.all([
      db.product.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          categories: {
            select: {
              category: {
                select: {
                  id: true,
                  name: true,
                  description: true,
                  code: true,
                  color: true,
                  icon: true
                }
              }
            }
          },
          supplier: {
            select: {
              id: true,
              corporateName: true,
              cnpj: true,
              tradeName: true
            }
          },
          store: {
            select: {
              id: true,
              name: true,
              cnpj: true
            }
          }
        }
      }),
      db.product.count({ where })
    ]);
    const productsWithStock = await Promise.all(
      products.map(async (product) => {
        const currentStock = await calculateCurrentStock(product.id);
        return {
          ...product,
          currentStock
        };
      })
    );
    return {
      items: productsWithStock,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getActive(storeId) {
    const products = await db.product.findMany({
      where: {
        status: true,
        storeId
      },
      orderBy: { createdAt: "desc" },
      include: {
        categories: {
          select: {
            category: {
              select: {
                id: true,
                name: true,
                description: true,
                code: true,
                color: true,
                icon: true
              }
            }
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true,
            cnpj: true,
            tradeName: true
          }
        },
        store: {
          select: {
            id: true,
            name: true,
            cnpj: true
          }
        }
      }
    });
    const productsWithStock = await Promise.all(
      products.map(async (product) => {
        const currentStock = await calculateCurrentStock(product.id);
        return {
          ...product,
          currentStock
        };
      })
    );
    return productsWithStock;
  },
  async getStats(storeId) {
    const [total, active, inactive] = await Promise.all([
      db.product.count({ where: { storeId } }),
      db.product.count({ where: { status: true, storeId } }),
      db.product.count({ where: { status: false, storeId } })
    ]);
    return {
      total,
      active,
      inactive
    };
  },
  async getByCategory(categoryId, storeId) {
    const products = await db.product.findMany({
      where: {
        categories: {
          some: {
            categoryId
          }
        }
      },
      orderBy: { createdAt: "desc" },
      include: {
        categories: {
          select: {
            category: {
              select: {
                id: true,
                name: true,
                description: true,
                code: true,
                color: true,
                icon: true
              }
            }
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true,
            cnpj: true,
            tradeName: true
          }
        },
        store: {
          select: {
            id: true,
            name: true,
            cnpj: true
          }
        }
      }
    });
    const productsWithStock = await Promise.all(
      products.map(async (product) => {
        const currentStock = await calculateCurrentStock(product.id);
        return {
          ...product,
          currentStock
        };
      })
    );
    return productsWithStock;
  },
  async getBySupplier(supplierId, storeId) {
    const products = await db.product.findMany({
      where: { supplierId },
      orderBy: { createdAt: "desc" },
      include: {
        categories: {
          select: {
            category: {
              select: {
                id: true,
                name: true,
                description: true,
                code: true,
                color: true,
                icon: true
              }
            }
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true,
            cnpj: true,
            tradeName: true
          }
        },
        store: {
          select: {
            id: true,
            name: true,
            cnpj: true
          }
        }
      }
    });
    const productsWithStock = await Promise.all(
      products.map(async (product) => {
        const currentStock = await calculateCurrentStock(product.id);
        return {
          ...product,
          currentStock
        };
      })
    );
    return productsWithStock;
  },
  async getByStore(storeId) {
    const products = await db.product.findMany({
      where: { storeId },
      orderBy: { createdAt: "desc" },
      include: {
        categories: {
          select: {
            category: {
              select: {
                id: true,
                name: true,
                description: true,
                code: true,
                color: true,
                icon: true
              }
            }
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true,
            cnpj: true,
            tradeName: true
          }
        },
        store: {
          select: {
            id: true,
            name: true,
            cnpj: true
          }
        }
      }
    });
    const productsWithStock = await Promise.all(
      products.map(async (product) => {
        const currentStock = await calculateCurrentStock(product.id);
        return {
          ...product,
          currentStock
        };
      })
    );
    return productsWithStock;
  },
  // === FUNÇÕES ADICIONAIS DE PRODUTO ===
  async getProductMovements(productId, params) {
    const { page = 1, limit = 10, type, startDate, endDate } = params;
    const skip2 = (page - 1) * limit;
    const product = await db.product.findUnique({
      where: { id: productId }
    });
    if (!product) {
      throw new Error("Product not found");
    }
    const where = {
      productId
    };
    if (type) {
      where.type = type;
    }
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) {
        where.createdAt.gte = new Date(startDate);
      }
      if (endDate) {
        where.createdAt.lte = new Date(endDate);
      }
    }
    const [items, total] = await Promise.all([
      db.movement.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          product: {
            select: {
              id: true,
              name: true,
              unitOfMeasure: true
            }
          },
          supplier: {
            select: {
              id: true,
              corporateName: true,
              cnpj: true
            }
          },
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          },
          store: {
            select: {
              id: true,
              name: true,
              cnpj: true
            }
          }
        }
      }),
      db.movement.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getProductStockHistory(productId, limit = 30) {
    const product = await db.product.findUnique({
      where: { id: productId }
    });
    if (!product) {
      throw new Error("Product not found");
    }
    const movements = await db.movement.findMany({
      where: { productId },
      take: limit,
      orderBy: { createdAt: "desc" },
      include: {
        supplier: {
          select: {
            id: true,
            corporateName: true,
            cnpj: true
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    let currentStock = 0;
    const stockHistory = movements.map((movement) => {
      if (movement.type === "ENTRADA") {
        currentStock += movement.quantity;
      } else {
        currentStock -= movement.quantity;
      }
      return {
        ...movement,
        balanceAfter: currentStock
      };
    }).reverse();
    return {
      product: {
        id: product.id,
        name: product.name,
        stockMin: product.stockMin,
        stockMax: product.stockMax,
        alertPercentage: product.alertPercentage
      },
      currentStock,
      history: stockHistory
    };
  },
  async getLowStockProducts(storeId) {
    const where = {
      status: true
    };
    if (storeId) {
      where.storeId = storeId;
    }
    const products = await db.product.findMany({
      where,
      include: {
        movements: {
          select: {
            type: true,
            quantity: true
          }
        },
        categories: {
          select: {
            category: {
              select: {
                id: true,
                name: true
              }
            }
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true
          }
        },
        store: {
          select: {
            id: true,
            name: true
          }
        }
      }
    });
    const lowStockProducts = products.filter((product) => {
      let currentStock = 0;
      product.movements.forEach((movement) => {
        if (movement.type === "ENTRADA") {
          currentStock += movement.quantity;
        } else {
          currentStock -= movement.quantity;
        }
      });
      return currentStock <= product.stockMin;
    }).map((product) => {
      let currentStock = 0;
      product.movements.forEach((movement) => {
        if (movement.type === "ENTRADA") {
          currentStock += movement.quantity;
        } else {
          currentStock -= movement.quantity;
        }
      });
      return {
        ...product,
        currentStock,
        stockStatus: currentStock <= 0 ? "CRITICAL" : "LOW"
      };
    });
    return lowStockProducts;
  },
  async getProductAnalytics(productId) {
    const product = await db.product.findUnique({
      where: { id: productId }
    });
    if (!product) {
      throw new Error("Product not found");
    }
    const movements = await db.movement.findMany({
      where: { productId },
      include: {
        supplier: {
          select: {
            id: true,
            corporateName: true
          }
        }
      }
    });
    const totalMovements = movements.length;
    const entradaMovements = movements.filter((m) => m.type === "ENTRADA");
    const saidaMovements = movements.filter((m) => m.type === "SAIDA");
    const perdaMovements = movements.filter((m) => m.type === "PERDA");
    const totalEntrada = entradaMovements.reduce((sum, m) => sum + m.quantity, 0);
    const totalSaida = saidaMovements.reduce((sum, m) => sum + m.quantity, 0);
    const totalPerda = perdaMovements.reduce((sum, m) => sum + m.quantity, 0);
    const currentStock = totalEntrada - totalSaida - totalPerda;
    const monthlyMovements = movements.reduce((acc, movement) => {
      const month = movement.createdAt.toISOString().substring(0, 7);
      if (!acc[month]) {
        acc[month] = { entrada: 0, saida: 0, perda: 0 };
      }
      acc[month][movement.type.toLowerCase()] += movement.quantity;
      return acc;
    }, {});
    const supplierStats = movements.filter((m) => m.supplierId).reduce((acc, movement) => {
      const supplierId = movement.supplierId;
      if (!acc[supplierId]) {
        acc[supplierId] = {
          supplier: movement.supplier,
          totalMovements: 0,
          totalQuantity: 0
        };
      }
      acc[supplierId].totalMovements++;
      acc[supplierId].totalQuantity += movement.quantity;
      return acc;
    }, {});
    return {
      product: {
        id: product.id,
        name: product.name,
        stockMin: product.stockMin,
        stockMax: product.stockMax,
        alertPercentage: product.alertPercentage
      },
      currentStock,
      statistics: {
        totalMovements,
        totalEntrada,
        totalSaida,
        totalPerda,
        monthlyMovements,
        supplierStats: Object.values(supplierStats)
      }
    };
  },
  // === MÉTODOS PARA GERENCIAR CATEGORIAS DO PRODUTO ===
  async getCategories(productId) {
    const product = await db.product.findUnique({
      where: { id: productId }
    });
    if (!product) {
      throw new Error("Product not found");
    }
    const categories = await db.productCategory.findMany({
      where: { productId },
      select: {
        category: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true,
            color: true,
            icon: true
          }
        }
      }
    });
    return {
      categories: categories.map((pc) => pc.category)
    };
  },
  async getProductsByCategories(categoryIds, storeId, params) {
    const { page = 1, limit = 10, search, status } = params;
    const skip2 = (page - 1) * limit;
    const where = {
      categories: {
        some: {
          categoryId: { in: categoryIds }
        }
      }
    };
    if (status !== void 0) {
      where.status = status;
    }
    if (search) {
      where.OR = [
        { name: { contains: search, mode: "insensitive" } },
        { description: { contains: search, mode: "insensitive" } }
      ];
    }
    const [products, total] = await Promise.all([
      db.product.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          categories: {
            select: {
              category: {
                select: {
                  id: true,
                  name: true,
                  description: true,
                  code: true,
                  color: true,
                  icon: true
                }
              }
            }
          },
          supplier: {
            select: {
              id: true,
              corporateName: true,
              cnpj: true,
              tradeName: true
            }
          },
          store: {
            select: {
              id: true,
              name: true,
              cnpj: true
            }
          }
        }
      }),
      db.product.count({ where })
    ]);
    const totalPages = Math.ceil(total / limit);
    return {
      products,
      pagination: {
        page,
        limit,
        total,
        totalPages
      }
    };
  }
};

// src/features/product/product.controller.ts
var ProductController = {
  // === CRUD BÁSICO ===
  async create(request, reply) {
    try {
      const { name, description, unitOfMeasure, referencePrice, categoryIds, supplierId, storeId, stockMin, stockMax, alertPercentage, status } = request.body;
      let finalStoreId = storeId;
      if (!finalStoreId) {
        if (!request.user?.id) {
          return reply.status(401).send({
            error: "Authentication required to determine store"
          });
        }
        const userStore = await getUserStore(request.user.id);
        finalStoreId = userStore.id;
      }
      const result = await ProductCommands.create({
        name,
        description,
        unitOfMeasure,
        referencePrice,
        categoryIds,
        supplierId,
        storeId: finalStoreId,
        stockMin,
        stockMax,
        alertPercentage,
        status
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product with this name already exists") {
        return reply.status(400).send({
          error: error.message
        });
      }
      if (error.message.includes("Categories not found")) {
        return reply.status(400).send({
          error: error.message
        });
      }
      if (error.message === "User has no associated store") {
        return reply.status(400).send({
          error: "User has no associated store. Please provide a storeId or ensure user has access to a store."
        });
      }
      if (error.code === "P2003") {
        return reply.status(400).send({
          error: "Invalid supplier or store reference"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id, storeId } = request.params;
      const result = await ProductQueries.getById(id, storeId);
      if (!result) {
        return reply.status(404).send({
          error: "Product not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      const result = await ProductCommands.update(id, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.code === "P2025") {
        return reply.status(404).send({
          error: "Product not found"
        });
      }
      if (error.code === "P2002") {
        return reply.status(400).send({
          error: "Product with this name already exists"
        });
      }
      if (error.message.includes("Categories not found")) {
        return reply.status(400).send({
          error: error.message
        });
      }
      if (error.code === "P2003") {
        return reply.status(400).send({
          error: "Invalid supplier or store reference"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      await ProductCommands.delete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message.includes("Cannot delete product") && error.message.includes("associated movements")) {
        return reply.status(400).send({
          error: error.message,
          suggestion: "Use DELETE /products/:id/force to delete the product and all its movements"
        });
      }
      if (error.code === "P2003") {
        return reply.status(400).send({
          error: "Cannot delete product due to foreign key constraints"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async forceDelete(request, reply) {
    try {
      const { id } = request.params;
      await ProductCommands.forceDelete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { page = 1, limit = 10, search, status, categoryIds, supplierId } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await ProductQueries.list({
        page,
        limit,
        search,
        status,
        categoryIds: categoryIds ? Array.isArray(categoryIds) ? categoryIds : [categoryIds] : void 0,
        supplierId,
        storeId
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (QUERIES) ===
  async getActive(request, reply) {
    try {
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await ProductQueries.getActive(storeId);
      return reply.send({ products: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await ProductQueries.getStats(storeId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { q, limit = 10, page = 1 } = request.query;
      const storeId = request.store?.id;
      const result = await ProductQueries.search(q, {
        page,
        limit,
        storeId
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByCategory(request, reply) {
    try {
      const { categoryId } = request.params;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await ProductQueries.getByCategory(categoryId, storeId);
      return reply.send({ products: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getBySupplier(request, reply) {
    try {
      const { supplierId } = request.params;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await ProductQueries.getBySupplier(supplierId, storeId);
      return reply.send({ products: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByStore(request, reply) {
    try {
      const { storeId } = request.params;
      const result = await ProductQueries.getByStore(storeId);
      return reply.send({ products: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (COMMANDS) ===
  async updateStatus(request, reply) {
    try {
      const { id } = request.params;
      const { status } = request.body;
      const result = await ProductCommands.updateStatus(id, status);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.code === "P2025") {
        return reply.status(404).send({
          error: "Product not found"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS DE PRODUTO ===
  async verifySku(request, reply) {
    try {
      const { id: productId } = request.params;
      const { sku } = request.body;
      const result = await ProductCommands.verifySku(productId, sku);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async updateStock(request, reply) {
    try {
      const { id: productId } = request.params;
      const { quantity, type, note } = request.body;
      const userId = request.user?.id;
      const result = await ProductCommands.updateStock(productId, quantity, type, note, userId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getMovements(request, reply) {
    try {
      const { id: productId } = request.params;
      const { page = 1, limit = 10, type, startDate, endDate } = request.query;
      const result = await ProductQueries.getProductMovements(productId, {
        page,
        limit,
        type,
        startDate,
        endDate
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async createMovement(request, reply) {
    try {
      const { id: productId } = request.params;
      const { type, quantity, supplierId, batch, expiration, price, note } = request.body;
      const userId = request.user?.id;
      const result = await ProductCommands.createMovement(productId, {
        type,
        quantity,
        supplierId,
        batch,
        expiration,
        price,
        note,
        userId
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Supplier not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStock(request, reply) {
    try {
      const { id: productId } = request.params;
      const result = await ProductCommands.getProductStock(productId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStockHistory(request, reply) {
    try {
      const { id: productId } = request.params;
      const { limit = 30 } = request.query;
      const result = await ProductQueries.getProductStockHistory(productId, limit);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getLowStock(request, reply) {
    try {
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await ProductQueries.getLowStockProducts(storeId);
      return reply.send({ products: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getAnalytics(request, reply) {
    try {
      const { id: productId } = request.params;
      const result = await ProductQueries.getProductAnalytics(productId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === MÉTODOS PARA GERENCIAR CATEGORIAS DO PRODUTO ===
  async addCategories(request, reply) {
    try {
      const { id } = request.params;
      const { categoryIds } = request.body;
      const result = await ProductCommands.addCategories(id, categoryIds);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message.includes("Categories not found") || error.message.includes("already associated")) {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async removeCategories(request, reply) {
    try {
      const { id } = request.params;
      const { categoryIds } = request.body;
      const result = await ProductCommands.removeCategories(id, categoryIds);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async setCategories(request, reply) {
    try {
      const { id } = request.params;
      const { categoryIds } = request.body;
      const result = await ProductCommands.setCategories(id, categoryIds);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message.includes("Categories not found")) {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getCategories(request, reply) {
    try {
      const { id } = request.params;
      const result = await ProductQueries.getCategories(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async bulkDelete(request, reply) {
    try {
      const { ids } = request.body;
      if (!ids || !Array.isArray(ids) || ids.length === 0) {
        return reply.status(400).send({
          error: "Product IDs are required and must be a non-empty array"
        });
      }
      const result = await ProductCommands.bulkDelete(ids);
      return reply.send({
        deleted: result.deleted,
        errors: result.errors,
        message: `Successfully deleted ${result.deleted} products${result.errors.length > 0 ? ` with ${result.errors.length} errors` : ""}`
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: error.message || "Internal server error"
      });
    }
  }
};

// src/features/product/product.schema.ts
var createProductSchema = {
  body: {
    type: "object",
    required: ["name", "unitOfMeasure", "referencePrice", "stockMin", "stockMax", "alertPercentage"],
    properties: {
      name: { type: "string", minLength: 1 },
      description: { type: "string" },
      unitOfMeasure: {
        type: "string",
        enum: ["UNIDADE", "KG", "L", "ML", "M", "CM", "MM", "UN", "DZ", "CX", "PCT", "KIT", "PAR", "H", "D"]
      },
      referencePrice: { type: "number", minimum: 0.01 },
      categoryIds: {
        type: "array",
        items: { type: "string", minLength: 1 },
        minItems: 1,
        uniqueItems: true
      },
      supplierId: { type: ["string", "null"], minLength: 1 },
      storeId: { type: "string", minLength: 1 },
      stockMin: { type: "number", minimum: 0 },
      stockMax: { type: "number", minimum: 0 },
      alertPercentage: { type: "number", minimum: 0, maximum: 100 },
      status: { type: "boolean", default: true }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        description: { type: "string", nullable: true },
        unitOfMeasure: { type: "string" },
        referencePrice: { type: "number" },
        supplierId: { type: "string" },
        storeId: { type: "string" },
        stockMin: { type: "number" },
        stockMax: { type: "number" },
        alertPercentage: { type: "number" },
        status: { type: "boolean" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        categories: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              code: { type: "string", nullable: true },
              color: { type: "string", nullable: true },
              icon: { type: "string", nullable: true }
            }
          }
        },
        supplier: { type: "object" },
        store: { type: "object" }
      }
    }
  }
};
var updateProductSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      name: { type: "string", minLength: 1 },
      description: { type: "string" },
      unitOfMeasure: {
        type: "string",
        enum: ["UNIDADE", "KG", "L", "ML", "M", "CM", "MM", "UN", "DZ", "CX", "PCT", "KIT", "PAR", "H", "D"]
      },
      referencePrice: { type: "number", minimum: 0.01 },
      categoryIds: {
        type: "array",
        items: { type: "string", minLength: 1 },
        minItems: 1,
        uniqueItems: true
      },
      supplierId: { type: ["string", "null"], minLength: 1 },
      storeId: { type: "string", minLength: 1 },
      stockMin: { type: "number", minimum: 0 },
      stockMax: { type: "number", minimum: 0 },
      alertPercentage: { type: "number", minimum: 0, maximum: 100 },
      status: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        description: { type: "string", nullable: true },
        unitOfMeasure: { type: "string" },
        referencePrice: { type: "number" },
        supplierId: { type: "string" },
        storeId: { type: "string" },
        stockMin: { type: "number" },
        stockMax: { type: "number" },
        alertPercentage: { type: "number" },
        status: { type: "boolean" },
        updatedAt: { type: "string", format: "date-time" },
        categories: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              code: { type: "string", nullable: true },
              color: { type: "string", nullable: true },
              icon: { type: "string", nullable: true }
            }
          }
        },
        supplier: { type: "object" },
        store: { type: "object" }
      }
    }
  }
};
var getProductSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        description: { type: "string", nullable: true },
        unitOfMeasure: { type: "string" },
        referencePrice: { type: "number" },
        categories: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              code: { type: "string", nullable: true },
              color: { type: "string", nullable: true },
              icon: { type: "string", nullable: true }
            }
          }
        },
        supplierId: { type: "string" },
        storeId: { type: "string" },
        stockMin: { type: "number" },
        stockMax: { type: "number" },
        alertPercentage: { type: "number" },
        status: { type: "boolean" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        category: { type: "object" },
        supplier: { type: "object" },
        store: { type: "object" }
      }
    }
  }
};
var listProductsSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      status: { type: "boolean" },
      categoryIds: {
        type: "array",
        items: { type: "string", minLength: 1 },
        uniqueItems: true
      },
      supplierId: { type: "string" },
      storeId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              unitOfMeasure: { type: "string" },
              referencePrice: { type: "number" },
              categories: {
                type: "array",
                items: {
                  type: "object",
                  properties: {
                    id: { type: "string" },
                    name: { type: "string" },
                    description: { type: "string", nullable: true },
                    code: { type: "string", nullable: true },
                    color: { type: "string", nullable: true },
                    icon: { type: "string", nullable: true }
                  }
                }
              },
              supplierId: { type: "string" },
              storeId: { type: "string" },
              stockMin: { type: "number" },
              stockMax: { type: "number" },
              alertPercentage: { type: "number" },
              status: { type: "boolean" },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" },
              category: { type: "object" },
              supplier: { type: "object" },
              store: { type: "object" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var deleteProductSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" }
  }
};
var updateStatusSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["status"],
    properties: {
      status: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        status: { type: "boolean" },
        category: { type: "object" },
        supplier: { type: "object" },
        store: { type: "object" }
      }
    }
  }
};
var verifySkuSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["sku"],
    properties: {
      sku: { type: "string", minLength: 1 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        available: { type: "boolean" },
        message: { type: "string" }
      }
    }
  }
};
var updateStockSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["quantity", "type"],
    properties: {
      quantity: { type: "number", minimum: 0.01 },
      type: {
        type: "string",
        enum: ["ENTRADA", "SAIDA", "PERDA"]
      },
      note: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        product: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            currentStock: { type: "number" }
          }
        },
        movement: {
          type: "object",
          properties: {
            id: { type: "string" },
            type: { type: "string" },
            quantity: { type: "number" },
            note: { type: "string", nullable: true },
            balanceAfter: { type: "number" },
            createdAt: { type: "string", format: "date-time" },
            supplier: { type: "object", nullable: true },
            user: { type: "object", nullable: true }
          }
        }
      }
    }
  }
};
var getProductMovementsSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      type: {
        type: "string",
        enum: ["ENTRADA", "SAIDA", "PERDA"]
      },
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              type: { type: "string" },
              quantity: { type: "number" },
              batch: { type: "string", nullable: true },
              expiration: { type: "string", format: "date-time", nullable: true },
              price: { type: "number", nullable: true },
              note: { type: "string", nullable: true },
              balanceAfter: { type: "number", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              product: { type: "object" },
              supplier: { type: "object", nullable: true },
              user: { type: "object", nullable: true },
              store: { type: "object" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var createProductMovementSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["type", "quantity"],
    properties: {
      type: {
        type: "string",
        enum: ["ENTRADA", "SAIDA", "PERDA"]
      },
      quantity: { type: "number", minimum: 0.01 },
      supplierId: { type: "string" },
      batch: { type: "string" },
      expiration: { type: "string", format: "date" },
      price: { type: "number", minimum: 0 },
      note: { type: "string" }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        type: { type: "string" },
        quantity: { type: "number" },
        batch: { type: "string", nullable: true },
        expiration: { type: "string", format: "date-time", nullable: true },
        price: { type: "number", nullable: true },
        note: { type: "string", nullable: true },
        balanceAfter: { type: "number" },
        createdAt: { type: "string", format: "date-time" },
        product: { type: "object" },
        supplier: { type: "object", nullable: true },
        user: { type: "object", nullable: true },
        store: { type: "object" }
      }
    }
  }
};
var getProductStockSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        currentStock: { type: "number" },
        stockMin: { type: "number" },
        stockMax: { type: "number" },
        alertPercentage: { type: "number" },
        status: {
          type: "string",
          enum: ["OK", "LOW", "CRITICAL", "OVERSTOCK"]
        },
        lastMovement: {
          type: "object",
          nullable: true,
          properties: {
            type: { type: "string" },
            quantity: { type: "number" },
            date: { type: "string", format: "date-time" }
          }
        }
      }
    }
  }
};
var getProductStockHistorySchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      limit: { type: "number", minimum: 1, maximum: 100, default: 30 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        product: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            stockMin: { type: "number" },
            stockMax: { type: "number" },
            alertPercentage: { type: "number" }
          }
        },
        currentStock: { type: "number" },
        history: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              type: { type: "string" },
              quantity: { type: "number" },
              batch: { type: "string", nullable: true },
              expiration: { type: "string", format: "date-time", nullable: true },
              price: { type: "number", nullable: true },
              note: { type: "string", nullable: true },
              balanceAfter: { type: "number" },
              createdAt: { type: "string", format: "date-time" },
              supplier: { type: "object", nullable: true },
              user: { type: "object", nullable: true }
            }
          }
        }
      }
    }
  }
};
var getLowStockProductsSchema = {
  querystring: {
    type: "object",
    properties: {
      storeId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        products: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              currentStock: { type: "number" },
              stockMin: { type: "number" },
              stockMax: { type: "number" },
              stockStatus: {
                type: "string",
                enum: ["LOW", "CRITICAL"]
              },
              category: { type: "object", nullable: true },
              supplier: { type: "object", nullable: true },
              store: { type: "object" }
            }
          }
        }
      }
    }
  }
};
var getProductAnalyticsSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        product: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            stockMin: { type: "number" },
            stockMax: { type: "number" },
            alertPercentage: { type: "number" }
          }
        },
        currentStock: { type: "number" },
        statistics: {
          type: "object",
          properties: {
            totalMovements: { type: "number" },
            totalEntrada: { type: "number" },
            totalSaida: { type: "number" },
            totalPerda: { type: "number" },
            monthlyMovements: { type: "object" },
            supplierStats: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  supplier: { type: "object" },
                  totalMovements: { type: "number" },
                  totalQuantity: { type: "number" }
                }
              }
            }
          }
        }
      }
    }
  }
};
var addProductCategoriesSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["categoryIds"],
    properties: {
      categoryIds: {
        type: "array",
        items: { type: "string", minLength: 1 },
        minItems: 1,
        uniqueItems: true
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        message: { type: "string" },
        addedCount: { type: "number" },
        categories: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              code: { type: "string", nullable: true },
              color: { type: "string", nullable: true },
              icon: { type: "string", nullable: true }
            }
          }
        }
      }
    }
  }
};
var removeProductCategoriesSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["categoryIds"],
    properties: {
      categoryIds: {
        type: "array",
        items: { type: "string", minLength: 1 },
        minItems: 1,
        uniqueItems: true
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        message: { type: "string" },
        removedCount: { type: "number" }
      }
    }
  }
};
var setProductCategoriesSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["categoryIds"],
    properties: {
      categoryIds: {
        type: "array",
        items: { type: "string", minLength: 1 },
        uniqueItems: true
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        message: { type: "string" },
        categories: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              code: { type: "string", nullable: true },
              color: { type: "string", nullable: true },
              icon: { type: "string", nullable: true }
            }
          }
        }
      }
    }
  }
};
var getProductCategoriesSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        categories: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              code: { type: "string", nullable: true },
              color: { type: "string", nullable: true },
              icon: { type: "string", nullable: true }
            }
          }
        }
      }
    }
  }
};
var getProductsByCategorySchema = {
  params: {
    type: "object",
    required: ["categoryId"],
    properties: {
      categoryId: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      status: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        products: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              unitOfMeasure: { type: "string" },
              referencePrice: { type: "number" },
              stockMin: { type: "number" },
              stockMax: { type: "number" },
              alertPercentage: { type: "number" },
              status: { type: "boolean" },
              createdAt: { type: "string", format: "date-time" },
              supplier: { type: "object", nullable: true },
              store: { type: "object" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var bulkDeleteProductsSchema = {
  body: {
    type: "object",
    required: ["ids"],
    properties: {
      ids: {
        type: "array",
        items: { type: "string", minLength: 1 },
        minItems: 1
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        deleted: { type: "number" },
        errors: {
          type: "array",
          items: { type: "string" }
        }
      }
    }
  }
};
var ProductSchemas = {
  create: createProductSchema,
  update: updateProductSchema,
  get: getProductSchema,
  delete: deleteProductSchema,
  list: listProductsSchema,
  updateStatus: updateStatusSchema,
  bulkDelete: bulkDeleteProductsSchema,
  // Funções adicionais
  verifySku: verifySkuSchema,
  updateStock: updateStockSchema,
  getMovements: getProductMovementsSchema,
  createMovement: createProductMovementSchema,
  getStock: getProductStockSchema,
  getStockHistory: getProductStockHistorySchema,
  getLowStock: getLowStockProductsSchema,
  getAnalytics: getProductAnalyticsSchema,
  // Gerenciar categorias
  addCategories: addProductCategoriesSchema,
  removeCategories: removeProductCategoriesSchema,
  setCategories: setProductCategoriesSchema,
  getCategories: getProductCategoriesSchema,
  getByCategory: getProductsByCategorySchema
};

// src/features/product/product.routes.ts
init_auth_middleware();

// src/middlewares/store-context.middleware.ts
init_prisma();
var getUserStore2 = async (userId) => {
  console.log("getUserStore: Searching for store for user:", userId);
  console.log("getUserStore: Checking owned stores...");
  const ownedStore = await db.store.findFirst({
    where: { ownerId: userId },
    select: { id: true, name: true }
  });
  if (ownedStore) {
    console.log("getUserStore: Found owned store:", ownedStore);
    return ownedStore;
  }
  console.log("getUserStore: Checking store user access...");
  const storeUser = await db.storeUser.findFirst({
    where: { userId },
    include: {
      store: {
        select: { id: true, name: true }
      }
    }
  });
  if (storeUser) {
    console.log("getUserStore: Found store user access:", storeUser);
    return storeUser.store;
  }
  console.log("getUserStore: No store found for user");
  return null;
};
var storeContextMiddleware = async (request, reply) => {
  try {
    console.log("StoreContextMiddleware: Starting...");
    if (!request.user?.id) {
      console.log("StoreContextMiddleware: User not authenticated");
      return reply.status(401).send({
        error: "User not authenticated"
      });
    }
    console.log("StoreContextMiddleware: User authenticated:", request.user.id);
    console.log("StoreContextMiddleware: Getting store for user...");
    const userStore = await getUserStore2(request.user.id);
    if (!userStore) {
      console.log("StoreContextMiddleware: User has no associated store");
      return reply.status(400).send({
        error: "User has no associated store. Please create a store or provide storeId in request."
      });
    }
    console.log("StoreContextMiddleware: Found user store:", userStore);
    request.store = userStore;
    if (request.body && typeof request.body === "object" && !("storeId" in request.body)) {
      console.log("StoreContextMiddleware: Adding storeId to request body");
      request.body.storeId = userStore.id;
    }
    console.log("StoreContextMiddleware: Completed successfully");
    return;
  } catch (error) {
    console.log("StoreContextMiddleware: Error:", error);
    request.log.error(error);
    return reply.status(500).send({
      error: "Internal server error"
    });
  }
};

// src/features/product/product.routes.ts
async function ProductRoutes(fastify2) {
  fastify2.addHook("preHandler", authMiddleware);
  fastify2.addHook("preHandler", storeContextMiddleware);
  fastify2.post("/", {
    schema: ProductSchemas.create,
    handler: ProductController.create
  });
  fastify2.get("/", {
    schema: ProductSchemas.list,
    handler: ProductController.list
  });
  fastify2.get("/:id", {
    schema: ProductSchemas.get,
    handler: ProductController.get
  });
  fastify2.put("/:id", {
    schema: ProductSchemas.update,
    handler: ProductController.update
  });
  fastify2.delete("/:id", {
    schema: ProductSchemas.delete,
    handler: ProductController.delete
  });
  fastify2.delete("/:id/force", {
    schema: ProductSchemas.delete,
    handler: ProductController.forceDelete
  });
  fastify2.get("/active", {
    handler: ProductController.getActive
  });
  fastify2.get("/stats", {
    handler: ProductController.getStats
  });
  fastify2.get("/search", {
    schema: {
      querystring: {
        type: "object",
        properties: {
          q: { type: "string" },
          limit: { type: "number" }
        },
        required: ["q"]
      }
    },
    handler: ProductController.search
  });
  fastify2.post("/bulk-delete", {
    schema: ProductSchemas.bulkDelete,
    handler: ProductController.bulkDelete
  });
  fastify2.get("/category/:categoryId", {
    schema: {
      params: {
        type: "object",
        properties: {
          categoryId: { type: "string" }
        },
        required: ["categoryId"]
      }
    },
    handler: ProductController.getByCategory
  });
  fastify2.get("/supplier/:supplierId", {
    schema: {
      params: {
        type: "object",
        properties: {
          supplierId: { type: "string" }
        },
        required: ["supplierId"]
      }
    },
    handler: ProductController.getBySupplier
  });
  fastify2.get("/store/:storeId", {
    schema: {
      params: {
        type: "object",
        properties: {
          storeId: { type: "string" }
        },
        required: ["storeId"]
      }
    },
    handler: ProductController.getByStore
  });
  fastify2.patch("/:id/status", {
    schema: ProductSchemas.updateStatus,
    handler: ProductController.updateStatus
  });
  fastify2.post("/:id/categories", {
    schema: ProductSchemas.addCategories,
    handler: ProductController.addCategories
  });
  fastify2.delete("/:id/categories", {
    schema: ProductSchemas.removeCategories,
    handler: ProductController.removeCategories
  });
  fastify2.put("/:id/categories", {
    schema: ProductSchemas.setCategories,
    handler: ProductController.setCategories
  });
  fastify2.get("/:id/categories", {
    schema: ProductSchemas.getCategories,
    handler: ProductController.getCategories
  });
}

// src/features/supplier/commands/supplier.commands.ts
init_prisma();
var SupplierCommands = {
  async create(data) {
    const existingSupplier = await db.supplier.findUnique({
      where: {
        cnpj_storeId: {
          cnpj: data.cnpj,
          storeId: data.storeId || null
        }
      }
    });
    if (existingSupplier) {
      throw new Error("CNPJ already exists");
    }
    const responsiblesData = data.responsibles?.map((responsible) => ({
      name: responsible.name,
      phone: responsible.phone,
      email: responsible.email,
      cpf: responsible.cpf,
      status: true
    })) || [];
    return await db.supplier.create({
      data: {
        corporateName: data.corporateName,
        cnpj: data.cnpj,
        tradeName: data.tradeName,
        cep: data.cep,
        city: data.city,
        state: data.state,
        address: data.address,
        storeId: data.storeId,
        status: true,
        responsibles: {
          create: responsiblesData
        }
      },
      include: {
        responsibles: true,
        products: {
          select: {
            id: true,
            name: true,
            status: true
          }
        }
      }
    });
  },
  async update(id, data) {
    const existingSupplier = await db.supplier.findUnique({
      where: { id }
    });
    if (!existingSupplier) {
      throw new Error("Supplier not found");
    }
    if (data.cnpj && data.cnpj !== existingSupplier.cnpj) {
      const cnpjExists = await db.supplier.findUnique({
        where: {
          cnpj_storeId: {
            cnpj: data.cnpj,
            storeId: existingSupplier.storeId
          }
        }
      });
      if (cnpjExists) {
        throw new Error("CNPJ already exists");
      }
    }
    return await db.supplier.update({
      where: { id },
      data,
      include: {
        responsibles: true,
        products: {
          select: {
            id: true,
            name: true,
            status: true
          }
        }
      }
    });
  },
  async delete(id) {
    const existingSupplier = await db.supplier.findUnique({
      where: { id }
    });
    if (!existingSupplier) {
      throw new Error("Supplier not found");
    }
    const productsCount = await db.product.count({
      where: { supplierId: id }
    });
    if (productsCount > 0) {
      throw new Error("Cannot delete supplier with associated products");
    }
    return await db.supplier.delete({
      where: { id }
    });
  },
  async toggleStatus(id) {
    const supplier = await db.supplier.findUnique({
      where: { id }
    });
    if (!supplier) {
      throw new Error("Supplier not found");
    }
    return await db.supplier.update({
      where: { id },
      data: { status: !supplier.status },
      include: {
        responsibles: true,
        products: {
          select: {
            id: true,
            name: true,
            status: true
          }
        }
      }
    });
  }
};

// src/features/supplier/queries/supplier.queries.ts
init_prisma();
var SupplierQueries = {
  async getById(id) {
    const supplier = await db.supplier.findUnique({
      where: { id },
      include: {
        responsibles: true,
        products: {
          select: {
            id: true,
            name: true,
            status: true,
            referencePrice: true,
            stockMin: true,
            stockMax: true
          }
        }
      }
    });
    if (!supplier) {
      throw new Error("Supplier not found");
    }
    return supplier;
  },
  async list(params) {
    const { page = 1, limit = 10, search, status, storeId } = params;
    const skip2 = (page - 1) * limit;
    const where = {};
    if (search) {
      where.OR = [
        { corporateName: { contains: search, mode: "insensitive" } },
        { tradeName: { contains: search, mode: "insensitive" } },
        { cnpj: { contains: search } },
        { city: { contains: search, mode: "insensitive" } },
        { state: { contains: search, mode: "insensitive" } }
      ];
    }
    if (status !== void 0) {
      where.status = status;
    }
    if (storeId) {
      where.storeId = storeId;
    }
    const [suppliers, total] = await Promise.all([
      db.supplier.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          responsibles: {
            where: { status: true }
          },
          products: {
            select: {
              id: true,
              name: true,
              status: true
            }
          }
        }
      }),
      db.supplier.count({ where })
    ]);
    return {
      items: suppliers,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getByCnpj(cnpj, storeId) {
    const supplier = await db.supplier.findUnique({
      where: { cnpj_storeId: { cnpj, storeId: storeId || null } },
      include: {
        responsibles: true,
        products: {
          select: {
            id: true,
            name: true,
            status: true
          }
        }
      }
    });
    if (!supplier) {
      throw new Error("Supplier not found");
    }
    return supplier;
  },
  async getByCity(city) {
    return await db.supplier.findMany({
      where: {
        city: { contains: city, mode: "insensitive" },
        status: true
      },
      orderBy: { corporateName: "asc" },
      include: {
        responsibles: {
          where: { status: true }
        }
      }
    });
  },
  async getByState(state) {
    return await db.supplier.findMany({
      where: {
        state: { contains: state, mode: "insensitive" },
        status: true
      },
      orderBy: { corporateName: "asc" },
      include: {
        responsibles: {
          where: { status: true }
        }
      }
    });
  },
  async getActive() {
    return await db.supplier.findMany({
      where: { status: true },
      orderBy: { corporateName: "asc" },
      select: {
        id: true,
        corporateName: true,
        tradeName: true,
        cnpj: true,
        city: true,
        state: true
      }
    });
  },
  async search(term, limit = 10) {
    return await db.supplier.findMany({
      where: {
        status: true,
        OR: [
          { corporateName: { contains: term, mode: "insensitive" } },
          { tradeName: { contains: term, mode: "insensitive" } },
          { cnpj: { contains: term } }
        ]
      },
      take: limit,
      orderBy: { corporateName: "asc" },
      select: {
        id: true,
        corporateName: true,
        tradeName: true,
        cnpj: true,
        city: true,
        state: true
      }
    });
  },
  async getStats() {
    const [total, active, inactive, withProducts] = await Promise.all([
      db.supplier.count(),
      db.supplier.count({ where: { status: true } }),
      db.supplier.count({ where: { status: false } }),
      db.supplier.count({
        where: {
          products: {
            some: {}
          }
        }
      })
    ]);
    return {
      total,
      active,
      inactive,
      withProducts,
      withoutProducts: total - withProducts
    };
  },
  async getTopSuppliers(limit = 5) {
    return await db.supplier.findMany({
      where: { status: true },
      orderBy: {
        products: {
          _count: "desc"
        }
      },
      take: limit,
      select: {
        id: true,
        corporateName: true,
        tradeName: true,
        cnpj: true,
        _count: {
          select: { products: true }
        }
      }
    });
  }
};

// src/features/supplier/supplier.controller.ts
var SupplierController = {
  // === CRUD BÁSICO ===
  async create(request, reply) {
    try {
      const { corporateName, cnpj, tradeName, cep, city, state, address, storeId, responsibles } = request.body;
      const contextStoreId = request.store?.id;
      const result = await SupplierCommands.create({
        corporateName,
        cnpj,
        tradeName,
        cep,
        city,
        state,
        address,
        storeId: storeId || contextStoreId,
        responsibles
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "CNPJ already exists") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      const result = await SupplierQueries.getById(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Supplier not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      const result = await SupplierCommands.update(id, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Supplier not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "CNPJ already exists") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      await SupplierCommands.delete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Supplier not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Cannot delete supplier with associated products") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { page = 1, limit = 10, search, status } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await SupplierQueries.list({
        page,
        limit,
        search,
        status,
        storeId
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (QUERIES) ===
  async getByCnpj(request, reply) {
    try {
      const { cnpj } = request.params;
      const storeId = request.store?.id;
      const result = await SupplierQueries.getByCnpj(cnpj, storeId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Supplier not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByCity(request, reply) {
    try {
      const { city } = request.params;
      const result = await SupplierQueries.getByCity(city);
      return reply.send({ suppliers: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByState(request, reply) {
    try {
      const { state } = request.params;
      const result = await SupplierQueries.getByState(state);
      return reply.send({ suppliers: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getActive(request, reply) {
    try {
      const result = await SupplierQueries.getActive();
      return reply.send({ suppliers: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const result = await SupplierQueries.getStats();
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { q, limit = 10 } = request.query;
      const result = await SupplierQueries.search(q, limit);
      return reply.send({ suppliers: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getTopSuppliers(request, reply) {
    try {
      const { limit = 5 } = request.query;
      const result = await SupplierQueries.getTopSuppliers(limit);
      return reply.send({ suppliers: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (COMMANDS) ===
  async toggleStatus(request, reply) {
    try {
      const { id } = request.params;
      const result = await SupplierCommands.toggleStatus(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Supplier not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/supplier/supplier.schema.ts
var createSupplierSchema = {
  body: {
    type: "object",
    required: ["corporateName", "cnpj"],
    properties: {
      corporateName: { type: "string", minLength: 1 },
      cnpj: { type: "string", minLength: 14 },
      tradeName: { type: "string" },
      cep: { type: "string" },
      city: { type: "string" },
      state: { type: "string" },
      address: { type: "string" },
      storeId: { type: "string" },
      responsibles: {
        type: "array",
        items: {
          type: "object",
          required: ["name"],
          properties: {
            name: { type: "string", minLength: 1 },
            phone: { type: "string" },
            email: { type: "string", format: "email" },
            cpf: { type: "string" }
          }
        }
      }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        corporateName: { type: "string" },
        cnpj: { type: "string" },
        tradeName: { type: "string", nullable: true },
        cep: { type: "string", nullable: true },
        city: { type: "string", nullable: true },
        state: { type: "string", nullable: true },
        address: { type: "string", nullable: true },
        status: { type: "boolean" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        responsibles: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              phone: { type: "string", nullable: true },
              email: { type: "string", nullable: true },
              cpf: { type: "string", nullable: true },
              status: { type: "boolean" }
            }
          }
        }
      }
    }
  }
};
var updateSupplierSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      corporateName: { type: "string", minLength: 1 },
      cnpj: { type: "string", minLength: 14 },
      tradeName: { type: "string" },
      status: { type: "boolean" },
      cep: { type: "string" },
      city: { type: "string" },
      state: { type: "string" },
      address: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        corporateName: { type: "string" },
        cnpj: { type: "string" },
        tradeName: { type: "string", nullable: true },
        cep: { type: "string", nullable: true },
        city: { type: "string", nullable: true },
        state: { type: "string", nullable: true },
        address: { type: "string", nullable: true },
        status: { type: "boolean" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var getSupplierSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        corporateName: { type: "string" },
        cnpj: { type: "string" },
        tradeName: { type: "string", nullable: true },
        cep: { type: "string", nullable: true },
        city: { type: "string", nullable: true },
        state: { type: "string", nullable: true },
        address: { type: "string", nullable: true },
        status: { type: "boolean" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var deleteSupplierSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" }
  }
};
var listSuppliersSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      status: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              corporateName: { type: "string" },
              cnpj: { type: "string" },
              tradeName: { type: "string", nullable: true },
              cep: { type: "string", nullable: true },
              city: { type: "string", nullable: true },
              state: { type: "string", nullable: true },
              address: { type: "string", nullable: true },
              status: { type: "boolean" },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" },
              responsibles: {
                type: "array",
                items: {
                  type: "object",
                  properties: {
                    id: { type: "string" },
                    name: { type: "string" },
                    email: { type: "string" },
                    phone: { type: "string", nullable: true },
                    status: { type: "boolean" }
                  }
                }
              },
              products: {
                type: "array",
                items: {
                  type: "object",
                  properties: {
                    id: { type: "string" },
                    name: { type: "string" },
                    status: { type: "boolean" }
                  }
                }
              }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getSupplierByCnpjSchema = {
  params: {
    type: "object",
    required: ["cnpj"],
    properties: {
      cnpj: { type: "string", minLength: 14 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        corporateName: { type: "string" },
        cnpj: { type: "string" },
        tradeName: { type: "string", nullable: true },
        cep: { type: "string", nullable: true },
        city: { type: "string", nullable: true },
        state: { type: "string", nullable: true },
        address: { type: "string", nullable: true },
        status: { type: "boolean" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var getSuppliersByCitySchema = {
  params: {
    type: "object",
    required: ["city"],
    properties: {
      city: { type: "string", minLength: 1 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        suppliers: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              corporateName: { type: "string" },
              cnpj: { type: "string" },
              tradeName: { type: "string", nullable: true },
              cep: { type: "string", nullable: true },
              city: { type: "string", nullable: true },
              state: { type: "string", nullable: true },
              address: { type: "string", nullable: true },
              status: { type: "boolean" },
              createdAt: { type: "string", format: "date-time" }
            }
          }
        }
      }
    }
  }
};
var getSuppliersByStateSchema = {
  params: {
    type: "object",
    required: ["state"],
    properties: {
      state: { type: "string", minLength: 1 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        suppliers: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              corporateName: { type: "string" },
              cnpj: { type: "string" },
              tradeName: { type: "string", nullable: true },
              cep: { type: "string", nullable: true },
              city: { type: "string", nullable: true },
              state: { type: "string", nullable: true },
              address: { type: "string", nullable: true },
              status: { type: "boolean" },
              createdAt: { type: "string", format: "date-time" }
            }
          }
        }
      }
    }
  }
};
var searchSuppliersSchema = {
  querystring: {
    type: "object",
    required: ["q"],
    properties: {
      q: { type: "string", minLength: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        suppliers: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              corporateName: { type: "string" },
              cnpj: { type: "string" },
              tradeName: { type: "string", nullable: true },
              cep: { type: "string", nullable: true },
              city: { type: "string", nullable: true },
              state: { type: "string", nullable: true },
              address: { type: "string", nullable: true },
              status: { type: "boolean" },
              createdAt: { type: "string", format: "date-time" }
            }
          }
        }
      }
    }
  }
};
var SupplierSchemas = {
  create: createSupplierSchema,
  update: updateSupplierSchema,
  get: getSupplierSchema,
  delete: deleteSupplierSchema,
  list: listSuppliersSchema,
  getByCnpj: getSupplierByCnpjSchema,
  getByCity: getSuppliersByCitySchema,
  getByState: getSuppliersByStateSchema,
  search: searchSuppliersSchema
};

// src/features/supplier/commands/supplier-responsible.commands.ts
init_prisma();
var SupplierResponsibleCommands = {
  async create({ supplierId, data }) {
    const supplier = await db.supplier.findUnique({
      where: { id: supplierId }
    });
    if (!supplier) {
      throw new Error("Supplier not found");
    }
    if (data.email) {
      const existingEmail = await db.supplierResponsible.findFirst({
        where: {
          supplierId,
          email: data.email
        }
      });
      if (existingEmail) {
        throw new Error("Email already exists for this supplier");
      }
    }
    if (data.cpf) {
      const existingCpf = await db.supplierResponsible.findFirst({
        where: {
          supplierId,
          cpf: data.cpf
        }
      });
      if (existingCpf) {
        throw new Error("CPF already exists for this supplier");
      }
    }
    return await db.supplierResponsible.create({
      data: {
        ...data,
        supplierId,
        status: true
      }
    });
  },
  async update({ supplierId, responsibleId, data }) {
    const existingResponsible = await db.supplierResponsible.findFirst({
      where: {
        id: responsibleId,
        supplierId
      }
    });
    if (!existingResponsible) {
      throw new Error("Responsible not found for this supplier");
    }
    if (data.email) {
      const existingEmail = await db.supplierResponsible.findFirst({
        where: {
          supplierId,
          email: data.email,
          id: { not: responsibleId }
        }
      });
      if (existingEmail) {
        throw new Error("Email already exists for another responsible of this supplier");
      }
    }
    if (data.cpf) {
      const existingCpf = await db.supplierResponsible.findFirst({
        where: {
          supplierId,
          cpf: data.cpf,
          id: { not: responsibleId }
        }
      });
      if (existingCpf) {
        throw new Error("CPF already exists for another responsible of this supplier");
      }
    }
    return await db.supplierResponsible.update({
      where: { id: responsibleId },
      data
    });
  },
  async delete({ supplierId, responsibleId }) {
    const existingResponsible = await db.supplierResponsible.findFirst({
      where: {
        id: responsibleId,
        supplierId
      }
    });
    if (!existingResponsible) {
      throw new Error("Responsible not found for this supplier");
    }
    await db.supplierResponsible.delete({
      where: { id: responsibleId }
    });
  },
  async toggleStatus({ supplierId, responsibleId }) {
    const existingResponsible = await db.supplierResponsible.findFirst({
      where: {
        id: responsibleId,
        supplierId
      }
    });
    if (!existingResponsible) {
      throw new Error("Responsible not found for this supplier");
    }
    return await db.supplierResponsible.update({
      where: { id: responsibleId },
      data: {
        status: !existingResponsible.status
      }
    });
  },
  async bulkCreate({ supplierId, responsibles }) {
    const supplier = await db.supplier.findUnique({
      where: { id: supplierId }
    });
    if (!supplier) {
      throw new Error("Supplier not found");
    }
    const emails = responsibles.filter((r) => r.email).map((r) => r.email);
    const cpfs = responsibles.filter((r) => r.cpf).map((r) => r.cpf);
    if (new Set(emails).size !== emails.length) {
      throw new Error("Duplicate emails found in the provided data");
    }
    if (new Set(cpfs).size !== cpfs.length) {
      throw new Error("Duplicate CPFs found in the provided data");
    }
    if (emails.length > 0) {
      const existingEmails = await db.supplierResponsible.findMany({
        where: {
          supplierId,
          email: { in: emails }
        },
        select: { email: true }
      });
      if (existingEmails.length > 0) {
        throw new Error(`Emails already exist: ${existingEmails.map((e) => e.email).join(", ")}`);
      }
    }
    if (cpfs.length > 0) {
      const existingCpfs = await db.supplierResponsible.findMany({
        where: {
          supplierId,
          cpf: { in: cpfs }
        },
        select: { cpf: true }
      });
      if (existingCpfs.length > 0) {
        throw new Error(`CPFs already exist: ${existingCpfs.map((c) => c.cpf).join(", ")}`);
      }
    }
    return await db.supplierResponsible.createMany({
      data: responsibles.map((responsible) => ({
        ...responsible,
        supplierId,
        status: true
      }))
    });
  }
};

// src/features/supplier/queries/supplier-responsible.queries.ts
init_prisma();
var SupplierResponsibleQueries = {
  async getById({ supplierId, responsibleId }) {
    const responsible = await db.supplierResponsible.findFirst({
      where: {
        id: responsibleId,
        supplierId
      }
    });
    if (!responsible) {
      throw new Error("Responsible not found for this supplier");
    }
    return responsible;
  },
  async list({ supplierId, params }) {
    const { page = 1, limit = 10, search, status } = params;
    const skip2 = (page - 1) * limit;
    const supplier = await db.supplier.findUnique({
      where: { id: supplierId }
    });
    if (!supplier) {
      throw new Error("Supplier not found");
    }
    const where = {
      supplierId
    };
    if (status !== void 0) {
      where.status = status;
    }
    if (search) {
      where.OR = [
        { name: { contains: search, mode: "insensitive" } },
        { email: { contains: search, mode: "insensitive" } },
        { phone: { contains: search, mode: "insensitive" } },
        { cpf: { contains: search, mode: "insensitive" } }
      ];
    }
    const [responsibles, total] = await Promise.all([
      db.supplierResponsible.findMany({
        where,
        skip: skip2,
        take: limit
      }),
      db.supplierResponsible.count({ where })
    ]);
    const totalPages = Math.ceil(total / limit);
    return {
      responsibles,
      pagination: {
        page,
        limit,
        total,
        totalPages
      }
    };
  },
  async getByEmail({ supplierId, email }) {
    const responsible = await db.supplierResponsible.findFirst({
      where: {
        supplierId,
        email
      }
    });
    if (!responsible) {
      throw new Error("Responsible not found with this email for this supplier");
    }
    return responsible;
  },
  async getByCpf({ supplierId, cpf }) {
    const responsible = await db.supplierResponsible.findFirst({
      where: {
        supplierId,
        cpf
      }
    });
    if (!responsible) {
      throw new Error("Responsible not found with this CPF for this supplier");
    }
    return responsible;
  },
  async getActive({ supplierId }) {
    const supplier = await db.supplier.findUnique({
      where: { id: supplierId }
    });
    if (!supplier) {
      throw new Error("Supplier not found");
    }
    return await db.supplierResponsible.findMany({
      where: {
        supplierId,
        status: true
      },
      orderBy: { name: "asc" }
    });
  },
  async getStats({ supplierId }) {
    const supplier = await db.supplier.findUnique({
      where: { id: supplierId }
    });
    if (!supplier) {
      throw new Error("Supplier not found");
    }
    const [total, active, inactive] = await Promise.all([
      db.supplierResponsible.count({
        where: { supplierId }
      }),
      db.supplierResponsible.count({
        where: { supplierId, status: true }
      }),
      db.supplierResponsible.count({
        where: { supplierId, status: false }
      })
    ]);
    return {
      total,
      active,
      inactive
    };
  },
  async search({ supplierId, searchTerm, limit }) {
    const supplier = await db.supplier.findUnique({
      where: { id: supplierId }
    });
    if (!supplier) {
      throw new Error("Supplier not found");
    }
    return await db.supplierResponsible.findMany({
      where: {
        supplierId,
        OR: [
          { name: { contains: searchTerm, mode: "insensitive" } },
          { email: { contains: searchTerm, mode: "insensitive" } },
          { phone: { contains: searchTerm, mode: "insensitive" } },
          { cpf: { contains: searchTerm, mode: "insensitive" } }
        ]
      },
      take: limit,
      orderBy: { name: "asc" }
    });
  },
  async getBySupplier({ supplierId }) {
    const supplier = await db.supplier.findUnique({
      where: { id: supplierId }
    });
    if (!supplier) {
      throw new Error("Supplier not found");
    }
    return await db.supplierResponsible.findMany({
      where: { supplierId },
      orderBy: { name: "asc" }
    });
  },
  async getRecent({ supplierId, limit }) {
    const supplier = await db.supplier.findUnique({
      where: { id: supplierId }
    });
    if (!supplier) {
      throw new Error("Supplier not found");
    }
    return await db.supplierResponsible.findMany({
      where: { supplierId },
      take: limit
    });
  }
};

// src/features/supplier/supplier-responsible.controller.ts
var SupplierResponsibleController = {
  // === CRUD BÁSICO ===
  async create(request, reply) {
    try {
      const { supplierId } = request.params;
      const { name, email, phone, cpf } = request.body;
      const createData = { name, email, phone, cpf };
      const result = await SupplierResponsibleCommands.create({ supplierId, data: createData });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Supplier not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Email already exists for this supplier" || error.message === "CPF already exists for this supplier") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { supplierId, responsibleId } = request.params;
      const result = await SupplierResponsibleQueries.getById({ supplierId, responsibleId });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Responsible not found for this supplier") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { supplierId, responsibleId } = request.params;
      const { name, email, phone, cpf, status } = request.body;
      const updateData = {};
      if (name !== void 0) updateData.name = name;
      if (email !== void 0) updateData.email = email;
      if (phone !== void 0) updateData.phone = phone;
      if (cpf !== void 0) updateData.cpf = cpf;
      if (status !== void 0) updateData.status = status;
      const result = await SupplierResponsibleCommands.update({ supplierId, responsibleId, data: updateData });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Responsible not found for this supplier") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Email already exists for another responsible of this supplier" || error.message === "CPF already exists for another responsible of this supplier") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { supplierId, responsibleId } = request.params;
      await SupplierResponsibleCommands.delete({ supplierId, responsibleId });
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Responsible not found for this supplier") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { supplierId } = request.params;
      const { page = 1, limit = 10, search, status } = request.query;
      const result = await SupplierResponsibleQueries.list({ supplierId, params: { page, limit, search, status } });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Supplier not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (QUERIES) ===
  async getByEmail(request, reply) {
    try {
      const { supplierId, email } = request.params;
      const result = await SupplierResponsibleQueries.getByEmail({ supplierId, email });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Responsible not found with this email for this supplier") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByCpf(request, reply) {
    try {
      const { supplierId, cpf } = request.params;
      const result = await SupplierResponsibleQueries.getByCpf({ supplierId, cpf });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Responsible not found with this CPF for this supplier") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getActive(request, reply) {
    try {
      const { supplierId } = request.params;
      const result = await SupplierResponsibleQueries.getActive({ supplierId });
      return reply.send({ responsibles: result });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Supplier not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const { supplierId } = request.params;
      const result = await SupplierResponsibleQueries.getStats({ supplierId });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Supplier not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { supplierId } = request.params;
      const { q, limit = 10 } = request.query;
      const result = await SupplierResponsibleQueries.search({ supplierId, searchTerm: q, limit });
      return reply.send({ responsibles: result });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Supplier not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getRecent(request, reply) {
    try {
      const { supplierId } = request.params;
      const { limit = 5 } = request.query;
      const result = await SupplierResponsibleQueries.getRecent({ supplierId, limit });
      return reply.send({ responsibles: result });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Supplier not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (COMMANDS) ===
  async toggleStatus(request, reply) {
    try {
      const { supplierId, responsibleId } = request.params;
      const result = await SupplierResponsibleCommands.toggleStatus({ supplierId, responsibleId });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Responsible not found for this supplier") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async bulkCreate(request, reply) {
    try {
      const { supplierId } = request.params;
      const responsibles = request.body;
      const filteredResponsibles = responsibles.map((responsible) => ({
        name: responsible.name,
        email: responsible.email,
        phone: responsible.phone,
        cpf: responsible.cpf
      }));
      const result = await SupplierResponsibleCommands.bulkCreate({ supplierId, responsibles: filteredResponsibles });
      return reply.status(201).send({
        message: `${result.count} responsibles created successfully`,
        count: result.count
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Supplier not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message.includes("already exist") || error.message.includes("Duplicate")) {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/supplier/supplier-responsible.schema.ts
var createSupplierResponsibleSchema = {
  params: {
    type: "object",
    required: ["supplierId"],
    properties: {
      supplierId: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["name"],
    properties: {
      name: { type: "string", minLength: 1 },
      email: { type: "string", format: "email" },
      phone: { type: "string" },
      cpf: { type: "string", minLength: 11, maxLength: 14 }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        email: { type: "string", nullable: true },
        phone: { type: "string", nullable: true },
        cpf: { type: "string", nullable: true },
        status: { type: "boolean" },
        supplierId: { type: "string" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var updateSupplierResponsibleSchema = {
  params: {
    type: "object",
    required: ["supplierId", "responsibleId"],
    properties: {
      supplierId: { type: "string" },
      responsibleId: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      name: { type: "string", minLength: 1 },
      email: { type: "string", format: "email" },
      phone: { type: "string" },
      cpf: { type: "string", minLength: 11, maxLength: 14 },
      status: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        email: { type: "string", nullable: true },
        phone: { type: "string", nullable: true },
        cpf: { type: "string", nullable: true },
        status: { type: "boolean" },
        supplierId: { type: "string" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var getSupplierResponsibleSchema = {
  params: {
    type: "object",
    required: ["supplierId", "responsibleId"],
    properties: {
      supplierId: { type: "string" },
      responsibleId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        email: { type: "string", nullable: true },
        phone: { type: "string", nullable: true },
        cpf: { type: "string", nullable: true },
        status: { type: "boolean" },
        supplierId: { type: "string" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var deleteSupplierResponsibleSchema = {
  params: {
    type: "object",
    required: ["supplierId", "responsibleId"],
    properties: {
      supplierId: { type: "string" },
      responsibleId: { type: "string" }
    }
  },
  response: {
    204: { type: "null" }
  }
};
var listSupplierResponsiblesSchema = {
  params: {
    type: "object",
    required: ["supplierId"],
    properties: {
      supplierId: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      status: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        responsibles: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              email: { type: "string", nullable: true },
              phone: { type: "string", nullable: true },
              cpf: { type: "string", nullable: true },
              status: { type: "boolean" },
              supplierId: { type: "string" },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getSupplierResponsibleByEmailSchema = {
  params: {
    type: "object",
    required: ["supplierId", "email"],
    properties: {
      supplierId: { type: "string" },
      email: { type: "string", format: "email" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        email: { type: "string", nullable: true },
        phone: { type: "string", nullable: true },
        cpf: { type: "string", nullable: true },
        status: { type: "boolean" },
        supplierId: { type: "string" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var getSupplierResponsibleByCpfSchema = {
  params: {
    type: "object",
    required: ["supplierId", "cpf"],
    properties: {
      supplierId: { type: "string" },
      cpf: { type: "string", minLength: 11, maxLength: 14 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        email: { type: "string", nullable: true },
        phone: { type: "string", nullable: true },
        cpf: { type: "string", nullable: true },
        status: { type: "boolean" },
        supplierId: { type: "string" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var SupplierResponsibleSchemas = {
  create: createSupplierResponsibleSchema,
  update: updateSupplierResponsibleSchema,
  get: getSupplierResponsibleSchema,
  delete: deleteSupplierResponsibleSchema,
  list: listSupplierResponsiblesSchema,
  getByEmail: getSupplierResponsibleByEmailSchema,
  getByCpf: getSupplierResponsibleByCpfSchema
};

// src/features/supplier/supplier-responsible.routes.ts
init_auth_middleware();
async function SupplierResponsibleRoutes(fastify2) {
  fastify2.post("/:supplierId/responsibles", {
    schema: SupplierResponsibleSchemas.create,
    preHandler: [authMiddleware],
    handler: SupplierResponsibleController.create
  });
  fastify2.get("/:supplierId/responsibles", {
    schema: SupplierResponsibleSchemas.list,
    handler: SupplierResponsibleController.list
  });
  fastify2.get("/:supplierId/responsibles/:responsibleId", {
    schema: SupplierResponsibleSchemas.get,
    handler: SupplierResponsibleController.get
  });
  fastify2.put("/:supplierId/responsibles/:responsibleId", {
    schema: SupplierResponsibleSchemas.update,
    preHandler: [authMiddleware],
    handler: SupplierResponsibleController.update
  });
  fastify2.delete("/:supplierId/responsibles/:responsibleId", {
    schema: SupplierResponsibleSchemas.delete,
    preHandler: [authMiddleware],
    handler: SupplierResponsibleController.delete
  });
  fastify2.get("/:supplierId/responsibles/email/:email", {
    schema: SupplierResponsibleSchemas.getByEmail,
    handler: SupplierResponsibleController.getByEmail
  });
  fastify2.get("/:supplierId/responsibles/cpf/:cpf", {
    schema: SupplierResponsibleSchemas.getByCpf,
    handler: SupplierResponsibleController.getByCpf
  });
  fastify2.get("/:supplierId/responsibles/active", {
    handler: SupplierResponsibleController.getActive
  });
  fastify2.get("/:supplierId/responsibles/stats", {
    handler: SupplierResponsibleController.getStats
  });
  fastify2.get("/:supplierId/responsibles/search", {
    handler: SupplierResponsibleController.search
  });
  fastify2.get("/:supplierId/responsibles/recent", {
    handler: SupplierResponsibleController.getRecent
  });
  fastify2.patch("/:supplierId/responsibles/:responsibleId/toggle-status", {
    preHandler: [authMiddleware],
    handler: SupplierResponsibleController.toggleStatus
  });
  fastify2.post("/:supplierId/responsibles/bulk", {
    preHandler: [authMiddleware],
    handler: SupplierResponsibleController.bulkCreate
  });
}

// src/features/supplier/supplier.routes.ts
init_auth_middleware();
async function SupplierRoutes(fastify2) {
  fastify2.addHook("preHandler", authMiddleware);
  fastify2.addHook("preHandler", storeContextMiddleware);
  fastify2.post("/", {
    schema: SupplierSchemas.create,
    handler: SupplierController.create
  });
  fastify2.get("/", {
    schema: SupplierSchemas.list,
    handler: SupplierController.list
  });
  fastify2.get("/:id", {
    schema: SupplierSchemas.get,
    handler: SupplierController.get
  });
  fastify2.put("/:id", {
    schema: SupplierSchemas.update,
    handler: SupplierController.update
  });
  fastify2.delete("/:id", {
    schema: SupplierSchemas.delete,
    handler: SupplierController.delete
  });
  fastify2.get("/cnpj/:cnpj", {
    schema: SupplierSchemas.getByCnpj,
    handler: SupplierController.getByCnpj
  });
  fastify2.get("/city/:city", {
    schema: SupplierSchemas.getByCity,
    handler: SupplierController.getByCity
  });
  fastify2.get("/state/:state", {
    schema: SupplierSchemas.getByState,
    handler: SupplierController.getByState
  });
  fastify2.get("/active", {
    handler: SupplierController.getActive
  });
  fastify2.get("/stats", {
    handler: SupplierController.getStats
  });
  fastify2.get("/search", {
    schema: SupplierSchemas.search,
    handler: SupplierController.search
  });
  fastify2.get("/top", {
    handler: SupplierController.getTopSuppliers
  });
  fastify2.patch("/:id/toggle-status", {
    schema: SupplierSchemas.get,
    handler: SupplierController.toggleStatus
  });
  await fastify2.register(SupplierResponsibleRoutes);
}

// src/features/store/commands/store.commands.ts
init_prisma();
var StoreCommands = {
  async create(data) {
    const existingStore = await db.store.findUnique({
      where: { cnpj: data.cnpj }
    });
    if (existingStore) {
      throw new Error("CNPJ already exists");
    }
    const owner = await db.user.findUnique({
      where: { id: data.ownerId }
    });
    if (!owner) {
      throw new Error("Owner not found");
    }
    return await db.store.create({
      data: {
        ownerId: data.ownerId,
        name: data.name,
        cnpj: data.cnpj,
        email: data.email || null,
        phone: data.phone || null,
        cep: data.cep || null,
        city: data.city || null,
        state: data.state || null,
        address: data.address || null,
        status: data.status !== void 0 ? data.status : true
      },
      include: {
        owner: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async update(id, data) {
    const existingStore = await db.store.findUnique({
      where: { id }
    });
    if (!existingStore) {
      throw new Error("Store not found");
    }
    if (data.cnpj && data.cnpj !== existingStore.cnpj) {
      const cnpjExists = await db.store.findUnique({
        where: { cnpj: data.cnpj }
      });
      if (cnpjExists) {
        throw new Error("CNPJ already exists");
      }
    }
    return await db.store.update({
      where: { id },
      data: {
        ...data,
        email: data.email === "" ? null : data.email,
        phone: data.phone === "" ? null : data.phone,
        cep: data.cep === "" ? null : data.cep,
        city: data.city === "" ? null : data.city,
        state: data.state === "" ? null : data.state,
        address: data.address === "" ? null : data.address
      },
      include: {
        owner: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async delete(id) {
    const existingStore = await db.store.findUnique({
      where: { id }
    });
    if (!existingStore) {
      throw new Error("Store not found");
    }
    const productCount = await db.product.count({
      where: { storeId: id }
    });
    if (productCount > 0) {
      throw new Error("Cannot delete store with existing products");
    }
    return await db.store.delete({
      where: { id }
    });
  },
  async toggleStatus(id) {
    const store = await db.store.findUnique({
      where: { id }
    });
    if (!store) {
      throw new Error("Store not found");
    }
    return await db.store.update({
      where: { id },
      data: { status: !store.status },
      include: {
        owner: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async verifyCnpj(cnpj) {
    const store = await db.store.findUnique({
      where: { cnpj }
    });
    return {
      exists: !!store,
      store: store ? {
        id: store.id,
        name: store.name,
        status: store.status
      } : null
    };
  },
  // === GERENCIAMENTO DE USUÁRIOS DA LOJA ===
  async addUser(storeId, userId, role) {
    const store = await db.store.findUnique({
      where: { id: storeId }
    });
    if (!store) {
      throw new Error("Store not found");
    }
    const user = await db.user.findUnique({
      where: { id: userId, status: true }
    });
    if (!user) {
      throw new Error("User not found or inactive");
    }
    const existingStoreUser = await db.storeUser.findUnique({
      where: {
        storeId_userId: {
          storeId,
          userId
        }
      }
    });
    if (existingStoreUser) {
      throw new Error("User already exists in this store");
    }
    return await db.storeUser.create({
      data: {
        storeId,
        userId,
        role
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            status: true,
            lastLoginAt: true
          }
        },
        store: {
          select: {
            id: true,
            name: true,
            cnpj: true
          }
        }
      }
    });
  },
  async removeUser(storeId, userId) {
    const store = await db.store.findUnique({
      where: { id: storeId }
    });
    if (!store) {
      throw new Error("Store not found");
    }
    const storeUser = await db.storeUser.findUnique({
      where: {
        storeId_userId: {
          storeId,
          userId
        }
      }
    });
    if (!storeUser) {
      throw new Error("User not found in this store");
    }
    if (storeUser.role === "OWNER") {
      throw new Error("Cannot remove store owner");
    }
    return await db.storeUser.delete({
      where: {
        storeId_userId: {
          storeId,
          userId
        }
      }
    });
  },
  async updateUserRole(storeId, userId, newRole) {
    const store = await db.store.findUnique({
      where: { id: storeId }
    });
    if (!store) {
      throw new Error("Store not found");
    }
    const storeUser = await db.storeUser.findUnique({
      where: {
        storeId_userId: {
          storeId,
          userId
        }
      }
    });
    if (!storeUser) {
      throw new Error("User not found in this store");
    }
    if (storeUser.role === "OWNER") {
      throw new Error("Cannot change store owner role");
    }
    return await db.storeUser.update({
      where: {
        storeId_userId: {
          storeId,
          userId
        }
      },
      data: {
        role: newRole
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            status: true,
            lastLoginAt: true
          }
        },
        store: {
          select: {
            id: true,
            name: true,
            cnpj: true
          }
        }
      }
    });
  },
  async transferOwnership(storeId, newOwnerId) {
    const store = await db.store.findUnique({
      where: { id: storeId }
    });
    if (!store) {
      throw new Error("Store not found");
    }
    const newOwner = await db.user.findUnique({
      where: { id: newOwnerId, status: true }
    });
    if (!newOwner) {
      throw new Error("New owner not found or inactive");
    }
    const existingStoreUser = await db.storeUser.findUnique({
      where: {
        storeId_userId: {
          storeId,
          userId: newOwnerId
        }
      }
    });
    if (!existingStoreUser) {
      await db.storeUser.create({
        data: {
          storeId,
          userId: newOwnerId,
          role: "OWNER"
        }
      });
    } else {
      await db.storeUser.update({
        where: {
          storeId_userId: {
            storeId,
            userId: newOwnerId
          }
        },
        data: {
          role: "OWNER"
        }
      });
    }
    return await db.store.update({
      where: { id: storeId },
      data: {
        ownerId: newOwnerId
      },
      include: {
        owner: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  }
};

// src/features/store/queries/store.queries.ts
init_prisma();
var StoreQueries = {
  async getById(id) {
    const store = await db.store.findUnique({
      where: { id },
      include: {
        owner: {
          select: {
            id: true,
            name: true,
            email: true
          }
        },
        products: {
          select: {
            id: true,
            name: true,
            referencePrice: true,
            status: true,
            createdAt: true
          }
        },
        _count: {
          select: {
            products: true,
            users: true
          }
        }
      }
    });
    if (!store) {
      throw new Error("Store not found");
    }
    return store;
  },
  async getByCnpj(cnpj) {
    const store = await db.store.findUnique({
      where: { cnpj },
      include: {
        owner: {
          select: {
            id: true,
            name: true,
            email: true
          }
        },
        _count: {
          select: {
            products: true,
            users: true
          }
        }
      }
    });
    if (!store) {
      throw new Error("Store not found");
    }
    return store;
  },
  async list(params) {
    const where = {};
    if (params.search) {
      where.OR = [
        { name: { contains: params.search, mode: "insensitive" } },
        { cnpj: { contains: params.search } },
        { email: { contains: params.search, mode: "insensitive" } }
      ];
    }
    if (params.status !== void 0) {
      where.status = params.status;
    }
    if (params.ownerId) {
      where.ownerId = params.ownerId;
    }
    const result = await PaginationUtils.paginate(db, "store", {
      where,
      include: {
        owner: {
          select: {
            id: true,
            name: true,
            email: true
          }
        },
        _count: {
          select: {
            products: true,
            users: true
          }
        }
      },
      orderBy: { id: "desc" },
      params: {
        page: params.page,
        limit: params.limit
      },
      paginationOptions: {
        defaultPage: 1,
        defaultLimit: 10,
        maxLimit: 100
      }
    });
    return PaginationUtils.transformPaginationResult(
      result,
      "stores"
    );
  },
  async search(term, limit = 10) {
    return await db.store.findMany({
      where: {
        OR: [
          { name: { contains: term, mode: "insensitive" } },
          { cnpj: { contains: term } },
          { email: { contains: term, mode: "insensitive" } }
        ]
      },
      take: limit,
      orderBy: { name: "asc" },
      include: {
        owner: {
          select: {
            id: true,
            name: true,
            email: true
          }
        },
        _count: {
          select: {
            products: true
          }
        }
      }
    });
  },
  async getByOwner(ownerId) {
    return await db.store.findMany({
      where: { ownerId },
      orderBy: { id: "desc" },
      include: {
        _count: {
          select: {
            products: true,
            users: true
          }
        }
      }
    });
  },
  async getActive() {
    return await db.store.findMany({
      where: { status: true },
      orderBy: { name: "asc" },
      select: {
        id: true,
        name: true,
        cnpj: true,
        city: true,
        state: true,
        _count: {
          select: {
            products: true
          }
        }
      }
    });
  },
  async getStats() {
    const [total, active, inactive, withProducts, withoutProducts] = await Promise.all([
      db.store.count(),
      db.store.count({ where: { status: true } }),
      db.store.count({ where: { status: false } }),
      db.store.count({
        where: {
          products: {
            some: {}
          }
        }
      }),
      db.store.count({
        where: {
          products: {
            none: {}
          }
        }
      })
    ]);
    const storesByState = await db.store.groupBy({
      by: ["state"],
      _count: { id: true },
      where: {
        state: { not: null }
      },
      orderBy: { _count: { id: "desc" } },
      take: 10
    });
    return {
      total,
      active,
      inactive,
      withProducts,
      withoutProducts,
      storesByState
    };
  },
  async getRecent(limit = 5) {
    return await db.store.findMany({
      take: limit,
      orderBy: { id: "desc" },
      include: {
        owner: {
          select: {
            id: true,
            name: true,
            email: true
          }
        },
        _count: {
          select: {
            products: true
          }
        }
      }
    });
  },
  // === CONSULTAS PARA GERENCIAMENTO DE USUÁRIOS DA LOJA ===
  async getStoreUsers(storeId, params) {
    const store = await db.store.findUnique({
      where: { id: storeId }
    });
    if (!store) {
      throw new Error("Store not found");
    }
    const where = {
      storeId
    };
    if (params.search) {
      where.user = {
        OR: [
          { name: { contains: params.search, mode: "insensitive" } },
          { email: { contains: params.search, mode: "insensitive" } }
        ]
      };
    }
    if (params.role) {
      where.role = params.role;
    }
    const result = await PaginationUtils.paginate(db, "storeUser", {
      where,
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            status: true,
            lastLoginAt: true,
            createdAt: true
          }
        },
        store: {
          select: {
            id: true,
            name: true,
            cnpj: true
          }
        }
      },
      orderBy: { id: "desc" },
      params: {
        page: params.page,
        limit: params.limit
      },
      paginationOptions: {
        defaultPage: 1,
        defaultLimit: 10,
        maxLimit: 100
      }
    });
    return PaginationUtils.transformPaginationResult(
      result,
      "storeUsers"
    );
  },
  async getStoreUser(storeId, userId) {
    const storeUser = await db.storeUser.findUnique({
      where: {
        storeId_userId: {
          storeId,
          userId
        }
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            status: true,
            lastLoginAt: true,
            createdAt: true
          }
        },
        store: {
          select: {
            id: true,
            name: true,
            cnpj: true
          }
        }
      }
    });
    if (!storeUser) {
      throw new Error("User not found in this store");
    }
    return storeUser;
  },
  async getStoreUsersByRole(storeId, role) {
    return await db.storeUser.findMany({
      where: {
        storeId,
        role
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            status: true,
            lastLoginAt: true
          }
        }
      },
      orderBy: { id: "desc" }
    });
  },
  async getStoreOwner(storeId) {
    const storeUser = await db.storeUser.findFirst({
      where: {
        storeId,
        role: "OWNER"
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            status: true,
            lastLoginAt: true
          }
        }
      }
    });
    if (!storeUser) {
      throw new Error("Store owner not found");
    }
    return storeUser;
  },
  async getStoreAdmins(storeId) {
    return await db.storeUser.findMany({
      where: {
        storeId,
        role: "ADMIN"
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            status: true,
            lastLoginAt: true
          }
        }
      },
      orderBy: { id: "desc" }
    });
  },
  async getStoreManagers(storeId) {
    return await db.storeUser.findMany({
      where: {
        storeId,
        role: "MANAGER"
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            status: true,
            lastLoginAt: true
          }
        }
      },
      orderBy: { id: "desc" }
    });
  },
  async getStoreStaff(storeId) {
    return await db.storeUser.findMany({
      where: {
        storeId,
        role: "STAFF"
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            status: true,
            lastLoginAt: true
          }
        }
      },
      orderBy: { id: "desc" }
    });
  },
  async getStoreUserStats(storeId) {
    const [total, byRole, active, inactive] = await Promise.all([
      db.storeUser.count({
        where: { storeId }
      }),
      db.storeUser.groupBy({
        by: ["role"],
        where: { storeId },
        _count: { id: true }
      }),
      db.storeUser.count({
        where: {
          storeId,
          user: { status: true }
        }
      }),
      db.storeUser.count({
        where: {
          storeId,
          user: { status: false }
        }
      })
    ]);
    return {
      total,
      byRole,
      active,
      inactive
    };
  },
  async searchStoreUsers(storeId, searchTerm, limit = 10) {
    return await db.storeUser.findMany({
      where: {
        storeId,
        user: {
          OR: [
            { name: { contains: searchTerm, mode: "insensitive" } },
            { email: { contains: searchTerm, mode: "insensitive" } }
          ]
        }
      },
      take: limit,
      orderBy: { id: "desc" },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            status: true,
            lastLoginAt: true
          }
        }
      }
    });
  }
};

// src/features/store/store.controller.ts
var StoreController = {
  // === CRUD BÁSICO ===
  async create(request, reply) {
    try {
      const { name, cnpj, email, phone, cep, city, state, address, status } = request.body;
      const ownerId = request.user.id;
      const cleanCnpj = cnpj.replace(/\D/g, "");
      const result = await StoreCommands.create({
        ownerId,
        name,
        cnpj: cleanCnpj,
        email,
        phone,
        cep,
        city,
        state,
        address,
        status
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "CNPJ already exists") {
        return reply.status(400).send({
          error: error.message
        });
      }
      if (error.message === "Owner not found") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      const result = await StoreQueries.getById(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Store not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      if (updateData.cnpj) {
        updateData.cnpj = updateData.cnpj.replace(/\D/g, "");
      }
      const result = await StoreCommands.update(id, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Store not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "CNPJ already exists") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      await StoreCommands.delete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Store not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Cannot delete store with existing products") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { page = 1, limit = 10, search, status } = request.query;
      const userId = request.user?.id;
      if (!userId) {
        return reply.status(401).send({
          error: "User not authenticated"
        });
      }
      const result = await StoreQueries.list({
        page,
        limit,
        search,
        status,
        ownerId: userId
        // Filtrar apenas as lojas do usuário autenticado
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (QUERIES) ===
  async getByCnpj(request, reply) {
    try {
      const { cnpj } = request.params;
      const cleanCnpj = cnpj.replace(/\D/g, "");
      const result = await StoreQueries.getByCnpj(cleanCnpj);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Store not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByOwner(request, reply) {
    try {
      const { ownerId } = request.params;
      const result = await StoreQueries.getByOwner(ownerId);
      return reply.send({ stores: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getActive(request, reply) {
    try {
      const result = await StoreQueries.getActive();
      return reply.send({ stores: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const result = await StoreQueries.getStats();
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { q, limit = 10 } = request.query;
      const result = await StoreQueries.search(q, limit);
      return reply.send({ stores: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getRecent(request, reply) {
    try {
      const { limit = 5 } = request.query;
      const result = await StoreQueries.getRecent(limit);
      return reply.send({ stores: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (COMMANDS) ===
  async verifyCnpj(request, reply) {
    try {
      const { cnpj } = request.params;
      const cleanCnpj = cnpj.replace(/\D/g, "");
      const result = await StoreCommands.verifyCnpj(cleanCnpj);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async toggleStatus(request, reply) {
    try {
      const { id } = request.params;
      const result = await StoreCommands.toggleStatus(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Store not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === GERENCIAMENTO DE USUÁRIOS DA LOJA ===
  async addUser(request, reply) {
    try {
      const { id: storeId } = request.params;
      const { userId, role } = request.body;
      const result = await StoreCommands.addUser(storeId, userId, role);
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Store not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "User not found or inactive") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "User already exists in this store") {
        return reply.status(409).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async removeUser(request, reply) {
    try {
      const { id: storeId, userId } = request.params;
      await StoreCommands.removeUser(storeId, userId);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Store not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "User not found in this store") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Cannot remove store owner") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async updateUserRole(request, reply) {
    try {
      const { id: storeId, userId } = request.params;
      const { role } = request.body;
      const result = await StoreCommands.updateUserRole(storeId, userId, role);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Store not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "User not found in this store") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Cannot change store owner role") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async listUsers(request, reply) {
    try {
      const { id: storeId } = request.params;
      const { page = 1, limit = 10, search, role } = request.query;
      const result = await StoreQueries.getStoreUsers(storeId, {
        page,
        limit,
        search,
        role
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Store not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStoreUser(request, reply) {
    try {
      const { id: storeId, userId } = request.params;
      const result = await StoreQueries.getStoreUser(storeId, userId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Store not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "User not found in this store") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStoreOwner(request, reply) {
    try {
      const { id: storeId } = request.params;
      const result = await StoreQueries.getStoreOwner(storeId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Store not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Store owner not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStoreAdmins(request, reply) {
    try {
      const { id: storeId } = request.params;
      const result = await StoreQueries.getStoreAdmins(storeId);
      return reply.send({ admins: result });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Store not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStoreManagers(request, reply) {
    try {
      const { id: storeId } = request.params;
      const result = await StoreQueries.getStoreManagers(storeId);
      return reply.send({ managers: result });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Store not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStoreStaff(request, reply) {
    try {
      const { id: storeId } = request.params;
      const result = await StoreQueries.getStoreStaff(storeId);
      return reply.send({ staff: result });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Store not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStoreUserStats(request, reply) {
    try {
      const { id: storeId } = request.params;
      const result = await StoreQueries.getStoreUserStats(storeId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Store not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async searchStoreUsers(request, reply) {
    try {
      const { id: storeId } = request.params;
      const { q, limit = 10 } = request.query;
      const result = await StoreQueries.searchStoreUsers(storeId, q, limit);
      return reply.send({ storeUsers: result });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Store not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async transferOwnership(request, reply) {
    try {
      const { id: storeId } = request.params;
      const { newOwnerId } = request.body;
      const result = await StoreCommands.transferOwnership(storeId, newOwnerId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Store not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "New owner not found or inactive") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/store/store.schema.ts
var createStoreSchema = {
  body: {
    type: "object",
    required: ["name", "cnpj"],
    properties: {
      name: { type: "string", minLength: 1, maxLength: 255 },
      cnpj: { type: "string", minLength: 14, maxLength: 18 },
      email: { type: "string", format: "email" },
      phone: { type: "string" },
      cep: { type: "string" },
      city: { type: "string" },
      state: { type: "string" },
      address: { type: "string" },
      status: { type: "boolean", default: true }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        cnpj: { type: "string" },
        email: { type: "string", nullable: true },
        phone: { type: "string", nullable: true },
        cep: { type: "string", nullable: true },
        city: { type: "string", nullable: true },
        state: { type: "string", nullable: true },
        address: { type: "string", nullable: true },
        status: { type: "boolean" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        owner: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" }
          }
        }
      }
    }
  }
};
var updateStoreSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      name: { type: "string", minLength: 1, maxLength: 255 },
      cnpj: { type: "string", minLength: 14, maxLength: 18 },
      email: { type: "string", format: "email" },
      phone: { type: "string" },
      cep: { type: "string" },
      city: { type: "string" },
      state: { type: "string" },
      address: { type: "string" },
      status: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        cnpj: { type: "string" },
        email: { type: "string", nullable: true },
        phone: { type: "string", nullable: true },
        cep: { type: "string", nullable: true },
        city: { type: "string", nullable: true },
        state: { type: "string", nullable: true },
        address: { type: "string", nullable: true },
        status: { type: "boolean" },
        updatedAt: { type: "string", format: "date-time" },
        owner: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" }
          }
        }
      }
    }
  }
};
var getStoreSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        cnpj: { type: "string" },
        email: { type: "string", nullable: true },
        phone: { type: "string", nullable: true },
        cep: { type: "string", nullable: true },
        city: { type: "string", nullable: true },
        state: { type: "string", nullable: true },
        address: { type: "string", nullable: true },
        status: { type: "boolean" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        owner: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" }
          }
        },
        products: { type: "array" },
        _count: {
          type: "object",
          properties: {
            products: { type: "number" },
            users: { type: "number" }
          }
        }
      }
    }
  }
};
var deleteStoreSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" }
  }
};
var listStoresSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      status: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        stores: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              cnpj: { type: "string" },
              email: { type: "string", nullable: true },
              phone: { type: "string", nullable: true },
              cep: { type: "string", nullable: true },
              city: { type: "string", nullable: true },
              state: { type: "string", nullable: true },
              address: { type: "string", nullable: true },
              status: { type: "boolean" },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" },
              owner: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  email: { type: "string" }
                }
              },
              _count: {
                type: "object",
                properties: {
                  products: { type: "number" },
                  users: { type: "number" }
                }
              }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getStoreByCnpjSchema = {
  params: {
    type: "object",
    required: ["cnpj"],
    properties: {
      cnpj: { type: "string", minLength: 14, maxLength: 14 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        cnpj: { type: "string" },
        email: { type: "string", nullable: true },
        phone: { type: "string", nullable: true },
        cep: { type: "string", nullable: true },
        city: { type: "string", nullable: true },
        state: { type: "string", nullable: true },
        address: { type: "string", nullable: true },
        status: { type: "boolean" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        owner: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" }
          }
        },
        _count: {
          type: "object",
          properties: {
            products: { type: "number" },
            users: { type: "number" }
          }
        }
      }
    }
  }
};
var getStoresByOwnerSchema = {
  params: {
    type: "object",
    required: ["ownerId"],
    properties: {
      ownerId: { type: "string", minLength: 1 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        stores: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              cnpj: { type: "string" },
              email: { type: "string", nullable: true },
              phone: { type: "string", nullable: true },
              cep: { type: "string", nullable: true },
              city: { type: "string", nullable: true },
              state: { type: "string", nullable: true },
              address: { type: "string", nullable: true },
              status: { type: "boolean" },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" },
              owner: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  email: { type: "string" }
                }
              },
              _count: {
                type: "object",
                properties: {
                  products: { type: "number" },
                  users: { type: "number" }
                }
              }
            }
          }
        }
      }
    }
  }
};
var verifyCnpjSchema = {
  params: {
    type: "object",
    required: ["cnpj"],
    properties: {
      cnpj: { type: "string", minLength: 14, maxLength: 14 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        available: { type: "boolean" },
        message: { type: "string" }
      }
    }
  }
};
var toggleStatusSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        status: { type: "boolean" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var addUserToStoreSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["userId", "role"],
    properties: {
      userId: { type: "string", minLength: 1 },
      role: {
        type: "string",
        enum: ["OWNER", "ADMIN", "MANAGER", "STAFF"]
      }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: "string" },
        userId: { type: "string" },
        role: { type: "string" },
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" },
            status: { type: "boolean" },
            lastLoginAt: { type: "string", format: "date-time", nullable: true }
          }
        },
        store: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            cnpj: { type: "string" }
          }
        }
      }
    }
  }
};
var removeUserFromStoreSchema = {
  params: {
    type: "object",
    required: ["id", "userId"],
    properties: {
      id: { type: "string" },
      userId: { type: "string" }
    }
  },
  response: {
    204: { type: "null" }
  }
};
var updateUserRoleSchema = {
  params: {
    type: "object",
    required: ["id", "userId"],
    properties: {
      id: { type: "string" },
      userId: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["role"],
    properties: {
      role: {
        type: "string",
        enum: ["OWNER", "ADMIN", "MANAGER", "STAFF"]
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: "string" },
        userId: { type: "string" },
        role: { type: "string" },
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" },
            status: { type: "boolean" },
            lastLoginAt: { type: "string", format: "date-time", nullable: true }
          }
        },
        store: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            cnpj: { type: "string" }
          }
        }
      }
    }
  }
};
var listStoreUsersSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      role: {
        type: "string",
        enum: ["OWNER", "ADMIN", "MANAGER", "STAFF"]
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        storeUsers: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              storeId: { type: "string" },
              userId: { type: "string" },
              role: { type: "string" },
              user: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  email: { type: "string" },
                  status: { type: "boolean" },
                  lastLoginAt: { type: "string", format: "date-time", nullable: true },
                  createdAt: { type: "string", format: "date-time" }
                }
              },
              store: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  cnpj: { type: "string" }
                }
              }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getStoreUserSchema = {
  params: {
    type: "object",
    required: ["id", "userId"],
    properties: {
      id: { type: "string" },
      userId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: "string" },
        userId: { type: "string" },
        role: { type: "string" },
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" },
            status: { type: "boolean" },
            lastLoginAt: { type: "string", format: "date-time", nullable: true },
            createdAt: { type: "string", format: "date-time" }
          }
        },
        store: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            cnpj: { type: "string" }
          }
        }
      }
    }
  }
};
var getStoreOwnerSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: "string" },
        userId: { type: "string" },
        role: { type: "string" },
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" },
            status: { type: "boolean" },
            lastLoginAt: { type: "string", format: "date-time", nullable: true }
          }
        }
      }
    }
  }
};
var getStoreAdminsSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        admins: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              storeId: { type: "string" },
              userId: { type: "string" },
              role: { type: "string" },
              user: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  email: { type: "string" },
                  status: { type: "boolean" },
                  lastLoginAt: { type: "string", format: "date-time", nullable: true }
                }
              }
            }
          }
        }
      }
    }
  }
};
var getStoreManagersSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        managers: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              storeId: { type: "string" },
              userId: { type: "string" },
              role: { type: "string" },
              user: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  email: { type: "string" },
                  status: { type: "boolean" },
                  lastLoginAt: { type: "string", format: "date-time", nullable: true }
                }
              }
            }
          }
        }
      }
    }
  }
};
var getStoreStaffSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        staff: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              storeId: { type: "string" },
              userId: { type: "string" },
              role: { type: "string" },
              user: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  email: { type: "string" },
                  status: { type: "boolean" },
                  lastLoginAt: { type: "string", format: "date-time", nullable: true }
                }
              }
            }
          }
        }
      }
    }
  }
};
var getStoreUserStatsSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        total: { type: "number" },
        byRole: {
          type: "array",
          items: {
            type: "object",
            properties: {
              role: { type: "string" },
              _count: {
                type: "object",
                properties: {
                  id: { type: "number" }
                }
              }
            }
          }
        },
        active: { type: "number" },
        inactive: { type: "number" }
      }
    }
  }
};
var searchStoreUsersSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    required: ["q"],
    properties: {
      q: { type: "string", minLength: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        storeUsers: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              storeId: { type: "string" },
              userId: { type: "string" },
              role: { type: "string" },
              user: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  email: { type: "string" },
                  status: { type: "boolean" },
                  lastLoginAt: { type: "string", format: "date-time", nullable: true }
                }
              }
            }
          }
        }
      }
    }
  }
};
var transferOwnershipSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["newOwnerId"],
    properties: {
      newOwnerId: { type: "string", minLength: 1 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        cnpj: { type: "string" },
        ownerId: { type: "string" },
        owner: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" }
          }
        }
      }
    }
  }
};
var StoreSchemas = {
  create: createStoreSchema,
  update: updateStoreSchema,
  get: getStoreSchema,
  delete: deleteStoreSchema,
  list: listStoresSchema,
  getByCnpj: getStoreByCnpjSchema,
  getByOwner: getStoresByOwnerSchema,
  verifyCnpj: verifyCnpjSchema,
  toggleStatus: toggleStatusSchema,
  // Gerenciamento de usuários
  addUser: addUserToStoreSchema,
  removeUser: removeUserFromStoreSchema,
  updateUserRole: updateUserRoleSchema,
  listUsers: listStoreUsersSchema,
  getStoreUser: getStoreUserSchema,
  getStoreOwner: getStoreOwnerSchema,
  getStoreAdmins: getStoreAdminsSchema,
  getStoreManagers: getStoreManagersSchema,
  getStoreStaff: getStoreStaffSchema,
  getStoreUserStats: getStoreUserStatsSchema,
  searchStoreUsers: searchStoreUsersSchema,
  transferOwnership: transferOwnershipSchema
};

// src/middlewares/index.ts
init_auth_middleware();

// src/middlewares/authorization.middleware.ts
var StoreRole = /* @__PURE__ */ ((StoreRole2) => {
  StoreRole2["OWNER"] = "OWNER";
  StoreRole2["ADMIN"] = "ADMIN";
  StoreRole2["MANAGER"] = "MANAGER";
  StoreRole2["STAFF"] = "STAFF";
  return StoreRole2;
})(StoreRole || {});
var Action = /* @__PURE__ */ ((Action3) => {
  Action3["CREATE_USER"] = "create_user";
  Action3["READ_USER"] = "read_user";
  Action3["UPDATE_USER"] = "update_user";
  Action3["DELETE_USER"] = "delete_user";
  Action3["LIST_USERS"] = "list_users";
  Action3["CREATE_STORE"] = "create_store";
  Action3["READ_STORE"] = "read_store";
  Action3["UPDATE_STORE"] = "update_store";
  Action3["DELETE_STORE"] = "delete_store";
  Action3["LIST_STORES"] = "list_stores";
  Action3["MANAGE_STORE_USERS"] = "manage_store_users";
  Action3["CREATE_PRODUCT"] = "create_product";
  Action3["READ_PRODUCT"] = "read_product";
  Action3["UPDATE_PRODUCT"] = "update_product";
  Action3["DELETE_PRODUCT"] = "delete_product";
  Action3["LIST_PRODUCTS"] = "list_products";
  Action3["CREATE_CATEGORY"] = "create_category";
  Action3["READ_CATEGORY"] = "read_category";
  Action3["UPDATE_CATEGORY"] = "update_category";
  Action3["DELETE_CATEGORY"] = "delete_category";
  Action3["LIST_CATEGORIES"] = "list_categories";
  Action3["CREATE_SUPPLIER"] = "create_supplier";
  Action3["READ_SUPPLIER"] = "read_supplier";
  Action3["UPDATE_SUPPLIER"] = "update_supplier";
  Action3["DELETE_SUPPLIER"] = "delete_supplier";
  Action3["LIST_SUPPLIERS"] = "list_suppliers";
  Action3["CREATE_MOVEMENT"] = "create_movement";
  Action3["READ_MOVEMENT"] = "read_movement";
  Action3["UPDATE_MOVEMENT"] = "update_movement";
  Action3["DELETE_MOVEMENT"] = "delete_movement";
  Action3["LIST_MOVEMENTS"] = "list_movements";
  Action3["VIEW_AUDIT_LOGS"] = "view_audit_logs";
  Action3["MANAGE_SYSTEM_SETTINGS"] = "manage_system_settings";
  return Action3;
})(Action || {});
var PERMISSIONS = {
  ["super_admin" /* SUPER_ADMIN */]: Object.values(Action),
  // Can do everything
  ["admin" /* ADMIN */]: [
    // User management
    "create_user" /* CREATE_USER */,
    "read_user" /* READ_USER */,
    "update_user" /* UPDATE_USER */,
    "delete_user" /* DELETE_USER */,
    "list_users" /* LIST_USERS */,
    // Store management
    "create_store" /* CREATE_STORE */,
    "read_store" /* READ_STORE */,
    "update_store" /* UPDATE_STORE */,
    "delete_store" /* DELETE_STORE */,
    "list_stores" /* LIST_STORES */,
    "manage_store_users" /* MANAGE_STORE_USERS */,
    // Product management
    "create_product" /* CREATE_PRODUCT */,
    "read_product" /* READ_PRODUCT */,
    "update_product" /* UPDATE_PRODUCT */,
    "delete_product" /* DELETE_PRODUCT */,
    "list_products" /* LIST_PRODUCTS */,
    // Category management
    "create_category" /* CREATE_CATEGORY */,
    "read_category" /* READ_CATEGORY */,
    "update_category" /* UPDATE_CATEGORY */,
    "delete_category" /* DELETE_CATEGORY */,
    "list_categories" /* LIST_CATEGORIES */,
    // Supplier management
    "create_supplier" /* CREATE_SUPPLIER */,
    "read_supplier" /* READ_SUPPLIER */,
    "update_supplier" /* UPDATE_SUPPLIER */,
    "delete_supplier" /* DELETE_SUPPLIER */,
    "list_suppliers" /* LIST_SUPPLIERS */,
    // Movement management
    "create_movement" /* CREATE_MOVEMENT */,
    "read_movement" /* READ_MOVEMENT */,
    "update_movement" /* UPDATE_MOVEMENT */,
    "delete_movement" /* DELETE_MOVEMENT */,
    "list_movements" /* LIST_MOVEMENTS */,
    // System
    "view_audit_logs" /* VIEW_AUDIT_LOGS */
  ],
  ["manager" /* MANAGER */]: [
    // Store management (limited)
    "read_store" /* READ_STORE */,
    "list_stores" /* LIST_STORES */,
    "manage_store_users" /* MANAGE_STORE_USERS */,
    // Product management
    "create_product" /* CREATE_PRODUCT */,
    "read_product" /* READ_PRODUCT */,
    "update_product" /* UPDATE_PRODUCT */,
    "delete_product" /* DELETE_PRODUCT */,
    "list_products" /* LIST_PRODUCTS */,
    // Category management
    "create_category" /* CREATE_CATEGORY */,
    "read_category" /* READ_CATEGORY */,
    "update_category" /* UPDATE_CATEGORY */,
    "delete_category" /* DELETE_CATEGORY */,
    "list_categories" /* LIST_CATEGORIES */,
    // Supplier management
    "create_supplier" /* CREATE_SUPPLIER */,
    "read_supplier" /* READ_SUPPLIER */,
    "update_supplier" /* UPDATE_SUPPLIER */,
    "delete_supplier" /* DELETE_SUPPLIER */,
    "list_suppliers" /* LIST_SUPPLIERS */,
    // Movement management
    "create_movement" /* CREATE_MOVEMENT */,
    "read_movement" /* READ_MOVEMENT */,
    "update_movement" /* UPDATE_MOVEMENT */,
    "delete_movement" /* DELETE_MOVEMENT */,
    "list_movements" /* LIST_MOVEMENTS */
  ],
  ["user" /* USER */]: [
    // Read-only access
    "read_store" /* READ_STORE */,
    "list_stores" /* LIST_STORES */,
    "read_product" /* READ_PRODUCT */,
    "list_products" /* LIST_PRODUCTS */,
    "read_category" /* READ_CATEGORY */,
    "list_categories" /* LIST_CATEGORIES */,
    "read_supplier" /* READ_SUPPLIER */,
    "list_suppliers" /* LIST_SUPPLIERS */,
    "read_movement" /* READ_MOVEMENT */,
    "list_movements" /* LIST_MOVEMENTS */
  ]
};
var hasPermission = (userRoles, action) => {
  for (const role of userRoles) {
    const userRole = role;
    if (PERMISSIONS[userRole]?.includes(action)) {
      return true;
    }
  }
  return false;
};
var requirePermission = (action) => {
  return async (request, reply) => {
    try {
      if (!request.user) {
        return reply.status(401).send({
          error: "Authentication required"
        });
      }
      const userRoles = request.user.roles;
      if (!hasPermission(userRoles, action)) {
        return reply.status(403).send({
          error: "Insufficient permissions",
          required: action,
          current: userRoles
        });
      }
      return;
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  };
};

// src/middlewares/granular-permissions.middleware.ts
var BASE_ROLE_PERMISSIONS = {
  ["super_admin" /* SUPER_ADMIN */]: Object.values(Action),
  // Pode fazer tudo
  ["admin" /* ADMIN */]: [
    // Gestão de usuários
    "create_user" /* CREATE_USER */,
    "read_user" /* READ_USER */,
    "update_user" /* UPDATE_USER */,
    "delete_user" /* DELETE_USER */,
    "list_users" /* LIST_USERS */,
    // Gestão de lojas
    "create_store" /* CREATE_STORE */,
    "read_store" /* READ_STORE */,
    "update_store" /* UPDATE_STORE */,
    "delete_store" /* DELETE_STORE */,
    "list_stores" /* LIST_STORES */,
    "manage_store_users" /* MANAGE_STORE_USERS */,
    // Gestão de produtos
    "create_product" /* CREATE_PRODUCT */,
    "read_product" /* READ_PRODUCT */,
    "update_product" /* UPDATE_PRODUCT */,
    "delete_product" /* DELETE_PRODUCT */,
    "list_products" /* LIST_PRODUCTS */,
    // Gestão de categorias
    "create_category" /* CREATE_CATEGORY */,
    "read_category" /* READ_CATEGORY */,
    "update_category" /* UPDATE_CATEGORY */,
    "delete_category" /* DELETE_CATEGORY */,
    "list_categories" /* LIST_CATEGORIES */,
    // Gestão de fornecedores
    "create_supplier" /* CREATE_SUPPLIER */,
    "read_supplier" /* READ_SUPPLIER */,
    "update_supplier" /* UPDATE_SUPPLIER */,
    "delete_supplier" /* DELETE_SUPPLIER */,
    "list_suppliers" /* LIST_SUPPLIERS */,
    // Gestão de movimentações
    "create_movement" /* CREATE_MOVEMENT */,
    "read_movement" /* READ_MOVEMENT */,
    "update_movement" /* UPDATE_MOVEMENT */,
    "delete_movement" /* DELETE_MOVEMENT */,
    "list_movements" /* LIST_MOVEMENTS */,
    // Sistema
    "view_audit_logs" /* VIEW_AUDIT_LOGS */
  ],
  ["manager" /* MANAGER */]: [
    // Gestão de lojas (limitada)
    "read_store" /* READ_STORE */,
    "list_stores" /* LIST_STORES */,
    "manage_store_users" /* MANAGE_STORE_USERS */,
    // Gestão de produtos
    "create_product" /* CREATE_PRODUCT */,
    "read_product" /* READ_PRODUCT */,
    "update_product" /* UPDATE_PRODUCT */,
    "delete_product" /* DELETE_PRODUCT */,
    "list_products" /* LIST_PRODUCTS */,
    // Gestão de categorias
    "create_category" /* CREATE_CATEGORY */,
    "read_category" /* READ_CATEGORY */,
    "update_category" /* UPDATE_CATEGORY */,
    "delete_category" /* DELETE_CATEGORY */,
    "list_categories" /* LIST_CATEGORIES */,
    // Gestão de fornecedores
    "create_supplier" /* CREATE_SUPPLIER */,
    "read_supplier" /* READ_SUPPLIER */,
    "update_supplier" /* UPDATE_SUPPLIER */,
    "delete_supplier" /* DELETE_SUPPLIER */,
    "list_suppliers" /* LIST_SUPPLIERS */,
    // Gestão de movimentações
    "create_movement" /* CREATE_MOVEMENT */,
    "read_movement" /* READ_MOVEMENT */,
    "update_movement" /* UPDATE_MOVEMENT */,
    "delete_movement" /* DELETE_MOVEMENT */,
    "list_movements" /* LIST_MOVEMENTS */
  ],
  ["user" /* USER */]: [
    // Acesso somente leitura
    "read_store" /* READ_STORE */,
    "list_stores" /* LIST_STORES */,
    "read_product" /* READ_PRODUCT */,
    "list_products" /* LIST_PRODUCTS */,
    "read_category" /* READ_CATEGORY */,
    "list_categories" /* LIST_CATEGORIES */,
    "read_supplier" /* READ_SUPPLIER */,
    "list_suppliers" /* LIST_SUPPLIERS */,
    "read_movement" /* READ_MOVEMENT */,
    "list_movements" /* LIST_MOVEMENTS */
  ]
};
var BASE_STORE_ROLE_PERMISSIONS = {
  ["OWNER" /* OWNER */]: [
    // Pode fazer tudo na loja
    "read_store" /* READ_STORE */,
    "update_store" /* UPDATE_STORE */,
    "manage_store_users" /* MANAGE_STORE_USERS */,
    "create_product" /* CREATE_PRODUCT */,
    "read_product" /* READ_PRODUCT */,
    "update_product" /* UPDATE_PRODUCT */,
    "delete_product" /* DELETE_PRODUCT */,
    "list_products" /* LIST_PRODUCTS */,
    "create_category" /* CREATE_CATEGORY */,
    "read_category" /* READ_CATEGORY */,
    "update_category" /* UPDATE_CATEGORY */,
    "delete_category" /* DELETE_CATEGORY */,
    "list_categories" /* LIST_CATEGORIES */,
    "create_supplier" /* CREATE_SUPPLIER */,
    "read_supplier" /* READ_SUPPLIER */,
    "update_supplier" /* UPDATE_SUPPLIER */,
    "delete_supplier" /* DELETE_SUPPLIER */,
    "list_suppliers" /* LIST_SUPPLIERS */,
    "create_movement" /* CREATE_MOVEMENT */,
    "read_movement" /* READ_MOVEMENT */,
    "update_movement" /* UPDATE_MOVEMENT */,
    "delete_movement" /* DELETE_MOVEMENT */,
    "list_movements" /* LIST_MOVEMENTS */
  ],
  ["ADMIN" /* ADMIN */]: [
    // Gestão completa da loja (exceto transferir propriedade)
    "read_store" /* READ_STORE */,
    "update_store" /* UPDATE_STORE */,
    "manage_store_users" /* MANAGE_STORE_USERS */,
    "create_product" /* CREATE_PRODUCT */,
    "read_product" /* READ_PRODUCT */,
    "update_product" /* UPDATE_PRODUCT */,
    "delete_product" /* DELETE_PRODUCT */,
    "list_products" /* LIST_PRODUCTS */,
    "create_category" /* CREATE_CATEGORY */,
    "read_category" /* READ_CATEGORY */,
    "update_category" /* UPDATE_CATEGORY */,
    "delete_category" /* DELETE_CATEGORY */,
    "list_categories" /* LIST_CATEGORIES */,
    "create_supplier" /* CREATE_SUPPLIER */,
    "read_supplier" /* READ_SUPPLIER */,
    "update_supplier" /* UPDATE_SUPPLIER */,
    "delete_supplier" /* DELETE_SUPPLIER */,
    "list_suppliers" /* LIST_SUPPLIERS */,
    "create_movement" /* CREATE_MOVEMENT */,
    "read_movement" /* READ_MOVEMENT */,
    "update_movement" /* UPDATE_MOVEMENT */,
    "delete_movement" /* DELETE_MOVEMENT */,
    "list_movements" /* LIST_MOVEMENTS */
  ],
  ["MANAGER" /* MANAGER */]: [
    // Gestão operacional
    "read_store" /* READ_STORE */,
    "list_stores" /* LIST_STORES */,
    "create_product" /* CREATE_PRODUCT */,
    "read_product" /* READ_PRODUCT */,
    "update_product" /* UPDATE_PRODUCT */,
    "delete_product" /* DELETE_PRODUCT */,
    "list_products" /* LIST_PRODUCTS */,
    "create_category" /* CREATE_CATEGORY */,
    "read_category" /* READ_CATEGORY */,
    "update_category" /* UPDATE_CATEGORY */,
    "delete_category" /* DELETE_CATEGORY */,
    "list_categories" /* LIST_CATEGORIES */,
    "create_supplier" /* CREATE_SUPPLIER */,
    "read_supplier" /* READ_SUPPLIER */,
    "update_supplier" /* UPDATE_SUPPLIER */,
    "delete_supplier" /* DELETE_SUPPLIER */,
    "list_suppliers" /* LIST_SUPPLIERS */,
    "create_movement" /* CREATE_MOVEMENT */,
    "read_movement" /* READ_MOVEMENT */,
    "update_movement" /* UPDATE_MOVEMENT */,
    "delete_movement" /* DELETE_MOVEMENT */,
    "list_movements" /* LIST_MOVEMENTS */
  ],
  ["STAFF" /* STAFF */]: [
    // Operações básicas
    "read_store" /* READ_STORE */,
    "list_stores" /* LIST_STORES */,
    "read_product" /* READ_PRODUCT */,
    "list_products" /* LIST_PRODUCTS */,
    "read_category" /* READ_CATEGORY */,
    "list_categories" /* LIST_CATEGORIES */,
    "read_supplier" /* READ_SUPPLIER */,
    "list_suppliers" /* LIST_SUPPLIERS */,
    "read_movement" /* READ_MOVEMENT */,
    "list_movements" /* LIST_MOVEMENTS */
  ]
};
var GranularPermissionService = class {
  // Verifica se usuário tem permissão considerando todas as camadas
  static async hasPermission(context, action, resource) {
    try {
      if (context.userRoles.includes("super_admin" /* SUPER_ADMIN */)) {
        return { allowed: true, source: "super_admin" };
      }
      if (context.customPermissions) {
        const customResult = this.checkCustomPermissions(context, action, resource);
        if (customResult !== null) {
          return customResult;
        }
      }
      if (context.storeId && context.storeRole) {
        const storeResult = this.checkStorePermissions(context, action);
        if (storeResult.allowed) {
          return { ...storeResult, source: "store_role" };
        }
      }
      const globalResult = this.checkGlobalRolePermissions(context, action);
      if (globalResult.allowed) {
        return { ...globalResult, source: "global_role" };
      }
      return { allowed: false, reason: "No permission found" };
    } catch (error) {
      console.error("Error checking granular permission:", error);
      return { allowed: false, reason: "Permission check error" };
    }
  }
  // Verifica permissões customizadas do usuário
  static checkCustomPermissions(context, action, resource) {
    if (!context.customPermissions) return null;
    const now = context.requestTime || /* @__PURE__ */ new Date();
    const applicablePermissions = context.customPermissions.filter((permission) => {
      if (permission.action !== action) return false;
      if (permission.resource && resource) {
        if (permission.resource !== "*" && permission.resource !== resource) return false;
      }
      if (permission.storeId && context.storeId && permission.storeId !== context.storeId) return false;
      if (permission.expiresAt && permission.expiresAt < now) return false;
      if (!this.checkConditions(permission.conditions, context)) return false;
      return true;
    });
    if (applicablePermissions.length === 0) return null;
    const denyPermission = applicablePermissions.find((p) => !p.grant);
    if (denyPermission) {
      return {
        allowed: false,
        reason: `Permission denied by custom rule: ${denyPermission.reason || "No reason provided"}`,
        source: "custom_deny"
      };
    }
    const grantPermission = applicablePermissions.find((p) => p.grant);
    if (grantPermission) {
      return {
        allowed: true,
        reason: `Permission granted by custom rule: ${grantPermission.reason || "No reason provided"}`,
        source: "custom_grant"
      };
    }
    return null;
  }
  // Verifica permissões da loja
  static checkStorePermissions(context, action) {
    if (!context.storeRole) {
      return { allowed: false, reason: "No store role defined" };
    }
    const storePermissions = BASE_STORE_ROLE_PERMISSIONS[context.storeRole] || [];
    if (storePermissions.includes(action)) {
      return { allowed: true, reason: `Allowed by store role: ${context.storeRole}` };
    }
    return { allowed: false, reason: `Store role ${context.storeRole} does not have permission for ${action}` };
  }
  // Verifica permissões do role global
  static checkGlobalRolePermissions(context, action) {
    for (const role of context.userRoles) {
      const userRole = role;
      const rolePermissions = BASE_ROLE_PERMISSIONS[userRole] || [];
      if (rolePermissions.includes(action)) {
        return { allowed: true, reason: `Allowed by global role: ${userRole}` };
      }
    }
    return { allowed: false, reason: "No global role has this permission" };
  }
  // Verifica condições de permissão
  static checkConditions(conditions, context) {
    if (!conditions) return true;
    const now = context.requestTime || /* @__PURE__ */ new Date();
    const requestData = context.requestData || {};
    if (conditions.timeRange) {
      const [start, end] = conditions.timeRange.split("-").map(Number);
      const currentHour = now.getHours();
      if (currentHour < start || currentHour > end) {
        return false;
      }
    }
    if (conditions.dayOfWeek) {
      const [start, end] = conditions.dayOfWeek.split("-").map(Number);
      const currentDay = now.getDay();
      if (currentDay < start || currentDay > end) {
        return false;
      }
    }
    if (conditions.dateRange) {
      const { start, end } = conditions.dateRange;
      if (now < new Date(start) || now > new Date(end)) {
        return false;
      }
    }
    if (conditions.amountLimit && requestData.body?.amount) {
      if (requestData.body.amount > conditions.amountLimit) {
        return false;
      }
    }
    if (conditions.ipWhitelist && requestData.ip) {
      if (!conditions.ipWhitelist.includes(requestData.ip)) {
        return false;
      }
    }
    if (conditions.userAgent && requestData.userAgent) {
      if (!requestData.userAgent.includes(conditions.userAgent)) {
        return false;
      }
    }
    if (conditions.custom) {
      try {
        const result = this.evaluateCustomCondition(conditions.custom, requestData);
        return result;
      } catch (error) {
        console.error("Error evaluating custom condition:", error);
        return false;
      }
    }
    return true;
  }
  // Avalia condição customizada de forma segura (substitui eval)
  static evaluateCustomCondition(expression, requestData) {
    try {
      const comparisonRegex = /(\w+(?:\.\w+)*)\s*(<|>|<=|>=|==|!=)\s*([\w\d.-]+)/;
      const match = expression.match(comparisonRegex);
      if (!match) {
        console.warn("Invalid custom condition expression:", expression);
        return false;
      }
      const [, leftSide, operator, rightSide] = match;
      const leftValue = this.resolveValue(leftSide, requestData);
      let rightValue;
      if (!isNaN(Number(rightSide))) {
        rightValue = Number(rightSide);
      } else {
        rightValue = this.resolveValue(rightSide, requestData);
      }
      switch (operator) {
        case "<":
          return leftValue < rightValue;
        case ">":
          return leftValue > rightValue;
        case "<=":
          return leftValue <= rightValue;
        case ">=":
          return leftValue >= rightValue;
        case "==":
          return leftValue == rightValue;
        case "!=":
          return leftValue != rightValue;
        default:
          console.warn("Unsupported operator:", operator);
          return false;
      }
    } catch (error) {
      console.error("Error in evaluateCustomCondition:", error);
      return false;
    }
  }
  // Resolve valor de propriedades aninhadas (ex: requestData.body.amount)
  static resolveValue(path3, requestData) {
    const parts = path3.split(".");
    let value = requestData;
    for (const part of parts) {
      if (value === void 0 || value === null) {
        return void 0;
      }
      value = value[part];
    }
    return value;
  }
  // Verifica se usuário tem qualquer uma das permissões
  static async hasAnyPermission(context, actions, resource) {
    for (const action of actions) {
      const result = await this.hasPermission(context, action, resource);
      if (result.allowed) {
        return result;
      }
    }
    return { allowed: false, reason: "None of the required permissions found" };
  }
  // Verifica se usuário tem todas as permissões
  static async hasAllPermissions(context, actions, resource) {
    for (const action of actions) {
      const result = await this.hasPermission(context, action, resource);
      if (!result.allowed) {
        return { allowed: false, reason: `Missing permission: ${action} - ${result.reason}` };
      }
    }
    return { allowed: true, reason: "All permissions granted" };
  }
  // Obtém todas as permissões efetivas do usuário
  static async getUserEffectivePermissions(context) {
    const effectivePermissions = /* @__PURE__ */ new Set();
    for (const role of context.userRoles) {
      const userRole = role;
      const rolePermissions = BASE_ROLE_PERMISSIONS[userRole] || [];
      rolePermissions.forEach((permission) => effectivePermissions.add(permission));
    }
    if (context.storeRole) {
      const storePermissions = BASE_STORE_ROLE_PERMISSIONS[context.storeRole] || [];
      storePermissions.forEach((permission) => effectivePermissions.add(permission));
    }
    if (context.customPermissions) {
      const now = context.requestTime || /* @__PURE__ */ new Date();
      context.customPermissions.forEach((permission) => {
        if (permission.expiresAt && permission.expiresAt < now) return;
        if (!this.checkConditions(permission.conditions, context)) return;
        if (permission.grant) {
          effectivePermissions.add(permission.action);
        } else {
          effectivePermissions.delete(permission.action);
        }
      });
    }
    return Array.from(effectivePermissions);
  }
};

// src/features/store/store.routes.ts
async function StoreRoutes(fastify2) {
  fastify2.post("/", {
    schema: StoreSchemas.create,
    preHandler: [authMiddleware],
    handler: StoreController.create
  });
  fastify2.get("/", {
    schema: StoreSchemas.list,
    preHandler: [authMiddleware],
    handler: StoreController.list
  });
  fastify2.get("/:id", {
    schema: StoreSchemas.get,
    preHandler: [authMiddleware],
    handler: StoreController.get
  });
  fastify2.put("/:id", {
    schema: StoreSchemas.update,
    preHandler: [authMiddleware],
    handler: StoreController.update
  });
  fastify2.delete("/:id", {
    schema: StoreSchemas.delete,
    preHandler: [authMiddleware],
    handler: StoreController.delete
  });
  fastify2.get("/cnpj/:cnpj", {
    schema: StoreSchemas.getByCnpj,
    handler: StoreController.getByCnpj
  });
  fastify2.get("/owner/:ownerId", {
    schema: StoreSchemas.getByOwner,
    handler: StoreController.getByOwner
  });
  fastify2.get("/active", {
    handler: StoreController.getActive
  });
  fastify2.get("/stats", {
    handler: StoreController.getStats
  });
  fastify2.get("/search", {
    schema: {
      querystring: {
        type: "object",
        properties: {
          q: { type: "string" },
          limit: { type: "number" }
        },
        required: ["q"]
      }
    },
    handler: StoreController.search
  });
  fastify2.get("/recent", {
    schema: {
      querystring: {
        type: "object",
        properties: {
          limit: { type: "number" }
        }
      }
    },
    handler: StoreController.getRecent
  });
  fastify2.get("/verify-cnpj/:cnpj", {
    schema: StoreSchemas.verifyCnpj,
    preHandler: [authMiddleware],
    handler: StoreController.verifyCnpj
  });
  fastify2.patch("/:id/toggle-status", {
    schema: StoreSchemas.toggleStatus,
    preHandler: [authMiddleware],
    handler: StoreController.toggleStatus
  });
}

// src/features/category/commands/category.commands.ts
init_prisma();
var CategoryCommands = {
  async create(data) {
    return await db.category.create({
      data: {
        ...data,
        status: data.status ?? true
      },
      include: {
        parent: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true
          }
        },
        children: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true,
            status: true,
            color: true,
            icon: true
          }
        },
        products: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                status: true
              }
            }
          },
          take: 5
        },
        _count: {
          select: {
            children: true,
            products: true
          }
        }
      }
    });
  },
  async update(id, data) {
    return await db.category.update({
      where: { id },
      data,
      include: {
        parent: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true
          }
        },
        children: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true,
            status: true,
            color: true,
            icon: true
          }
        },
        products: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                status: true
              }
            }
          },
          take: 5
        },
        _count: {
          select: {
            children: true,
            products: true
          }
        }
      }
    });
  },
  async delete(id) {
    return await db.category.delete({
      where: { id }
    });
  },
  async updateStatus(id, status) {
    return await db.category.update({
      where: { id },
      data: { status },
      include: {
        parent: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true
          }
        },
        children: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true,
            status: true,
            color: true,
            icon: true
          }
        },
        products: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                status: true
              }
            }
          },
          take: 5
        },
        _count: {
          select: {
            children: true,
            products: true
          }
        }
      }
    });
  },
  async moveToParent(id, parentId) {
    return await db.category.update({
      where: { id },
      data: { parentId },
      include: {
        parent: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true
          }
        },
        children: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true,
            status: true,
            color: true,
            icon: true
          }
        },
        _count: {
          select: {
            children: true,
            products: true
          }
        }
      }
    });
  }
};

// src/features/category/queries/category.queries.ts
init_prisma();
var CategoryQueries = {
  async getById(id) {
    return await db.category.findUnique({
      where: { id },
      include: {
        parent: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true
          }
        },
        children: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true,
            status: true,
            color: true,
            icon: true
          }
        },
        products: {
          select: {
            id: true,
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                status: true
              }
            }
          }
        },
        _count: {
          select: {
            children: true,
            products: true
          }
        }
      }
    });
  },
  async list(params) {
    const { page = 1, limit = 10, search, status, parentId, storeId } = params;
    const skip2 = (page - 1) * limit;
    const where = {};
    if (status !== void 0) {
      where.status = status;
    }
    if (parentId !== void 0) {
      if (parentId === null) {
        where.parentId = null;
      } else {
        where.parentId = parentId;
      }
    }
    if (storeId) {
      where.storeId = storeId;
    }
    if (search) {
      where.OR = [
        { name: { contains: search, mode: "insensitive" } },
        { description: { contains: search, mode: "insensitive" } },
        { code: { contains: search, mode: "insensitive" } }
      ];
    }
    const [items, total] = await Promise.all([
      db.category.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          parent: {
            select: {
              id: true,
              name: true,
              description: true,
              code: true
            }
          },
          children: {
            select: {
              id: true,
              name: true,
              description: true,
              code: true,
              status: true,
              color: true,
              icon: true
            }
          },
          products: {
            select: {
              id: true,
              product: {
                select: {
                  id: true,
                  name: true,
                  description: true,
                  status: true
                }
              }
            },
            take: 5
          },
          _count: {
            select: {
              children: true,
              products: true
            }
          }
        }
      }),
      db.category.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async search(term, storeId, limit = 10) {
    return await db.category.findMany({
      where: {
        storeId,
        OR: [
          { name: { contains: term, mode: "insensitive" } },
          { description: { contains: term, mode: "insensitive" } },
          { code: { contains: term, mode: "insensitive" } }
        ]
      },
      take: limit,
      orderBy: { createdAt: "desc" },
      include: {
        parent: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true
          }
        },
        children: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true,
            status: true,
            color: true,
            icon: true
          }
        },
        _count: {
          select: {
            children: true,
            products: true
          }
        }
      }
    });
  },
  async getActive(storeId) {
    return await db.category.findMany({
      where: {
        status: true,
        storeId
      },
      orderBy: { createdAt: "desc" },
      include: {
        parent: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true
          }
        },
        children: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true,
            status: true,
            color: true,
            icon: true
          }
        },
        _count: {
          select: {
            children: true,
            products: true
          }
        }
      }
    });
  },
  async getStats(storeId) {
    const [total, active, inactive, withChildren, withoutChildren] = await Promise.all([
      db.category.count({ where: { storeId } }),
      db.category.count({ where: { status: true, storeId } }),
      db.category.count({ where: { status: false, storeId } }),
      db.category.count({
        where: {
          storeId,
          children: { some: {} }
        }
      }),
      db.category.count({
        where: {
          storeId,
          children: { none: {} }
        }
      })
    ]);
    return {
      total,
      active,
      inactive,
      withChildren,
      withoutChildren
    };
  },
  async getRootCategories(storeId, status) {
    const where = {
      parentId: null,
      storeId
    };
    if (status !== void 0) {
      where.status = status;
    }
    return await db.category.findMany({
      where,
      orderBy: { createdAt: "desc" },
      include: {
        children: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true,
            status: true,
            color: true,
            icon: true
          }
        },
        _count: {
          select: {
            children: true,
            products: true
          }
        }
      }
    });
  },
  async getChildren(parentId, storeId) {
    return await db.category.findMany({
      where: {
        parentId,
        storeId
      },
      orderBy: { createdAt: "desc" },
      include: {
        children: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true,
            status: true,
            color: true,
            icon: true
          }
        },
        products: {
          select: {
            id: true,
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                status: true
              }
            }
          },
          take: 5
        },
        _count: {
          select: {
            children: true,
            products: true
          }
        }
      }
    });
  },
  async getHierarchy(storeId) {
    const rootCategories = await CategoryQueries.getRootCategories(storeId);
    const buildHierarchy = async (categories) => {
      for (const category of categories) {
        category.children = await CategoryQueries.getChildren(category.id, storeId);
        if (category.children.length > 0) {
          await buildHierarchy(category.children);
        }
      }
    };
    await buildHierarchy(rootCategories);
    return rootCategories;
  },
  async getByCode(code, storeId) {
    return await db.category.findUnique({
      where: {
        code_storeId: {
          code,
          storeId
        }
      },
      include: {
        parent: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true
          }
        },
        children: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true,
            status: true,
            color: true,
            icon: true
          }
        },
        products: {
          select: {
            id: true,
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                status: true
              }
            }
          },
          take: 5
        },
        _count: {
          select: {
            children: true,
            products: true
          }
        }
      }
    });
  },
  async getTopCategoriesByProducts(storeId, params) {
    const { limit = 10, status, includeInactive = false } = params;
    const where = {
      storeId
    };
    if (!includeInactive) {
      where.status = status !== void 0 ? status : true;
    } else if (status !== void 0) {
      where.status = status;
    }
    where.products = {
      some: {}
    };
    return await db.category.findMany({
      where,
      take: limit,
      orderBy: {
        products: {
          _count: "desc"
        }
      },
      select: {
        id: true,
        name: true,
        description: true,
        code: true,
        status: true,
        color: true,
        icon: true,
        parentId: true,
        createdAt: true,
        updatedAt: true,
        parent: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true
          }
        },
        _count: {
          select: {
            products: true,
            children: true
          }
        }
      }
    });
  },
  async getTopCategoriesByProductsWithDetails(storeId, params) {
    const { limit = 10, status, includeInactive = false, includeProductDetails = false } = params;
    const where = {
      storeId
    };
    if (!includeInactive) {
      where.status = status !== void 0 ? status : true;
    } else if (status !== void 0) {
      where.status = status;
    }
    where.products = {
      some: {}
    };
    const include = {
      parent: {
        select: {
          id: true,
          name: true,
          description: true,
          code: true
        }
      },
      _count: {
        select: {
          products: true,
          children: true
        }
      }
    };
    if (includeProductDetails) {
      include.products = {
        select: {
          id: true,
          product: {
            select: {
              id: true,
              name: true,
              description: true,
              status: true,
              sku: true,
              price: true,
              stock: true
            }
          }
        },
        take: 5
        // Limitar a 5 produtos por categoria para não sobrecarregar
      };
    }
    return await db.category.findMany({
      where,
      take: limit,
      orderBy: {
        products: {
          _count: "desc"
        }
      },
      select: {
        id: true,
        name: true,
        description: true,
        code: true,
        status: true,
        color: true,
        icon: true,
        parentId: true,
        createdAt: true,
        updatedAt: true,
        ...include
      }
    });
  },
  async getCategoryCreationEvolution(storeId, params) {
    const {
      period = "month",
      startDate,
      endDate,
      status,
      includeInactive = false
    } = params;
    const where = {
      storeId
    };
    if (!includeInactive) {
      where.status = status !== void 0 ? status : true;
    } else if (status !== void 0) {
      where.status = status;
    }
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) {
        where.createdAt.gte = startDate;
      }
      if (endDate) {
        where.createdAt.lte = endDate;
      }
    }
    const categories = await db.category.findMany({
      where,
      select: {
        id: true,
        name: true,
        status: true,
        createdAt: true
      },
      orderBy: {
        createdAt: "asc"
      }
    });
    const groupedData = this.groupByPeriod(categories, period);
    const totalCategories = categories.length;
    const activeCategories = categories.filter((cat) => cat.status).length;
    const inactiveCategories = totalCategories - activeCategories;
    const periods = Object.keys(groupedData).sort();
    const growthRate = this.calculateGrowthRate(groupedData, periods);
    return {
      data: groupedData,
      metadata: {
        totalCategories,
        activeCategories,
        inactiveCategories,
        period,
        startDate: startDate || null,
        endDate: endDate || null,
        growthRate,
        description: `Evolu\xE7\xE3o de cria\xE7\xE3o de categorias por ${period}`,
        chartType: "line"
      }
    };
  },
  async getCategoryCreationEvolutionDetailed(storeId, params) {
    const {
      period = "month",
      startDate,
      endDate,
      status,
      includeInactive = false,
      includeDetails = false
    } = params;
    const where = {
      storeId
    };
    if (!includeInactive) {
      where.status = status !== void 0 ? status : true;
    } else if (status !== void 0) {
      where.status = status;
    }
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) {
        where.createdAt.gte = startDate;
      }
      if (endDate) {
        where.createdAt.lte = endDate;
      }
    }
    const selectFields = {
      id: true,
      name: true,
      status: true,
      createdAt: true
    };
    if (includeDetails) {
      selectFields.parent = {
        select: {
          id: true,
          name: true
        }
      };
      selectFields._count = {
        select: {
          children: true,
          products: true
        }
      };
    }
    const categories = await db.category.findMany({
      where,
      select: selectFields,
      orderBy: {
        createdAt: "asc"
      }
    });
    const groupedData = this.groupByPeriod(categories, period);
    const totalCategories = categories.length;
    const activeCategories = categories.filter((cat) => cat.status).length;
    const inactiveCategories = totalCategories - activeCategories;
    const periods = Object.keys(groupedData).sort();
    const growthRate = this.calculateGrowthRate(groupedData, periods);
    const periodStats = this.calculatePeriodStats(groupedData, periods);
    return {
      data: groupedData,
      periodStats,
      metadata: {
        totalCategories,
        activeCategories,
        inactiveCategories,
        period,
        startDate: startDate || null,
        endDate: endDate || null,
        growthRate,
        description: `Evolu\xE7\xE3o detalhada de cria\xE7\xE3o de categorias por ${period}`,
        chartType: "line"
      }
    };
  },
  // Métodos auxiliares privados
  groupByPeriod(categories, period) {
    const grouped = {};
    categories.forEach((category) => {
      const date = new Date(category.createdAt);
      let key;
      switch (period) {
        case "day":
          key = date.toISOString().split("T")[0];
          break;
        case "week":
          const weekStart = new Date(date);
          weekStart.setDate(date.getDate() - date.getDay());
          key = weekStart.toISOString().split("T")[0];
          break;
        case "month":
          key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, "0")}`;
          break;
        case "year":
          key = String(date.getFullYear());
          break;
        default:
          key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, "0")}`;
      }
      if (!grouped[key]) {
        grouped[key] = [];
      }
      grouped[key].push(category);
    });
    const chartData = {};
    Object.keys(grouped).forEach((key) => {
      chartData[key] = {
        count: grouped[key].length,
        categories: grouped[key]
      };
    });
    return chartData;
  },
  calculateGrowthRate(groupedData, periods) {
    if (periods.length < 2) return 0;
    const firstPeriod = periods[0];
    const lastPeriod = periods[periods.length - 1];
    const firstCount = groupedData[firstPeriod]?.count || 0;
    const lastCount = groupedData[lastPeriod]?.count || 0;
    if (firstCount === 0) return lastCount > 0 ? 100 : 0;
    return (lastCount - firstCount) / firstCount * 100;
  },
  calculatePeriodStats(groupedData, periods) {
    const stats = {
      averagePerPeriod: 0,
      maxPerPeriod: 0,
      minPerPeriod: Infinity,
      totalPeriods: periods.length,
      periodsWithGrowth: 0,
      periodsWithDecline: 0,
      periodsStable: 0
    };
    if (periods.length === 0) return stats;
    let totalCount = 0;
    let previousCount = 0;
    periods.forEach((period, index) => {
      const count = groupedData[period]?.count || 0;
      totalCount += count;
      stats.maxPerPeriod = Math.max(stats.maxPerPeriod, count);
      stats.minPerPeriod = Math.min(stats.minPerPeriod, count);
      if (index > 0) {
        if (count > previousCount) {
          stats.periodsWithGrowth++;
        } else if (count < previousCount) {
          stats.periodsWithDecline++;
        } else {
          stats.periodsStable++;
        }
      }
      previousCount = count;
    });
    stats.averagePerPeriod = totalCount / periods.length;
    stats.minPerPeriod = stats.minPerPeriod === Infinity ? 0 : stats.minPerPeriod;
    return stats;
  },
  async getActiveInactiveRatio(storeId, params) {
    const { includeDetails = false, includeHierarchy = false } = params;
    const [activeCount, inactiveCount, totalCount] = await Promise.all([
      db.category.count({ where: { status: true, storeId } }),
      db.category.count({ where: { status: false, storeId } }),
      db.category.count({ where: { storeId } })
    ]);
    const activePercentage = totalCount > 0 ? activeCount / totalCount * 100 : 0;
    const inactivePercentage = totalCount > 0 ? inactiveCount / totalCount * 100 : 0;
    const hygieneScore = activePercentage;
    const result = {
      active: {
        count: activeCount,
        percentage: Math.round(activePercentage * 100) / 100
      },
      inactive: {
        count: inactiveCount,
        percentage: Math.round(inactivePercentage * 100) / 100
      },
      total: totalCount,
      hygieneScore: Math.round(hygieneScore * 100) / 100,
      metadata: {
        description: "Taxa de categorias ativas vs inativas",
        chartType: "donut",
        lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
      }
    };
    if (includeDetails) {
      const [activeCategories, inactiveCategories] = await Promise.all([
        db.category.findMany({
          where: { status: true, storeId },
          select: {
            id: true,
            name: true,
            code: true,
            createdAt: true,
            updatedAt: true,
            _count: {
              select: {
                children: true,
                products: true
              }
            }
          },
          orderBy: { createdAt: "desc" },
          take: 10
          // Limitar para não sobrecarregar
        }),
        db.category.findMany({
          where: { status: false, storeId },
          select: {
            id: true,
            name: true,
            code: true,
            createdAt: true,
            updatedAt: true,
            _count: {
              select: {
                children: true,
                products: true
              }
            }
          },
          orderBy: { updatedAt: "desc" },
          take: 10
          // Limitar para não sobrecarregar
        })
      ]);
      result.active.recentCategories = activeCategories;
      result.inactive.recentCategories = inactiveCategories;
    }
    if (includeHierarchy) {
      const [activeWithChildren, inactiveWithChildren, activeWithoutChildren, inactiveWithoutChildren] = await Promise.all([
        db.category.count({
          where: {
            storeId,
            status: true,
            children: { some: {} }
          }
        }),
        db.category.count({
          where: {
            storeId,
            status: false,
            children: { some: {} }
          }
        }),
        db.category.count({
          where: {
            storeId,
            status: true,
            children: { none: {} }
          }
        }),
        db.category.count({
          where: {
            storeId,
            status: false,
            children: { none: {} }
          }
        })
      ]);
      result.hierarchy = {
        activeWithChildren,
        inactiveWithChildren,
        activeWithoutChildren,
        inactiveWithoutChildren,
        totalWithChildren: activeWithChildren + inactiveWithChildren,
        totalWithoutChildren: activeWithoutChildren + inactiveWithoutChildren
      };
    }
    return result;
  },
  async getActiveInactiveTrend(storeId, params) {
    const { period = "month", startDate, endDate } = params;
    const where = {
      storeId
    };
    if (startDate || endDate) {
      where.updatedAt = {};
      if (startDate) {
        where.updatedAt.gte = startDate;
      }
      if (endDate) {
        where.updatedAt.lte = endDate;
      }
    }
    const categories = await db.category.findMany({
      where,
      select: {
        id: true,
        name: true,
        status: true,
        createdAt: true,
        updatedAt: true
      },
      orderBy: {
        updatedAt: "asc"
      }
    });
    const groupedData = this.groupByPeriod(categories, period);
    const trendData = {};
    Object.keys(groupedData).forEach((periodKey) => {
      const periodCategories = groupedData[periodKey].categories;
      const active = periodCategories.filter((cat) => cat.status).length;
      const inactive = periodCategories.filter((cat) => !cat.status).length;
      trendData[periodKey] = {
        active,
        inactive,
        total: active + inactive
      };
    });
    return {
      trendData,
      metadata: {
        period,
        startDate: startDate || null,
        endDate: endDate || null,
        description: `Tend\xEAncia de categorias ativas vs inativas por ${period}`,
        chartType: "line"
      }
    };
  }
};

// src/features/category/category.controller.ts
var CategoryController = {
  // === CRUD BÁSICO ===
  async create(request, reply) {
    try {
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CategoryCommands.create({
        ...request.body,
        storeId
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.code === "P2002") {
        return reply.status(400).send({
          error: "Category with this name or code already exists"
        });
      }
      if (error.code === "P2003") {
        return reply.status(400).send({
          error: "Invalid parent category reference"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      const result = await CategoryQueries.getById(id);
      if (!result) {
        return reply.status(404).send({
          error: "Category not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Category not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = request.body;
      const result = await CategoryCommands.update(id, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.code === "P2025") {
        return reply.status(404).send({
          error: "Category not found"
        });
      }
      if (error.code === "P2002") {
        return reply.status(400).send({
          error: "Category with this name or code already exists"
        });
      }
      if (error.code === "P2003") {
        return reply.status(400).send({
          error: "Invalid parent category reference"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      await CategoryCommands.delete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.code === "P2025") {
        return reply.status(404).send({
          error: "Category not found"
        });
      }
      if (error.code === "P2003") {
        return reply.status(400).send({
          error: "Cannot delete category with children or products"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { page = 1, limit = 10, search, status, parentId } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CategoryQueries.list({
        page,
        limit,
        search,
        status,
        parentId,
        storeId
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (QUERIES) ===
  async getActive(request, reply) {
    try {
      const result = await CategoryQueries.getActive(request.store?.id);
      if (!result) {
        return reply.status(404).send({
          error: "Categories not found"
        });
      }
      return reply.send({ categories: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const result = await CategoryQueries.getStats(request.store?.id);
      if (!result) {
        return reply.status(404).send({
          error: "Categories not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { q, limit = 10 } = request.query;
      const result = await CategoryQueries.search(q, limit);
      return reply.send({ categories: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getRootCategories(request, reply) {
    try {
      const { status } = request.query;
      const result = await CategoryQueries.getRootCategories(status);
      return reply.send({ categories: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getChildren(request, reply) {
    try {
      const { id } = request.params;
      const result = await CategoryQueries.getChildren(id, request.store?.id);
      return reply.send({ categories: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getHierarchy(request, reply) {
    try {
      const result = await CategoryQueries.getHierarchy(request.store?.id);
      return reply.send({ categories: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByCode(request, reply) {
    try {
      const { code } = request.params;
      const result = await CategoryQueries.getByCode(code, request.store?.id);
      if (!result) {
        return reply.status(404).send({
          error: "Category not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (COMMANDS) ===
  async updateStatus(request, reply) {
    try {
      const { id } = request.params;
      const { status } = request.body;
      const result = await CategoryCommands.updateStatus(id, status);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.code === "P2025") {
        return reply.status(404).send({
          error: "Category not found"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async moveToParent(request, reply) {
    try {
      const { id } = request.params;
      const { parentId } = request.body;
      const result = await CategoryCommands.moveToParent(id, parentId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.code === "P2025") {
        return reply.status(404).send({
          error: "Category not found"
        });
      }
      if (error.code === "P2003") {
        return reply.status(400).send({
          error: "Invalid parent category reference"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === RELATÓRIOS ===
  async getTopCategoriesByProducts(request, reply) {
    try {
      const { limit = 10, status, includeInactive = false, includeProductDetails = false } = request.query;
      const result = await CategoryQueries.getTopCategoriesByProductsWithDetails(request.store?.id, {
        limit: parseInt(limit),
        status,
        includeInactive: includeInactive === "true",
        includeProductDetails: includeProductDetails === "true"
      });
      return reply.send({
        categories: result,
        metadata: {
          total: result.length,
          limit: parseInt(limit),
          description: "Top categorias com mais produtos",
          chartType: "horizontalBar",
          recommendedLimit: Math.min(parseInt(limit), 10)
        }
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getCategoryCreationEvolution(request, reply) {
    try {
      const {
        period = "month",
        startDate,
        endDate,
        status,
        includeInactive = false,
        includeDetails = false
      } = request.query;
      const startDateObj = startDate ? new Date(startDate) : void 0;
      const endDateObj = endDate ? new Date(endDate) : void 0;
      if (startDateObj && isNaN(startDateObj.getTime())) {
        return reply.status(400).send({
          error: "Data de in\xEDcio inv\xE1lida"
        });
      }
      if (endDateObj && isNaN(endDateObj.getTime())) {
        return reply.status(400).send({
          error: "Data de fim inv\xE1lida"
        });
      }
      if (startDateObj && endDateObj && startDateObj > endDateObj) {
        return reply.status(400).send({
          error: "Data de in\xEDcio deve ser anterior \xE0 data de fim"
        });
      }
      const result = await CategoryQueries.getCategoryCreationEvolutionDetailed(request.store?.id, {
        period,
        startDate: startDateObj,
        endDate: endDateObj,
        status,
        includeInactive: includeInactive === "true",
        includeDetails: includeDetails === "true"
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getActiveInactiveRatio(request, reply) {
    try {
      const { includeDetails = false, includeHierarchy = false } = request.query;
      const result = await CategoryQueries.getActiveInactiveRatio(request.store?.id, {
        includeDetails: includeDetails === "true",
        includeHierarchy: includeHierarchy === "true"
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getActiveInactiveTrend(request, reply) {
    try {
      const {
        period = "month",
        startDate,
        endDate
      } = request.query;
      const startDateObj = startDate ? new Date(startDate) : void 0;
      const endDateObj = endDate ? new Date(endDate) : void 0;
      if (startDateObj && isNaN(startDateObj.getTime())) {
        return reply.status(400).send({
          error: "Data de in\xEDcio inv\xE1lida"
        });
      }
      if (endDateObj && isNaN(endDateObj.getTime())) {
        return reply.status(400).send({
          error: "Data de fim inv\xE1lida"
        });
      }
      if (startDateObj && endDateObj && startDateObj > endDateObj) {
        return reply.status(400).send({
          error: "Data de in\xEDcio deve ser anterior \xE0 data de fim"
        });
      }
      const result = await CategoryQueries.getActiveInactiveTrend(request.store?.id, {
        period,
        startDate: startDateObj,
        endDate: endDateObj
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/category/category.schema.ts
var createCategorySchema = {
  body: {
    type: "object",
    required: ["name"],
    properties: {
      name: { type: "string", minLength: 1, maxLength: 255 },
      description: { type: "string" },
      code: { type: "string" },
      status: { type: "boolean", default: true },
      color: { type: "string" },
      icon: { type: "string" },
      parentId: { type: "string" }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        description: { type: "string", nullable: true },
        code: { type: "string", nullable: true },
        status: { type: "boolean" },
        color: { type: "string", nullable: true },
        icon: { type: "string", nullable: true },
        parentId: { type: "string", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        parent: { type: "object", nullable: true },
        children: { type: "array" },
        products: { type: "array" },
        _count: {
          type: "object",
          properties: {
            children: { type: "number" },
            products: { type: "number" }
          }
        }
      }
    }
  }
};
var updateCategorySchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      name: { type: "string", minLength: 1, maxLength: 255 },
      description: { type: "string" },
      code: { type: "string" },
      status: { type: "boolean" },
      color: { type: "string" },
      icon: { type: "string" },
      parentId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        description: { type: "string", nullable: true },
        code: { type: "string", nullable: true },
        status: { type: "boolean" },
        color: { type: "string", nullable: true },
        icon: { type: "string", nullable: true },
        parentId: { type: "string", nullable: true },
        updatedAt: { type: "string", format: "date-time" },
        parent: { type: "object", nullable: true },
        children: { type: "array" },
        products: { type: "array" },
        _count: {
          type: "object",
          properties: {
            children: { type: "number" },
            products: { type: "number" }
          }
        }
      }
    }
  }
};
var getCategorySchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        description: { type: "string", nullable: true },
        code: { type: "string", nullable: true },
        status: { type: "boolean" },
        color: { type: "string", nullable: true },
        icon: { type: "string", nullable: true },
        parentId: { type: "string", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        parent: { type: "object", nullable: true },
        children: { type: "array" },
        products: { type: "array" },
        _count: {
          type: "object",
          properties: {
            children: { type: "number" },
            products: { type: "number" }
          }
        }
      }
    }
  }
};
var listCategoriesSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      status: { type: "boolean" },
      parentId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              code: { type: "string", nullable: true },
              status: { type: "boolean" },
              color: { type: "string", nullable: true },
              icon: { type: "string", nullable: true },
              parentId: { type: "string", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" },
              parent: { type: "object", nullable: true },
              children: { type: "array" },
              products: { type: "array" },
              _count: {
                type: "object",
                properties: {
                  children: { type: "number" },
                  products: { type: "number" }
                }
              }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var deleteCategorySchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" }
  }
};
var updateStatusSchema2 = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["status"],
    properties: {
      status: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        status: { type: "boolean" },
        parent: { type: "object", nullable: true },
        children: { type: "array" },
        products: { type: "array" },
        _count: {
          type: "object",
          properties: {
            children: { type: "number" },
            products: { type: "number" }
          }
        }
      }
    }
  }
};
var getChildrenSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        categories: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              code: { type: "string", nullable: true },
              status: { type: "boolean" },
              color: { type: "string", nullable: true },
              icon: { type: "string", nullable: true },
              parentId: { type: "string", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" },
              parent: { type: "object", nullable: true },
              children: { type: "array" },
              products: { type: "array" },
              _count: {
                type: "object",
                properties: {
                  children: { type: "number" },
                  products: { type: "number" }
                }
              }
            }
          }
        }
      }
    }
  }
};
var getRootCategoriesSchema = {
  querystring: {
    type: "object",
    properties: {
      status: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        categories: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              code: { type: "string", nullable: true },
              status: { type: "boolean" },
              color: { type: "string", nullable: true },
              icon: { type: "string", nullable: true },
              parentId: { type: "string", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" },
              parent: { type: "object", nullable: true },
              children: { type: "array" },
              products: { type: "array" },
              _count: {
                type: "object",
                properties: {
                  children: { type: "number" },
                  products: { type: "number" }
                }
              }
            }
          }
        }
      }
    }
  }
};
var getTopCategoriesByProductsSchema = {
  querystring: {
    type: "object",
    properties: {
      limit: {
        type: "number",
        minimum: 1,
        maximum: 50,
        default: 10,
        description: "N\xFAmero m\xE1ximo de categorias a retornar (recomendado: 5-10 para gr\xE1ficos)"
      },
      status: {
        type: "boolean",
        description: "Filtrar por status da categoria (true = ativa, false = inativa)"
      },
      includeInactive: {
        type: "boolean",
        default: false,
        description: "Incluir categorias inativas no resultado"
      },
      includeProductDetails: {
        type: "boolean",
        default: false,
        description: "Incluir detalhes dos produtos em cada categoria"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        categories: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              code: { type: "string", nullable: true },
              status: { type: "boolean" },
              color: { type: "string", nullable: true },
              icon: { type: "string", nullable: true },
              parentId: { type: "string", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" },
              parent: {
                type: "object",
                nullable: true,
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  description: { type: "string", nullable: true },
                  code: { type: "string", nullable: true }
                }
              },
              products: {
                type: "array",
                nullable: true,
                items: {
                  type: "object",
                  properties: {
                    id: { type: "string" },
                    product: {
                      type: "object",
                      properties: {
                        id: { type: "string" },
                        name: { type: "string" },
                        description: { type: "string", nullable: true },
                        status: { type: "boolean" },
                        sku: { type: "string", nullable: true },
                        price: { type: "number", nullable: true },
                        stock: { type: "number", nullable: true }
                      }
                    }
                  }
                }
              },
              _count: {
                type: "object",
                properties: {
                  products: { type: "number" },
                  children: { type: "number" }
                }
              }
            }
          }
        },
        metadata: {
          type: "object",
          properties: {
            total: { type: "number" },
            limit: { type: "number" },
            description: { type: "string" },
            chartType: { type: "string" },
            recommendedLimit: { type: "number" }
          }
        }
      }
    }
  }
};
var getCategoryCreationEvolutionSchema = {
  querystring: {
    type: "object",
    properties: {
      period: {
        type: "string",
        enum: ["day", "week", "month", "year"],
        default: "month",
        description: "Per\xEDodo de agrupamento dos dados"
      },
      startDate: {
        type: "string",
        format: "date",
        description: "Data de in\xEDcio do per\xEDodo (YYYY-MM-DD)"
      },
      endDate: {
        type: "string",
        format: "date",
        description: "Data de fim do per\xEDodo (YYYY-MM-DD)"
      },
      status: {
        type: "boolean",
        description: "Filtrar por status da categoria (true = ativa, false = inativa)"
      },
      includeInactive: {
        type: "boolean",
        default: false,
        description: "Incluir categorias inativas no resultado"
      },
      includeDetails: {
        type: "boolean",
        default: false,
        description: "Incluir detalhes adicionais das categorias"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        data: {
          type: "object",
          additionalProperties: {
            type: "object",
            properties: {
              count: { type: "number" },
              categories: {
                type: "array",
                items: {
                  type: "object",
                  properties: {
                    id: { type: "string" },
                    name: { type: "string" },
                    status: { type: "boolean" },
                    createdAt: { type: "string", format: "date-time" },
                    parent: {
                      type: "object",
                      nullable: true,
                      properties: {
                        id: { type: "string" },
                        name: { type: "string" }
                      }
                    },
                    _count: {
                      type: "object",
                      nullable: true,
                      properties: {
                        children: { type: "number" },
                        products: { type: "number" }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        periodStats: {
          type: "object",
          properties: {
            averagePerPeriod: { type: "number" },
            maxPerPeriod: { type: "number" },
            minPerPeriod: { type: "number" },
            totalPeriods: { type: "number" },
            periodsWithGrowth: { type: "number" },
            periodsWithDecline: { type: "number" },
            periodsStable: { type: "number" }
          }
        },
        metadata: {
          type: "object",
          properties: {
            totalCategories: { type: "number" },
            activeCategories: { type: "number" },
            inactiveCategories: { type: "number" },
            period: { type: "string" },
            startDate: { type: "string", nullable: true },
            endDate: { type: "string", nullable: true },
            growthRate: { type: "number" },
            description: { type: "string" },
            chartType: { type: "string" }
          }
        }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getActiveInactiveRatioSchema = {
  querystring: {
    type: "object",
    properties: {
      includeDetails: {
        type: "boolean",
        default: false,
        description: "Incluir detalhes das categorias recentes"
      },
      includeHierarchy: {
        type: "boolean",
        default: false,
        description: "Incluir an\xE1lise hier\xE1rquica das categorias"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        active: {
          type: "object",
          properties: {
            count: { type: "number" },
            percentage: { type: "number" },
            recentCategories: {
              type: "array",
              nullable: true,
              items: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  code: { type: "string", nullable: true },
                  createdAt: { type: "string", format: "date-time" },
                  updatedAt: { type: "string", format: "date-time" },
                  _count: {
                    type: "object",
                    properties: {
                      children: { type: "number" },
                      products: { type: "number" }
                    }
                  }
                }
              }
            }
          }
        },
        inactive: {
          type: "object",
          properties: {
            count: { type: "number" },
            percentage: { type: "number" },
            recentCategories: {
              type: "array",
              nullable: true,
              items: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  code: { type: "string", nullable: true },
                  createdAt: { type: "string", format: "date-time" },
                  updatedAt: { type: "string", format: "date-time" },
                  _count: {
                    type: "object",
                    properties: {
                      children: { type: "number" },
                      products: { type: "number" }
                    }
                  }
                }
              }
            }
          }
        },
        total: { type: "number" },
        hygieneScore: { type: "number" },
        hierarchy: {
          type: "object",
          nullable: true,
          properties: {
            activeWithChildren: { type: "number" },
            inactiveWithChildren: { type: "number" },
            activeWithoutChildren: { type: "number" },
            inactiveWithoutChildren: { type: "number" },
            totalWithChildren: { type: "number" },
            totalWithoutChildren: { type: "number" }
          }
        },
        metadata: {
          type: "object",
          properties: {
            description: { type: "string" },
            chartType: { type: "string" },
            lastUpdated: { type: "string", format: "date-time" }
          }
        }
      }
    }
  }
};
var getActiveInactiveTrendSchema = {
  querystring: {
    type: "object",
    properties: {
      period: {
        type: "string",
        enum: ["day", "week", "month", "year"],
        default: "month",
        description: "Per\xEDodo de agrupamento dos dados"
      },
      startDate: {
        type: "string",
        format: "date",
        description: "Data de in\xEDcio do per\xEDodo (YYYY-MM-DD)"
      },
      endDate: {
        type: "string",
        format: "date",
        description: "Data de fim do per\xEDodo (YYYY-MM-DD)"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        trendData: {
          type: "object",
          additionalProperties: {
            type: "object",
            properties: {
              active: { type: "number" },
              inactive: { type: "number" },
              total: { type: "number" }
            }
          }
        },
        metadata: {
          type: "object",
          properties: {
            period: { type: "string" },
            startDate: { type: "string", nullable: true },
            endDate: { type: "string", nullable: true },
            description: { type: "string" },
            chartType: { type: "string" }
          }
        }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var CategorySchemas = {
  create: createCategorySchema,
  update: updateCategorySchema,
  get: getCategorySchema,
  delete: deleteCategorySchema,
  list: listCategoriesSchema,
  updateStatus: updateStatusSchema2,
  getChildren: getChildrenSchema,
  getRoot: getRootCategoriesSchema,
  getTopCategoriesByProducts: getTopCategoriesByProductsSchema,
  getCategoryCreationEvolution: getCategoryCreationEvolutionSchema,
  getActiveInactiveRatio: getActiveInactiveRatioSchema,
  getActiveInactiveTrend: getActiveInactiveTrendSchema
};

// src/features/category/category.routes.ts
init_auth_middleware();
async function CategoryRoutes(fastify2) {
  fastify2.addHook("preHandler", authMiddleware);
  fastify2.addHook("preHandler", storeContextMiddleware);
  fastify2.post("/", {
    schema: CategorySchemas.create,
    handler: CategoryController.create
  });
  fastify2.get("/", {
    schema: CategorySchemas.list,
    handler: CategoryController.list
  });
  fastify2.get("/:id", {
    schema: CategorySchemas.get,
    handler: CategoryController.get
  });
  fastify2.put("/:id", {
    schema: CategorySchemas.update,
    handler: CategoryController.update
  });
  fastify2.delete("/:id", {
    schema: CategorySchemas.delete,
    handler: CategoryController.delete
  });
  fastify2.get("/active", {
    handler: CategoryController.getActive
  });
  fastify2.get("/stats", {
    handler: CategoryController.getStats
  });
  fastify2.get("/search", {
    schema: {
      querystring: {
        type: "object",
        properties: {
          q: { type: "string" },
          limit: { type: "number" }
        },
        required: ["q"]
      }
    },
    handler: CategoryController.search
  });
  fastify2.get("/root", {
    schema: CategorySchemas.getRoot,
    handler: CategoryController.getRootCategories
  });
  fastify2.get("/:id/children", {
    schema: CategorySchemas.getChildren,
    handler: CategoryController.getChildren
  });
  fastify2.get("/hierarchy", {
    handler: CategoryController.getHierarchy
  });
  fastify2.get("/code/:code", {
    schema: {
      params: {
        type: "object",
        properties: {
          code: { type: "string" }
        },
        required: ["code"]
      }
    },
    handler: CategoryController.getByCode
  });
  fastify2.patch("/:id/status", {
    schema: CategorySchemas.updateStatus,
    handler: CategoryController.updateStatus
  });
  fastify2.patch("/:id/move", {
    schema: {
      params: {
        type: "object",
        properties: {
          id: { type: "string" }
        },
        required: ["id"]
      },
      body: {
        type: "object",
        properties: {
          parentId: { type: "string", nullable: true }
        }
      }
    },
    handler: CategoryController.moveToParent
  });
  fastify2.get("/reports/top-by-products", {
    schema: CategorySchemas.getTopCategoriesByProducts,
    handler: CategoryController.getTopCategoriesByProducts
  });
  fastify2.get("/reports/creation-evolution", {
    schema: CategorySchemas.getCategoryCreationEvolution,
    handler: CategoryController.getCategoryCreationEvolution
  });
  fastify2.get("/reports/active-inactive-ratio", {
    schema: CategorySchemas.getActiveInactiveRatio,
    handler: CategoryController.getActiveInactiveRatio
  });
  fastify2.get("/reports/active-inactive-trend", {
    schema: CategorySchemas.getActiveInactiveTrend,
    handler: CategoryController.getActiveInactiveTrend
  });
}

// src/features/movement/commands/movement.commands.ts
init_prisma();
var MovementCommands = {
  async create(data) {
    console.log("MovementCommands.create called with:", data);
    const storeId = data.storeId;
    console.log("Using storeId:", storeId);
    const product = await db.product.findFirst({
      where: {
        id: data.productId,
        storeId,
        status: true
      }
    });
    console.log("Product found:", product);
    if (!product) {
      throw new Error("Product not found in this store");
    }
    if (data.supplierId) {
      const supplier = await db.supplier.findUnique({
        where: {
          id: data.supplierId,
          status: true
        }
      });
      if (!supplier) {
        throw new Error("Supplier not found or inactive");
      }
    }
    console.log("Calculating current stock for product:", data.productId, "store:", storeId);
    const currentStock = await MovementCommands.getCurrentStock(data.productId, storeId);
    console.log("Current stock:", currentStock);
    let balanceAfter = currentStock;
    if (data.type === "ENTRADA") {
      balanceAfter = currentStock + data.quantity;
    } else if (data.type === "SAIDA" || data.type === "PERDA") {
      if (currentStock < data.quantity) {
        throw new Error("Insufficient stock for this movement");
      }
      balanceAfter = currentStock - data.quantity;
    }
    console.log("Balance after movement:", balanceAfter);
    console.log("Creating movement in database...");
    const movement = await db.movement.create({
      data: {
        type: data.type,
        quantity: data.quantity,
        storeId,
        productId: data.productId,
        supplierId: data.supplierId,
        batch: data.batch,
        expiration: data.expiration ? new Date(data.expiration) : null,
        price: data.price,
        note: data.note,
        userId: data.userId,
        balanceAfter,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      },
      include: {
        store: {
          select: {
            id: true,
            name: true
          }
        },
        product: {
          select: {
            id: true,
            name: true,
            unitOfMeasure: true
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    console.log("Movement created successfully:", movement);
    return movement;
  },
  async update(id, data) {
    const existingMovement = await db.movement.findUnique({
      where: { id },
      include: {
        product: true
      }
    });
    if (!existingMovement) {
      throw new Error("Movement not found");
    }
    if (data.quantity !== void 0 || data.type !== void 0) {
      const currentStock = await MovementCommands.getCurrentStock(existingMovement.productId, existingMovement.storeId);
      let revertedStock = currentStock;
      if (existingMovement.type === "ENTRADA") {
        revertedStock = currentStock - existingMovement.quantity;
      } else if (existingMovement.type === "SAIDA" || existingMovement.type === "PERDA") {
        revertedStock = currentStock + existingMovement.quantity;
      }
      const newQuantity = data.quantity ?? existingMovement.quantity;
      const newType = data.type ?? existingMovement.type;
      let newBalanceAfter = revertedStock;
      if (newType === "ENTRADA") {
        newBalanceAfter = revertedStock + newQuantity;
      } else if (newType === "SAIDA" || newType === "PERDA") {
        if (revertedStock < newQuantity) {
          throw new Error("Insufficient stock for this movement");
        }
        newBalanceAfter = revertedStock - newQuantity;
      }
      data.balanceAfter = newBalanceAfter;
    }
    const updateData = {
      ...data,
      expiration: data.expiration ? new Date(data.expiration) : void 0,
      updatedAt: /* @__PURE__ */ new Date()
    };
    return await db.movement.update({
      where: { id },
      data: updateData,
      include: {
        store: {
          select: {
            id: true,
            name: true
          }
        },
        product: {
          select: {
            id: true,
            name: true,
            unitOfMeasure: true
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async delete(id) {
    const movement = await db.movement.findUnique({
      where: { id }
    });
    if (!movement) {
      throw new Error("Movement not found");
    }
    const currentStock = await MovementCommands.getCurrentStock(movement.productId, movement.storeId);
    if (movement.type === "SAIDA" || movement.type === "PERDA") {
      if (currentStock < movement.quantity) {
        throw new Error("Cannot delete movement: insufficient stock to revert");
      }
    }
    await db.movement.delete({
      where: { id }
    });
    return { success: true };
  },
  async getCurrentStock(productId, storeId) {
    const movements = await db.movement.findMany({
      where: {
        productId,
        storeId
      },
      orderBy: {
        createdAt: "desc"
      }
    });
    let stock = 0;
    for (const movement of movements) {
      if (movement.type === "ENTRADA") {
        stock += movement.quantity;
      } else if (movement.type === "SAIDA" || movement.type === "PERDA") {
        stock -= movement.quantity;
      }
    }
    return Math.max(0, stock);
  },
  async recalculateStock(productId, storeId) {
    const movements = await db.movement.findMany({
      where: {
        productId,
        storeId
      },
      orderBy: {
        createdAt: "asc"
      }
    });
    let currentStock = 0;
    const updatedMovements = [];
    for (const movement of movements) {
      if (movement.type === "ENTRADA") {
        currentStock += movement.quantity;
      } else if (movement.type === "SAIDA" || movement.type === "PERDA") {
        currentStock -= movement.quantity;
      }
      if (movement.balanceAfter !== currentStock) {
        updatedMovements.push({
          id: movement.id,
          balanceAfter: currentStock
        });
      }
    }
    if (updatedMovements.length > 0) {
      await db.$transaction(
        updatedMovements.map(
          (movement) => db.movement.update({
            where: { id: movement.id },
            data: { balanceAfter: movement.balanceAfter }
          })
        )
      );
    }
    return currentStock;
  },
  // === FUNÇÕES ADICIONAIS DE MOVIMENTAÇÃO ===
  async createBulk(movements, userId) {
    const results = [];
    let successCount = 0;
    let failedCount = 0;
    for (let i = 0; i < movements.length; i++) {
      try {
        const movement = await MovementCommands.create({
          ...movements[i],
          userId
        });
        results.push({
          index: i,
          success: true,
          movement
        });
        successCount++;
      } catch (error) {
        results.push({
          index: i,
          success: false,
          error: error.message
        });
        failedCount++;
      }
    }
    return {
      success: successCount,
      failed: failedCount,
      results
    };
  },
  async verify(id, verified, note, userId) {
    const movement = await db.movement.findUnique({
      where: { id }
    });
    if (!movement) {
      throw new Error("Movement not found");
    }
    return await db.movement.update({
      where: { id },
      data: {
        verified,
        verifiedAt: verified ? /* @__PURE__ */ new Date() : null,
        verifiedBy: verified ? userId : null,
        verificationNote: note,
        updatedAt: /* @__PURE__ */ new Date()
      },
      include: {
        store: {
          select: {
            id: true,
            name: true
          }
        },
        product: {
          select: {
            id: true,
            name: true,
            unitOfMeasure: true
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async cancel(id, reason, userId) {
    const movement = await db.movement.findUnique({
      where: { id }
    });
    if (!movement) {
      throw new Error("Movement not found");
    }
    if (movement.cancelled) {
      throw new Error("Movement already cancelled");
    }
    const currentStock = await MovementCommands.getCurrentStock(movement.productId, movement.storeId);
    if (movement.type === "SAIDA" || movement.type === "PERDA") {
      if (currentStock < movement.quantity) {
        throw new Error("Cannot cancel movement: insufficient stock to revert");
      }
    }
    return await db.movement.update({
      where: { id },
      data: {
        cancelled: true,
        cancelledAt: /* @__PURE__ */ new Date(),
        cancelledBy: userId,
        cancellationReason: reason,
        updatedAt: /* @__PURE__ */ new Date()
      },
      include: {
        store: {
          select: {
            id: true,
            name: true
          }
        },
        product: {
          select: {
            id: true,
            name: true,
            unitOfMeasure: true
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async getMovementReport(params) {
    const {
      storeId,
      productId,
      supplierId,
      type,
      startDate,
      endDate,
      groupBy = "day"
    } = params;
    const where = {};
    if (storeId) where.storeId = storeId;
    if (productId) where.productId = productId;
    if (supplierId) where.supplierId = supplierId;
    if (type) where.type = type;
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) where.createdAt.gte = new Date(startDate);
      if (endDate) where.createdAt.lte = new Date(endDate);
    }
    const movements = await db.movement.findMany({
      where,
      include: {
        store: {
          select: {
            id: true,
            name: true
          }
        },
        product: {
          select: {
            id: true,
            name: true
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true
          }
        }
      },
      orderBy: { createdAt: "asc" }
    });
    const groupedData = /* @__PURE__ */ new Map();
    movements.forEach((movement) => {
      let dateKey;
      const date = new Date(movement.createdAt);
      switch (groupBy) {
        case "day":
          dateKey = date.toISOString().split("T")[0];
          break;
        case "week":
          const weekStart = new Date(date);
          weekStart.setDate(date.getDate() - date.getDay());
          dateKey = weekStart.toISOString().split("T")[0];
          break;
        case "month":
          dateKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, "0")}`;
          break;
        case "year":
          dateKey = String(date.getFullYear());
          break;
        default:
          dateKey = date.toISOString().split("T")[0];
      }
      if (!groupedData.has(dateKey)) {
        groupedData.set(dateKey, {
          movements: 0,
          value: 0,
          entrada: 0,
          saida: 0,
          perda: 0
        });
      }
      const data2 = groupedData.get(dateKey);
      data2.movements++;
      data2.value += Number(movement.price) || 0;
      if (movement.type === "ENTRADA") {
        data2.entrada += movement.quantity;
      } else if (movement.type === "SAIDA") {
        data2.saida += movement.quantity;
      } else if (movement.type === "PERDA") {
        data2.perda += movement.quantity;
      }
    });
    const data = Array.from(groupedData.entries()).map(([date, stats]) => ({
      date,
      ...stats
    }));
    const byType = {
      ENTRADA: { count: 0, value: 0, quantity: 0 },
      SAIDA: { count: 0, value: 0, quantity: 0 },
      PERDA: { count: 0, value: 0, quantity: 0 }
    };
    movements.forEach((movement) => {
      const typeData = byType[movement.type];
      typeData.count++;
      typeData.value += Number(movement.price) || 0;
      typeData.quantity += movement.quantity;
    });
    const storeMap = /* @__PURE__ */ new Map();
    movements.forEach((movement) => {
      const storeId2 = movement.storeId;
      if (!storeMap.has(storeId2)) {
        storeMap.set(storeId2, { movements: 0, value: 0 });
      }
      const storeData = storeMap.get(storeId2);
      storeData.movements++;
      storeData.value += Number(movement.price) || 0;
    });
    const byStore = Array.from(storeMap.entries()).map(([storeId2, stats]) => {
      const store = movements.find((m) => m.storeId === storeId2)?.store;
      return {
        storeId: storeId2,
        storeName: store?.name || "Unknown",
        ...stats
      };
    });
    const productMap = /* @__PURE__ */ new Map();
    movements.forEach((movement) => {
      const productId2 = movement.productId;
      if (!productMap.has(productId2)) {
        productMap.set(productId2, { movements: 0, quantity: 0 });
      }
      const productData = productMap.get(productId2);
      productData.movements++;
      productData.quantity += movement.quantity;
    });
    const byProduct = Array.from(productMap.entries()).map(([productId2, stats]) => {
      const product = movements.find((m) => m.productId === productId2)?.product;
      return {
        productId: productId2,
        productName: product?.name || "Unknown",
        ...stats
      };
    });
    const supplierMap = /* @__PURE__ */ new Map();
    movements.forEach((movement) => {
      if (movement.supplierId) {
        const supplierId2 = movement.supplierId;
        if (!supplierMap.has(supplierId2)) {
          supplierMap.set(supplierId2, { movements: 0, value: 0 });
        }
        const supplierData = supplierMap.get(supplierId2);
        supplierData.movements++;
        supplierData.value += Number(movement.price) || 0;
      }
    });
    const bySupplier = Array.from(supplierMap.entries()).map(([supplierId2, stats]) => {
      const supplier = movements.find((m) => m.supplierId === supplierId2)?.supplier;
      return {
        supplierId: supplierId2,
        supplierName: supplier?.corporateName || "Unknown",
        ...stats
      };
    });
    return {
      summary: {
        totalMovements: movements.length,
        totalValue: movements.reduce((sum, m) => sum + (Number(m.price) || 0), 0),
        period: {
          startDate: startDate || new Date(Math.min(...movements.map((m) => m.createdAt.getTime()))).toISOString().split("T")[0],
          endDate: endDate || new Date(Math.max(...movements.map((m) => m.createdAt.getTime()))).toISOString().split("T")[0]
        }
      },
      data,
      byType,
      byStore,
      byProduct,
      bySupplier
    };
  }
};

// src/features/movement/queries/movement.queries.ts
init_prisma();

// src/services/llm/index.ts
var import_ollama = require("@langchain/ollama");
var import_messages = require("@langchain/core/messages");
var defaultModel = new import_ollama.ChatOllama({
  model: "mistral",
  temperature: 0.2
});
var LLMService = {
  async executePrompt(prompt) {
    try {
      const response = await defaultModel.invoke([new import_messages.HumanMessage(prompt)]);
      return response.content;
    } catch (error) {
      console.error("Erro em executePrompt:", error);
      throw new Error("Falha ao executar prompt no LLM");
    }
  },
  async executeWithStreaming(prompt, onToken) {
    try {
      if (!defaultModel.stream) {
        throw new Error("Streaming n\xE3o suportado nesta vers\xE3o do ChatOllama");
      }
      const stream = await defaultModel.stream([new import_messages.HumanMessage(prompt)]);
      let fullResponse = "";
      for await (const chunk of stream) {
        const token = chunk.content;
        if (token) {
          fullResponse += token;
          onToken(token);
        }
      }
      return fullResponse;
    } catch (error) {
      console.error("Erro em executeWithStreaming:", error);
      throw new Error("Falha ao executar prompt com streaming");
    }
  },
  async executeBatch(prompts) {
    try {
      const results = await Promise.all(prompts.map((p) => this.executePrompt(p)));
      return results;
    } catch (error) {
      console.error("Erro em executeBatch:", error);
      throw new Error("Falha ao executar batch de prompts no LLM");
    }
  },
  async executeWithTemplate(template, variables) {
    try {
      const prompt = await template.format(variables);
      return await this.executePrompt(prompt);
    } catch (error) {
      console.error("Erro em executeWithTemplate:", error);
      throw new Error("Falha ao executar prompt com template");
    }
  },
  async executeWithOptions(prompt, options) {
    try {
      const useDefault = (options.temperature ?? 0.2) === 0.2 && (options.numPredict ?? 1e3) === 1e3 && (options.repeatPenalty ?? 1.1) === 1.1;
      if (useDefault) {
        return await this.executePrompt(prompt);
      }
      const tempModel = new import_ollama.ChatOllama({
        model: "mistral",
        temperature: options.temperature ?? 0.2,
        numPredict: options.numPredict ?? 1e3,
        repeatPenalty: options.repeatPenalty ?? 1.1
      });
      const response = await tempModel.invoke([new import_messages.HumanMessage(prompt)]);
      return response.content;
    } catch (error) {
      console.error("Erro em executeWithOptions:", error);
      throw new Error("Falha ao executar prompt com op\xE7\xF5es customizadas");
    }
  }
};

// src/features/movement/queries/movement.queries.ts
var MovementQueries = {
  async getById(id) {
    console.log("MovementQueries.getById: Searching for movement with id:", id);
    const movement = await db.movement.findUnique({
      where: { id },
      include: {
        store: {
          select: {
            id: true,
            name: true
          }
        },
        product: {
          select: {
            id: true,
            name: true,
            unitOfMeasure: true
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    if (!movement) {
      console.log("MovementQueries.getById: Movement not found");
      return null;
    }
    console.log("MovementQueries.getById: Found movement with relations:", {
      id: movement.id,
      storeId: movement.storeId,
      productId: movement.productId,
      supplierId: movement.supplierId,
      userId: movement.userId,
      store: movement.store,
      product: movement.product,
      supplier: movement.supplier,
      user: movement.user
    });
    const result = {
      ...movement,
      store: movement.store || null,
      product: movement.product || null,
      supplier: movement.supplier || null,
      user: movement.user || null
    };
    console.log("MovementQueries.getById: Final result:", JSON.stringify(result, null, 2));
    return result;
  },
  async list(params) {
    const {
      page = 1,
      limit = 10,
      search,
      type,
      storeId,
      productId,
      supplierId,
      startDate,
      endDate
    } = params;
    const skip2 = (page - 1) * limit;
    const where = {};
    if (type) {
      where.type = type;
    }
    if (storeId) {
      where.storeId = storeId;
    }
    if (productId) {
      where.productId = productId;
    }
    if (supplierId) {
      where.supplierId = supplierId;
    }
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) {
        where.createdAt.gte = new Date(startDate);
      }
      if (endDate) {
        where.createdAt.lte = new Date(endDate);
      }
    }
    if (search) {
      where.OR = [
        {
          product: {
            name: {
              contains: search,
              mode: "insensitive"
            }
          }
        },
        {
          store: {
            name: {
              contains: search,
              mode: "insensitive"
            }
          }
        },
        {
          supplier: {
            corporateName: {
              contains: search,
              mode: "insensitive"
            }
          }
        },
        {
          batch: {
            contains: search,
            mode: "insensitive"
          }
        },
        {
          note: {
            contains: search,
            mode: "insensitive"
          }
        }
      ];
    }
    const [items, total] = await Promise.all([
      db.movement.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          store: {
            select: {
              id: true,
              name: true
            }
          },
          product: {
            select: {
              id: true,
              name: true,
              unitOfMeasure: true
            }
          },
          supplier: {
            select: {
              id: true,
              corporateName: true
            }
          },
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      }),
      db.movement.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async search(term, limit = 10) {
    return await db.movement.findMany({
      where: {
        OR: [
          {
            product: {
              name: {
                contains: term,
                mode: "insensitive"
              }
            }
          },
          {
            store: {
              name: {
                contains: term,
                mode: "insensitive"
              }
            }
          },
          {
            supplier: {
              corporateName: {
                contains: term,
                mode: "insensitive"
              }
            }
          },
          {
            batch: {
              contains: term,
              mode: "insensitive"
            }
          }
        ]
      },
      take: limit,
      orderBy: { createdAt: "desc" },
      include: {
        store: {
          select: {
            id: true,
            name: true
          }
        },
        product: {
          select: {
            id: true,
            name: true,
            unitOfMeasure: true
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true
          }
        }
      }
    });
  },
  async getByStore(storeId, params) {
    const { page = 1, limit = 10, type, startDate, endDate } = params;
    const skip2 = (page - 1) * limit;
    const where = { storeId };
    if (type) {
      where.type = type;
    }
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) {
        where.createdAt.gte = new Date(startDate);
      }
      if (endDate) {
        where.createdAt.lte = new Date(endDate);
      }
    }
    const [items, total] = await Promise.all([
      db.movement.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          store: {
            select: {
              id: true,
              name: true
            }
          },
          product: {
            select: {
              id: true,
              name: true,
              unitOfMeasure: true
            }
          },
          supplier: {
            select: {
              id: true,
              corporateName: true
            }
          },
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      }),
      db.movement.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getByProduct(productId, params) {
    const { page = 1, limit = 10, type, startDate, endDate, storeId } = params;
    const skip2 = (page - 1) * limit;
    const where = { productId };
    if (storeId) {
      where.storeId = storeId;
    }
    if (type) {
      where.type = type;
    }
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) {
        where.createdAt.gte = new Date(startDate);
      }
      if (endDate) {
        where.createdAt.lte = new Date(endDate);
      }
    }
    const [items, total] = await Promise.all([
      db.movement.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          store: {
            select: {
              id: true,
              name: true
            }
          },
          supplier: {
            select: {
              id: true,
              corporateName: true
            }
          },
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      }),
      db.movement.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getBySupplier(supplierId, params) {
    const { page = 1, limit = 10, type, startDate, endDate } = params;
    const skip2 = (page - 1) * limit;
    const where = { supplierId };
    if (type) {
      where.type = type;
    }
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) {
        where.createdAt.gte = new Date(startDate);
      }
      if (endDate) {
        where.createdAt.lte = new Date(endDate);
      }
    }
    const [items, total] = await Promise.all([
      db.movement.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          store: {
            select: {
              id: true,
              name: true
            }
          },
          product: {
            select: {
              id: true,
              name: true,
              unitOfMeasure: true
            }
          },
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      }),
      db.movement.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getStockHistory(productId, storeId, params) {
    const { startDate, endDate } = params;
    const where = { productId, storeId };
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) {
        where.createdAt.gte = new Date(startDate);
      }
      if (endDate) {
        where.createdAt.lte = new Date(endDate);
      }
    }
    return await db.movement.findMany({
      where,
      orderBy: { createdAt: "asc" },
      select: {
        id: true,
        type: true,
        quantity: true,
        balanceAfter: true,
        createdAt: true,
        batch: true,
        price: true,
        note: true,
        user: {
          select: {
            id: true,
            name: true
          }
        }
      }
    });
  },
  async getCurrentStock(productId, storeId) {
    const movements = await db.movement.findMany({
      where: {
        productId,
        storeId
      },
      orderBy: {
        createdAt: "desc"
      }
    });
    let stock = 0;
    for (const movement of movements) {
      if (movement.type === "ENTRADA") {
        stock += movement.quantity;
      } else if (movement.type === "SAIDA" || movement.type === "PERDA") {
        stock -= movement.quantity;
      }
    }
    return Math.max(0, stock);
  },
  async getStats() {
    const [
      total,
      entrada,
      saida,
      perda,
      totalValue,
      averageValue,
      _byType,
      byStore,
      byProduct,
      bySupplier
    ] = await Promise.all([
      db.movement.count(),
      db.movement.count({ where: { type: "ENTRADA" } }),
      db.movement.count({ where: { type: "SAIDA" } }),
      db.movement.count({ where: { type: "PERDA" } }),
      db.movement.aggregate({
        _sum: {
          price: true
        }
      }),
      db.movement.aggregate({
        _avg: {
          price: true
        }
      }),
      db.movement.groupBy({
        by: ["type"],
        _count: {
          id: true
        }
      }),
      db.movement.groupBy({
        by: ["storeId"],
        _count: {
          id: true
        },
        _sum: {
          price: true
        }
      }),
      db.movement.groupBy({
        by: ["productId"],
        _count: {
          id: true
        },
        _sum: {
          quantity: true
        }
      }),
      db.movement.groupBy({
        by: ["supplierId"],
        _count: {
          id: true
        },
        _sum: {
          price: true
        },
        where: {
          supplierId: {
            not: null
          }
        }
      })
    ]);
    const storeIds = byStore.map((item) => item.storeId);
    const productIds = byProduct.map((item) => item.productId);
    const supplierIds = bySupplier.map((item) => item.supplierId).filter(Boolean);
    const [stores, products, suppliers] = await Promise.all([
      storeIds.length > 0 ? db.store.findMany({
        where: { id: { in: storeIds } },
        select: { id: true, name: true }
      }) : [],
      productIds.length > 0 ? db.product.findMany({
        where: { id: { in: productIds } },
        select: { id: true, name: true }
      }) : [],
      supplierIds.length > 0 ? db.supplier.findMany({
        where: { id: { in: supplierIds } },
        select: { id: true, corporateName: true }
      }) : []
    ]);
    const storeMap = new Map(stores.map((store) => [store.id, store.name]));
    const productMap = new Map(products.map((product) => [product.id, product.name]));
    const supplierMap = new Map(suppliers.map((supplier) => [supplier.id, supplier.corporateName]));
    return {
      total,
      entrada,
      saida,
      perda,
      totalValue: totalValue._sum.price || 0,
      averageValue: averageValue._avg.price || 0,
      byType: {
        ENTRADA: entrada,
        SAIDA: saida,
        PERDA: perda
      },
      byStore: byStore.map((item) => ({
        storeId: item.storeId,
        storeName: storeMap.get(item.storeId) || "Unknown",
        count: item._count.id,
        totalValue: item._sum.price || 0
      })),
      byProduct: byProduct.map((item) => ({
        productId: item.productId,
        productName: productMap.get(item.productId) || "Unknown",
        count: item._count.id,
        totalQuantity: item._sum.quantity || 0
      })),
      bySupplier: bySupplier.map((item) => ({
        supplierId: item.supplierId,
        supplierName: supplierMap.get(item.supplierId) || "Unknown",
        count: item._count.id,
        totalValue: item._sum.price || 0
      }))
    };
  },
  async getLowStockProducts(storeId) {
    const where = {};
    if (storeId) {
      where.storeId = storeId;
    }
    const products = await db.product.findMany({
      where: {
        ...where,
        status: true
      },
      include: {
        movements: {
          where: {
            storeId: storeId || void 0
          },
          orderBy: {
            createdAt: "desc"
          }
        },
        store: {
          select: {
            id: true,
            name: true
          }
        }
      }
    });
    const lowStockProducts = [];
    for (const product of products) {
      const currentStock = await MovementQueries.getCurrentStock(product.id, product.storeId);
      const alertThreshold = Math.floor(product.stockMin * product.alertPercentage / 100);
      if (currentStock <= alertThreshold) {
        lowStockProducts.push({
          product: {
            id: product.id,
            name: product.name,
            unitOfMeasure: product.unitOfMeasure
          },
          store: product.store,
          currentStock,
          stockMin: product.stockMin,
          stockMax: product.stockMax,
          alertThreshold,
          status: currentStock === 0 ? "OUT_OF_STOCK" : "LOW_STOCK"
        });
      }
    }
    return lowStockProducts.sort((a, b) => a.currentStock - b.currentStock);
  },
  // === FUNÇÕES ADICIONAIS DE MOVIMENTAÇÃO ===
  async getMovementReport(params) {
    const { storeId, productId, supplierId, type, startDate, endDate } = params;
    const where = {};
    if (storeId) where.storeId = storeId;
    if (productId) where.productId = productId;
    if (supplierId) where.supplierId = supplierId;
    if (type) where.type = type;
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) where.createdAt.gte = new Date(startDate);
      if (endDate) where.createdAt.lte = new Date(endDate);
    }
    const movements = await db.movement.findMany({
      where,
      orderBy: { createdAt: "desc" },
      include: {
        store: { select: { id: true, name: true } },
        product: { select: { id: true, name: true, unitOfMeasure: true } },
        supplier: { select: { id: true, corporateName: true } },
        user: { select: { id: true, name: true, email: true } }
      }
    });
    return {
      movements,
      summary: {
        total: movements.length,
        totalValue: movements.reduce((sum, m) => sum + (Number(m.price) || 0), 0),
        byType: movements.reduce((acc, m) => {
          acc[m.type] = (acc[m.type] || 0) + 1;
          return acc;
        }, {})
      }
    };
  },
  async getVerifiedMovements(params) {
    const { page = 1, limit = 10, storeId, verified, startDate, endDate } = params;
    const skip2 = (page - 1) * limit;
    const where = {};
    if (storeId) where.storeId = storeId;
    if (verified !== void 0) where.verified = verified;
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) where.createdAt.gte = new Date(startDate);
      if (endDate) where.createdAt.lte = new Date(endDate);
    }
    const [items, total] = await Promise.all([
      db.movement.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          store: {
            select: {
              id: true,
              name: true
            }
          },
          product: {
            select: {
              id: true,
              name: true,
              unitOfMeasure: true
            }
          },
          supplier: {
            select: {
              id: true,
              corporateName: true
            }
          },
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      }),
      db.movement.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getCancelledMovements(params) {
    const { page = 1, limit = 10, storeId, startDate, endDate } = params;
    const skip2 = (page - 1) * limit;
    const where = { cancelled: true };
    if (storeId) where.storeId = storeId;
    if (startDate || endDate) {
      where.cancelledAt = {};
      if (startDate) where.cancelledAt.gte = new Date(startDate);
      if (endDate) where.cancelledAt.lte = new Date(endDate);
    }
    const [items, total] = await Promise.all([
      db.movement.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { cancelledAt: "desc" },
        include: {
          store: {
            select: {
              id: true,
              name: true
            }
          },
          product: {
            select: {
              id: true,
              name: true,
              unitOfMeasure: true
            }
          },
          supplier: {
            select: {
              id: true,
              corporateName: true
            }
          },
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      }),
      db.movement.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getMovementAnalytics(params) {
    const { storeId, productId, supplierId, startDate, endDate } = params;
    const where = {};
    if (storeId) where.storeId = storeId;
    if (productId) where.productId = productId;
    if (supplierId) where.supplierId = supplierId;
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) where.createdAt.gte = new Date(startDate);
      if (endDate) where.createdAt.lte = new Date(endDate);
    }
    const [
      totalMovements,
      totalValue,
      averageValue,
      byType,
      byMonth,
      byStore,
      byProduct,
      bySupplier,
      verifiedCount,
      cancelledCount
    ] = await Promise.all([
      db.movement.count({ where }),
      db.movement.aggregate({
        where,
        _sum: { price: true }
      }),
      db.movement.aggregate({
        where,
        _avg: { price: true }
      }),
      db.movement.groupBy({
        by: ["type"],
        where,
        _count: { id: true },
        _sum: { quantity: true, price: true }
      }),
      db.movement.groupBy({
        by: ["createdAt"],
        where,
        _count: { id: true },
        _sum: { price: true },
        orderBy: { createdAt: "asc" }
      }),
      db.movement.groupBy({
        by: ["storeId"],
        where,
        _count: { id: true },
        _sum: { price: true }
      }),
      db.movement.groupBy({
        by: ["productId"],
        where,
        _count: { id: true },
        _sum: { quantity: true, price: true }
      }),
      db.movement.groupBy({
        by: ["supplierId"],
        where: { ...where, supplierId: { not: null } },
        _count: { id: true },
        _sum: { price: true }
      }),
      db.movement.count({ where: { ...where, verified: true } }),
      db.movement.count({ where: { ...where, cancelled: true } })
    ]);
    const storeIds = byStore.map((item) => item.storeId);
    const productIds = byProduct.map((item) => item.productId);
    const supplierIds = bySupplier.map((item) => item.supplierId).filter(Boolean);
    const [stores, products, suppliers] = await Promise.all([
      storeIds.length > 0 ? db.store.findMany({
        where: { id: { in: storeIds } },
        select: { id: true, name: true }
      }) : [],
      productIds.length > 0 ? db.product.findMany({
        where: { id: { in: productIds } },
        select: { id: true, name: true }
      }) : [],
      supplierIds.length > 0 ? db.supplier.findMany({
        where: { id: { in: supplierIds } },
        select: { id: true, corporateName: true }
      }) : []
    ]);
    const storeMap = new Map(stores.map((store) => [store.id, store.name]));
    const productMap = new Map(products.map((product) => [product.id, product.name]));
    const supplierMap = new Map(suppliers.map((supplier) => [supplier.id, supplier.corporateName]));
    return {
      summary: {
        totalMovements,
        totalValue: totalValue._sum.price || 0,
        averageValue: averageValue._avg.price || 0,
        verifiedCount,
        cancelledCount,
        verificationRate: totalMovements > 0 ? verifiedCount / totalMovements * 100 : 0,
        cancellationRate: totalMovements > 0 ? cancelledCount / totalMovements * 100 : 0
      },
      byType: byType.map((item) => ({
        type: item.type,
        count: item._count.id,
        quantity: item._sum.quantity || 0,
        value: item._sum.price || 0
      })),
      byMonth: byMonth.map((item) => ({
        month: item.createdAt.toISOString().substring(0, 7),
        count: item._count.id,
        value: item._sum.price || 0
      })),
      byStore: byStore.map((item) => ({
        storeId: item.storeId,
        storeName: storeMap.get(item.storeId) || "Unknown",
        count: item._count.id,
        value: item._sum.price || 0
      })),
      byProduct: byProduct.map((item) => ({
        productId: item.productId,
        productName: productMap.get(item.productId) || "Unknown",
        count: item._count.id,
        quantity: item._sum.quantity || 0,
        value: item._sum.price || 0
      })),
      bySupplier: bySupplier.map((item) => ({
        supplierId: item.supplierId,
        supplierName: supplierMap.get(item.supplierId) || "Unknown",
        count: item._count.id,
        value: item._sum.price || 0
      }))
    };
  },
  async summarize() {
    const movements = await db.movement.findMany();
    const summary = movements.map(
      (m) => `Produto: ${m.productId}, Tipo: ${m.type}, Quantidade: ${m.quantity}`
    ).join("\n");
    const prompt = `
    Ol\xE1! Sou o gerente do estoque e preciso de uma an\xE1lise amig\xE1vel sobre as movimenta\xE7\xF5es de hoje.
      
      Analise os dados abaixo e me conte como est\xE1 nosso estoque de forma conversacional e humanizada.
      Quero entender o que est\xE1 acontecendo sem muito jarg\xE3o t\xE9cnico. Me fale sobre:
      - O que mais est\xE1 entrando e saindo
      - Se temos algum problema com perdas
      - Como est\xE1 a demanda geral
      - Alguma observa\xE7\xE3o importante que devo saber
 
    ${summary}`;
    const result = LLMService.executePrompt(prompt);
    return result;
  },
  /*
    Resumo gerado pelo LLM:
    Olá, eu analisei os dados do seu estoque de hoje e aqui está uma resumida:
  
  - Entradas mais comuns: Notebook Dell Inspiron 15 3000 (25 unidades), SSD NVMe 
  1TB Kingston (30 unidades) e Smartphone Samsung Galaxy A54 (40 unidades). Esses 
  itens estão entrando em grande quantidade, indicando uma alta demanda.
  
  - Saídas mais comuns: Monitor Samsung 24" Full HD (12 unidades), Memória RAM 
  DDR4 16GB Corsair (18 unidades) e Fone Bluetooth JBL Tune 500BT (22 unidades). 
  Esses itens estão sendo vendidos em grande quantidade, indicando uma alta demanda.
  
  - Perdas: Cabo HDMI Premium 2m (3 unidades), Carregador USB-C 65W Universal (1 
  unidade) e Webcam Logitech C920 HD Pro (2 unidades). Esses itens estão sendo 
  perdidos, o que pode ser causado por erros de inventário ou falhas no produto.
  
  - Observação importante: O estoque de Memória RAM DDR4 16GB Corsair está 
  sendo vendido em grande quantidade e também está entrando em pequena quantidade. 
  Isso indica que a demanda pode estar ultrapassando a oferta, o que pode causar 
  problemas no futuro se não for feito alguma ação para aumentar a quantidade 
  disponível.
  
  - Demanda geral: A demanda geral parece ser alta, com muitos itens entrando e 
  saídas em grande quantidade. Isso é um bom sinal para o negócio, mas precisa 
  ser monitorado de forma regular para evitar problemas no futuro.
  
  Espero que essa análise ajude a entender melhor o que está acontecendo com seu 
  estoque hoje!
    */
  async getProductSummary(productId, params) {
    const { startDate, endDate, storeId } = params;
    const product = await db.product.findUnique({
      where: { id: productId },
      select: {
        id: true,
        name: true,
        unitOfMeasure: true,
        stockMin: true,
        stockMax: true,
        alertPercentage: true
      }
    });
    if (!product) {
      throw new Error("Product not found");
    }
    const where = { productId };
    if (storeId) {
      where.storeId = storeId;
    }
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) where.createdAt.gte = new Date(startDate);
      if (endDate) where.createdAt.lte = new Date(endDate);
    }
    const movements = await db.movement.findMany({
      where,
      orderBy: { createdAt: "desc" },
      include: {
        store: {
          select: {
            id: true,
            name: true
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true
          }
        },
        user: {
          select: {
            id: true,
            name: true
          }
        }
      }
    });
    const totalMovements = movements.length;
    const entradaMovements = movements.filter((m) => m.type === "ENTRADA");
    const saidaMovements = movements.filter((m) => m.type === "SAIDA");
    const perdaMovements = movements.filter((m) => m.type === "PERDA");
    const totalEntrada = entradaMovements.reduce((sum, m) => sum + m.quantity, 0);
    const totalSaida = saidaMovements.reduce((sum, m) => sum + m.quantity, 0);
    const totalPerda = perdaMovements.reduce((sum, m) => sum + m.quantity, 0);
    const totalValue = movements.reduce((sum, m) => sum + (Number(m.price) || 0), 0);
    const averageValue = totalMovements > 0 ? totalValue / totalMovements : 0;
    const stores = [...new Set(movements.map((m) => m.storeId))];
    const currentStockByStore = await Promise.all(
      stores.map(async (storeId2) => {
        const currentStock = await MovementQueries.getCurrentStock(productId, storeId2);
        const store = movements.find((m) => m.storeId === storeId2)?.store;
        return {
          storeId: storeId2,
          storeName: store?.name || "Unknown",
          currentStock
        };
      })
    );
    const movementsSummary = movements.slice(0, 20).map(
      (m) => `Data: ${m.createdAt.toISOString().split("T")[0]}, Tipo: ${m.type}, Quantidade: ${m.quantity} ${product.unitOfMeasure}, Loja: ${m.store.name}, Pre\xE7o: R$ ${Number(m.price || 0).toFixed(2)}, Lote: ${m.batch || "N/A"}`
    ).join("\n");
    const prompt = `
      Voc\xEA \xE9 um especialista em an\xE1lise de estoque. Analise as movimenta\xE7\xF5es do produto "${product.name}" e gere um resumo executivo em portugu\xEAs.

      INFORMA\xC7\xD5ES DO PRODUTO:
      - Nome: ${product.name}
      - Unidade: ${product.unitOfMeasure}
      - Estoque M\xEDnimo: ${product.stockMin}
      - Estoque M\xE1ximo: ${product.stockMax}
      - Percentual de Alerta: ${product.alertPercentage}%

      ESTAT\xCDSTICAS GERAIS:
      - Total de Movimenta\xE7\xF5es: ${totalMovements}
      - Entradas: ${entradaMovements.length} (${totalEntrada} ${product.unitOfMeasure})
      - Sa\xEDdas: ${saidaMovements.length} (${totalSaida} ${product.unitOfMeasure})
      - Perdas: ${perdaMovements.length} (${totalPerda} ${product.unitOfMeasure})
      - Valor Total: R$ ${totalValue.toFixed(2)}
      - Valor M\xE9dio por Movimenta\xE7\xE3o: R$ ${averageValue.toFixed(2)}

      ESTOQUE ATUAL POR LOJA:
      ${currentStockByStore.map((s) => `- ${s.storeName}: ${s.currentStock} ${product.unitOfMeasure}`).join("\n")}

      MOVIMENTA\xC7\xD5ES RECENTES:
      ${movementsSummary}

      Gere um resumo executivo destacando:
      1. Situa\xE7\xE3o atual do estoque
      2. Tend\xEAncias de movimenta\xE7\xE3o
      3. Alertas importantes (estoque baixo, perdas, etc.)
      4. Recomenda\xE7\xF5es de a\xE7\xE3o
    `;
    const llmSummary = await LLMService.executePrompt(prompt);
    return {
      product: {
        id: product.id,
        name: product.name,
        unitOfMeasure: product.unitOfMeasure,
        stockMin: product.stockMin,
        stockMax: product.stockMax,
        alertPercentage: product.alertPercentage
      },
      period: {
        startDate: startDate || null,
        endDate: endDate || null,
        storeId: storeId || null
      },
      statistics: {
        totalMovements,
        entrada: {
          count: entradaMovements.length,
          quantity: totalEntrada
        },
        saida: {
          count: saidaMovements.length,
          quantity: totalSaida
        },
        perda: {
          count: perdaMovements.length,
          quantity: totalPerda
        },
        totalValue,
        averageValue
      },
      currentStockByStore,
      recentMovements: movements.slice(0, 10).map((m) => ({
        id: m.id,
        type: m.type,
        quantity: m.quantity,
        price: m.price,
        batch: m.batch,
        createdAt: m.createdAt,
        store: m.store,
        supplier: m.supplier,
        user: m.user
      })),
      summary: llmSummary
    };
  }
};

// src/features/movement/movement.controller.ts
init_prisma();

// src/services/stock-monitoring/stock-alert.service.ts
init_prisma();

// src/features/notification/commands/notification.commands.ts
init_prisma();
var NotificationCommands = {
  async create(data) {
    return await db.notification.create({
      data: {
        userId: data.userId,
        title: data.title,
        message: data.message,
        type: data.type || "INFO",
        priority: data.priority || "MEDIUM",
        data: data.data,
        actionUrl: data.actionUrl,
        expiresAt: data.expiresAt
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async update(id, data) {
    return await db.notification.update({
      where: { id },
      data,
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async delete(id) {
    return await db.notification.delete({
      where: { id }
    });
  },
  async markAsRead(id) {
    return await db.notification.update({
      where: { id },
      data: {
        isRead: true,
        readAt: /* @__PURE__ */ new Date()
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async markAsUnread(id) {
    return await db.notification.update({
      where: { id },
      data: {
        isRead: false,
        readAt: null
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async markAllAsRead(userId) {
    return await db.notification.updateMany({
      where: {
        userId,
        isRead: false
      },
      data: {
        isRead: true,
        readAt: /* @__PURE__ */ new Date()
      }
    });
  },
  async deleteExpired() {
    return await db.notification.deleteMany({
      where: {
        expiresAt: {
          lt: /* @__PURE__ */ new Date()
        }
      }
    });
  },
  async deleteByUser(userId) {
    return await db.notification.deleteMany({
      where: { userId }
    });
  },
  async markStockAlertsAsRead(userId, storeId) {
    const whereCondition = {
      userId,
      isRead: false,
      type: "STOCK_ALERT"
    };
    if (storeId) {
      whereCondition.data = {
        path: ["storeId"],
        equals: storeId
      };
    }
    return await db.notification.updateMany({
      where: whereCondition,
      data: {
        isRead: true,
        readAt: /* @__PURE__ */ new Date()
      }
    });
  }
};

// src/services/stock-monitoring/stock-alert.service.ts
var StockAlertService = class {
  /**
   * Verifica se uma movimentação deve gerar alertas de estoque
   */
  static async checkStockAlerts(productId, storeId, movementType, movementQuantity, movementId) {
    try {
      const product = await db.product.findFirst({
        where: {
          id: productId,
          storeId,
          status: true
        },
        include: {
          store: {
            select: {
              id: true,
              name: true,
              ownerId: true,
              users: {
                select: {
                  userId: true,
                  user: {
                    select: {
                      id: true,
                      name: true,
                      email: true
                    }
                  }
                }
              }
            }
          }
        }
      });
      if (!product) {
        throw new Error("Product not found");
      }
      const movements = await db.movement.findMany({
        where: {
          productId,
          cancelled: false
        },
        select: {
          type: true,
          quantity: true
        }
      });
      let currentStock = 0;
      movements.forEach((movement) => {
        if (movement.type === "ENTRADA") {
          currentStock += movement.quantity;
        } else {
          currentStock -= movement.quantity;
        }
      });
      const previousStock = movementType === "ENTRADA" ? currentStock - movementQuantity : currentStock + movementQuantity;
      const alertType = this.determineAlertType(
        currentStock,
        previousStock,
        product.stockMin,
        product.stockMax,
        product.alertPercentage
      );
      if (!alertType) {
        return {
          alertTriggered: false,
          alertType: null
        };
      }
      const alertData = {
        productId: product.id,
        productName: product.name,
        storeId: product.store.id,
        storeName: product.store.name,
        currentStock,
        stockMin: product.stockMin,
        stockMax: product.stockMax,
        alertPercentage: product.alertPercentage,
        previousStock,
        movementType,
        movementQuantity,
        movementId
      };
      const notifications = await this.createStockAlertNotifications(alertData, alertType, product.store);
      return {
        alertTriggered: true,
        alertType,
        notification: notifications[0],
        // Retorna a primeira notificação como exemplo
        message: this.generateAlertMessage(alertData, alertType)
      };
    } catch (error) {
      console.error("Error checking stock alerts:", error);
      return {
        alertTriggered: false,
        alertType: null
      };
    }
  }
  /**
   * Determina o tipo de alerta baseado no estoque atual e anterior
   */
  static determineAlertType(currentStock, previousStock, stockMin, stockMax, alertPercentage) {
    const alertThreshold = Math.round(stockMin * (alertPercentage / 100));
    if (currentStock <= 0) {
      return "CRITICAL_STOCK";
    }
    if (currentStock <= alertThreshold && currentStock > 0) {
      return "LOW_STOCK";
    }
    if (currentStock > alertThreshold && previousStock <= alertThreshold) {
      return "STOCK_RECOVERED";
    }
    if (currentStock > stockMax && previousStock <= stockMax) {
      return "OVERSTOCK";
    }
    return null;
  }
  /**
   * Cria notificações para usuários da loja
   */
  static async createStockAlertNotifications(alertData, alertType, store) {
    const notifications = [];
    const { priority, notificationType } = this.getNotificationConfig(alertType);
    const ownerNotification = await NotificationCommands.create({
      userId: store.ownerId,
      title: this.getAlertTitle(alertType),
      message: this.generateAlertMessage(alertData, alertType),
      type: notificationType,
      priority,
      data: {
        productId: alertData.productId,
        productName: alertData.productName,
        storeId: alertData.storeId,
        storeName: alertData.storeName,
        currentStock: alertData.currentStock,
        stockMin: alertData.stockMin,
        stockMax: alertData.stockMax,
        movementType: alertData.movementType,
        movementQuantity: alertData.movementQuantity,
        movementId: alertData.movementId,
        alertType
      },
      actionUrl: `/products/${alertData.productId}`,
      expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1e3)
      // 7 dias
    });
    notifications.push(ownerNotification);
    const storeUsers = store.users.filter((su) => su.userId !== store.ownerId);
    for (const storeUser of storeUsers) {
      const userNotification = await NotificationCommands.create({
        userId: storeUser.userId,
        title: this.getAlertTitle(alertType),
        message: this.generateAlertMessage(alertData, alertType),
        type: notificationType,
        priority,
        data: {
          productId: alertData.productId,
          productName: alertData.productName,
          storeId: alertData.storeId,
          storeName: alertData.storeName,
          currentStock: alertData.currentStock,
          stockMin: alertData.stockMin,
          stockMax: alertData.stockMax,
          movementType: alertData.movementType,
          movementQuantity: alertData.movementQuantity,
          movementId: alertData.movementId,
          alertType
        },
        actionUrl: `/products/${alertData.productId}`,
        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1e3)
        // 7 dias
      });
      notifications.push(userNotification);
    }
    return notifications;
  }
  /**
   * Obtém configuração de notificação baseada no tipo de alerta
   */
  static getNotificationConfig(alertType) {
    switch (alertType) {
      case "CRITICAL_STOCK":
        return { priority: "URGENT", notificationType: "ERROR" };
      case "LOW_STOCK":
        return { priority: "HIGH", notificationType: "WARNING" };
      case "OVERSTOCK":
        return { priority: "MEDIUM", notificationType: "WARNING" };
      case "STOCK_RECOVERED":
        return { priority: "LOW", notificationType: "STOCK_ALERT" };
      default:
        return { priority: "MEDIUM", notificationType: "STOCK_ALERT" };
    }
  }
  /**
   * Gera título do alerta
   */
  static getAlertTitle(alertType) {
    switch (alertType) {
      case "CRITICAL_STOCK":
        return "\u{1F6A8} Estoque Cr\xEDtico";
      case "LOW_STOCK":
        return "\u26A0\uFE0F Estoque Baixo";
      case "OVERSTOCK":
        return "\u{1F4E6} Estoque Excessivo";
      case "STOCK_RECOVERED":
        return "\u2705 Estoque Recuperado";
      default:
        return "\u{1F4CA} Alerta de Estoque";
    }
  }
  /**
   * Gera mensagem do alerta
   */
  static generateAlertMessage(alertData, alertType) {
    const { productName, currentStock, stockMin, stockMax, movementType, movementQuantity } = alertData;
    switch (alertType) {
      case "CRITICAL_STOCK":
        return `Produto "${productName}" est\xE1 com estoque cr\xEDtico (${currentStock} unidades). Movimenta\xE7\xE3o de ${movementType.toLowerCase()} de ${movementQuantity} unidades realizada.`;
      case "LOW_STOCK":
        return `Produto "${productName}" est\xE1 com estoque baixo (${currentStock} unidades). Estoque m\xEDnimo: ${stockMin} unidades. Movimenta\xE7\xE3o de ${movementType.toLowerCase()} de ${movementQuantity} unidades realizada.`;
      case "OVERSTOCK":
        return `Produto "${productName}" est\xE1 com estoque excessivo (${currentStock} unidades). Estoque m\xE1ximo: ${stockMax} unidades. Movimenta\xE7\xE3o de ${movementType.toLowerCase()} de ${movementQuantity} unidades realizada.`;
      case "STOCK_RECOVERED":
        return `Produto "${productName}" recuperou o estoque (${currentStock} unidades). Estoque m\xEDnimo: ${stockMin} unidades. Movimenta\xE7\xE3o de ${movementType.toLowerCase()} de ${movementQuantity} unidades realizada.`;
      default:
        return `Alerta de estoque para o produto "${productName}" (${currentStock} unidades).`;
    }
  }
  /**
   * Verifica produtos com estoque baixo em uma loja
   */
  static async checkLowStockProducts(storeId) {
    try {
      const products = await db.product.findMany({
        where: {
          storeId,
          status: true
        },
        include: {
          store: {
            select: {
              id: true,
              name: true
            }
          }
        }
      });
      const lowStockProducts = [];
      for (const product of products) {
        const movements = await db.movement.findMany({
          where: {
            productId: product.id,
            cancelled: false
          },
          select: {
            type: true,
            quantity: true
          }
        });
        let currentStock = 0;
        movements.forEach((movement) => {
          if (movement.type === "ENTRADA") {
            currentStock += movement.quantity;
          } else {
            currentStock -= movement.quantity;
          }
        });
        const alertThreshold = Math.round(product.stockMin * (product.alertPercentage / 100));
        if (currentStock <= alertThreshold) {
          lowStockProducts.push({
            productId: product.id,
            productName: product.name,
            currentStock,
            stockMin: product.stockMin,
            stockMax: product.stockMax,
            alertPercentage: product.alertPercentage,
            alertThreshold,
            storeId: product.store.id,
            storeName: product.store.name
          });
        }
      }
      return lowStockProducts;
    } catch (error) {
      console.error("Error checking low stock products:", error);
      return [];
    }
  }
  /**
   * Cria notificação de resumo de estoque baixo
   */
  static async createLowStockSummaryNotification(storeId) {
    try {
      const lowStockProducts = await this.checkLowStockProducts(storeId);
      if (lowStockProducts.length === 0) {
        return null;
      }
      const store = await db.store.findUnique({
        where: { id: storeId },
        select: {
          id: true,
          name: true,
          ownerId: true,
          users: {
            select: {
              userId: true
            }
          }
        }
      });
      if (!store) {
        throw new Error("Store not found");
      }
      const criticalProducts = lowStockProducts.filter((p) => p.currentStock <= 0);
      const lowProducts = lowStockProducts.filter((p) => p.currentStock > 0);
      const title = `\u{1F4CA} Resumo de Estoque - ${store.name}`;
      const message = `Encontrados ${lowStockProducts.length} produtos com estoque baixo:
\u2022 ${criticalProducts.length} produtos cr\xEDticos (estoque zero)
\u2022 ${lowProducts.length} produtos com estoque baixo

Produtos cr\xEDticos: ${criticalProducts.map((p) => p.productName).join(", ")}`;
      return await NotificationCommands.create({
        userId: store.ownerId,
        title,
        message,
        type: "STOCK_ALERT",
        priority: criticalProducts.length > 0 ? "URGENT" : "HIGH",
        data: {
          storeId,
          storeName: store.name,
          lowStockProducts,
          criticalCount: criticalProducts.length,
          lowCount: lowProducts.length
        },
        actionUrl: `/reports/low-stock?storeId=${storeId}`,
        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1e3)
        // 24 horas
      });
    } catch (error) {
      console.error("Error creating low stock summary notification:", error);
      return null;
    }
  }
};

// src/features/movement/movement.controller.ts
var MovementController = {
  // === CRUD BÁSICO ===
  async create(request, reply) {
    try {
      const { type, quantity, storeId, productId, supplierId, batch, expiration, price, note } = request.body;
      const userId = request.user?.id;
      console.log("Creating movement with data:", {
        type,
        quantity,
        storeId,
        productId,
        supplierId,
        batch,
        price,
        note,
        userId
      });
      const result = await MovementCommands.create({
        type,
        quantity,
        storeId,
        // Agora vem do middleware
        productId,
        supplierId,
        batch,
        expiration,
        price,
        note,
        userId
      });
      console.log("Movement created successfully:", result);
      try {
        const stockAlert = await StockAlertService.checkStockAlerts(
          productId,
          storeId,
          type,
          quantity,
          result.id
        );
        if (stockAlert.alertTriggered) {
          console.log("Stock alert triggered:", stockAlert);
          const resultWithAlert = {
            ...result,
            stockAlert: {
              triggered: true,
              type: stockAlert.alertType,
              message: stockAlert.message
            }
          };
          return reply.status(201).send(resultWithAlert);
        }
      } catch (alertError) {
        console.error("Error checking stock alerts:", alertError);
      }
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found in this store") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Insufficient stock for this movement") {
        return reply.status(400).send({
          error: error.message
        });
      }
      if (error.message === "Supplier not found or inactive") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message.includes("Store ID is required")) {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      console.log("MovementController.get: Getting movement with id:", id);
      const result = await MovementQueries.getById(id);
      if (!result) {
        console.log("MovementController.get: Movement not found");
        return reply.status(404).send({
          error: "Movement not found"
        });
      }
      console.log("MovementController.get: Returning movement:", {
        id: result.id,
        store: result.store,
        product: result.product,
        supplier: result.supplier,
        user: result.user
      });
      console.log("MovementController.get: Full result JSON:", JSON.stringify(result, null, 2));
      const serializedResult = {
        ...result,
        store: result.store ? {
          id: result.store.id,
          name: result.store.name
        } : null,
        product: result.product ? {
          id: result.product.id,
          name: result.product.name,
          unitOfMeasure: result.product.unitOfMeasure
        } : null,
        supplier: result.supplier ? {
          id: result.supplier.id,
          corporateName: result.supplier.corporateName
        } : null,
        user: result.user ? {
          id: result.user.id,
          name: result.user.name,
          email: result.user.email
        } : null
      };
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Movement not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      const result = await MovementCommands.update(id, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Movement not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Insufficient stock for this movement") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      await MovementCommands.delete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Movement not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Cannot delete movement: insufficient stock to revert") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { page = 1, limit = 10, search, type, productId, supplierId, startDate, endDate } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await MovementQueries.list({
        page,
        limit,
        search,
        type,
        storeId,
        productId,
        supplierId,
        startDate,
        endDate
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === NOVOS ENDPOINTS ESPECÍFICOS ===
  async listByStore(request, reply) {
    try {
      const { page = 1, limit = 10, search, type, productId, supplierId, startDate, endDate } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store ID is required. User must be associated with a store."
        });
      }
      console.log("Listing movements for store:", storeId);
      const result = await MovementQueries.getByStore(storeId, {
        page,
        limit,
        type,
        startDate,
        endDate
      });
      if (search || productId || supplierId) {
        const filteredResult = await MovementQueries.list({
          page,
          limit,
          search,
          type,
          storeId,
          productId,
          supplierId,
          startDate,
          endDate
        });
        return reply.send(filteredResult);
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async listByProduct(request, reply) {
    try {
      const { productId } = request.params;
      const { page = 1, limit = 10, type, startDate, endDate } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store ID is required. User must be associated with a store."
        });
      }
      console.log("Listing movements for product:", productId, "in store:", storeId);
      const product = await db.product.findFirst({
        where: {
          id: productId,
          storeId,
          status: true
        }
      });
      if (!product) {
        return reply.status(404).send({
          error: "Product not found in this store"
        });
      }
      const result = await MovementQueries.getByProduct(productId, {
        page,
        limit,
        type,
        startDate,
        endDate
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (QUERIES) ===
  async getByStore(request, reply) {
    try {
      const { storeId } = request.params;
      const { page = 1, limit = 10, type, startDate, endDate } = request.query;
      const result = await MovementQueries.getByStore(storeId, {
        page,
        limit,
        type,
        startDate,
        endDate
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByProduct(request, reply) {
    try {
      const { productId } = request.params;
      const { page = 1, limit = 10, type, startDate, endDate } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store ID is required. User must be associated with a store."
        });
      }
      console.log("Getting movements for product:", productId, "in store:", storeId);
      const product = await ProductQueries.getById(productId, storeId);
      console.log("Product:", product);
      if (!product) {
        return reply.status(404).send({
          error: "Product not found in this store"
        });
      }
      const result = await MovementQueries.getByProduct(productId, {
        page,
        limit,
        type,
        startDate,
        endDate,
        storeId
      });
      console.log("Result:", result);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getBySupplier(request, reply) {
    try {
      const { supplierId } = request.params;
      const { page = 1, limit = 10, type, startDate, endDate } = request.query;
      const result = await MovementQueries.getBySupplier(supplierId, {
        page,
        limit,
        type,
        startDate,
        endDate
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStockHistory(request, reply) {
    try {
      const { productId, storeId } = request.params;
      const { startDate, endDate } = request.query;
      const result = await MovementQueries.getStockHistory(productId, storeId, {
        startDate,
        endDate
      });
      return reply.send({ movements: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getCurrentStock(request, reply) {
    try {
      const { productId, storeId } = request.params;
      const result = await MovementQueries.getCurrentStock(productId, storeId);
      return reply.send({ currentStock: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const result = await MovementQueries.getStats();
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { q, limit = 10 } = request.query;
      const result = await MovementQueries.search(q, limit);
      return reply.send({ movements: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getLowStockProducts(request, reply) {
    try {
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await MovementQueries.getLowStockProducts(storeId);
      return reply.send({ products: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (COMMANDS) ===
  async recalculateStock(request, reply) {
    try {
      const { productId, storeId } = request.params;
      const result = await MovementCommands.recalculateStock(productId, storeId);
      return reply.send({ currentStock: result });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS DE MOVIMENTAÇÃO ===
  async getReport(request, reply) {
    try {
      const { productId, supplierId, type, startDate, endDate, groupBy, format } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await MovementQueries.getMovementReport({
        storeId,
        productId,
        supplierId,
        type,
        startDate,
        endDate,
        groupBy
      });
      if (format === "csv") {
        return reply.type("text/csv").send("CSV generation not implemented yet");
      }
      if (format === "pdf") {
        return reply.type("application/pdf").send("PDF generation not implemented yet");
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async createBulk(request, reply) {
    try {
      const { movements } = request.body;
      const userId = request.user?.id;
      const result = await MovementCommands.createBulk(movements, userId);
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async verify(request, reply) {
    try {
      const { id } = request.params;
      const { verified, note } = request.body;
      const userId = request.user?.id;
      const result = await MovementCommands.verify(id, verified, note, userId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Movement not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async cancel(request, reply) {
    try {
      const { id } = request.params;
      const { reason } = request.body;
      const userId = request.user?.id;
      const result = await MovementCommands.cancel(id, reason, userId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Movement not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Movement already cancelled") {
        return reply.status(400).send({
          error: error.message
        });
      }
      if (error.message === "Cannot cancel movement: insufficient stock to revert") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getVerifiedMovements(request, reply) {
    try {
      const { page = 1, limit = 10, verified, startDate, endDate } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await MovementQueries.getVerifiedMovements({
        page,
        limit,
        storeId,
        verified,
        startDate,
        endDate
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getCancelledMovements(request, reply) {
    try {
      const { page = 1, limit = 10, startDate, endDate } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await MovementQueries.getCancelledMovements({
        page,
        limit,
        storeId,
        startDate,
        endDate
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getAnalytics(request, reply) {
    try {
      const { productId, supplierId, startDate, endDate } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await MovementQueries.getMovementAnalytics({
        storeId,
        productId,
        supplierId,
        startDate,
        endDate
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async summarize(request, reply) {
    try {
      const result = await MovementQueries.summarize();
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async summarizeProduct(request, reply) {
    try {
      const { productId } = request.params;
      const { startDate, endDate } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await MovementQueries.getProductSummary(productId, {
        startDate,
        endDate,
        storeId
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === ENDPOINTS PARA ALERTAS DE ESTOQUE ===
  async checkStockAlerts(request, reply) {
    try {
      const finalStoreId = request.store?.id;
      if (!finalStoreId) {
        return reply.status(400).send({
          error: "Store ID is required"
        });
      }
      const lowStockProducts = await StockAlertService.checkLowStockProducts(finalStoreId);
      return reply.send({
        storeId: finalStoreId,
        lowStockCount: lowStockProducts.length,
        products: lowStockProducts
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async createLowStockSummaryNotification(request, reply) {
    try {
      const finalStoreId = request.store?.id;
      if (!finalStoreId) {
        return reply.status(400).send({
          error: "Store ID is required"
        });
      }
      const notification = await StockAlertService.createLowStockSummaryNotification(finalStoreId);
      if (!notification) {
        return reply.send({
          message: "No low stock products found",
          notification: null
        });
      }
      return reply.status(201).send({
        message: "Low stock summary notification created",
        notification
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/movement/movement.schema.ts
var createMovementSchema = {
  body: {
    type: "object",
    required: ["type", "quantity", "productId"],
    properties: {
      type: {
        type: "string",
        enum: ["ENTRADA", "SAIDA", "PERDA"]
      },
      quantity: { type: "number", minimum: 1 },
      storeId: { type: "string", minLength: 1 },
      // Obrigatório, vem do middleware
      productId: { type: "string", minLength: 1 },
      supplierId: { type: "string" },
      batch: { type: "string" },
      expiration: { type: "string", format: "date-time" },
      price: { type: "number", minimum: 0.01 },
      note: { type: "string", maxLength: 500 },
      userId: { type: "string" }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        type: { type: "string" },
        quantity: { type: "number" },
        storeId: { type: "string" },
        productId: { type: "string" },
        supplierId: { type: "string", nullable: true },
        batch: { type: "string", nullable: true },
        expiration: { type: "string", format: "date-time", nullable: true },
        price: { type: "number", nullable: true },
        note: { type: "string", nullable: true },
        userId: { type: "string", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        store: { type: "object" },
        product: { type: "object" },
        supplier: { type: "object", nullable: true },
        user: { type: "object", nullable: true }
      }
    }
  }
};
var updateMovementSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      type: {
        type: "string",
        enum: ["ENTRADA", "SAIDA", "PERDA"]
      },
      quantity: { type: "number", minimum: 1 },
      supplierId: { type: "string" },
      batch: { type: "string" },
      expiration: { type: "string", format: "date-time" },
      price: { type: "number", minimum: 0.01 },
      note: { type: "string", maxLength: 500 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        type: { type: "string" },
        quantity: { type: "number" },
        storeId: { type: "string" },
        productId: { type: "string" },
        supplierId: { type: "string", nullable: true },
        batch: { type: "string", nullable: true },
        expiration: { type: "string", format: "date-time", nullable: true },
        price: { type: "number", nullable: true },
        note: { type: "string", nullable: true },
        userId: { type: "string", nullable: true },
        updatedAt: { type: "string", format: "date-time" },
        store: { type: "object" },
        product: { type: "object" },
        supplier: { type: "object", nullable: true },
        user: { type: "object", nullable: true }
      }
    }
  }
};
var getMovementSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        type: { type: "string" },
        quantity: { type: "number" },
        storeId: { type: "string" },
        productId: { type: "string" },
        supplierId: { type: "string", nullable: true },
        batch: { type: "string", nullable: true },
        expiration: { type: "string", format: "date-time", nullable: true },
        price: { type: "number", nullable: true },
        note: { type: "string", nullable: true },
        userId: { type: "string", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        store: { type: "object" },
        product: { type: "object" },
        supplier: { type: "object", nullable: true },
        user: { type: "object", nullable: true }
      }
    }
  }
};
var listMovementsSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      type: {
        type: "string",
        enum: ["ENTRADA", "SAIDA", "PERDA"]
      },
      storeId: { type: "string" },
      productId: { type: "string" },
      supplierId: { type: "string" },
      startDate: { type: "string", format: "date-time" },
      endDate: { type: "string", format: "date-time" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              type: { type: "string" },
              quantity: { type: "number" },
              storeId: { type: "string" },
              productId: { type: "string" },
              supplierId: { type: "string", nullable: true },
              batch: { type: "string", nullable: true },
              expiration: { type: "string", format: "date-time", nullable: true },
              price: { type: "number", nullable: true },
              note: { type: "string", nullable: true },
              userId: { type: "string", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" },
              store: { type: "object" },
              product: { type: "object" },
              supplier: { type: "object", nullable: true },
              user: { type: "object", nullable: true }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var deleteMovementSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" }
  }
};
var getByStoreSchema = {
  params: {
    type: "object",
    required: ["storeId"],
    properties: {
      storeId: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      type: {
        type: "string",
        enum: ["ENTRADA", "SAIDA", "PERDA"]
      },
      startDate: { type: "string", format: "date-time" },
      endDate: { type: "string", format: "date-time" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        movements: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              type: { type: "string" },
              quantity: { type: "number" },
              storeId: { type: "string" },
              productId: { type: "string" },
              supplierId: { type: "string", nullable: true },
              batch: { type: "string", nullable: true },
              expiration: { type: "string", format: "date-time", nullable: true },
              price: { type: "number", nullable: true },
              note: { type: "string", nullable: true },
              userId: { type: "string", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              store: { type: "object" },
              product: { type: "object" },
              supplier: { type: "object", nullable: true },
              user: { type: "object", nullable: true }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getByProductSchema = {
  params: {
    type: "object",
    required: ["productId"],
    properties: {
      productId: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      type: {
        type: "string",
        enum: ["ENTRADA", "SAIDA", "PERDA"]
      },
      startDate: { type: "string", format: "date-time" },
      endDate: { type: "string", format: "date-time" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        movements: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              type: { type: "string" },
              quantity: { type: "number" },
              storeId: { type: "string" },
              productId: { type: "string" },
              supplierId: { type: "string", nullable: true },
              batch: { type: "string", nullable: true },
              expiration: { type: "string", format: "date-time", nullable: true },
              price: { type: "number", nullable: true },
              note: { type: "string", nullable: true },
              userId: { type: "string", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              store: { type: "object" },
              product: { type: "object" },
              supplier: { type: "object", nullable: true },
              user: { type: "object", nullable: true }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getBySupplierSchema = {
  params: {
    type: "object",
    required: ["supplierId"],
    properties: {
      supplierId: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      type: {
        type: "string",
        enum: ["ENTRADA", "SAIDA", "PERDA"]
      },
      startDate: { type: "string", format: "date-time" },
      endDate: { type: "string", format: "date-time" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        movements: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              type: { type: "string" },
              quantity: { type: "number" },
              storeId: { type: "string" },
              productId: { type: "string" },
              supplierId: { type: "string", nullable: true },
              batch: { type: "string", nullable: true },
              expiration: { type: "string", format: "date-time", nullable: true },
              price: { type: "number", nullable: true },
              note: { type: "string", nullable: true },
              userId: { type: "string", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              store: { type: "object" },
              product: { type: "object" },
              supplier: { type: "object", nullable: true },
              user: { type: "object", nullable: true }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getStockHistorySchema = {
  params: {
    type: "object",
    required: ["productId", "storeId"],
    properties: {
      productId: { type: "string" },
      storeId: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      startDate: { type: "string", format: "date-time" },
      endDate: { type: "string", format: "date-time" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        product: { type: "object" },
        store: { type: "object" },
        currentStock: { type: "number" },
        history: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              type: { type: "string" },
              quantity: { type: "number" },
              batch: { type: "string", nullable: true },
              expiration: { type: "string", format: "date-time", nullable: true },
              price: { type: "number", nullable: true },
              note: { type: "string", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              supplier: { type: "object", nullable: true },
              user: { type: "object", nullable: true }
            }
          }
        },
        summary: {
          type: "object",
          properties: {
            totalEntries: { type: "number" },
            totalExits: { type: "number" },
            totalLosses: { type: "number" },
            netMovement: { type: "number" }
          }
        }
      }
    }
  }
};
var getMovementReportSchema = {
  querystring: {
    type: "object",
    properties: {
      storeId: { type: "string" },
      productId: { type: "string" },
      supplierId: { type: "string" },
      type: {
        type: "string",
        enum: ["ENTRADA", "SAIDA", "PERDA"]
      },
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" },
      groupBy: {
        type: "string",
        enum: ["day", "week", "month", "year"],
        default: "day"
      },
      format: {
        type: "string",
        enum: ["json", "csv", "pdf"],
        default: "json"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        summary: {
          type: "object",
          properties: {
            totalMovements: { type: "number" },
            totalValue: { type: "number" },
            period: {
              type: "object",
              properties: {
                startDate: { type: "string" },
                endDate: { type: "string" }
              }
            }
          }
        },
        data: {
          type: "array",
          items: {
            type: "object",
            properties: {
              date: { type: "string" },
              movements: { type: "number" },
              value: { type: "number" },
              entrada: { type: "number" },
              saida: { type: "number" },
              perda: { type: "number" }
            }
          }
        },
        byType: {
          type: "object",
          properties: {
            ENTRADA: {
              type: "object",
              properties: {
                count: { type: "number" },
                value: { type: "number" },
                quantity: { type: "number" }
              }
            },
            SAIDA: {
              type: "object",
              properties: {
                count: { type: "number" },
                value: { type: "number" },
                quantity: { type: "number" }
              }
            },
            PERDA: {
              type: "object",
              properties: {
                count: { type: "number" },
                value: { type: "number" },
                quantity: { type: "number" }
              }
            }
          }
        },
        byStore: {
          type: "array",
          items: {
            type: "object",
            properties: {
              storeId: { type: "string" },
              storeName: { type: "string" },
              movements: { type: "number" },
              value: { type: "number" }
            }
          }
        },
        byProduct: {
          type: "array",
          items: {
            type: "object",
            properties: {
              productId: { type: "string" },
              productName: { type: "string" },
              movements: { type: "number" },
              quantity: { type: "number" }
            }
          }
        },
        bySupplier: {
          type: "array",
          items: {
            type: "object",
            properties: {
              supplierId: { type: "string" },
              supplierName: { type: "string" },
              movements: { type: "number" },
              value: { type: "number" }
            }
          }
        }
      }
    }
  }
};
var createBulkMovementSchema = {
  body: {
    type: "object",
    required: ["movements"],
    properties: {
      movements: {
        type: "array",
        minItems: 1,
        maxItems: 100,
        items: {
          type: "object",
          required: ["type", "quantity", "storeId", "productId"],
          properties: {
            type: {
              type: "string",
              enum: ["ENTRADA", "SAIDA", "PERDA"]
            },
            quantity: { type: "number", minimum: 1 },
            storeId: { type: "string", minLength: 1 },
            productId: { type: "string", minLength: 1 },
            supplierId: { type: "string" },
            batch: { type: "string" },
            expiration: { type: "string", format: "date" },
            price: { type: "number", minimum: 0 },
            note: { type: "string", maxLength: 500 }
          }
        }
      }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        success: { type: "number" },
        failed: { type: "number" },
        results: {
          type: "array",
          items: {
            type: "object",
            properties: {
              index: { type: "number" },
              success: { type: "boolean" },
              movement: { type: "object", nullable: true },
              error: { type: "string", nullable: true }
            }
          }
        }
      }
    }
  }
};
var verifyMovementSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["verified"],
    properties: {
      verified: { type: "boolean" },
      note: { type: "string", maxLength: 500 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        verified: { type: "boolean" },
        verifiedAt: { type: "string", format: "date-time", nullable: true },
        verifiedBy: { type: "string", nullable: true },
        verificationNote: { type: "string", nullable: true },
        updatedAt: { type: "string", format: "date-time" },
        store: { type: "object" },
        product: { type: "object" },
        supplier: { type: "object", nullable: true },
        user: { type: "object", nullable: true }
      }
    }
  }
};
var cancelMovementSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["reason"],
    properties: {
      reason: { type: "string", minLength: 1, maxLength: 500 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        cancelled: { type: "boolean" },
        cancelledAt: { type: "string", format: "date-time" },
        cancelledBy: { type: "string", nullable: true },
        cancellationReason: { type: "string" },
        updatedAt: { type: "string", format: "date-time" },
        store: { type: "object" },
        product: { type: "object" },
        supplier: { type: "object", nullable: true },
        user: { type: "object", nullable: true }
      }
    }
  }
};
var getVerifiedMovementsSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      storeId: { type: "string" },
      verified: { type: "boolean" },
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              type: { type: "string" },
              quantity: { type: "number" },
              verified: { type: "boolean" },
              verifiedAt: { type: "string", format: "date-time", nullable: true },
              verifiedBy: { type: "string", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              store: { type: "object" },
              product: { type: "object" },
              supplier: { type: "object", nullable: true },
              user: { type: "object", nullable: true }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getCancelledMovementsSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      storeId: { type: "string" },
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              type: { type: "string" },
              quantity: { type: "number" },
              cancelled: { type: "boolean" },
              cancelledAt: { type: "string", format: "date-time" },
              cancelledBy: { type: "string", nullable: true },
              cancellationReason: { type: "string" },
              createdAt: { type: "string", format: "date-time" },
              store: { type: "object" },
              product: { type: "object" },
              supplier: { type: "object", nullable: true },
              user: { type: "object", nullable: true }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getMovementAnalyticsSchema = {
  querystring: {
    type: "object",
    properties: {
      storeId: { type: "string" },
      productId: { type: "string" },
      supplierId: { type: "string" },
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        summary: {
          type: "object",
          properties: {
            totalMovements: { type: "number" },
            totalValue: { type: "number" },
            averageValue: { type: "number" },
            verifiedCount: { type: "number" },
            cancelledCount: { type: "number" },
            verificationRate: { type: "number" },
            cancellationRate: { type: "number" }
          }
        },
        byType: {
          type: "array",
          items: {
            type: "object",
            properties: {
              type: { type: "string" },
              count: { type: "number" },
              quantity: { type: "number" },
              value: { type: "number" }
            }
          }
        },
        byMonth: {
          type: "array",
          items: {
            type: "object",
            properties: {
              month: { type: "string" },
              count: { type: "number" },
              value: { type: "number" }
            }
          }
        },
        byStore: {
          type: "array",
          items: {
            type: "object",
            properties: {
              storeId: { type: "string" },
              storeName: { type: "string" },
              count: { type: "number" },
              value: { type: "number" }
            }
          }
        },
        byProduct: {
          type: "array",
          items: {
            type: "object",
            properties: {
              productId: { type: "string" },
              productName: { type: "string" },
              count: { type: "number" },
              quantity: { type: "number" },
              value: { type: "number" }
            }
          }
        },
        bySupplier: {
          type: "array",
          items: {
            type: "object",
            properties: {
              supplierId: { type: "string" },
              supplierName: { type: "string" },
              count: { type: "number" },
              value: { type: "number" }
            }
          }
        }
      }
    }
  }
};
var MovementSchemas = {
  create: createMovementSchema,
  update: updateMovementSchema,
  get: getMovementSchema,
  delete: deleteMovementSchema,
  list: listMovementsSchema,
  getByStore: getByStoreSchema,
  getByProduct: getByProductSchema,
  getBySupplier: getBySupplierSchema,
  getStockHistory: getStockHistorySchema,
  // Funções adicionais
  getReport: getMovementReportSchema,
  createBulk: createBulkMovementSchema,
  verify: verifyMovementSchema,
  cancel: cancelMovementSchema,
  getVerifiedMovements: getVerifiedMovementsSchema,
  getCancelledMovements: getCancelledMovementsSchema,
  getAnalytics: getMovementAnalyticsSchema
};

// src/features/movement/movement.routes.ts
async function MovementRoutes(fastify2) {
  fastify2.addHook("preHandler", authMiddleware);
  fastify2.addHook("preHandler", storeContextMiddleware);
  fastify2.post("/", {
    schema: MovementSchemas.create,
    handler: MovementController.create
  });
  fastify2.get("/", {
    schema: MovementSchemas.list,
    handler: MovementController.list
  });
  fastify2.get("/my-store", {
    schema: {
      querystring: {
        type: "object",
        properties: {
          page: { type: "number", minimum: 1 },
          limit: { type: "number", minimum: 1, maximum: 100 },
          search: { type: "string" },
          type: { type: "string", enum: ["ENTRADA", "SAIDA", "PERDA"] },
          productId: { type: "string" },
          supplierId: { type: "string" },
          startDate: { type: "string", format: "date-time" },
          endDate: { type: "string", format: "date-time" }
        }
      }
    },
    handler: MovementController.listByStore
  });
  fastify2.get("/my-store/product/:productId", {
    schema: {
      params: {
        type: "object",
        required: ["productId"],
        properties: {
          productId: { type: "string", minLength: 1 }
        }
      },
      querystring: {
        type: "object",
        properties: {
          page: { type: "number", minimum: 1 },
          limit: { type: "number", minimum: 1, maximum: 100 },
          type: { type: "string", enum: ["ENTRADA", "SAIDA", "PERDA"] },
          startDate: { type: "string", format: "date-time" },
          endDate: { type: "string", format: "date-time" }
        }
      }
    },
    handler: MovementController.listByProduct
  });
  fastify2.get("/:id", {
    schema: MovementSchemas.get,
    handler: MovementController.get
  });
  fastify2.put("/:id", {
    schema: MovementSchemas.update,
    handler: MovementController.update
  });
  fastify2.delete("/:id", {
    schema: MovementSchemas.delete,
    handler: MovementController.delete
  });
  fastify2.get("/store/:storeId", {
    schema: MovementSchemas.getByStore,
    handler: MovementController.getByStore
  });
  fastify2.get("/product/:productId", {
    schema: MovementSchemas.getByProduct,
    handler: MovementController.getByProduct
  });
  fastify2.get("/product/:productId/summary", {
    handler: MovementController.summarizeProduct
  });
  fastify2.get("/supplier/:supplierId", {
    schema: MovementSchemas.getBySupplier,
    handler: MovementController.getBySupplier
  });
  fastify2.get("/stock-history/:productId/:storeId", {
    schema: MovementSchemas.getStockHistory,
    handler: MovementController.getStockHistory
  });
  fastify2.get("/current-stock/:productId/:storeId", {
    handler: MovementController.getCurrentStock
  });
  fastify2.get("/stats", {
    handler: MovementController.getStats
  });
  fastify2.get("/search", {
    handler: MovementController.search
  });
  fastify2.get("/low-stock", {
    handler: MovementController.getLowStockProducts
  });
  fastify2.post("/recalculate-stock/:productId/:storeId", {
    handler: MovementController.recalculateStock
  });
  fastify2.get("/summarize", {
    handler: MovementController.summarize
  });
  fastify2.get("/stock-alerts", {
    schema: {
      querystring: {
        type: "object",
        properties: {
          storeId: { type: "string" }
        }
      }
    },
    handler: MovementController.checkStockAlerts
  });
  fastify2.post("/stock-alerts/summary", {
    schema: {
      querystring: {
        type: "object",
        properties: {
          storeId: { type: "string" }
        }
      }
    },
    handler: MovementController.createLowStockSummaryNotification
  });
}

// src/features/permission/commands/permission.commands.ts
var createUserPermission = async (prisma2, data) => {
  return await prisma2.userPermission.create({
    data: {
      userId: data.userId,
      action: data.action,
      resource: data.resource,
      storeId: data.storeId,
      grant: data.grant,
      conditions: data.conditions ? JSON.stringify(data.conditions) : null,
      expiresAt: data.expiresAt ? new Date(data.expiresAt) : null,
      reason: data.reason,
      createdBy: data.createdBy
    }
  });
};
var updateUserPermission = async (prisma2, id, data) => {
  return await prisma2.userPermission.update({
    where: { id },
    data: {
      ...data,
      conditions: data.conditions ? JSON.stringify(data.conditions) : void 0,
      expiresAt: data.expiresAt ? new Date(data.expiresAt) : void 0
    }
  });
};
var deleteUserPermission = async (prisma2, id) => {
  return await prisma2.userPermission.delete({
    where: { id }
  });
};
var setStoreUserPermissions = async (prisma2, data) => {
  return await prisma2.storePermission.upsert({
    where: {
      userId_storeId: {
        userId: data.userId,
        storeId: data.storeId
      }
    },
    update: {
      storeRole: data.storeRole,
      permissions: JSON.stringify(data.permissions),
      conditions: data.conditions ? JSON.stringify(data.conditions) : null,
      expiresAt: data.expiresAt ? new Date(data.expiresAt) : null,
      createdBy: data.createdBy
    },
    create: {
      userId: data.userId,
      storeId: data.storeId,
      storeRole: data.storeRole,
      permissions: JSON.stringify(data.permissions),
      conditions: data.conditions ? JSON.stringify(data.conditions) : null,
      expiresAt: data.expiresAt ? new Date(data.expiresAt) : null,
      createdBy: data.createdBy
    }
  });
};

// src/features/permission/queries/permission.queries.ts
var getUserPermissions = async (prisma2, filters) => {
  const { userId, storeId, action, active, page = 1, limit = 10 } = filters;
  const where = { userId };
  if (storeId) where.storeId = storeId;
  if (action) where.action = action;
  if (active !== void 0) {
    if (active) {
      where.OR = [
        { expiresAt: null },
        { expiresAt: { gt: /* @__PURE__ */ new Date() } }
      ];
    } else {
      where.expiresAt = { lte: /* @__PURE__ */ new Date() };
    }
  }
  const [permissions, total] = await Promise.all([
    prisma2.userPermission.findMany({
      where,
      skip: (page - 1) * limit,
      take: limit,
      orderBy: { createdAt: "desc" },
      include: {
        user: {
          select: { id: true, name: true, email: true }
        },
        creator: {
          select: { id: true, name: true, email: true }
        }
      }
    }),
    prisma2.userPermission.count({ where })
  ]);
  return {
    permissions: permissions.map((p) => ({
      ...p,
      conditions: p.conditions ? JSON.parse(p.conditions) : null
    })),
    pagination: {
      page,
      limit,
      total,
      pages: Math.ceil(total / limit)
    }
  };
};
var getStoreUserPermissions = async (prisma2, filters) => {
  const { storeId, page = 1, limit = 10 } = filters;
  const [permissions, total] = await Promise.all([
    prisma2.storePermission.findMany({
      where: { storeId },
      skip: (page - 1) * limit,
      take: limit,
      orderBy: { createdAt: "desc" },
      include: {
        user: {
          select: { id: true, name: true, email: true }
        },
        store: {
          select: { id: true, name: true }
        },
        creator: {
          select: { id: true, name: true, email: true }
        }
      }
    }),
    prisma2.storePermission.count({ where: { storeId } })
  ]);
  return {
    permissions: permissions.map((p) => ({
      ...p,
      permissions: JSON.parse(p.permissions),
      conditions: p.conditions ? JSON.parse(p.conditions) : null
    })),
    pagination: {
      page,
      limit,
      total,
      pages: Math.ceil(total / limit)
    }
  };
};
var getUserEffectivePermissions = async (prisma2, context) => {
  const { userId, storeId } = context;
  const user = await prisma2.user.findUnique({
    where: { id: userId },
    select: { id: true, roles: true }
  });
  if (!user) {
    throw new Error("User not found");
  }
  const customPermissions = await prisma2.userPermission.findMany({
    where: {
      userId,
      ...storeId ? { storeId } : {}
    }
  });
  let storePermissions = [];
  if (storeId) {
    storePermissions = await prisma2.storePermission.findMany({
      where: { userId, storeId }
    });
  }
  const permissionContext = {
    userId,
    userRoles: user.roles,
    storeId,
    storeRole: storePermissions[0]?.storeRole,
    customPermissions: customPermissions.map((p) => ({
      ...p,
      conditions: p.conditions ? JSON.parse(p.conditions) : null
    })),
    storePermissions: storePermissions.map((p) => ({
      ...p,
      permissions: JSON.parse(p.permissions),
      conditions: p.conditions ? JSON.parse(p.conditions) : null
    }))
  };
  const effectivePermissions = await GranularPermissionService.getUserEffectivePermissions(permissionContext);
  return {
    userId,
    userRoles: user.roles,
    storeId,
    effectivePermissions,
    customPermissions: permissionContext.customPermissions,
    storePermissions: permissionContext.storePermissions
  };
};
var testPermission = async (prisma2, context) => {
  const { userId, action, resource, storeId, testContext } = context;
  const user = await prisma2.user.findUnique({
    where: { id: userId },
    select: { id: true, roles: true }
  });
  if (!user) {
    throw new Error("User not found");
  }
  const customPermissions = await prisma2.userPermission.findMany({
    where: { userId }
  });
  let storePermissions = [];
  if (storeId) {
    storePermissions = await prisma2.storePermission.findMany({
      where: { userId, storeId }
    });
  }
  const permissionContext = {
    userId,
    userRoles: user.roles,
    storeId,
    storeRole: storePermissions[0]?.storeRole,
    customPermissions: customPermissions.map((p) => ({
      ...p,
      conditions: p.conditions ? JSON.parse(p.conditions) : null
    })),
    storePermissions: storePermissions.map((p) => ({
      ...p,
      permissions: JSON.parse(p.permissions),
      conditions: p.conditions ? JSON.parse(p.conditions) : null
    })),
    requestTime: /* @__PURE__ */ new Date(),
    requestData: testContext || {}
  };
  const result = await GranularPermissionService.hasPermission(permissionContext, action, resource);
  return {
    userId,
    action,
    resource,
    storeId,
    result,
    context: permissionContext
  };
};
var getPermissionStats = async (prisma2) => {
  const [
    totalUserPermissions,
    activeUserPermissions,
    expiredUserPermissions,
    totalStorePermissions,
    permissionsByAction,
    permissionsByRole
  ] = await Promise.all([
    prisma2.userPermission.count(),
    prisma2.userPermission.count({
      where: {
        OR: [
          { expiresAt: null },
          { expiresAt: { gt: /* @__PURE__ */ new Date() } }
        ]
      }
    }),
    prisma2.userPermission.count({
      where: {
        expiresAt: { lte: /* @__PURE__ */ new Date() }
      }
    }),
    prisma2.storePermission.count(),
    prisma2.userPermission.groupBy({
      by: ["action"],
      _count: { action: true }
    }),
    prisma2.storePermission.groupBy({
      by: ["storeRole"],
      _count: { storeRole: true }
    })
  ]);
  return {
    userPermissions: {
      total: totalUserPermissions,
      active: activeUserPermissions,
      expired: expiredUserPermissions
    },
    storePermissions: {
      total: totalStorePermissions
    },
    permissionsByAction: permissionsByAction.map((p) => ({
      action: p.action,
      count: p._count.action
    })),
    permissionsByRole: permissionsByRole.map((p) => ({
      role: p.storeRole,
      count: p._count.storeRole
    }))
  };
};

// src/features/permission/permission.controller.ts
var PermissionController = {
  // ================================
  // GESTÃO DE PERMISSÕES CUSTOMIZADAS
  // ================================
  // Criar permissão customizada para usuário
  async createUserPermission(request, reply) {
    try {
      const { userId, action, resource, storeId, grant, conditions, expiresAt, reason } = request.body;
      const prisma2 = request.server.prisma;
      if (!request.user?.roles.includes("super_admin" /* SUPER_ADMIN */) && !request.user?.roles.includes("admin" /* ADMIN */)) {
        return reply.status(403).send({
          error: "Insufficient permissions to create user permissions"
        });
      }
      const userPermission = await createUserPermission(prisma2, {
        userId,
        action,
        resource,
        storeId,
        grant,
        conditions,
        expiresAt,
        reason,
        createdBy: request.user.id
      });
      return reply.status(201).send({
        message: "User permission created successfully",
        permission: userPermission
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // Listar permissões customizadas de um usuário
  async getUserPermissions(request, reply) {
    try {
      const { userId } = request.params;
      const { storeId, action, active, page = 1, limit = 10 } = request.query;
      const prisma2 = request.server.prisma;
      if (!request.user?.roles.includes("super_admin" /* SUPER_ADMIN */) && !request.user?.roles.includes("admin" /* ADMIN */) && request.user?.id !== userId) {
        return reply.status(403).send({
          error: "Insufficient permissions to view user permissions"
        });
      }
      const result = await getUserPermissions(prisma2, {
        userId,
        storeId,
        action,
        active,
        page,
        limit
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // Atualizar permissão customizada
  async updateUserPermission(request, reply) {
    try {
      const { id } = request.params;
      const updateData = request.body;
      const prisma2 = request.server.prisma;
      if (!request.user?.roles.includes("super_admin" /* SUPER_ADMIN */) && !request.user?.roles.includes("admin" /* ADMIN */)) {
        return reply.status(403).send({
          error: "Insufficient permissions to update user permissions"
        });
      }
      const permission = await updateUserPermission(prisma2, id, updateData);
      return reply.send({
        message: "User permission updated successfully",
        permission: {
          ...permission,
          conditions: permission.conditions ? JSON.parse(permission.conditions) : null
        }
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // Deletar permissão customizada
  async deleteUserPermission(request, reply) {
    try {
      const { id } = request.params;
      const prisma2 = request.server.prisma;
      if (!request.user?.roles.includes("super_admin" /* SUPER_ADMIN */) && !request.user?.roles.includes("admin" /* ADMIN */)) {
        return reply.status(403).send({
          error: "Insufficient permissions to delete user permissions"
        });
      }
      await deleteUserPermission(prisma2, id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // ================================
  // GESTÃO DE PERMISSÕES POR LOJA
  // ================================
  // Definir permissões de usuário em uma loja
  async setStoreUserPermissions(request, reply) {
    try {
      const { userId, storeId, storeRole, permissions, conditions, expiresAt } = request.body;
      const prisma2 = request.server.prisma;
      if (!request.user?.roles.includes("super_admin" /* SUPER_ADMIN */) && !request.user?.roles.includes("admin" /* ADMIN */) && !request.storeRole?.includes("OWNER" /* OWNER */) && !request.storeRole?.includes("ADMIN" /* ADMIN */)) {
        return reply.status(403).send({
          error: "Insufficient permissions to manage store user permissions"
        });
      }
      if (request.store?.id !== storeId) {
        return reply.status(403).send({
          error: "Access denied to this store"
        });
      }
      const storePermission = await setStoreUserPermissions(prisma2, {
        userId,
        storeId,
        storeRole,
        permissions,
        conditions,
        expiresAt,
        createdBy: request.user.id
      });
      return reply.send({
        message: "Store user permissions set successfully",
        permission: {
          ...storePermission,
          permissions: JSON.parse(storePermission.permissions),
          conditions: storePermission.conditions ? JSON.parse(storePermission.conditions) : null
        }
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // Listar permissões de usuários em uma loja
  async getStoreUserPermissions(request, reply) {
    try {
      const { storeId } = request.params;
      const { page = 1, limit = 10 } = request.query;
      const prisma2 = request.server.prisma;
      if (!request.user?.roles.includes("super_admin" /* SUPER_ADMIN */) && !request.user?.roles.includes("admin" /* ADMIN */) && !request.storeRole?.includes("OWNER" /* OWNER */) && !request.storeRole?.includes("ADMIN" /* ADMIN */)) {
        return reply.status(403).send({
          error: "Insufficient permissions to view store user permissions"
        });
      }
      if (request.store?.id !== storeId) {
        return reply.status(403).send({
          error: "Access denied to this store"
        });
      }
      const result = await getStoreUserPermissions(prisma2, {
        storeId,
        page,
        limit
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // ================================
  // CONSULTAS E RELATÓRIOS
  // ================================
  // Obter permissões efetivas de um usuário
  async getUserEffectivePermissions(request, reply) {
    try {
      const { userId } = request.params;
      const { storeId } = request.query;
      if (!request.user?.roles.includes("super_admin" /* SUPER_ADMIN */) && !request.user?.roles.includes("admin" /* ADMIN */) && request.user?.id !== userId) {
        return reply.status(403).send({
          error: "Insufficient permissions to view user permissions"
        });
      }
      const prisma2 = request.server.prisma;
      const result = await getUserEffectivePermissions(prisma2, {
        userId,
        storeId
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // Testar permissão específica
  async testPermission(request, reply) {
    try {
      const { userId, action, resource, storeId, context: testContext } = request.body;
      if (!request.user?.roles.includes("super_admin" /* SUPER_ADMIN */) && !request.user?.roles.includes("admin" /* ADMIN */)) {
        return reply.status(403).send({
          error: "Insufficient permissions to test permissions"
        });
      }
      const prisma2 = request.server.prisma;
      const result = await testPermission(prisma2, {
        userId,
        action,
        resource,
        storeId,
        testContext
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // Obter estatísticas de permissões
  async getPermissionStats(request, reply) {
    try {
      const prisma2 = request.server.prisma;
      if (!request.user?.roles.includes("super_admin" /* SUPER_ADMIN */) && !request.user?.roles.includes("admin" /* ADMIN */)) {
        return reply.status(403).send({
          error: "Insufficient permissions to view permission statistics"
        });
      }
      const result = await getPermissionStats(prisma2);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/permission/permission.schema.ts
var PermissionSchemas = {
  // Criar permissão customizada
  createUserPermission: {
    body: {
      type: "object",
      required: ["userId", "action", "grant"],
      properties: {
        userId: { type: "string", minLength: 1 },
        action: { type: "string", enum: Object.values(Action) },
        resource: { type: "string", maxLength: 100 },
        storeId: { type: "string", minLength: 1 },
        grant: { type: "boolean" },
        conditions: {
          type: "object",
          properties: {
            timeRange: { type: "string", pattern: "^\\d{1,2}-\\d{1,2}$" },
            dayOfWeek: { type: "string", pattern: "^\\d-\\d$" },
            dateRange: {
              type: "object",
              properties: {
                start: { type: "string", format: "date" },
                end: { type: "string", format: "date" }
              },
              required: ["start", "end"]
            },
            amountLimit: { type: "number", minimum: 0 },
            custom: { type: "string", maxLength: 500 },
            ipWhitelist: {
              type: "array",
              items: { type: "string", format: "ipv4" }
            },
            userAgent: { type: "string", maxLength: 200 }
          }
        },
        expiresAt: { type: "string", format: "date-time" },
        reason: { type: "string", maxLength: 500 }
      }
    }
  },
  // Listar permissões de usuário
  getUserPermissions: {
    params: {
      type: "object",
      required: ["userId"],
      properties: {
        userId: { type: "string", minLength: 1 }
      }
    },
    querystring: {
      type: "object",
      properties: {
        storeId: { type: "string", minLength: 1 },
        action: { type: "string", enum: Object.values(Action) },
        active: { type: "boolean" },
        page: { type: "integer", minimum: 1, default: 1 },
        limit: { type: "integer", minimum: 1, maximum: 100, default: 10 }
      }
    }
  },
  // Atualizar permissão customizada
  updateUserPermission: {
    params: {
      type: "object",
      required: ["id"],
      properties: {
        id: { type: "string", minLength: 1 }
      }
    },
    body: {
      type: "object",
      properties: {
        action: { type: "string", enum: Object.values(Action) },
        resource: { type: "string", maxLength: 100 },
        storeId: { type: "string", minLength: 1 },
        grant: { type: "boolean" },
        conditions: {
          type: "object",
          properties: {
            timeRange: { type: "string", pattern: "^\\d{1,2}-\\d{1,2}$" },
            dayOfWeek: { type: "string", pattern: "^\\d-\\d$" },
            dateRange: {
              type: "object",
              properties: {
                start: { type: "string", format: "date" },
                end: { type: "string", format: "date" }
              },
              required: ["start", "end"]
            },
            amountLimit: { type: "number", minimum: 0 },
            custom: { type: "string", maxLength: 500 },
            ipWhitelist: {
              type: "array",
              items: { type: "string", format: "ipv4" }
            },
            userAgent: { type: "string", maxLength: 200 }
          }
        },
        expiresAt: { type: "string", format: "date-time" },
        reason: { type: "string", maxLength: 500 }
      }
    }
  },
  // Deletar permissão customizada
  deleteUserPermission: {
    params: {
      type: "object",
      required: ["id"],
      properties: {
        id: { type: "string", minLength: 1 }
      }
    }
  },
  // ================================
  // SCHEMAS PARA PERMISSÕES DE LOJA
  // ================================
  // Definir permissões de usuário em loja
  setStoreUserPermissions: {
    body: {
      type: "object",
      required: ["userId", "storeId", "storeRole", "permissions"],
      properties: {
        userId: { type: "string", minLength: 1 },
        storeId: { type: "string", minLength: 1 },
        storeRole: { type: "string", enum: Object.values(StoreRole) },
        permissions: {
          type: "array",
          items: { type: "string", enum: Object.values(Action) },
          minItems: 1
        },
        conditions: {
          type: "object",
          properties: {
            timeRange: { type: "string", pattern: "^\\d{1,2}-\\d{1,2}$" },
            dayOfWeek: { type: "string", pattern: "^\\d-\\d$" },
            dateRange: {
              type: "object",
              properties: {
                start: { type: "string", format: "date" },
                end: { type: "string", format: "date" }
              },
              required: ["start", "end"]
            },
            amountLimit: { type: "number", minimum: 0 },
            custom: { type: "string", maxLength: 500 },
            ipWhitelist: {
              type: "array",
              items: { type: "string", format: "ipv4" }
            },
            userAgent: { type: "string", maxLength: 200 }
          }
        },
        expiresAt: { type: "string", format: "date-time" }
      }
    }
  },
  // Listar permissões de loja
  getStoreUserPermissions: {
    params: {
      type: "object",
      required: ["storeId"],
      properties: {
        storeId: { type: "string", minLength: 1 }
      }
    },
    querystring: {
      type: "object",
      properties: {
        page: { type: "integer", minimum: 1, default: 1 },
        limit: { type: "integer", minimum: 1, maximum: 100, default: 10 }
      }
    }
  },
  // ================================
  // SCHEMAS PARA CONSULTAS
  // ================================
  // Obter permissões efetivas
  getUserEffectivePermissions: {
    params: {
      type: "object",
      required: ["userId"],
      properties: {
        userId: { type: "string", minLength: 1 }
      }
    },
    querystring: {
      type: "object",
      properties: {
        storeId: { type: "string", minLength: 1 }
      }
    }
  },
  // Testar permissão
  testPermission: {
    body: {
      type: "object",
      required: ["userId", "action"],
      properties: {
        userId: { type: "string", minLength: 1 },
        action: { type: "string", enum: Object.values(Action) },
        resource: { type: "string", maxLength: 100 },
        storeId: { type: "string", minLength: 1 },
        context: { type: "object" }
      }
    }
  },
  // Obter estatísticas
  getPermissionStats: {
    querystring: {
      type: "object",
      properties: {
        storeId: { type: "string", minLength: 1 },
        dateFrom: { type: "string", format: "date" },
        dateTo: { type: "string", format: "date" }
      }
    }
  },
  // ================================
  // SCHEMAS PARA BULK OPERATIONS
  // ================================
  // Criar múltiplas permissões
  bulkCreateUserPermissions: {
    body: {
      type: "object",
      required: ["permissions"],
      properties: {
        permissions: {
          type: "array",
          items: {
            type: "object",
            required: ["userId", "action", "grant"],
            properties: {
              userId: { type: "string", minLength: 1 },
              action: { type: "string", enum: Object.values(Action) },
              resource: { type: "string", maxLength: 100 },
              storeId: { type: "string", minLength: 1 },
              grant: { type: "boolean" },
              conditions: {
                type: "object",
                properties: {
                  timeRange: { type: "string", pattern: "^\\d{1,2}-\\d{1,2}$" },
                  dayOfWeek: { type: "string", pattern: "^\\d-\\d$" },
                  dateRange: {
                    type: "object",
                    properties: {
                      start: { type: "string", format: "date" },
                      end: { type: "string", format: "date" }
                    },
                    required: ["start", "end"]
                  },
                  amountLimit: { type: "number", minimum: 0 },
                  custom: { type: "string", maxLength: 500 },
                  ipWhitelist: {
                    type: "array",
                    items: { type: "string", format: "ipv4" }
                  },
                  userAgent: { type: "string", maxLength: 200 }
                }
              },
              expiresAt: { type: "string", format: "date-time" },
              reason: { type: "string", maxLength: 500 }
            }
          },
          minItems: 1,
          maxItems: 100
        }
      }
    }
  },
  // Atualizar múltiplas permissões
  bulkUpdateUserPermissions: {
    body: {
      type: "object",
      required: ["updates"],
      properties: {
        updates: {
          type: "array",
          items: {
            type: "object",
            required: ["id"],
            properties: {
              id: { type: "string", minLength: 1 },
              action: { type: "string", enum: Object.values(Action) },
              resource: { type: "string", maxLength: 100 },
              storeId: { type: "string", minLength: 1 },
              grant: { type: "boolean" },
              conditions: {
                type: "object",
                properties: {
                  timeRange: { type: "string", pattern: "^\\d{1,2}-\\d{1,2}$" },
                  dayOfWeek: { type: "string", pattern: "^\\d-\\d$" },
                  dateRange: {
                    type: "object",
                    properties: {
                      start: { type: "string", format: "date" },
                      end: { type: "string", format: "date" }
                    },
                    required: ["start", "end"]
                  },
                  amountLimit: { type: "number", minimum: 0 },
                  custom: { type: "string", maxLength: 500 },
                  ipWhitelist: {
                    type: "array",
                    items: { type: "string", format: "ipv4" }
                  },
                  userAgent: { type: "string", maxLength: 200 }
                }
              },
              expiresAt: { type: "string", format: "date-time" },
              reason: { type: "string", maxLength: 500 }
            }
          },
          minItems: 1,
          maxItems: 100
        }
      }
    }
  },
  // Deletar múltiplas permissões
  bulkDeleteUserPermissions: {
    body: {
      type: "object",
      required: ["ids"],
      properties: {
        ids: {
          type: "array",
          items: { type: "string", minLength: 1 },
          minItems: 1,
          maxItems: 100
        }
      }
    }
  },
  // ================================
  // SCHEMAS PARA TEMPLATES
  // ================================
  // Criar template de permissão
  createPermissionTemplate: {
    body: {
      type: "object",
      required: ["name", "description", "permissions"],
      properties: {
        name: { type: "string", minLength: 3, maxLength: 100 },
        description: { type: "string", maxLength: 500 },
        permissions: {
          type: "array",
          items: { type: "string", enum: Object.values(Action) },
          minItems: 1
        },
        conditions: {
          type: "object",
          properties: {
            timeRange: { type: "string", pattern: "^\\d{1,2}-\\d{1,2}$" },
            dayOfWeek: { type: "string", pattern: "^\\d-\\d$" },
            dateRange: {
              type: "object",
              properties: {
                start: { type: "string", format: "date" },
                end: { type: "string", format: "date" }
              },
              required: ["start", "end"]
            },
            amountLimit: { type: "number", minimum: 0 },
            custom: { type: "string", maxLength: 500 },
            ipWhitelist: {
              type: "array",
              items: { type: "string", format: "ipv4" }
            },
            userAgent: { type: "string", maxLength: 200 }
          }
        }
      }
    }
  },
  // Aplicar template de permissão
  applyPermissionTemplate: {
    body: {
      type: "object",
      required: ["userId", "templateId"],
      properties: {
        userId: { type: "string", minLength: 1 },
        templateId: { type: "string", minLength: 1 },
        storeId: { type: "string", minLength: 1 },
        expiresAt: { type: "string", format: "date-time" }
      }
    }
  },
  // ================================
  // SCHEMAS PARA AUDITORIA
  // ================================
  // Obter log de auditoria
  getPermissionAuditLog: {
    params: {
      type: "object",
      required: ["permissionId"],
      properties: {
        permissionId: { type: "string", minLength: 1 }
      }
    },
    querystring: {
      type: "object",
      properties: {
        page: { type: "integer", minimum: 1, default: 1 },
        limit: { type: "integer", minimum: 1, maximum: 100, default: 10 },
        action: { type: "string", enum: ["created", "updated", "deleted", "expired"] },
        dateFrom: { type: "string", format: "date" },
        dateTo: { type: "string", format: "date" }
      }
    }
  }
};

// src/features/permission/permission.routes.ts
async function PermissionRoutes(fastify2) {
  fastify2.post("/user", {
    schema: PermissionSchemas.createUserPermission,
    preHandler: [
      authMiddleware,
      requirePermission("create_user" /* CREATE_USER */)
    ],
    handler: PermissionController.createUserPermission
  });
  fastify2.get("/user/:userId", {
    schema: PermissionSchemas.getUserPermissions,
    preHandler: [
      authMiddleware,
      requirePermission("read_user" /* READ_USER */)
    ],
    handler: PermissionController.getUserPermissions
  });
  fastify2.put("/user/:id", {
    schema: PermissionSchemas.updateUserPermission,
    preHandler: [
      authMiddleware,
      requirePermission("update_user" /* UPDATE_USER */)
    ],
    handler: PermissionController.updateUserPermission
  });
  fastify2.delete("/user/:id", {
    schema: PermissionSchemas.deleteUserPermission,
    preHandler: [
      authMiddleware,
      requirePermission("delete_user" /* DELETE_USER */)
    ],
    handler: PermissionController.deleteUserPermission
  });
  fastify2.post("/store", {
    schema: PermissionSchemas.setStoreUserPermissions,
    preHandler: [
      authMiddleware,
      requirePermission("manage_store_users" /* MANAGE_STORE_USERS */)
    ],
    handler: PermissionController.setStoreUserPermissions
  });
  fastify2.get("/store/:storeId", {
    schema: PermissionSchemas.getStoreUserPermissions,
    preHandler: [
      authMiddleware,
      requirePermission("read_store" /* READ_STORE */)
    ],
    handler: PermissionController.getStoreUserPermissions
  });
  fastify2.get("/effective/:userId", {
    schema: PermissionSchemas.getUserEffectivePermissions,
    preHandler: [
      authMiddleware,
      requirePermission("read_user" /* READ_USER */)
    ],
    handler: PermissionController.getUserEffectivePermissions
  });
  fastify2.post("/test", {
    schema: PermissionSchemas.testPermission,
    preHandler: [
      authMiddleware,
      requirePermission("read_user" /* READ_USER */)
    ],
    handler: PermissionController.testPermission
  });
  fastify2.get("/stats", {
    schema: PermissionSchemas.getPermissionStats,
    preHandler: [
      authMiddleware,
      requirePermission("view_audit_logs" /* VIEW_AUDIT_LOGS */)
    ],
    handler: PermissionController.getPermissionStats
  });
}

// src/features/report/queries/report.queries.ts
init_prisma();
var ReportQueries = {
  // ================================
  // DASHBOARD STATS
  // ================================
  async getDashboardStats(filters) {
    const { storeId, startDate, endDate } = filters;
    const dateFilter = ReportQueries.buildDateFilter(startDate, endDate);
    const [
      totalProducts,
      totalCategories,
      totalSuppliers,
      totalStores,
      totalUsers
    ] = await Promise.all([
      db.product.count({
        where: storeId ? { storeId } : {}
      }),
      db.category.count(),
      db.supplier.count(),
      db.store.count(),
      db.user.count()
    ]);
    const inventoryStats = await ReportQueries.getInventoryStats(storeId);
    const movementStats = await ReportQueries.getMovementStats(storeId, dateFilter);
    const recentActivity = await ReportQueries.getRecentActivity(storeId, dateFilter);
    const charts = await ReportQueries.getChartData(storeId, dateFilter);
    return {
      overview: {
        totalProducts,
        totalCategories,
        totalSuppliers,
        totalStores,
        totalUsers
      },
      inventory: inventoryStats,
      movements: movementStats,
      recentActivity,
      charts
    };
  },
  // ================================
  // INVENTORY REPORT
  // ================================
  async getInventoryReport(filters, pagination, sort) {
    const { storeId, categoryId, supplierId, status, lowStock } = filters;
    const { page, limit } = pagination;
    const { field, order } = sort;
    const where = {};
    if (storeId) where.storeId = storeId;
    if (categoryId) where.categoryId = categoryId;
    if (supplierId) where.supplierId = supplierId;
    if (status && status !== "all") where.status = status === "active";
    if (lowStock) {
      where.AND = [
        { stockMin: { gt: 0 } },
        {
          OR: [
            { stockMin: { gt: 0 } },
            { currentStock: { lte: 0 } }
          ]
        }
      ];
    }
    const orderBy = {};
    switch (field) {
      case "name":
        orderBy.name = order;
        break;
      case "stock":
        orderBy.currentStock = order;
        break;
      case "value":
        orderBy.totalValue = order;
        break;
      case "category":
        orderBy.category = { name: order };
        break;
      default:
        orderBy.name = "asc";
    }
    const [products, total] = await Promise.all([
      db.product.findMany({
        where,
        orderBy,
        skip: (page - 1) * limit,
        take: limit,
        include: {
          categories: {
            select: {
              category: {
                select: { id: true, name: true }
              }
            }
          },
          supplier: {
            select: { id: true, corporateName: true }
          },
          movements: {
            orderBy: { createdAt: "desc" },
            take: 1,
            select: { createdAt: true }
          }
        }
      }),
      db.product.count({ where })
    ]);
    const productsWithStats = products.map((product) => {
      const currentStock = ReportQueries.calculateCurrentStock(product.movements || []);
      const totalValue = Number(product.referencePrice) * currentStock;
      let alertLevel = "normal";
      if (currentStock <= 0) alertLevel = "out";
      else if (currentStock <= product.stockMin) alertLevel = "low";
      else if (currentStock >= product.stockMax) alertLevel = "high";
      return {
        id: product.id,
        name: product.name,
        description: product.description,
        category: product.categories[0]?.category,
        supplier: product.supplier,
        currentStock,
        stockMin: product.stockMin,
        stockMax: product.stockMax,
        unitPrice: Number(product.referencePrice),
        totalValue,
        status: product.status,
        alertLevel,
        lastMovement: product.movements?.[0]?.createdAt?.toISOString()
      };
    });
    const summary = await ReportQueries.calculateInventorySummary(where);
    return {
      products: productsWithStats,
      summary,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  // ================================
  // MOVEMENT REPORT
  // ================================
  async getMovementReport(filters, pagination) {
    const { storeId, productId, supplierId, type, startDate, endDate } = filters;
    const { page, limit } = pagination;
    const where = {};
    if (storeId) where.storeId = storeId;
    if (productId) where.productId = productId;
    if (supplierId) where.supplierId = supplierId;
    if (type) where.type = type;
    if (startDate || endDate) {
      where.createdAt = ReportQueries.buildDateFilter(startDate, endDate);
    }
    const [movements, total] = await Promise.all([
      db.movement.findMany({
        where,
        orderBy: { createdAt: "desc" },
        skip: (page - 1) * limit,
        take: limit,
        include: {
          product: {
            select: { id: true, name: true, unitOfMeasure: true }
          },
          supplier: {
            select: { id: true, corporateName: true }
          },
          user: {
            select: { id: true, name: true }
          }
        }
      }),
      db.movement.count({ where })
    ]);
    const summary = await ReportQueries.calculateMovementSummary(where);
    return {
      movements: movements.map((movement) => ({
        id: movement.id,
        type: movement.type,
        quantity: movement.quantity,
        price: movement.price ? Number(movement.price) : void 0,
        totalValue: movement.price ? Number(movement.price) * movement.quantity : void 0,
        batch: movement.batch,
        expiration: movement.expiration?.toISOString(),
        note: movement.note,
        balanceAfter: movement.balanceAfter,
        product: movement.product,
        supplier: movement.supplier,
        user: movement.user,
        createdAt: movement.createdAt.toISOString()
      })),
      summary,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  // ================================
  // FINANCIAL REPORT
  // ================================
  async getFinancialReport(filters) {
    const { storeId, startDate, endDate, groupBy = "month" } = filters;
    const dateFilter = ReportQueries.buildDateFilter(startDate, endDate);
    const where = { ...dateFilter };
    if (storeId) where.storeId = storeId;
    const movements = await db.movement.findMany({
      where: {
        ...where,
        price: { not: null }
      },
      include: {
        product: {
          select: { id: true, name: true, categories: true }
        },
        supplier: {
          select: { id: true, corporateName: true }
        }
      }
    });
    const financialData = ReportQueries.calculateFinancialData(movements, groupBy);
    const breakdown = await ReportQueries.calculateFinancialBreakdown(movements);
    return {
      period: {
        startDate: startDate || new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3).toISOString().split("T")[0],
        endDate: endDate || (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
        groupBy
      },
      summary: financialData.summary,
      data: financialData.timeSeries,
      breakdown
    };
  },
  // ================================
  // CATEGORY REPORT
  // ================================
  async getCategoryReport(filters) {
    const { storeId, includeSubcategories = true } = filters;
    const where = {};
    if (storeId) where.storeId = storeId;
    const categories = await db.category.findMany({
      include: {
        products: {
          where,
          include: {
            product: {
              include: {
                movements: {
                  orderBy: { createdAt: "desc" },
                  take: 1,
                  select: { createdAt: true }
                }
              }
            }
          }
        },
        children: includeSubcategories ? {
          include: {
            products: {
              where,
              include: {
                product: {
                  include: {
                    movements: {
                      orderBy: { createdAt: "desc" },
                      take: 1,
                      select: { createdAt: true }
                    }
                  }
                }
              }
            }
          }
        } : false,
        parent: true
      }
    });
    const categoriesWithStats = categories.map((category) => {
      const allProducts = includeSubcategories && category.children ? [...category.products, ...category.children.flatMap((child) => child.products || [])] : category.products;
      const totalValue2 = allProducts.reduce((sum, productCategory) => {
        const product = productCategory.product;
        const currentStock = ReportQueries.calculateCurrentStock(product.movements || []);
        return sum + Number(product.referencePrice) * currentStock;
      }, 0);
      const totalMovements = allProducts.reduce((sum, productCategory) => {
        return sum + (productCategory.product.movements?.length || 0);
      }, 0);
      const lastMovement = allProducts.flatMap((productCategory) => productCategory.product.movements || []).sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime())[0];
      return {
        id: category.id,
        name: category.name,
        description: category.description,
        code: category.code,
        color: category.color,
        icon: category.icon,
        parentId: category.parentId,
        parent: category.parent,
        children: category.children?.map((child) => ({
          id: child.id,
          name: child.name
        })),
        stats: {
          totalProducts: allProducts.length,
          totalValue: totalValue2,
          averagePrice: allProducts.length > 0 ? totalValue2 / allProducts.length : 0,
          movements: totalMovements,
          lastMovement: lastMovement?.createdAt.toISOString()
        }
      };
    });
    const totalProducts = categoriesWithStats.reduce((sum, cat) => sum + cat.stats.totalProducts, 0);
    const totalValue = categoriesWithStats.reduce((sum, cat) => sum + cat.stats.totalValue, 0);
    return {
      categories: categoriesWithStats,
      summary: {
        totalCategories: categories.length,
        totalProducts,
        totalValue,
        averageProductsPerCategory: categories.length > 0 ? totalProducts / categories.length : 0
      }
    };
  },
  // ================================
  // SUPPLIER REPORT
  // ================================
  async getSupplierReport(filters) {
    const { storeId, status } = filters;
    const where = {};
    if (status && status !== "all") where.status = status === "active";
    const suppliers = await db.supplier.findMany({
      where,
      include: {
        products: {
          where: storeId ? { storeId } : {},
          include: {
            movements: {
              orderBy: { createdAt: "desc" },
              take: 1,
              select: { createdAt: true }
            }
          }
        },
        movements: {
          where: storeId ? { storeId } : {},
          orderBy: { createdAt: "desc" },
          take: 1,
          select: { createdAt: true }
        },
        responsibles: true
      }
    });
    const suppliersWithStats = suppliers.map((supplier) => {
      const totalValue2 = supplier.products.reduce((sum, product) => {
        const currentStock = ReportQueries.calculateCurrentStock(product.movements || []);
        return sum + Number(product.referencePrice) * currentStock;
      }, 0);
      const totalMovements = supplier.movements.length;
      const lastMovement = supplier.movements[0];
      return {
        id: supplier.id,
        corporateName: supplier.corporateName,
        tradeName: supplier.tradeName,
        cnpj: supplier.cnpj,
        status: supplier.status,
        address: {
          cep: supplier.cep,
          city: supplier.city,
          state: supplier.state,
          address: supplier.address
        },
        stats: {
          totalProducts: supplier.products.length,
          totalValue: totalValue2,
          totalMovements,
          lastMovement: lastMovement?.createdAt.toISOString(),
          averageOrderValue: totalMovements > 0 ? totalValue2 / totalMovements : 0
        },
        responsibles: supplier.responsibles.map((resp) => ({
          id: resp.id,
          name: resp.name,
          phone: resp.phone,
          email: resp.email
        }))
      };
    });
    const totalProducts = suppliersWithStats.reduce((sum, sup) => sum + sup.stats.totalProducts, 0);
    const totalValue = suppliersWithStats.reduce((sum, sup) => sum + sup.stats.totalValue, 0);
    const activeSuppliers = suppliersWithStats.filter((sup) => sup.status).length;
    return {
      suppliers: suppliersWithStats,
      summary: {
        totalSuppliers: suppliers.length,
        activeSuppliers,
        totalProducts,
        totalValue,
        averageProductsPerSupplier: suppliers.length > 0 ? totalProducts / suppliers.length : 0
      }
    };
  },
  // ================================
  // USER ACTIVITY REPORT
  // ================================
  async getUserActivityReport(filters, pagination) {
    const { storeId, userId, startDate, endDate, action } = filters;
    const { page, limit } = pagination;
    const where = {};
    if (userId) where.userId = userId;
    if (action) where.action = action;
    if (startDate || endDate) {
      where.createdAt = ReportQueries.buildDateFilter(startDate, endDate);
    }
    const [activities, total] = await Promise.all([
      db.auditLog.findMany({
        where,
        orderBy: { createdAt: "desc" },
        skip: (page - 1) * limit,
        take: limit,
        include: {
          user: {
            select: { id: true, name: true, email: true }
          }
        }
      }),
      db.auditLog.count({ where })
    ]);
    const summary = await ReportQueries.calculateUserActivitySummary(where);
    return {
      activities: activities.map((activity) => ({
        id: activity.id,
        entity: activity.entity,
        entityId: activity.entityId,
        action: activity.action,
        before: activity.before,
        after: activity.after,
        user: activity.user,
        createdAt: activity.createdAt.toISOString()
      })),
      summary,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  // ================================
  // STOCK ALERT REPORT
  // ================================
  async getStockAlertReport(filters, pagination) {
    const { storeId, alertType = "all" } = filters;
    const { page, limit } = pagination;
    const where = {};
    if (storeId) where.storeId = storeId;
    const products = await db.product.findMany({
      where,
      include: {
        categories: {
          select: {
            category: {
              select: { id: true, name: true }
            }
          }
        },
        supplier: {
          select: { id: true, corporateName: true }
        },
        movements: {
          orderBy: { createdAt: "desc" },
          take: 1,
          select: { createdAt: true }
        }
      }
    });
    const alerts = products.map((product) => {
      const currentStock = ReportQueries.calculateCurrentStock(product.movements || []);
      const unitPrice = Number(product.referencePrice);
      const totalValue = unitPrice * currentStock;
      let alertType2 = null;
      let severity = "low";
      if (currentStock <= 0) {
        alertType2 = "out";
        severity = "critical";
      } else if (currentStock <= product.stockMin) {
        alertType2 = "low";
        severity = currentStock === 0 ? "critical" : "high";
      } else if (currentStock >= product.stockMax) {
        alertType2 = "high";
        severity = "medium";
      }
      return {
        id: product.id,
        productId: product.id,
        productName: product.name,
        currentStock,
        stockMin: product.stockMin,
        stockMax: product.stockMax,
        alertType: alertType2,
        severity,
        unitPrice,
        totalValue,
        lastMovement: product.movements?.[0]?.createdAt.toISOString(),
        category: product.categories[0]?.category,
        supplier: product.supplier
      };
    }).filter((alert) => {
      if (alertType === "all") return alert.alertType !== null;
      return alert.alertType === alertType;
    }).sort((a, b) => {
      const severityOrder = { critical: 4, high: 3, medium: 2, low: 1 };
      return severityOrder[b.severity] - severityOrder[a.severity];
    });
    const paginatedAlerts = alerts.slice((page - 1) * limit, page * limit);
    const summary = {
      totalAlerts: alerts.length,
      lowStockAlerts: alerts.filter((a) => a.alertType === "low").length,
      highStockAlerts: alerts.filter((a) => a.alertType === "high").length,
      expiredAlerts: alerts.filter((a) => a.alertType === "expired").length,
      outOfStockAlerts: alerts.filter((a) => a.alertType === "out").length,
      totalValue: alerts.reduce((sum, alert) => sum + alert.totalValue, 0)
    };
    return {
      alerts: paginatedAlerts,
      summary,
      pagination: {
        page,
        limit,
        total: alerts.length,
        totalPages: Math.ceil(alerts.length / limit)
      }
    };
  },
  // ================================
  // HELPER METHODS
  // ================================
  buildDateFilter(startDate, endDate) {
    const filter = {};
    if (startDate) {
      filter.gte = new Date(startDate);
    }
    if (endDate) {
      filter.lte = new Date(endDate);
    }
    return Object.keys(filter).length > 0 ? filter : void 0;
  },
  calculateCurrentStock(movements) {
    return movements.reduce((stock, movement) => {
      switch (movement.type) {
        case "ENTRADA":
          return stock + movement.quantity;
        case "SAIDA":
        case "PERDA":
          return stock - movement.quantity;
        default:
          return stock;
      }
    }, 0);
  },
  async getInventoryStats(storeId) {
    const where = storeId ? { storeId } : {};
    const [totalValue, lowStockCount, outOfStockCount] = await Promise.all([
      db.product.aggregate({
        where,
        _sum: { referencePrice: true }
      }),
      db.product.count({
        where: {
          ...where,
          AND: [
            { stockMin: { gt: 0 } },
            { stockMin: { gt: 0 } }
          ]
        }
      }),
      db.product.count({
        where: {
          ...where,
          stockMin: { gt: 0 }
        }
      })
    ]);
    return {
      totalValue: Number(totalValue._sum.referencePrice || 0),
      lowStockItems: lowStockCount,
      outOfStockItems: outOfStockCount,
      averageStockValue: 0
      // Will be calculated based on actual stock
    };
  },
  async getMovementStats(storeId, dateFilter) {
    const where = { ...dateFilter };
    if (storeId) where.storeId = storeId;
    const [totalMovements, entries, exits, losses, totalValue] = await Promise.all([
      db.movement.count({ where }),
      db.movement.count({ where: { ...where, type: "ENTRADA" } }),
      db.movement.count({ where: { ...where, type: "SAIDA" } }),
      db.movement.count({ where: { ...where, type: "PERDA" } }),
      db.movement.aggregate({
        where: { ...where, price: { not: null } },
        _sum: { price: true }
      })
    ]);
    return {
      totalMovements,
      entries,
      exits,
      losses,
      totalValue: Number(totalValue._sum.price || 0)
    };
  },
  async getRecentActivity(storeId, dateFilter) {
    const where = { ...dateFilter };
    if (storeId) where.storeId = storeId;
    const [lastMovements, recentProducts] = await Promise.all([
      db.movement.findMany({
        where,
        orderBy: { createdAt: "desc" },
        take: 5,
        include: {
          product: {
            select: { name: true }
          }
        }
      }),
      db.product.findMany({
        where: storeId ? { storeId } : {},
        orderBy: { createdAt: "desc" },
        take: 5,
        select: { id: true, name: true, createdAt: true }
      })
    ]);
    return {
      lastMovements: lastMovements.map((movement) => ({
        id: movement.id,
        type: movement.type,
        productName: movement.product.name,
        quantity: movement.quantity,
        createdAt: movement.createdAt.toISOString()
      })),
      recentProducts: recentProducts.map((product) => ({
        id: product.id,
        name: product.name,
        createdAt: product.createdAt.toISOString()
      }))
    };
  },
  async getChartData(storeId, dateFilter) {
    const where = { ...dateFilter };
    if (storeId) where.storeId = storeId;
    const movementsByType = await db.movement.groupBy({
      by: ["type"],
      where,
      _count: { type: true },
      _sum: { price: true }
    });
    const topProducts = await db.movement.groupBy({
      by: ["productId"],
      where,
      _count: { productId: true },
      _sum: { price: true },
      orderBy: { _count: { productId: "desc" } },
      take: 5
    });
    const productIds = topProducts.map((p) => p.productId);
    const products = await db.product.findMany({
      where: { id: { in: productIds } },
      select: { id: true, name: true }
    });
    const productMap = new Map(products.map((p) => [p.id, p.name]));
    return {
      movementsByType: movementsByType.map((m) => ({
        type: m.type,
        count: m._count.type,
        value: Number(m._sum.price || 0)
      })),
      topProducts: topProducts.map((p) => ({
        productId: p.productId,
        productName: productMap.get(p.productId) || "Unknown",
        movements: p._count.productId,
        value: Number(p._sum.price || 0)
      })),
      movementsByDay: []
      // Will be implemented with proper date grouping
    };
  },
  async calculateInventorySummary(where) {
    const [totalProducts, totalValue, lowStockCount, outOfStockCount] = await Promise.all([
      db.product.count({ where }),
      db.product.aggregate({
        where,
        _sum: { referencePrice: true }
      }),
      db.product.count({
        where: {
          ...where,
          AND: [
            { stockMin: { gt: 0 } },
            { stockMin: { gt: 0 } }
          ]
        }
      }),
      db.product.count({
        where: {
          ...where,
          stockMin: { gt: 0 }
        }
      })
    ]);
    return {
      totalProducts,
      totalValue: Number(totalValue._sum.referencePrice || 0),
      lowStockCount,
      outOfStockCount,
      averageStockValue: totalProducts > 0 ? Number(totalValue._sum.referencePrice || 0) / totalProducts : 0
    };
  },
  async calculateMovementSummary(where) {
    const [totalMovements, totalEntries, totalExits, totalLosses, totalValue] = await Promise.all([
      db.movement.count({ where }),
      db.movement.count({ where: { ...where, type: "ENTRADA" } }),
      db.movement.count({ where: { ...where, type: "SAIDA" } }),
      db.movement.count({ where: { ...where, type: "PERDA" } }),
      db.movement.aggregate({
        where: { ...where, price: { not: null } },
        _sum: { price: true }
      })
    ]);
    return {
      totalMovements,
      totalEntries,
      totalExits,
      totalLosses,
      totalValue: Number(totalValue._sum.price || 0),
      averageValue: totalMovements > 0 ? Number(totalValue._sum.price || 0) / totalMovements : 0
    };
  },
  calculateFinancialData(movements, groupBy) {
    const totalRevenue = movements.filter((m) => m.type === "ENTRADA" && m.price).reduce((sum, m) => sum + Number(m.price) * m.quantity, 0);
    const totalCosts = movements.filter((m) => m.type === "SAIDA" && m.price).reduce((sum, m) => sum + Number(m.price) * m.quantity, 0);
    const grossProfit = totalRevenue - totalCosts;
    const profitMargin = totalRevenue > 0 ? grossProfit / totalRevenue * 100 : 0;
    return {
      summary: {
        totalRevenue,
        totalCosts,
        grossProfit,
        profitMargin,
        totalMovements: movements.length
      },
      timeSeries: []
      // Would be implemented with proper date grouping
    };
  },
  async calculateFinancialBreakdown(movements) {
    const byProduct = /* @__PURE__ */ new Map();
    const byCategory = /* @__PURE__ */ new Map();
    const bySupplier = /* @__PURE__ */ new Map();
    movements.forEach((movement) => {
      const value = Number(movement.price || 0) * movement.quantity;
      const isRevenue = movement.type === "ENTRADA";
      const isCost = movement.type === "SAIDA";
      if (!byProduct.has(movement.product.id)) {
        byProduct.set(movement.product.id, {
          productId: movement.product.id,
          productName: movement.product.name,
          revenue: 0,
          costs: 0,
          profit: 0,
          movements: 0
        });
      }
      const productData = byProduct.get(movement.product.id);
      productData.movements++;
      if (isRevenue) productData.revenue += value;
      if (isCost) productData.costs += value;
      productData.profit = productData.revenue - productData.costs;
    });
    return {
      byProduct: Array.from(byProduct.values()),
      byCategory: Array.from(byCategory.values()),
      bySupplier: Array.from(bySupplier.values())
    };
  },
  async calculateUserActivitySummary(where) {
    const [totalActivities, uniqueUsers, activitiesByType] = await Promise.all([
      db.auditLog.count({ where }),
      db.auditLog.groupBy({
        by: ["userId"],
        where,
        _count: { userId: true }
      }),
      db.auditLog.groupBy({
        by: ["action"],
        where,
        _count: { action: true }
      })
    ]);
    const mostActiveUser = uniqueUsers.length > 0 ? uniqueUsers.reduce((max, user) => user._count.userId > max._count.userId ? user : max) : null;
    return {
      totalActivities,
      uniqueUsers: uniqueUsers.length,
      mostActiveUser: mostActiveUser ? {
        id: mostActiveUser.userId,
        name: "Unknown",
        // Would need to join with user table
        activities: mostActiveUser._count.userId
      } : null,
      activitiesByType: activitiesByType.map((activity) => ({
        action: activity.action,
        count: activity._count.action
      }))
    };
  }
};

// src/features/report/commands/report.commands.ts
init_prisma();
var ReportCommands = {
  // ================================
  // EXPORT REPORTS
  // ================================
  async exportReport(reportType, format, filters) {
    try {
      const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
      const filename = `${reportType}-report-${timestamp}.${format}`;
      const exportRecord = await db.auditLog.create({
        data: {
          entity: "REPORT",
          entityId: `export-${Date.now()}`,
          action: "CREATE",
          before: null,
          after: {
            reportType,
            format,
            filters,
            filename,
            generatedAt: (/* @__PURE__ */ new Date()).toISOString()
          }
        }
      });
      const downloadUrl = `/api/reports/download/${exportRecord.id}`;
      const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1e3);
      return {
        success: true,
        downloadUrl,
        filename,
        format,
        generatedAt: (/* @__PURE__ */ new Date()).toISOString(),
        expiresAt: expiresAt.toISOString()
      };
    } catch (error) {
      throw new Error(`Failed to export report: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  },
  // ================================
  // GENERATE CSV REPORT
  // ================================
  async generateCsvReport(reportType, data, columns) {
    try {
      const header = columns.join(",");
      const rows = data.map((item) => {
        return columns.map((column) => {
          const value = ReportCommands.getNestedValue(item, column);
          if (typeof value === "string" && (value.includes(",") || value.includes('"') || value.includes("\n"))) {
            return `"${value.replace(/"/g, '""')}"`;
          }
          return value || "";
        }).join(",");
      });
      return [header, ...rows].join("\n");
    } catch (error) {
      throw new Error(`Failed to generate CSV report: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  },
  // ================================
  // GENERATE EXCEL REPORT
  // ================================
  async generateExcelReport(reportType, data, columns) {
    try {
      const workbook = {
        SheetNames: [reportType],
        Sheets: {
          [reportType]: {
            "!ref": "A1",
            A1: { v: "Report Generated", t: "s" },
            A2: { v: (/* @__PURE__ */ new Date()).toISOString(), t: "s" }
          }
        }
      };
      return Buffer.from(JSON.stringify(workbook));
    } catch (error) {
      throw new Error(`Failed to generate Excel report: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  },
  // ================================
  // GENERATE PDF REPORT
  // ================================
  async generatePdfReport(reportType, data, columns) {
    try {
      const pdfContent = {
        title: `${reportType} Report`,
        generatedAt: (/* @__PURE__ */ new Date()).toISOString(),
        totalRecords: data.length,
        columns: columns.map((col) => col.label),
        data: data.slice(0, 10)
        // Limit for demo
      };
      return Buffer.from(JSON.stringify(pdfContent));
    } catch (error) {
      throw new Error(`Failed to generate PDF report: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  },
  // ================================
  // SCHEDULE REPORT
  // ================================
  async scheduleReport(reportType, schedule, filters, emailRecipients) {
    try {
      const scheduledReport = await db.auditLog.create({
        data: {
          entity: "REPORT",
          entityId: `schedule-${Date.now()}`,
          action: "CREATE",
          before: null,
          after: {
            reportType,
            schedule,
            filters,
            emailRecipients,
            isActive: true,
            createdAt: (/* @__PURE__ */ new Date()).toISOString()
          }
        }
      });
      return {
        success: true,
        scheduleId: scheduledReport.id
      };
    } catch (error) {
      throw new Error(`Failed to schedule report: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  },
  // ================================
  // CANCEL SCHEDULED REPORT
  // ================================
  async cancelScheduledReport(scheduleId) {
    try {
      await db.auditLog.update({
        where: { id: scheduleId },
        data: {
          after: {
            ...(await db.auditLog.findUnique({
              where: { id: scheduleId },
              select: { after: true }
            }))?.after,
            isActive: false,
            cancelledAt: (/* @__PURE__ */ new Date()).toISOString()
          }
        }
      });
      return { success: true };
    } catch (error) {
      throw new Error(`Failed to cancel scheduled report: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  },
  // ================================
  // SEND REPORT VIA EMAIL
  // ================================
  async sendReportViaEmail(reportType, format, data, emailRecipients, subject, message) {
    try {
      let reportContent;
      let filename;
      switch (format) {
        case "csv":
          const columns = ReportCommands.getDefaultColumns(reportType);
          reportContent = await ReportCommands.generateCsvReport(reportType, data, columns);
          filename = `${reportType}-report-${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.csv`;
          break;
        case "xlsx":
          const excelColumns = ReportCommands.getDefaultExcelColumns(reportType);
          reportContent = await ReportCommands.generateExcelReport(reportType, data, excelColumns);
          filename = `${reportType}-report-${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.xlsx`;
          break;
        case "pdf":
          const pdfColumns = ReportCommands.getDefaultPdfColumns(reportType);
          reportContent = await ReportCommands.generatePdfReport(reportType, data, pdfColumns);
          filename = `${reportType}-report-${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.pdf`;
          break;
        default:
          throw new Error(`Unsupported format: ${format}`);
      }
      const emailLog = await db.auditLog.create({
        data: {
          entity: "REPORT",
          entityId: `email-${Date.now()}`,
          action: "CREATE",
          before: null,
          after: {
            reportType,
            format,
            recipients: emailRecipients,
            subject: subject || `${reportType} Report`,
            message: message || "Please find the attached report.",
            filename,
            sentAt: (/* @__PURE__ */ new Date()).toISOString()
          }
        }
      });
      return {
        success: true,
        messageId: emailLog.id
      };
    } catch (error) {
      throw new Error(`Failed to send report via email: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  },
  // ================================
  // GENERATE REPORT SUMMARY
  // ================================
  async generateReportSummary(reportType, data, filters) {
    try {
      const summary = {};
      switch (reportType) {
        case "inventory":
          summary.totalValue = data.reduce((sum, item) => sum + (item.totalValue || 0), 0);
          summary.lowStockItems = data.filter((item) => item.alertLevel === "low").length;
          summary.outOfStockItems = data.filter((item) => item.alertLevel === "out").length;
          break;
        case "movement":
          summary.totalMovements = data.length;
          summary.totalValue = data.reduce((sum, item) => sum + (item.totalValue || 0), 0);
          summary.entries = data.filter((item) => item.type === "ENTRADA").length;
          summary.exits = data.filter((item) => item.type === "SAIDA").length;
          summary.losses = data.filter((item) => item.type === "PERDA").length;
          break;
        case "financial":
          summary.totalRevenue = data.reduce((sum, item) => sum + (item.revenue || 0), 0);
          summary.totalCosts = data.reduce((sum, item) => sum + (item.costs || 0), 0);
          summary.grossProfit = summary.totalRevenue - summary.totalCosts;
          summary.profitMargin = summary.totalRevenue > 0 ? summary.grossProfit / summary.totalRevenue * 100 : 0;
          break;
        default:
          summary.totalRecords = data.length;
      }
      return {
        totalRecords: data.length,
        dateRange: {
          start: filters.startDate || new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3).toISOString().split("T")[0],
          end: filters.endDate || (/* @__PURE__ */ new Date()).toISOString().split("T")[0]
        },
        filters,
        generatedAt: (/* @__PURE__ */ new Date()).toISOString(),
        summary
      };
    } catch (error) {
      throw new Error(`Failed to generate report summary: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  },
  // ================================
  // HELPER METHODS
  // ================================
  getNestedValue(obj, path3) {
    return path3.split(".").reduce((current, key) => current?.[key], obj);
  },
  getDefaultColumns(reportType) {
    const columnMap = {
      inventory: ["id", "name", "description", "category.name", "supplier.corporateName", "currentStock", "stockMin", "stockMax", "unitPrice", "totalValue", "status", "alertLevel"],
      movement: ["id", "type", "quantity", "price", "totalValue", "batch", "expiration", "note", "product.name", "supplier.corporateName", "user.name", "createdAt"],
      financial: ["period", "revenue", "costs", "profit", "movements"],
      category: ["id", "name", "description", "code", "stats.totalProducts", "stats.totalValue", "stats.averagePrice", "stats.movements"],
      supplier: ["id", "corporateName", "tradeName", "cnpj", "status", "stats.totalProducts", "stats.totalValue", "stats.totalMovements", "stats.averageOrderValue"],
      "user-activity": ["id", "entity", "entityId", "action", "user.name", "user.email", "createdAt"],
      "stock-alert": ["id", "productName", "currentStock", "stockMin", "stockMax", "alertType", "severity", "unitPrice", "totalValue", "category.name", "supplier.corporateName"]
    };
    return columnMap[reportType] || ["id", "name", "createdAt"];
  },
  getDefaultExcelColumns(reportType) {
    const columnMap = {
      inventory: [
        { key: "id", label: "ID", type: "string" },
        { key: "name", label: "Nome", type: "string" },
        { key: "description", label: "Descri\xE7\xE3o", type: "string" },
        { key: "category.name", label: "Categoria", type: "string" },
        { key: "supplier.corporateName", label: "Fornecedor", type: "string" },
        { key: "currentStock", label: "Estoque Atual", type: "number" },
        { key: "stockMin", label: "Estoque M\xEDnimo", type: "number" },
        { key: "stockMax", label: "Estoque M\xE1ximo", type: "number" },
        { key: "unitPrice", label: "Pre\xE7o Unit\xE1rio", type: "number" },
        { key: "totalValue", label: "Valor Total", type: "number" },
        { key: "status", label: "Status", type: "string" },
        { key: "alertLevel", label: "N\xEDvel de Alerta", type: "string" }
      ],
      movement: [
        { key: "id", label: "ID", type: "string" },
        { key: "type", label: "Tipo", type: "string" },
        { key: "quantity", label: "Quantidade", type: "number" },
        { key: "price", label: "Pre\xE7o", type: "number" },
        { key: "totalValue", label: "Valor Total", type: "number" },
        { key: "batch", label: "Lote", type: "string" },
        { key: "expiration", label: "Validade", type: "date" },
        { key: "note", label: "Observa\xE7\xE3o", type: "string" },
        { key: "product.name", label: "Produto", type: "string" },
        { key: "supplier.corporateName", label: "Fornecedor", type: "string" },
        { key: "user.name", label: "Usu\xE1rio", type: "string" },
        { key: "createdAt", label: "Data", type: "date" }
      ]
    };
    return columnMap[reportType] || [
      { key: "id", label: "ID", type: "string" },
      { key: "name", label: "Nome", type: "string" },
      { key: "createdAt", label: "Data de Cria\xE7\xE3o", type: "date" }
    ];
  },
  getDefaultPdfColumns(reportType) {
    const columnMap = {
      inventory: [
        { key: "name", label: "Produto", width: 30 },
        { key: "category.name", label: "Categoria", width: 20 },
        { key: "currentStock", label: "Estoque", width: 15 },
        { key: "unitPrice", label: "Pre\xE7o", width: 15 },
        { key: "totalValue", label: "Valor Total", width: 20 }
      ],
      movement: [
        { key: "product.name", label: "Produto", width: 25 },
        { key: "type", label: "Tipo", width: 15 },
        { key: "quantity", label: "Quantidade", width: 15 },
        { key: "totalValue", label: "Valor", width: 15 },
        { key: "user.name", label: "Usu\xE1rio", width: 15 },
        { key: "createdAt", label: "Data", width: 15 }
      ]
    };
    return columnMap[reportType] || [
      { key: "name", label: "Nome", width: 50 },
      { key: "createdAt", label: "Data", width: 50 }
    ];
  },
  // ================================
  // VALIDATION METHODS
  // ================================
  validateReportFilters(filters) {
    const errors = [];
    if (filters.startDate && filters.endDate) {
      const startDate = new Date(filters.startDate);
      const endDate = new Date(filters.endDate);
      if (startDate > endDate) {
        errors.push("Start date cannot be after end date");
      }
    }
    if (filters.storeId && typeof filters.storeId !== "string") {
      errors.push("Store ID must be a string");
    }
    return {
      valid: errors.length === 0,
      errors
    };
  },
  getAvailableReportTypes() {
    return [
      "inventory",
      "movement",
      "financial",
      "category",
      "supplier",
      "user-activity",
      "stock-alert"
    ];
  },
  getReportStatistics() {
    return {
      totalReports: 0,
      // This would be calculated from actual data
      availableTypes: ReportCommands.getAvailableReportTypes()
    };
  }
};

// src/features/report/report.controller.ts
var ReportController = {
  // ================================
  // DASHBOARD STATS
  // ================================
  async getDashboardStats(request, reply) {
    try {
      const { storeId, period, startDate, endDate } = request.query;
      const filters = {
        storeId,
        startDate,
        endDate,
        period
      };
      const result = await ReportQueries.getDashboardStats(filters);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("Failed to get dashboard stats")) {
        return reply.status(500).send({
          error: "Erro ao obter estat\xEDsticas do dashboard"
        });
      }
      return reply.status(500).send({
        error: "Erro interno do servidor"
      });
    }
  },
  // ================================
  // INVENTORY REPORT
  // ================================
  async getInventoryReport(request, reply) {
    try {
      const {
        storeId,
        categoryId,
        supplierId,
        status,
        lowStock,
        sortBy,
        sortOrder,
        page = 1,
        limit = 20
      } = request.query;
      const filters = {
        storeId,
        categoryId,
        supplierId,
        status,
        lowStock
      };
      const pagination = { page, limit };
      const sort = { field: sortBy || "name", order: sortOrder || "asc" };
      const result = await ReportQueries.getInventoryReport(filters, pagination, sort);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("Failed to get inventory report")) {
        return reply.status(500).send({
          error: "Erro ao obter relat\xF3rio de invent\xE1rio"
        });
      }
      return reply.status(500).send({
        error: "Erro interno do servidor"
      });
    }
  },
  // ================================
  // MOVEMENT REPORT
  // ================================
  async getMovementReport(request, reply) {
    try {
      const {
        storeId,
        productId,
        supplierId,
        type,
        startDate,
        endDate,
        page = 1,
        limit = 20
      } = request.query;
      const filters = {
        storeId,
        productId,
        supplierId,
        type,
        startDate,
        endDate
      };
      const pagination = { page, limit };
      const result = await ReportQueries.getMovementReport(filters, pagination);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("Failed to get movement report")) {
        return reply.status(500).send({
          error: "Erro ao obter relat\xF3rio de movimenta\xE7\xF5es"
        });
      }
      return reply.status(500).send({
        error: "Erro interno do servidor"
      });
    }
  },
  // ================================
  // FINANCIAL REPORT
  // ================================
  async getFinancialReport(request, reply) {
    try {
      const { storeId, startDate, endDate, groupBy } = request.query;
      const filters = {
        storeId,
        startDate,
        endDate,
        groupBy
      };
      const result = await ReportQueries.getFinancialReport(filters);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("Failed to get financial report")) {
        return reply.status(500).send({
          error: "Erro ao obter relat\xF3rio financeiro"
        });
      }
      return reply.status(500).send({
        error: "Erro interno do servidor"
      });
    }
  },
  // ================================
  // CATEGORY REPORT
  // ================================
  async getCategoryReport(request, reply) {
    try {
      const { storeId, startDate, endDate, includeSubcategories } = request.query;
      const filters = {
        storeId,
        startDate,
        endDate,
        includeSubcategories
      };
      const result = await ReportQueries.getCategoryReport(filters);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("Failed to get category report")) {
        return reply.status(500).send({
          error: "Erro ao obter relat\xF3rio de categorias"
        });
      }
      return reply.status(500).send({
        error: "Erro interno do servidor"
      });
    }
  },
  // ================================
  // SUPPLIER REPORT
  // ================================
  async getSupplierReport(request, reply) {
    try {
      const { storeId, startDate, endDate, status } = request.query;
      const filters = {
        storeId,
        startDate,
        endDate,
        status
      };
      const result = await ReportQueries.getSupplierReport(filters);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("Failed to get supplier report")) {
        return reply.status(500).send({
          error: "Erro ao obter relat\xF3rio de fornecedores"
        });
      }
      return reply.status(500).send({
        error: "Erro interno do servidor"
      });
    }
  },
  // ================================
  // USER ACTIVITY REPORT
  // ================================
  async getUserActivityReport(request, reply) {
    try {
      const {
        storeId,
        userId,
        startDate,
        endDate,
        action,
        page = 1,
        limit = 20
      } = request.query;
      const filters = {
        storeId,
        userId,
        startDate,
        endDate,
        action
      };
      const pagination = { page, limit };
      const result = await ReportQueries.getUserActivityReport(filters, pagination);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("Failed to get user activity report")) {
        return reply.status(500).send({
          error: "Erro ao obter relat\xF3rio de atividade de usu\xE1rios"
        });
      }
      return reply.status(500).send({
        error: "Erro interno do servidor"
      });
    }
  },
  // ================================
  // STOCK ALERT REPORT
  // ================================
  async getStockAlertReport(request, reply) {
    try {
      const { storeId, alertType, page = 1, limit = 20 } = request.query;
      const filters = {
        storeId,
        alertType
      };
      const pagination = { page, limit };
      const result = await ReportQueries.getStockAlertReport(filters, pagination);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("Failed to get stock alert report")) {
        return reply.status(500).send({
          error: "Erro ao obter relat\xF3rio de alertas de estoque"
        });
      }
      return reply.status(500).send({
        error: "Erro interno do servidor"
      });
    }
  },
  // ================================
  // EXPORT REPORTS
  // ================================
  async exportReport(request, reply) {
    try {
      const { reportType, format, storeId, startDate, endDate, filters } = request.query;
      const reportFilters = {
        storeId,
        startDate,
        endDate,
        ...filters ? JSON.parse(filters) : {}
      };
      const result = await ReportCommands.exportReport(reportType, format, reportFilters);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("Failed to export report")) {
        return reply.status(500).send({
          error: "Erro ao exportar relat\xF3rio"
        });
      }
      if (error.message.includes("Unsupported report type")) {
        return reply.status(400).send({
          error: "Tipo de relat\xF3rio n\xE3o suportado"
        });
      }
      return reply.status(500).send({
        error: "Erro interno do servidor"
      });
    }
  },
  // ================================
  // SCHEDULE REPORTS
  // ================================
  async scheduleReport(request, reply) {
    try {
      const { reportType, schedule, filters, emailRecipients } = request.body;
      const result = await ReportCommands.scheduleReport(reportType, schedule, filters, emailRecipients);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("Failed to schedule report")) {
        return reply.status(500).send({
          error: "Erro ao agendar relat\xF3rio"
        });
      }
      return reply.status(500).send({
        error: "Erro interno do servidor"
      });
    }
  },
  async cancelScheduledReport(request, reply) {
    try {
      const { scheduleId } = request.params;
      const result = await ReportCommands.cancelScheduledReport(scheduleId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("Failed to cancel scheduled report")) {
        return reply.status(500).send({
          error: "Erro ao cancelar relat\xF3rio agendado"
        });
      }
      return reply.status(500).send({
        error: "Erro interno do servidor"
      });
    }
  },
  // ================================
  // EMAIL REPORTS
  // ================================
  async sendReportViaEmail(request, reply) {
    try {
      const { reportType, format, data, emailRecipients, subject, message } = request.body;
      const result = await ReportCommands.sendReportViaEmail(
        reportType,
        format,
        data,
        emailRecipients,
        subject,
        message
      );
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("Failed to send report via email")) {
        return reply.status(500).send({
          error: "Erro ao enviar relat\xF3rio por email"
        });
      }
      return reply.status(500).send({
        error: "Erro interno do servidor"
      });
    }
  },
  // ================================
  // UTILITY ENDPOINTS
  // ================================
  async getAvailableReportTypes(request, reply) {
    try {
      const result = ReportCommands.getAvailableReportTypes();
      return reply.send({ reportTypes: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Erro interno do servidor"
      });
    }
  },
  async getReportStatistics(request, reply) {
    try {
      const result = ReportCommands.getReportStatistics();
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Erro interno do servidor"
      });
    }
  },
  // ================================
  // VALIDATION ENDPOINT
  // ================================
  async validateFilters(request, reply) {
    try {
      const { filters } = request.body;
      const result = ReportCommands.validateReportFilters(filters);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Erro interno do servidor"
      });
    }
  }
};

// src/features/report/report.schema.ts
var getDashboardStatsSchema = {
  querystring: {
    type: "object",
    properties: {
      storeId: { type: "string" },
      period: {
        type: "string",
        enum: ["day", "week", "month", "year"],
        default: "month"
      },
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        overview: {
          type: "object",
          properties: {
            totalProducts: { type: "number" },
            totalCategories: { type: "number" },
            totalSuppliers: { type: "number" },
            totalStores: { type: "number" },
            totalUsers: { type: "number" }
          }
        },
        inventory: {
          type: "object",
          properties: {
            totalValue: { type: "number" },
            lowStockItems: { type: "number" },
            outOfStockItems: { type: "number" },
            averageStockValue: { type: "number" }
          }
        },
        movements: {
          type: "object",
          properties: {
            totalMovements: { type: "number" },
            entries: { type: "number" },
            exits: { type: "number" },
            losses: { type: "number" },
            totalValue: { type: "number" }
          }
        },
        recentActivity: {
          type: "object",
          properties: {
            lastMovements: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  type: { type: "string" },
                  productName: { type: "string" },
                  quantity: { type: "number" },
                  createdAt: { type: "string" }
                }
              }
            },
            recentProducts: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  createdAt: { type: "string" }
                }
              }
            }
          }
        },
        charts: {
          type: "object",
          properties: {
            movementsByType: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  type: { type: "string" },
                  count: { type: "number" },
                  value: { type: "number" }
                }
              }
            },
            topProducts: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  productId: { type: "string" },
                  productName: { type: "string" },
                  movements: { type: "number" },
                  value: { type: "number" }
                }
              }
            },
            movementsByDay: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  date: { type: "string" },
                  entries: { type: "number" },
                  exits: { type: "number" },
                  losses: { type: "number" }
                }
              }
            }
          }
        }
      }
    }
  }
};
var getInventoryReportSchema = {
  querystring: {
    type: "object",
    properties: {
      storeId: { type: "string" },
      categoryId: { type: "string" },
      supplierId: { type: "string" },
      status: {
        type: "string",
        enum: ["all", "active", "inactive"],
        default: "all"
      },
      lowStock: { type: "boolean" },
      sortBy: {
        type: "string",
        enum: ["name", "stock", "value", "category"],
        default: "name"
      },
      sortOrder: {
        type: "string",
        enum: ["asc", "desc"],
        default: "asc"
      },
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 20 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        products: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string" },
              category: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" }
                }
              },
              supplier: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  corporateName: { type: "string" }
                }
              },
              currentStock: { type: "number" },
              stockMin: { type: "number" },
              stockMax: { type: "number" },
              unitPrice: { type: "number" },
              totalValue: { type: "number" },
              status: { type: "boolean" },
              alertLevel: {
                type: "string",
                enum: ["normal", "low", "high", "out"]
              },
              lastMovement: { type: "string" }
            }
          }
        },
        summary: {
          type: "object",
          properties: {
            totalProducts: { type: "number" },
            totalValue: { type: "number" },
            lowStockCount: { type: "number" },
            outOfStockCount: { type: "number" },
            averageStockValue: { type: "number" }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getMovementReportSchema2 = {
  querystring: {
    type: "object",
    properties: {
      storeId: { type: "string" },
      productId: { type: "string" },
      supplierId: { type: "string" },
      type: {
        type: "string",
        enum: ["ENTRADA", "SAIDA", "PERDA"]
      },
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" },
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 20 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        movements: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              type: { type: "string" },
              quantity: { type: "number" },
              price: { type: "number" },
              totalValue: { type: "number" },
              batch: { type: "string" },
              expiration: { type: "string" },
              note: { type: "string" },
              balanceAfter: { type: "number" },
              product: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  unitOfMeasure: { type: "string" }
                }
              },
              supplier: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  corporateName: { type: "string" }
                }
              },
              user: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" }
                }
              },
              createdAt: { type: "string" }
            }
          }
        },
        summary: {
          type: "object",
          properties: {
            totalMovements: { type: "number" },
            totalEntries: { type: "number" },
            totalExits: { type: "number" },
            totalLosses: { type: "number" },
            totalValue: { type: "number" },
            averageValue: { type: "number" }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getFinancialReportSchema = {
  querystring: {
    type: "object",
    properties: {
      storeId: { type: "string" },
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" },
      groupBy: {
        type: "string",
        enum: ["day", "week", "month", "year"],
        default: "month"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        period: {
          type: "object",
          properties: {
            startDate: { type: "string" },
            endDate: { type: "string" },
            groupBy: { type: "string" }
          }
        },
        summary: {
          type: "object",
          properties: {
            totalRevenue: { type: "number" },
            totalCosts: { type: "number" },
            grossProfit: { type: "number" },
            profitMargin: { type: "number" },
            totalMovements: { type: "number" }
          }
        },
        data: {
          type: "array",
          items: {
            type: "object",
            properties: {
              period: { type: "string" },
              revenue: { type: "number" },
              costs: { type: "number" },
              profit: { type: "number" },
              movements: { type: "number" }
            }
          }
        },
        breakdown: {
          type: "object",
          properties: {
            byProduct: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  productId: { type: "string" },
                  productName: { type: "string" },
                  revenue: { type: "number" },
                  costs: { type: "number" },
                  profit: { type: "number" },
                  movements: { type: "number" }
                }
              }
            },
            byCategory: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  categoryId: { type: "string" },
                  categoryName: { type: "string" },
                  revenue: { type: "number" },
                  costs: { type: "number" },
                  profit: { type: "number" },
                  movements: { type: "number" }
                }
              }
            },
            bySupplier: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  supplierId: { type: "string" },
                  supplierName: { type: "string" },
                  revenue: { type: "number" },
                  costs: { type: "number" },
                  profit: { type: "number" },
                  movements: { type: "number" }
                }
              }
            }
          }
        }
      }
    }
  }
};
var getCategoryReportSchema = {
  querystring: {
    type: "object",
    properties: {
      storeId: { type: "string" },
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" },
      includeSubcategories: { type: "boolean", default: true }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        categories: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string" },
              code: { type: "string" },
              color: { type: "string" },
              icon: { type: "string" },
              parentId: { type: "string" },
              parent: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" }
                }
              },
              children: {
                type: "array",
                items: {
                  type: "object",
                  properties: {
                    id: { type: "string" },
                    name: { type: "string" }
                  }
                }
              },
              stats: {
                type: "object",
                properties: {
                  totalProducts: { type: "number" },
                  totalValue: { type: "number" },
                  averagePrice: { type: "number" },
                  movements: { type: "number" },
                  lastMovement: { type: "string" }
                }
              }
            }
          }
        },
        summary: {
          type: "object",
          properties: {
            totalCategories: { type: "number" },
            totalProducts: { type: "number" },
            totalValue: { type: "number" },
            averageProductsPerCategory: { type: "number" }
          }
        }
      }
    }
  }
};
var getSupplierReportSchema = {
  querystring: {
    type: "object",
    properties: {
      storeId: { type: "string" },
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" },
      status: {
        type: "string",
        enum: ["all", "active", "inactive"],
        default: "all"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        suppliers: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              corporateName: { type: "string" },
              tradeName: { type: "string" },
              cnpj: { type: "string" },
              status: { type: "boolean" },
              address: {
                type: "object",
                properties: {
                  cep: { type: "string" },
                  city: { type: "string" },
                  state: { type: "string" },
                  address: { type: "string" }
                }
              },
              stats: {
                type: "object",
                properties: {
                  totalProducts: { type: "number" },
                  totalValue: { type: "number" },
                  totalMovements: { type: "number" },
                  lastMovement: { type: "string" },
                  averageOrderValue: { type: "number" }
                }
              },
              responsibles: {
                type: "array",
                items: {
                  type: "object",
                  properties: {
                    id: { type: "string" },
                    name: { type: "string" },
                    phone: { type: "string" },
                    email: { type: "string" }
                  }
                }
              }
            }
          }
        },
        summary: {
          type: "object",
          properties: {
            totalSuppliers: { type: "number" },
            activeSuppliers: { type: "number" },
            totalProducts: { type: "number" },
            totalValue: { type: "number" },
            averageProductsPerSupplier: { type: "number" }
          }
        }
      }
    }
  }
};
var getUserActivityReportSchema = {
  querystring: {
    type: "object",
    properties: {
      storeId: { type: "string" },
      userId: { type: "string" },
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" },
      action: {
        type: "string",
        enum: ["CREATE", "UPDATE", "DELETE"]
      },
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 20 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        activities: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              entity: { type: "string" },
              entityId: { type: "string" },
              action: { type: "string" },
              before: { type: "object" },
              after: { type: "object" },
              user: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  email: { type: "string" }
                }
              },
              createdAt: { type: "string" }
            }
          }
        },
        summary: {
          type: "object",
          properties: {
            totalActivities: { type: "number" },
            uniqueUsers: { type: "number" },
            mostActiveUser: {
              type: "object",
              properties: {
                id: { type: "string" },
                name: { type: "string" },
                activities: { type: "number" }
              }
            },
            activitiesByType: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  action: { type: "string" },
                  count: { type: "number" }
                }
              }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getStockAlertReportSchema = {
  querystring: {
    type: "object",
    properties: {
      storeId: { type: "string" },
      alertType: {
        type: "string",
        enum: ["low", "high", "expired", "all"],
        default: "all"
      },
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 20 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        alerts: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              productId: { type: "string" },
              productName: { type: "string" },
              currentStock: { type: "number" },
              stockMin: { type: "number" },
              stockMax: { type: "number" },
              alertType: {
                type: "string",
                enum: ["low", "high", "expired", "out"]
              },
              severity: {
                type: "string",
                enum: ["low", "medium", "high", "critical"]
              },
              unitPrice: { type: "number" },
              totalValue: { type: "number" },
              lastMovement: { type: "string" },
              category: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" }
                }
              },
              supplier: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  corporateName: { type: "string" }
                }
              }
            }
          }
        },
        summary: {
          type: "object",
          properties: {
            totalAlerts: { type: "number" },
            lowStockAlerts: { type: "number" },
            highStockAlerts: { type: "number" },
            expiredAlerts: { type: "number" },
            outOfStockAlerts: { type: "number" },
            totalValue: { type: "number" }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var exportReportSchema = {
  querystring: {
    type: "object",
    required: ["reportType", "format"],
    properties: {
      reportType: {
        type: "string",
        enum: ["inventory", "movement", "financial", "category", "supplier", "user-activity", "stock-alert"]
      },
      format: {
        type: "string",
        enum: ["csv", "xlsx", "pdf"]
      },
      storeId: { type: "string" },
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" },
      filters: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        success: { type: "boolean" },
        downloadUrl: { type: "string" },
        filename: { type: "string" },
        format: { type: "string" },
        generatedAt: { type: "string" },
        expiresAt: { type: "string" }
      }
    }
  }
};

// src/features/report/report.routes.ts
async function ReportRoutes(fastify2) {
  fastify2.get("/dashboard/stats", {
    schema: getDashboardStatsSchema,
    handler: ReportController.getDashboardStats
  });
  fastify2.get("/inventory", {
    schema: getInventoryReportSchema,
    handler: ReportController.getInventoryReport
  });
  fastify2.get("/movements", {
    schema: getMovementReportSchema2,
    handler: ReportController.getMovementReport
  });
  fastify2.get("/financial", {
    schema: getFinancialReportSchema,
    handler: ReportController.getFinancialReport
  });
  fastify2.get("/categories", {
    schema: getCategoryReportSchema,
    handler: ReportController.getCategoryReport
  });
  fastify2.get("/suppliers", {
    schema: getSupplierReportSchema,
    handler: ReportController.getSupplierReport
  });
  fastify2.get("/user-activity", {
    schema: getUserActivityReportSchema,
    handler: ReportController.getUserActivityReport
  });
  fastify2.get("/stock-alerts", {
    schema: getStockAlertReportSchema,
    handler: ReportController.getStockAlertReport
  });
  fastify2.get("/export", {
    schema: exportReportSchema,
    handler: ReportController.exportReport
  });
  fastify2.post("/schedule", {
    schema: {
      description: "Agendar relat\xF3rio para gera\xE7\xE3o autom\xE1tica",
      tags: ["Reports"],
      body: {
        type: "object",
        required: ["reportType", "schedule", "filters", "emailRecipients"],
        properties: {
          reportType: {
            type: "string",
            enum: ["inventory", "movement", "financial", "category", "supplier", "user-activity", "stock-alert"]
          },
          schedule: {
            type: "object",
            required: ["frequency", "time"],
            properties: {
              frequency: {
                type: "string",
                enum: ["daily", "weekly", "monthly"]
              },
              time: {
                type: "string",
                pattern: "^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$",
                description: "Time in HH:MM format"
              },
              dayOfWeek: {
                type: "number",
                minimum: 0,
                maximum: 6,
                description: "Day of week (0-6) for weekly frequency"
              },
              dayOfMonth: {
                type: "number",
                minimum: 1,
                maximum: 31,
                description: "Day of month (1-31) for monthly frequency"
              }
            }
          },
          filters: {
            type: "object",
            properties: {
              storeId: { type: "string" },
              startDate: { type: "string", format: "date" },
              endDate: { type: "string", format: "date" },
              categoryId: { type: "string" },
              supplierId: { type: "string" },
              productId: { type: "string" },
              userId: { type: "string" },
              status: { type: "string" },
              type: { type: "string" }
            }
          },
          emailRecipients: {
            type: "array",
            items: { type: "string", format: "email" },
            minItems: 1
          }
        }
      },
      response: {
        200: {
          type: "object",
          properties: {
            success: { type: "boolean" },
            scheduleId: { type: "string" }
          }
        }
      }
    },
    handler: ReportController.scheduleReport
  });
  fastify2.delete("/schedule/:scheduleId", {
    schema: {
      description: "Cancelar relat\xF3rio agendado",
      tags: ["Reports"],
      params: {
        type: "object",
        properties: {
          scheduleId: { type: "string" }
        },
        required: ["scheduleId"]
      },
      response: {
        200: {
          type: "object",
          properties: {
            success: { type: "boolean" }
          }
        }
      }
    },
    handler: ReportController.cancelScheduledReport
  });
  fastify2.post("/send-email", {
    schema: {
      description: "Enviar relat\xF3rio por email",
      tags: ["Reports"],
      body: {
        type: "object",
        required: ["reportType", "format", "data", "emailRecipients"],
        properties: {
          reportType: {
            type: "string",
            enum: ["inventory", "movement", "financial", "category", "supplier", "user-activity", "stock-alert"]
          },
          format: {
            type: "string",
            enum: ["csv", "xlsx", "pdf"]
          },
          data: {
            type: "array",
            items: { type: "object" }
          },
          emailRecipients: {
            type: "array",
            items: { type: "string", format: "email" },
            minItems: 1
          },
          subject: {
            type: "string",
            description: "Email subject (optional)"
          },
          message: {
            type: "string",
            description: "Email message (optional)"
          }
        }
      },
      response: {
        200: {
          type: "object",
          properties: {
            success: { type: "boolean" },
            messageId: { type: "string" }
          }
        }
      }
    },
    handler: ReportController.sendReportViaEmail
  });
  fastify2.get("/types", {
    schema: {
      description: "Obter tipos de relat\xF3rios dispon\xEDveis",
      tags: ["Reports"],
      response: {
        200: {
          type: "object",
          properties: {
            reportTypes: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  type: { type: "string" },
                  name: { type: "string" },
                  description: { type: "string" },
                  supportedFormats: {
                    type: "array",
                    items: { type: "string" }
                  }
                }
              }
            }
          }
        }
      }
    },
    handler: ReportController.getAvailableReportTypes
  });
  fastify2.get("/statistics", {
    schema: {
      description: "Obter estat\xEDsticas de relat\xF3rios",
      tags: ["Reports"],
      response: {
        200: {
          type: "object",
          properties: {
            totalReports: { type: "number" },
            reportsByType: { type: "object" },
            reportsByFormat: { type: "object" },
            lastGenerated: { type: "string", nullable: true }
          }
        }
      }
    },
    handler: ReportController.getReportStatistics
  });
  fastify2.post("/validate-filters", {
    schema: {
      description: "Validar filtros de relat\xF3rio",
      tags: ["Reports"],
      body: {
        type: "object",
        required: ["filters"],
        properties: {
          filters: {
            type: "object",
            properties: {
              storeId: { type: "string" },
              startDate: { type: "string", format: "date" },
              endDate: { type: "string", format: "date" },
              categoryId: { type: "string" },
              supplierId: { type: "string" },
              productId: { type: "string" },
              userId: { type: "string" },
              status: { type: "string" },
              type: { type: "string" },
              page: { type: "number", minimum: 1 },
              limit: { type: "number", minimum: 1, maximum: 1e3 }
            }
          }
        }
      },
      response: {
        200: {
          type: "object",
          properties: {
            isValid: { type: "boolean" },
            errors: {
              type: "array",
              items: { type: "string" }
            }
          }
        }
      }
    },
    handler: ReportController.validateFilters
  });
  fastify2.get("/download/:exportId", {
    schema: {
      description: "Download de relat\xF3rio exportado",
      tags: ["Reports"],
      params: {
        type: "object",
        properties: {
          exportId: { type: "string" }
        },
        required: ["exportId"]
      },
      response: {
        200: {
          type: "string",
          description: "File content"
        },
        500: {
          type: "object",
          properties: {
            error: { type: "string" }
          }
        }
      }
    },
    handler: async (request, reply) => {
      try {
        const { exportId } = request.params;
        reply.type("application/json");
        return reply.send({
          message: "Download endpoint - implementation needed",
          exportId,
          note: "This would return the actual file content"
        });
      } catch (error) {
        request.log.error(error);
        return reply.status(500).send({
          error: "Erro ao fazer download do relat\xF3rio"
        });
      }
    }
  });
}

// src/features/notification/queries/notification.queries.ts
init_prisma();
var NotificationQueries = {
  async getById(id) {
    return await db.notification.findUnique({
      where: { id },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async list(params) {
    const { page = 1, limit = 10, search, type, priority, isRead, userId } = params;
    const skip2 = (page - 1) * limit;
    const where = {};
    if (userId) {
      where.userId = userId;
    }
    if (type) {
      where.type = type;
    }
    if (priority) {
      where.priority = priority;
    }
    if (isRead !== void 0) {
      where.isRead = isRead;
    }
    if (search) {
      where.OR = [
        { title: { contains: search, mode: "insensitive" } },
        { message: { contains: search, mode: "insensitive" } }
      ];
    }
    where.OR = [
      { expiresAt: null },
      { expiresAt: { gt: /* @__PURE__ */ new Date() } }
    ];
    const [items, total] = await Promise.all([
      db.notification.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      }),
      db.notification.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getByUser(userId, params) {
    return await NotificationQueries.list({
      userId,
      ...params
    });
  },
  async getUnread(userId, limit) {
    return await db.notification.findMany({
      where: {
        userId,
        isRead: false,
        OR: [
          { expiresAt: null },
          { expiresAt: { gt: /* @__PURE__ */ new Date() } }
        ]
      },
      take: limit || 10,
      orderBy: [
        { priority: "desc" },
        { createdAt: "desc" }
      ],
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async getByType(type, limit) {
    return await db.notification.findMany({
      where: {
        type,
        OR: [
          { expiresAt: null },
          { expiresAt: { gt: /* @__PURE__ */ new Date() } }
        ]
      },
      take: limit || 10,
      orderBy: { createdAt: "desc" },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async getByPriority(priority, limit) {
    return await db.notification.findMany({
      where: {
        priority,
        OR: [
          { expiresAt: null },
          { expiresAt: { gt: /* @__PURE__ */ new Date() } }
        ]
      },
      take: limit || 10,
      orderBy: { createdAt: "desc" },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async search(term, limit = 10) {
    return await db.notification.findMany({
      where: {
        AND: [
          {
            OR: [
              { title: { contains: term, mode: "insensitive" } },
              { message: { contains: term, mode: "insensitive" } }
            ]
          },
          {
            OR: [
              { expiresAt: null },
              { expiresAt: { gt: /* @__PURE__ */ new Date() } }
            ]
          }
        ]
      },
      take: limit,
      orderBy: { createdAt: "desc" },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async getStats(userId) {
    const where = userId ? { userId } : {};
    const [total, unread, byType, byPriority] = await Promise.all([
      db.notification.count({ where }),
      db.notification.count({
        where: {
          ...where,
          isRead: false,
          OR: [
            { expiresAt: null },
            { expiresAt: { gt: /* @__PURE__ */ new Date() } }
          ]
        }
      }),
      db.notification.groupBy({
        by: ["type"],
        where,
        _count: true
      }),
      db.notification.groupBy({
        by: ["priority"],
        where,
        _count: true
      })
    ]);
    return {
      total,
      unread,
      read: total - unread,
      byType: byType.reduce((acc, item) => {
        acc[item.type] = item._count;
        return acc;
      }, {}),
      byPriority: byPriority.reduce((acc, item) => {
        acc[item.priority] = item._count;
        return acc;
      }, {})
    };
  },
  async getRecent(userId, days = 7, limit = 20) {
    const startDate = /* @__PURE__ */ new Date();
    startDate.setDate(startDate.getDate() - days);
    return await db.notification.findMany({
      where: {
        userId,
        createdAt: {
          gte: startDate
        },
        OR: [
          { expiresAt: null },
          { expiresAt: { gt: /* @__PURE__ */ new Date() } }
        ]
      },
      take: limit,
      orderBy: { createdAt: "desc" },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  // === QUERIES ESPECÍFICAS PARA ALERTAS DE ESTOQUE ===
  async getStockAlerts(params) {
    const { userId, storeId, isRead, limit = 20 } = params;
    const where = {
      type: "STOCK_ALERT",
      OR: [
        { expiresAt: null },
        { expiresAt: { gt: /* @__PURE__ */ new Date() } }
      ]
    };
    if (userId) {
      where.userId = userId;
    }
    if (isRead !== void 0) {
      where.isRead = isRead;
    }
    if (storeId) {
      where.data = {
        path: ["storeId"],
        equals: storeId
      };
    }
    return await db.notification.findMany({
      where,
      take: limit,
      orderBy: [
        { priority: "desc" },
        { createdAt: "desc" }
      ],
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async getUnreadStockAlerts(userId, limit = 10) {
    return await db.notification.findMany({
      where: {
        userId,
        type: "STOCK_ALERT",
        isRead: false,
        OR: [
          { expiresAt: null },
          { expiresAt: { gt: /* @__PURE__ */ new Date() } }
        ]
      },
      take: limit,
      orderBy: [
        { priority: "desc" },
        { createdAt: "desc" }
      ],
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  }
};

// src/features/notification/notification.controller.ts
var NotificationController = {
  // === CRUD BÁSICO ===
  async create(request, reply) {
    try {
      const { userId, title, message, type, priority, data, actionUrl, expiresAt } = request.body;
      const result = await NotificationCommands.create({
        userId,
        title,
        message,
        type,
        priority,
        data,
        actionUrl,
        expiresAt: expiresAt ? new Date(expiresAt) : void 0
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      const result = await NotificationQueries.getById(id);
      if (!result) {
        return reply.status(404).send({
          error: "Notification not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Notification not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      if (updateData.expiresAt) {
        updateData.expiresAt = new Date(updateData.expiresAt);
      }
      const result = await NotificationCommands.update(id, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Notification not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Validation error") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      await NotificationCommands.delete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Notification not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { page = 1, limit = 10, search, type, priority, isRead, userId } = request.query;
      const result = await NotificationQueries.list({
        page,
        limit,
        search,
        type,
        priority,
        isRead,
        userId
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (QUERIES) ===
  async getByUser(request, reply) {
    try {
      const { userId } = request.params;
      const { page = 1, limit = 10, isRead, type } = request.query;
      const result = await NotificationQueries.getByUser(userId, {
        page,
        limit,
        isRead,
        type
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getUnread(request, reply) {
    try {
      const { userId } = request.params;
      const { limit = 10 } = request.query;
      const result = await NotificationQueries.getUnread(userId, limit);
      return reply.send({ notifications: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByType(request, reply) {
    try {
      const { type } = request.params;
      const { limit = 10 } = request.query;
      const result = await NotificationQueries.getByType(type, limit);
      return reply.send({ notifications: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByPriority(request, reply) {
    try {
      const { priority } = request.params;
      const { limit = 10 } = request.query;
      const result = await NotificationQueries.getByPriority(priority, limit);
      return reply.send({ notifications: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getRecent(request, reply) {
    try {
      const { userId } = request.params;
      const { days = 7, limit = 20 } = request.query;
      const result = await NotificationQueries.getRecent(userId, days, limit);
      return reply.send({ notifications: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const { userId } = request.query;
      const result = await NotificationQueries.getStats(userId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { q, limit = 10 } = request.query;
      const result = await NotificationQueries.search(q, limit);
      return reply.send({ notifications: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (COMMANDS) ===
  async markAsRead(request, reply) {
    try {
      const { id } = request.params;
      const result = await NotificationCommands.markAsRead(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Notification not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async markAsUnread(request, reply) {
    try {
      const { id } = request.params;
      const result = await NotificationCommands.markAsUnread(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Notification not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async markAllAsRead(request, reply) {
    try {
      const { userId } = request.body;
      const result = await NotificationCommands.markAllAsRead(userId);
      return reply.send({
        success: true,
        count: result.count
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async deleteExpired(request, reply) {
    try {
      const result = await NotificationCommands.deleteExpired();
      return reply.send({
        success: true,
        count: result.count
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async deleteByUser(request, reply) {
    try {
      const { userId } = request.params;
      const result = await NotificationCommands.deleteByUser(userId);
      return reply.send({
        success: true,
        count: result.count
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === ENDPOINTS ESPECÍFICOS PARA ALERTAS DE ESTOQUE ===
  async getStockAlerts(request, reply) {
    try {
      const { userId, storeId, isRead, limit = 20 } = request.query;
      const result = await NotificationQueries.getStockAlerts({
        userId,
        storeId,
        isRead,
        limit
      });
      return reply.send({ notifications: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getUnreadStockAlerts(request, reply) {
    try {
      const { userId } = request.params;
      const { limit = 10 } = request.query;
      const result = await NotificationQueries.getUnreadStockAlerts(userId, limit);
      return reply.send({ notifications: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async markStockAlertsAsRead(request, reply) {
    try {
      const { userId, storeId } = request.body;
      const result = await NotificationCommands.markStockAlertsAsRead(userId, storeId);
      return reply.send({
        success: true,
        count: result.count
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/notification/notification.schema.ts
var notificationTypeEnum = ["INFO", "SUCCESS", "WARNING", "ERROR", "STOCK_ALERT", "MOVEMENT", "PERMISSION", "SYSTEM"];
var notificationPriorityEnum = ["LOW", "MEDIUM", "HIGH", "URGENT"];
var notificationResponseSchema = {
  type: "object",
  properties: {
    id: { type: "string" },
    userId: { type: "string" },
    title: { type: "string" },
    message: { type: "string" },
    type: { type: "string", enum: notificationTypeEnum },
    priority: { type: "string", enum: notificationPriorityEnum },
    isRead: { type: "boolean" },
    readAt: { type: ["string", "null"], format: "date-time" },
    data: { type: "object" },
    actionUrl: { type: ["string", "null"] },
    expiresAt: { type: ["string", "null"], format: "date-time" },
    createdAt: { type: "string", format: "date-time" },
    updatedAt: { type: "string", format: "date-time" },
    user: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: ["string", "null"] },
        email: { type: "string" }
      }
    }
  }
};
var createNotificationSchema = {
  body: {
    type: "object",
    required: ["userId", "title", "message"],
    properties: {
      userId: { type: "string" },
      title: { type: "string", minLength: 1, maxLength: 255 },
      message: { type: "string", minLength: 1, maxLength: 1e3 },
      type: { type: "string", enum: notificationTypeEnum, default: "INFO" },
      priority: { type: "string", enum: notificationPriorityEnum, default: "MEDIUM" },
      data: { type: "object" },
      actionUrl: { type: "string", format: "uri" },
      expiresAt: { type: "string", format: "date-time" }
    }
  },
  response: {
    201: notificationResponseSchema,
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var updateNotificationSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      title: { type: "string", minLength: 1, maxLength: 255 },
      message: { type: "string", minLength: 1, maxLength: 1e3 },
      type: { type: "string", enum: notificationTypeEnum },
      priority: { type: "string", enum: notificationPriorityEnum },
      data: { type: "object" },
      actionUrl: { type: "string", format: "uri" },
      expiresAt: { type: "string", format: "date-time" }
    }
  },
  response: {
    200: notificationResponseSchema,
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getNotificationSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: notificationResponseSchema,
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var listNotificationsSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      type: { type: "string", enum: notificationTypeEnum },
      priority: { type: "string", enum: notificationPriorityEnum },
      isRead: { type: "boolean" },
      userId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: notificationResponseSchema
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var deleteNotificationSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var markAsReadSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: notificationResponseSchema,
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var markAllAsReadSchema = {
  body: {
    type: "object",
    required: ["userId"],
    properties: {
      userId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        success: { type: "boolean" },
        count: { type: "number" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getByUserSchema = {
  params: {
    type: "object",
    required: ["userId"],
    properties: {
      userId: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      isRead: { type: "boolean" },
      type: { type: "string", enum: notificationTypeEnum }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: notificationResponseSchema
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getUnreadSchema = {
  params: {
    type: "object",
    required: ["userId"],
    properties: {
      userId: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        notifications: {
          type: "array",
          items: notificationResponseSchema
        }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getByTypeSchema = {
  params: {
    type: "object",
    required: ["type"],
    properties: {
      type: { type: "string", enum: notificationTypeEnum }
    }
  },
  querystring: {
    type: "object",
    properties: {
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        notifications: {
          type: "array",
          items: notificationResponseSchema
        }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getByPrioritySchema = {
  params: {
    type: "object",
    required: ["priority"],
    properties: {
      priority: { type: "string", enum: notificationPriorityEnum }
    }
  },
  querystring: {
    type: "object",
    properties: {
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        notifications: {
          type: "array",
          items: notificationResponseSchema
        }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getRecentSchema = {
  params: {
    type: "object",
    required: ["userId"],
    properties: {
      userId: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      days: { type: "number", minimum: 1, maximum: 365, default: 7 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 20 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        notifications: {
          type: "array",
          items: notificationResponseSchema
        }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getStatsSchema = {
  querystring: {
    type: "object",
    properties: {
      userId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        total: { type: "number" },
        unread: { type: "number" },
        read: { type: "number" },
        byType: { type: "object" },
        byPriority: { type: "object" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var searchSchema = {
  querystring: {
    type: "object",
    required: ["q"],
    properties: {
      q: { type: "string", minLength: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        notifications: {
          type: "array",
          items: notificationResponseSchema
        }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var NotificationSchemas = {
  create: createNotificationSchema,
  update: updateNotificationSchema,
  get: getNotificationSchema,
  delete: deleteNotificationSchema,
  list: listNotificationsSchema,
  markAsRead: markAsReadSchema,
  markAllAsRead: markAllAsReadSchema,
  getByUser: getByUserSchema,
  getUnread: getUnreadSchema,
  getByType: getByTypeSchema,
  getByPriority: getByPrioritySchema,
  getRecent: getRecentSchema,
  getStats: getStatsSchema,
  search: searchSchema
};

// src/features/notification/notification.routes.ts
init_auth_middleware();
async function NotificationRoutes(fastify2) {
  fastify2.post("/", {
    schema: NotificationSchemas.create,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.create
  });
  fastify2.get("/", {
    schema: NotificationSchemas.list,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.list
  });
  fastify2.get("/:id", {
    schema: NotificationSchemas.get,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.get
  });
  fastify2.put("/:id", {
    schema: NotificationSchemas.update,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.update
  });
  fastify2.delete("/:id", {
    schema: NotificationSchemas.delete,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.delete
  });
  fastify2.get("/user/:userId", {
    schema: NotificationSchemas.getByUser,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.getByUser
  });
  fastify2.get("/user/:userId/unread", {
    schema: NotificationSchemas.getUnread,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.getUnread
  });
  fastify2.get("/user/:userId/recent", {
    schema: NotificationSchemas.getRecent,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.getRecent
  });
  fastify2.get("/type/:type", {
    schema: NotificationSchemas.getByType,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.getByType
  });
  fastify2.get("/priority/:priority", {
    schema: NotificationSchemas.getByPriority,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.getByPriority
  });
  fastify2.get("/stats", {
    schema: NotificationSchemas.getStats,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.getStats
  });
  fastify2.get("/search", {
    schema: NotificationSchemas.search,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.search
  });
  fastify2.patch("/:id/read", {
    schema: NotificationSchemas.markAsRead,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.markAsRead
  });
  fastify2.patch("/:id/unread", {
    schema: NotificationSchemas.markAsRead,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.markAsUnread
  });
  fastify2.patch("/mark-all-read", {
    schema: NotificationSchemas.markAllAsRead,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.markAllAsRead
  });
  fastify2.delete("/expired", {
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.deleteExpired
  });
  fastify2.delete("/user/:userId", {
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.deleteByUser
  });
  fastify2.get("/stock-alerts", {
    schema: {
      querystring: {
        type: "object",
        properties: {
          userId: { type: "string" },
          storeId: { type: "string" },
          isRead: { type: "boolean" },
          limit: { type: "number", minimum: 1, maximum: 100 }
        }
      }
    },
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.getStockAlerts
  });
  fastify2.get("/user/:userId/stock-alerts/unread", {
    schema: {
      params: {
        type: "object",
        required: ["userId"],
        properties: {
          userId: { type: "string" }
        }
      },
      querystring: {
        type: "object",
        properties: {
          limit: { type: "number", minimum: 1, maximum: 100 }
        }
      }
    },
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.getUnreadStockAlerts
  });
  fastify2.patch("/stock-alerts/mark-read", {
    schema: {
      body: {
        type: "object",
        required: ["userId"],
        properties: {
          userId: { type: "string" },
          storeId: { type: "string" }
        }
      }
    },
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.markStockAlertsAsRead
  });
}

// src/features/chat/queries/chat.query.ts
init_prisma();
var ChatToolbox = class {
  constructor(prisma2) {
    this.prisma = prisma2;
  }
  // === SERVIÇOS DE PRODUTOS ===
  async getProducts(params) {
    return await ProductQueries.list(params);
  }
  async getProductById(id, storeId) {
    if (!storeId) {
      throw new Error("Store ID is required for product queries");
    }
    return await ProductQueries.getById(id, storeId);
  }
  async searchProducts(term, params = {}) {
    return await ProductQueries.search(term, params);
  }
  async getActiveProducts(storeId) {
    if (!storeId) {
      throw new Error("Store ID is required for product queries");
    }
    return await ProductQueries.getActive(storeId);
  }
  async getProductStats(storeId) {
    if (!storeId) {
      throw new Error("Store ID is required for product queries");
    }
    return await ProductQueries.getStats(storeId);
  }
  async getLowStockProducts(storeId) {
    return await ProductQueries.getLowStockProducts(storeId);
  }
  // === SERVIÇOS DE LOJAS ===
  async getStores(params) {
    return await StoreQueries.list(params);
  }
  async getStoreById(id) {
    return await StoreQueries.getById(id);
  }
  async searchStores(term, limit = 10) {
    return await StoreQueries.search(term, limit);
  }
  async getActiveStores() {
    return await StoreQueries.getActive();
  }
  async getStoreStats() {
    return await StoreQueries.getStats();
  }
  // === SERVIÇOS DE CATEGORIAS ===
  async getCategories(params) {
    return await CategoryQueries.list(params);
  }
  async getCategoryById(id) {
    return await CategoryQueries.getById(id);
  }
  async searchCategories(term, limit = 10, storeId) {
    if (!storeId) {
      throw new Error("Store ID is required for category queries");
    }
    return await CategoryQueries.search(term, storeId, limit);
  }
  async getActiveCategories(storeId) {
    if (!storeId) {
      throw new Error("Store ID is required for category queries");
    }
    return await CategoryQueries.getActive(storeId);
  }
  async getCategoryStats(storeId) {
    if (!storeId) {
      throw new Error("Store ID is required for category queries");
    }
    return await CategoryQueries.getStats(storeId);
  }
  async getCategoryHierarchy(storeId) {
    if (!storeId) {
      throw new Error("Store ID is required for category queries");
    }
    return await CategoryQueries.getHierarchy(storeId);
  }
  // === SERVIÇOS DE FORNECEDORES ===
  async getSuppliers(params) {
    return await SupplierQueries.list(params);
  }
  async getSupplierById(id) {
    return await SupplierQueries.getById(id);
  }
  async searchSuppliers(term, limit = 10) {
    return await SupplierQueries.search(term, limit);
  }
  async getActiveSuppliers() {
    return await SupplierQueries.getActive();
  }
  async getSupplierStats() {
    return await SupplierQueries.getStats();
  }
  // === SERVIÇOS DE MOVIMENTAÇÕES ===
  async getMovements(params) {
    return await MovementQueries.list(params);
  }
  async getMovementById(id) {
    return await MovementQueries.getById(id);
  }
  async getMovementStats() {
    return await MovementQueries.getStats();
  }
  async getRecentMovements(limit = 10) {
    return;
  }
  // === SERVIÇOS DE RELATÓRIOS ===
  async getReports(params) {
    return;
  }
  async getReportById(id) {
    return;
  }
  async getReportStats() {
    return;
  }
  // === MÉTODO PARA EXECUTAR COMANDOS DINÂMICOS ===
  async executeCommand(command, params = {}) {
    const [service, method] = command.split(".");
    switch (service) {
      case "products":
        return await this.executeProductCommand(method, params);
      case "stores":
        return await this.executeStoreCommand(method, params);
      case "categories":
        return await this.executeCategoryCommand(method, params);
      case "suppliers":
        return await this.executeSupplierCommand(method, params);
      case "movements":
        return await this.executeMovementCommand(method, params);
      case "reports":
        return await this.executeReportCommand(method, params);
      default:
        throw new Error(`Unknown service: ${service}`);
    }
  }
  async executeProductCommand(method, params) {
    switch (method) {
      case "list":
        return await this.getProducts(params);
      case "getById":
        return await this.getProductById(params.id, params.storeId);
      case "search":
        return await this.searchProducts(params.term, params.limit);
      case "getActive":
        return await this.getActiveProducts();
      case "getStats":
        return await this.getProductStats();
      case "getLowStock":
        return await this.getLowStockProducts(params.storeId);
      default:
        throw new Error(`Unknown product method: ${method}`);
    }
  }
  async executeStoreCommand(method, params) {
    switch (method) {
      case "list":
        return await this.getStores(params);
      case "getById":
        return await this.getStoreById(params.id);
      case "search":
        return await this.searchStores(params.term, params.limit);
      case "getActive":
        return await this.getActiveStores();
      case "getStats":
        return await this.getStoreStats();
      default:
        throw new Error(`Unknown store method: ${method}`);
    }
  }
  async executeCategoryCommand(method, params) {
    switch (method) {
      case "list":
        return await this.getCategories(params);
      case "getById":
        return await this.getCategoryById(params.id);
      case "search":
        return await this.searchCategories(params.term, params.limit);
      case "getActive":
        return await this.getActiveCategories();
      case "getStats":
        return await this.getCategoryStats();
      case "getHierarchy":
        return await this.getCategoryHierarchy();
      default:
        throw new Error(`Unknown category method: ${method}`);
    }
  }
  async executeSupplierCommand(method, params) {
    switch (method) {
      case "list":
        return await this.getSuppliers(params);
      case "getById":
        return await this.getSupplierById(params.id);
      case "search":
        return await this.searchSuppliers(params.term, params.limit);
      case "getActive":
        return await this.getActiveSuppliers();
      case "getStats":
        return await this.getSupplierStats();
      default:
        throw new Error(`Unknown supplier method: ${method}`);
    }
  }
  async executeMovementCommand(method, params) {
    switch (method) {
      case "list":
        return await this.getMovements(params);
      case "getById":
        return await this.getMovementById(params.id);
      case "getStats":
        return await this.getMovementStats();
      case "getRecent":
        return await this.getRecentMovements(params.limit);
      default:
        throw new Error(`Unknown movement method: ${method}`);
    }
  }
  async executeReportCommand(method, params) {
    switch (method) {
      case "list":
        return await this.getReports(params);
      case "getById":
        return await this.getReportById(params.id);
      case "getStats":
        return await this.getReportStats();
      default:
        throw new Error(`Unknown report method: ${method}`);
    }
  }
};
var ChatQueries = {
  async getById(id) {
    const chatMessage = await db.chatMessage.findUnique({
      where: { id },
      include: {
        session: {
          select: {
            id: true,
            userId: true,
            storeId: true,
            title: true
          }
        }
      }
    });
    if (!chatMessage) {
      throw new Error("Chat message not found");
    }
    return chatMessage;
  },
  async list(params) {
    const { page = 1, limit = 10, sessionId, userId, storeId } = params;
    const skip2 = (page - 1) * Number(limit);
    const takeLimit = Number(limit);
    const where = {};
    if (sessionId) {
      where.sessionId = sessionId;
    }
    if (userId) {
      where.session = {
        userId
      };
    }
    if (storeId) {
      where.session = {
        ...where.session,
        storeId
      };
    }
    const [items, total] = await Promise.all([
      db.chatMessage.findMany({
        where,
        skip: skip2,
        take: takeLimit,
        orderBy: { createdAt: "desc" },
        include: {
          session: {
            select: {
              id: true,
              userId: true,
              storeId: true,
              title: true
            }
          }
        }
      }),
      db.chatMessage.count({ where })
    ]);
    const formattedItems = items.map((item) => ({
      id: item.id,
      interaction: {
        user: {
          message: item.content,
          timestamp: item.createdAt
        },
        ai: {
          response: item.content,
          timestamp: item.createdAt
        }
      },
      context: item.context,
      options: item.options,
      createdAt: item.createdAt,
      updatedAt: item.updatedAt,
      session: item.session
    }));
    return {
      items: formattedItems,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  // === FORMATO TRADICIONAL (compatibilidade) ===
  async listTraditional(params) {
    const { page = 1, limit = 10, sessionId, userId, storeId } = params;
    const skip2 = (page - 1) * Number(limit);
    const takeLimit = Number(limit);
    const where = {};
    if (sessionId) {
      where.sessionId = sessionId;
    }
    if (userId) {
      where.session = {
        userId
      };
    }
    if (storeId) {
      where.session = {
        ...where.session,
        storeId
      };
    }
    const [items, total] = await Promise.all([
      db.chatMessage.findMany({
        where,
        skip: skip2,
        take: takeLimit,
        orderBy: { createdAt: "desc" },
        include: {
          session: {
            select: {
              id: true,
              userId: true,
              storeId: true,
              title: true
            }
          }
        }
      }),
      db.chatMessage.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getSessionById(sessionId, params) {
    const { page = 1, limit = 20 } = params || {};
    const skip2 = (page - 1) * Number(limit);
    const takeLimit = Number(limit);
    const session = await db.chatSession.findUnique({
      where: { id: sessionId },
      include: {
        messages: {
          select: {
            id: true,
            content: true,
            isFromUser: true,
            createdAt: true,
            updatedAt: true
          },
          orderBy: { createdAt: "asc" },
          skip: skip2,
          take: takeLimit
        }
      }
    });
    if (!session) {
      throw new Error("Chat session not found");
    }
    const totalMessages = await db.chatMessage.count({
      where: { sessionId }
    });
    const formattedMessages = [];
    session.messages.forEach((message) => {
      formattedMessages.push({
        id: `${message.id}_user`,
        content: message.content,
        isUser: true,
        createdAt: message.createdAt,
        updatedAt: message.updatedAt
      });
      formattedMessages.push({
        id: `${message.id}_ai`,
        content: message.content,
        isUser: false,
        createdAt: message.createdAt,
        updatedAt: message.updatedAt
      });
    });
    return {
      id: session.id,
      userId: session.userId,
      storeId: session.storeId,
      title: session.title,
      createdAt: session.createdAt,
      updatedAt: session.updatedAt,
      messages: formattedMessages,
      pagination: {
        page,
        limit,
        total: totalMessages,
        totalPages: Math.ceil(totalMessages / limit)
      }
    };
  },
  async getSessions(params) {
    const { page = 1, limit = 10, userId, storeId } = params;
    const skip2 = (page - 1) * Number(limit);
    const takeLimit = Number(limit);
    const where = {};
    if (userId) {
      where.userId = userId;
    }
    if (storeId) {
      where.storeId = storeId;
    }
    const [items, total] = await Promise.all([
      db.chatSession.findMany({
        where,
        skip: skip2,
        take: takeLimit,
        orderBy: { updatedAt: "desc" },
        include: {
          _count: {
            select: {
              messages: true
            }
          }
        }
      }),
      db.chatSession.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getToolbox() {
    return {
      availableServices: {
        products: {
          description: "Servi\xE7os para gerenciar produtos, estoque e categorias",
          methods: [
            "products.list - Listar produtos com filtros",
            "products.getById - Buscar produto por ID",
            "products.search - Buscar produtos por termo",
            "products.getActive - Listar produtos ativos",
            "products.getStats - Estat\xEDsticas de produtos",
            "products.getLowStock - Produtos com estoque baixo"
          ]
        },
        stores: {
          description: "Servi\xE7os para gerenciar lojas e usu\xE1rios",
          methods: [
            "stores.list - Listar lojas com filtros",
            "stores.getById - Buscar loja por ID",
            "stores.search - Buscar lojas por termo",
            "stores.getActive - Listar lojas ativas",
            "stores.getStats - Estat\xEDsticas de lojas"
          ]
        },
        categories: {
          description: "Servi\xE7os para gerenciar categorias de produtos",
          methods: [
            "categories.list - Listar categorias com filtros",
            "categories.getById - Buscar categoria por ID",
            "categories.search - Buscar categorias por termo",
            "categories.getActive - Listar categorias ativas",
            "categories.getStats - Estat\xEDsticas de categorias",
            "categories.getHierarchy - Hierarquia de categorias"
          ]
        },
        suppliers: {
          description: "Servi\xE7os para gerenciar fornecedores",
          methods: [
            "suppliers.list - Listar fornecedores com filtros",
            "suppliers.getById - Buscar fornecedor por ID",
            "suppliers.search - Buscar fornecedores por termo",
            "suppliers.getActive - Listar fornecedores ativos",
            "suppliers.getStats - Estat\xEDsticas de fornecedores"
          ]
        },
        movements: {
          description: "Servi\xE7os para gerenciar movimenta\xE7\xF5es de estoque",
          methods: [
            "movements.list - Listar movimenta\xE7\xF5es com filtros",
            "movements.getById - Buscar movimenta\xE7\xE3o por ID",
            "movements.getStats - Estat\xEDsticas de movimenta\xE7\xF5es",
            "movements.getRecent - Movimenta\xE7\xF5es recentes"
          ]
        },
        reports: {
          description: "Servi\xE7os para gerenciar relat\xF3rios",
          methods: [
            "reports.list - Listar relat\xF3rios com filtros",
            "reports.getById - Buscar relat\xF3rio por ID",
            "reports.getStats - Estat\xEDsticas de relat\xF3rios"
          ]
        }
      }
    };
  },
  async getAnalytics(params) {
    const { startDate, endDate, userId, storeId } = params;
    const where = {};
    if (userId) {
      where.session = {
        userId
      };
    }
    if (storeId) {
      where.session = {
        ...where.session,
        storeId
      };
    }
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) {
        where.createdAt.gte = new Date(startDate);
      }
      if (endDate) {
        where.createdAt.lte = new Date(endDate);
      }
    }
    const [totalMessages, totalSessions, messagesByDay] = await Promise.all([
      db.chatMessage.count({ where }),
      db.chatSession.count({
        where: userId ? { userId } : storeId ? { storeId } : {}
      }),
      db.chatMessage.groupBy({
        by: ["createdAt"],
        where,
        _count: { id: true },
        orderBy: { createdAt: "desc" },
        take: 30
      })
    ]);
    const averageMessagesPerSession = totalSessions > 0 ? totalMessages / totalSessions : 0;
    return {
      totalMessages,
      totalSessions,
      averageMessagesPerSession: Math.round(averageMessagesPerSession * 100) / 100,
      mostUsedServices: [],
      // Implementar análise de serviços mais usados
      messagesByDay: messagesByDay.map((item) => ({
        date: item.createdAt.toISOString().split("T")[0],
        count: item._count.id
      }))
    };
  },
  async search(term, limit = 10) {
    const messages = await db.chatMessage.findMany({
      where: {
        OR: [
          { content: { contains: term, mode: "insensitive" } }
        ]
      },
      take: Number(limit),
      orderBy: { createdAt: "desc" },
      include: {
        session: {
          select: {
            id: true,
            userId: true,
            storeId: true,
            title: true
          }
        }
      }
    });
    return messages;
  }
};

// src/features/chat/commands/chat.commands.ts
init_prisma();
var ChatCommands = {
  // === CRIAÇÃO DE SESSÃO ===
  async createSession(data) {
    const session = await db.chatSession.create({
      data: {
        userId: data.userId,
        storeId: data.storeId,
        title: data.title || "\u{1F4AC} Nova conversa"
      }
    });
    return session;
  },
  // === CRIAÇÃO DE MENSAGEM ===
  async createMessage(data) {
    const chatMessage = await db.chatMessage.create({
      data: {
        content: data.content,
        isFromUser: data.isFromUser,
        sessionId: data.sessionId,
        context: data.context || {},
        options: data.options || {}
      },
      include: {
        session: {
          select: {
            id: true,
            userId: true,
            storeId: true,
            title: true
          }
        }
      }
    });
    return chatMessage;
  },
  // === PROCESSAMENTO COMPLETO DE MENSAGEM ===
  async processMessage(data) {
    let sessionId = data.context?.sessionId;
    if (!sessionId) {
      const session = await ChatCommands.createSession({
        userId: data.context?.userId || "anonymous",
        storeId: data.context?.storeId,
        title: data.message.substring(0, 50) + (data.message.length > 50 ? "..." : "")
      });
      sessionId = session.id;
    }
    const toolbox = new ChatToolbox(db);
    let systemData = "";
    const message = data.message.toLowerCase();
    if (message.includes("produto") || message.includes("estoque") || message.includes("invent\xE1rio")) {
      try {
        const products = await toolbox.executeCommand("products.list", {
          limit: 10,
          ...data.context?.storeId && { storeId: data.context.storeId }
        });
        systemData += `
DADOS DE PRODUTOS DISPON\xCDVEIS:
${JSON.stringify(products, null, 2)}
`;
      } catch (error) {
        systemData += `
Erro ao buscar produtos: ${error.message}
`;
      }
    }
    if (message.includes("categoria") || message.includes("categorias")) {
      try {
        const categories = await toolbox.executeCommand("categories.list", { limit: 10 });
        systemData += `
DADOS DE CATEGORIAS DISPON\xCDVEIS:
${JSON.stringify(categories, null, 2)}
`;
      } catch (error) {
        systemData += `
Erro ao buscar categorias: ${error.message}
`;
      }
    }
    if (message.includes("loja") || message.includes("lojas") || message.includes("store")) {
      try {
        const stores = await toolbox.executeCommand("stores.list", { limit: 10 });
        systemData += `
DADOS DE LOJAS DISPON\xCDVEIS:
${JSON.stringify(stores, null, 2)}
`;
      } catch (error) {
        systemData += `
Erro ao buscar lojas: ${error.message}
`;
      }
    }
    if (message.includes("fornecedor") || message.includes("fornecedores") || message.includes("supplier")) {
      try {
        const suppliers = await toolbox.executeCommand("suppliers.list", { limit: 10 });
        systemData += `
DADOS DE FORNECEDORES DISPON\xCDVEIS:
${JSON.stringify(suppliers, null, 2)}
`;
      } catch (error) {
        systemData += `
Erro ao buscar fornecedores: ${error.message}
`;
      }
    }
    if (message.includes("movimenta\xE7\xE3o") || message.includes("movimenta\xE7\xF5es") || message.includes("movimento")) {
      try {
        const movements = await toolbox.executeCommand("movements.list", { limit: 10 });
        systemData += `
DADOS DE MOVIMENTA\xC7\xD5ES DISPON\xCDVEIS:
${JSON.stringify(movements, null, 2)}
`;
      } catch (error) {
        systemData += `
Erro ao buscar movimenta\xE7\xF5es: ${error.message}
`;
      }
    }
    const toolboxInfo = await ChatQueries.getToolbox();
    const systemPrompt = `
Voc\xEA \xE9 um assistente inteligente para um sistema de gest\xE3o de estoque. 
Voc\xEA tem acesso aos seguintes servi\xE7os atrav\xE9s da toolbox:

${JSON.stringify(toolboxInfo, null, 2)}

${systemData}

Para acessar os servi\xE7os, use comandos no formato: service.method
Exemplo: products.list, stores.getById, categories.search

Responda de forma \xFAtil e precisa, sempre em portugu\xEAs.
Use os dados fornecidos acima para responder \xE0s perguntas do usu\xE1rio de forma espec\xEDfica e precisa.

Mensagem do usu\xE1rio: ${data.message}
`;
    let response;
    if (data.options) {
      const llmResponse = await LLMService.executeWithOptions(systemPrompt, data.options);
      response = typeof llmResponse === "string" ? llmResponse : String(llmResponse);
    } else {
      const llmResponse = await LLMService.executePrompt(systemPrompt);
      response = typeof llmResponse === "string" ? llmResponse : String(llmResponse);
    }
    const chatMessage = await ChatCommands.createMessage({
      content: data.message,
      isFromUser: true,
      sessionId,
      context: data.context || {},
      options: data.options || {}
    });
    await ChatCommands.updateSessionTimestamp(sessionId);
    await ChatCommands.updateSessionTitleIntelligent(sessionId);
    return chatMessage;
  },
  // === GERAR TÍTULO INTELIGENTE ===
  async generateSmartTitle(messages) {
    if (messages.length === 0) return "Nova conversa";
    const recentMessages = messages.slice(-3);
    const allText = recentMessages.map((m) => `${m.message} ${m.response}`).join(" ").toLowerCase();
    if (allText.includes("produto") || allText.includes("estoque") || allText.includes("invent\xE1rio")) {
      if (allText.includes("baixo") || allText.includes("cr\xEDtico")) {
        return "\u{1F4E6} An\xE1lise de Estoque Cr\xEDtico";
      }
      if (allText.includes("relat\xF3rio") || allText.includes("relatorio")) {
        return "\u{1F4CA} Relat\xF3rio de Produtos";
      }
      if (allText.includes("categoria") || allText.includes("categorias")) {
        return "\u{1F4C2} Produtos por Categoria";
      }
      return "\u{1F4E6} Consulta de Produtos";
    }
    if (allText.includes("categoria") || allText.includes("categorias")) {
      if (allText.includes("hierarquia") || allText.includes("estrutura")) {
        return "\u{1F333} Hierarquia de Categorias";
      }
      if (allText.includes("criar") || allText.includes("nova")) {
        return "\u2795 Gest\xE3o de Categorias";
      }
      return "\u{1F4C2} Consulta de Categorias";
    }
    if (allText.includes("loja") || allText.includes("lojas") || allText.includes("store")) {
      if (allText.includes("relat\xF3rio") || allText.includes("relatorio")) {
        return "\u{1F3EA} Relat\xF3rio de Lojas";
      }
      return "\u{1F3EA} Consulta de Lojas";
    }
    if (allText.includes("fornecedor") || allText.includes("fornecedores") || allText.includes("supplier")) {
      if (allText.includes("relat\xF3rio") || allText.includes("relatorio")) {
        return "\u{1F69A} Relat\xF3rio de Fornecedores";
      }
      return "\u{1F69A} Consulta de Fornecedores";
    }
    if (allText.includes("movimenta\xE7\xE3o") || allText.includes("movimenta\xE7\xF5es") || allText.includes("movimento")) {
      if (allText.includes("entrada") || allText.includes("sa\xEDda")) {
        return "\u{1F4C8} Movimenta\xE7\xF5es de Estoque";
      }
      return "\u{1F4C8} Consulta de Movimenta\xE7\xF5es";
    }
    if (allText.includes("relat\xF3rio") || allText.includes("relatorio") || allText.includes("relat\xF3rios")) {
      return "\u{1F4CA} Gera\xE7\xE3o de Relat\xF3rios";
    }
    if (allText.includes("usu\xE1rio") || allText.includes("usuarios") || allText.includes("user")) {
      return "\u{1F465} Gest\xE3o de Usu\xE1rios";
    }
    if (allText.includes("configura\xE7\xE3o") || allText.includes("configuracao") || allText.includes("config")) {
      return "\u2699\uFE0F Configura\xE7\xF5es do Sistema";
    }
    if (allText.includes("ajuda") || allText.includes("help") || allText.includes("como")) {
      return "\u2753 Suporte e Ajuda";
    }
    const firstMessage = messages[0]?.message || "";
    if (firstMessage.length > 0) {
      const truncated = firstMessage.substring(0, 30);
      return truncated.length < firstMessage.length ? `${truncated}...` : truncated;
    }
    return "\u{1F4AC} Conversa Geral";
  },
  // === ATUALIZAR TIMESTAMP DA SESSÃO ===
  async updateSessionTimestamp(sessionId) {
    await db.chatSession.update({
      where: { id: sessionId },
      data: { updatedAt: /* @__PURE__ */ new Date() }
    });
  },
  // === ATUALIZAR TÍTULO DA SESSÃO ===
  async updateSessionTitle(sessionId, title) {
    const session = await db.chatSession.update({
      where: { id: sessionId },
      data: { title }
    });
    return session;
  },
  // === ATUALIZAR TÍTULO INTELIGENTE ===
  async updateSessionTitleIntelligent(sessionId) {
    const messages = await db.chatMessage.findMany({
      where: { sessionId },
      select: { content: true, isFromUser: true },
      orderBy: { createdAt: "asc" }
    });
    const smartTitle = await ChatCommands.generateSmartTitle(messages);
    await db.chatSession.update({
      where: { id: sessionId },
      data: { title: smartTitle }
    });
    return smartTitle;
  },
  // === EXECUÇÃO DE COMANDO DA TOOLBOX ===
  async executeToolboxCommand(command, params = {}) {
    const toolbox = new ChatToolbox(db);
    return await toolbox.executeCommand(command, params);
  },
  // === EXECUÇÃO DE COMANDO COM CONTEXTO ===
  async executeCommandWithContext(data) {
    const toolbox = new ChatToolbox(db);
    const enrichedParams = {
      ...data.params,
      ...data.context?.storeId && { storeId: data.context.storeId },
      ...data.context?.userId && { userId: data.context.userId }
    };
    return await toolbox.executeCommand(data.command, enrichedParams);
  },
  // === DELETAR SESSÃO ===
  async deleteSession(sessionId) {
    const session = await db.chatSession.findUnique({
      where: { id: sessionId }
    });
    if (!session) {
      throw new Error("Chat session not found");
    }
    await db.chatMessage.deleteMany({
      where: { sessionId }
    });
    await db.chatSession.delete({
      where: { id: sessionId }
    });
    return { success: true };
  },
  // === DELETAR MENSAGEM ===
  async deleteMessage(messageId) {
    const message = await db.chatMessage.findUnique({
      where: { id: messageId }
    });
    if (!message) {
      throw new Error("Chat message not found");
    }
    await db.chatMessage.delete({
      where: { id: messageId }
    });
    return { success: true };
  },
  // === LIMPEZA DE SESSÕES ANTIGAS ===
  async cleanupOldSessions(daysOld = 30) {
    const cutoffDate = /* @__PURE__ */ new Date();
    cutoffDate.setDate(cutoffDate.getDate() - daysOld);
    const deletedSessions = await db.chatSession.deleteMany({
      where: {
        updatedAt: {
          lt: cutoffDate
        }
      }
    });
    return {
      deletedSessions: deletedSessions.count,
      cutoffDate
    };
  },
  // === LIMPEZA DE MENSAGENS ANTIGAS ===
  async cleanupOldMessages(daysOld = 30) {
    const cutoffDate = /* @__PURE__ */ new Date();
    cutoffDate.setDate(cutoffDate.getDate() - daysOld);
    const deletedMessages = await db.chatMessage.deleteMany({
      where: {
        createdAt: {
          lt: cutoffDate
        }
      }
    });
    return {
      deletedMessages: deletedMessages.count,
      cutoffDate
    };
  },
  // === BATCH OPERATIONS ===
  async createMultipleMessages(messages) {
    const createdMessages = await db.chatMessage.createMany({
      data: messages.map((msg) => ({
        content: msg.content,
        isFromUser: msg.isFromUser,
        sessionId: msg.sessionId,
        context: msg.context || {},
        options: msg.options || {}
      }))
    });
    return createdMessages;
  },
  // === MIGRAÇÃO DE DADOS ===
  async migrateSessionData(oldSessionId, newSessionId) {
    const updatedMessages = await db.chatMessage.updateMany({
      where: { sessionId: oldSessionId },
      data: { sessionId: newSessionId }
    });
    const oldSession = await db.chatSession.findUnique({
      where: { id: oldSessionId },
      include: { messages: true }
    });
    if (oldSession && oldSession.messages.length === 0) {
      await db.chatSession.delete({
        where: { id: oldSessionId }
      });
    }
    return {
      migratedMessages: updatedMessages.count,
      oldSessionDeleted: oldSession?.messages.length === 0
    };
  }
};

// src/features/chat/chat.controller.ts
var ChatController = {
  // === ENVIO DE MENSAGENS ===
  async sendMessage(request, reply) {
    try {
      const { message, context, options } = request.body;
      const enrichedContext = {
        ...context,
        userId: request.user?.id || context?.userId,
        storeId: request.store?.id || context?.storeId
      };
      const result = await ChatCommands.processMessage({
        message,
        context: enrichedContext,
        options
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("LLM")) {
        return reply.status(503).send({
          error: "Servi\xE7o de IA temporariamente indispon\xEDvel"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === HISTÓRICO DE CHAT ===
  async getHistory(request, reply) {
    try {
      const { page = 1, limit = 10, sessionId } = request.query;
      const enrichedParams = {
        page,
        limit,
        sessionId,
        userId: request.user?.id,
        storeId: request.store?.id
      };
      const result = await ChatQueries.list(enrichedParams);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === MENSAGENS DE UMA SESSÃO ESPECÍFICA ===
  async getSessionMessages(request, reply) {
    try {
      const { sessionId } = request.params;
      const { page = 1, limit = 20 } = request.query;
      const result = await ChatQueries.getSessionById(sessionId, { page, limit });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Chat session not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === ENVIAR MENSAGEM PARA SESSÃO ESPECÍFICA ===
  async sendMessageToSession(request, reply) {
    try {
      const { sessionId } = request.params;
      const { message, options } = request.body;
      const enrichedContext = {
        sessionId,
        userId: request.user?.id,
        storeId: request.store?.id
      };
      const result = await ChatCommands.processMessage({
        message,
        context: enrichedContext,
        options
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("LLM")) {
        return reply.status(503).send({
          error: "Servi\xE7o de IA temporariamente indispon\xEDvel"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === HISTÓRICO TRADICIONAL (compatibilidade) ===
  async getHistoryTraditional(request, reply) {
    try {
      const { page = 1, limit = 10, sessionId } = request.query;
      const enrichedParams = {
        page,
        limit,
        sessionId,
        userId: request.user?.id,
        storeId: request.store?.id
      };
      const result = await ChatQueries.listTraditional(enrichedParams);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === SESSÃO DE CHAT ===
  async getSession(request, reply) {
    try {
      const { sessionId } = request.params;
      const result = await ChatQueries.getSessionById(sessionId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Chat session not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async deleteSession(request, reply) {
    try {
      const { sessionId } = request.params;
      await ChatCommands.deleteSession(sessionId);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Chat session not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === TOOLBOX ===
  async getToolbox(request, reply) {
    try {
      const result = await ChatQueries.getToolbox();
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === EXECUÇÃO DE COMANDOS DA TOOLBOX ===
  async executeCommand(request, reply) {
    try {
      const { command, params = {} } = request.body;
      const result = await ChatCommands.executeToolboxCommand(command, params);
      return reply.send({
        command,
        params,
        result
      });
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("Unknown service") || error.message.includes("Unknown")) {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === ANÁLISE E ESTATÍSTICAS ===
  async getAnalytics(request, reply) {
    try {
      const { startDate, endDate, userId, storeId } = request.query;
      const result = await ChatQueries.getAnalytics({
        startDate,
        endDate,
        userId,
        storeId
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === BUSCA ===
  async search(request, reply) {
    try {
      const { q, limit = 10 } = request.query;
      const result = await ChatQueries.search(q, limit);
      return reply.send({ messages: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === SESSÕES ===
  async getSessions(request, reply) {
    try {
      const { page = 1, limit = 10 } = request.query;
      const enrichedParams = {
        page,
        limit,
        userId: request.user?.id,
        storeId: request.store?.id
      };
      const result = await ChatQueries.getSessions(enrichedParams);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === MENSAGEM ESPECÍFICA ===
  async getMessage(request, reply) {
    try {
      const { id } = request.params;
      const result = await ChatQueries.getById(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Chat message not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === OPERAÇÕES ADICIONAIS DE SESSÃO ===
  async updateSessionTitle(request, reply) {
    try {
      const { sessionId } = request.params;
      const { title } = request.body;
      const result = await ChatCommands.updateSessionTitle(sessionId, title);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Chat session not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === ATUALIZAR TÍTULO INTELIGENTE ===
  async updateSessionTitleIntelligent(request, reply) {
    try {
      const { sessionId } = request.params;
      const result = await ChatCommands.updateSessionTitleIntelligent(sessionId);
      return reply.send({
        sessionId,
        title: result,
        message: "T\xEDtulo atualizado com sucesso"
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Chat session not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === OPERAÇÕES DE LIMPEZA ===
  async cleanupOldSessions(request, reply) {
    try {
      const { daysOld = 30 } = request.query;
      const result = await ChatCommands.cleanupOldSessions(daysOld);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async cleanupOldMessages(request, reply) {
    try {
      const { daysOld = 30 } = request.query;
      const result = await ChatCommands.cleanupOldMessages(daysOld);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/chat/chat.schema.ts
var sendMessageSchema = {
  body: {
    type: "object",
    required: ["message"],
    properties: {
      message: {
        type: "string",
        minLength: 1,
        maxLength: 2e3,
        description: "Mensagem do usu\xE1rio para o chat"
      },
      context: {
        type: "object",
        properties: {
          storeId: { type: "string" },
          userId: { type: "string" },
          sessionId: { type: "string" }
        },
        additionalProperties: true
      },
      options: {
        type: "object",
        properties: {
          temperature: {
            type: "number",
            minimum: 0,
            maximum: 2,
            default: 0.2
          },
          numPredict: {
            type: "number",
            minimum: 1,
            maximum: 4e3,
            default: 1e3
          },
          repeatPenalty: {
            type: "number",
            minimum: 0.1,
            maximum: 2,
            default: 1.1
          }
        }
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        message: { type: "string" },
        response: { type: "string" },
        context: {
          type: "object",
          properties: {
            storeId: { type: "string", nullable: true },
            userId: { type: "string", nullable: true },
            sessionId: { type: "string", nullable: true }
          }
        },
        options: {
          type: "object",
          properties: {
            temperature: { type: "number" },
            numPredict: { type: "number" },
            repeatPenalty: { type: "number" }
          }
        },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var getChatHistorySchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      sessionId: { type: "string" },
      userId: { type: "string" },
      storeId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              message: { type: "string" },
              response: { type: "string" },
              context: {
                type: "object",
                properties: {
                  storeId: { type: "string", nullable: true },
                  userId: { type: "string", nullable: true },
                  sessionId: { type: "string", nullable: true }
                }
              },
              options: {
                type: "object",
                properties: {
                  temperature: { type: "number" },
                  numPredict: { type: "number" },
                  repeatPenalty: { type: "number" }
                }
              },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getChatSessionSchema = {
  params: {
    type: "object",
    required: ["sessionId"],
    properties: {
      sessionId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        storeId: { type: "string", nullable: true },
        title: { type: "string", nullable: true },
        messages: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              message: { type: "string" },
              response: { type: "string" },
              context: {
                type: "object",
                properties: {
                  storeId: { type: "string", nullable: true },
                  userId: { type: "string", nullable: true },
                  sessionId: { type: "string", nullable: true }
                }
              },
              options: {
                type: "object",
                properties: {
                  temperature: { type: "number" },
                  numPredict: { type: "number" },
                  repeatPenalty: { type: "number" }
                }
              },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" }
            }
          }
        },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var deleteChatSessionSchema = {
  params: {
    type: "object",
    required: ["sessionId"],
    properties: {
      sessionId: { type: "string" }
    }
  },
  response: {
    204: { type: "null" }
  }
};
var getToolboxSchema = {
  response: {
    200: {
      type: "object",
      properties: {
        availableServices: {
          type: "object",
          properties: {
            products: {
              type: "object",
              properties: {
                description: { type: "string" },
                methods: {
                  type: "array",
                  items: { type: "string" }
                }
              }
            },
            stores: {
              type: "object",
              properties: {
                description: { type: "string" },
                methods: {
                  type: "array",
                  items: { type: "string" }
                }
              }
            },
            categories: {
              type: "object",
              properties: {
                description: { type: "string" },
                methods: {
                  type: "array",
                  items: { type: "string" }
                }
              }
            },
            suppliers: {
              type: "object",
              properties: {
                description: { type: "string" },
                methods: {
                  type: "array",
                  items: { type: "string" }
                }
              }
            },
            movements: {
              type: "object",
              properties: {
                description: { type: "string" },
                methods: {
                  type: "array",
                  items: { type: "string" }
                }
              }
            },
            reports: {
              type: "object",
              properties: {
                description: { type: "string" },
                methods: {
                  type: "array",
                  items: { type: "string" }
                }
              }
            }
          }
        }
      }
    }
  }
};
var getAnalyticsSchema = {
  querystring: {
    type: "object",
    properties: {
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" },
      userId: { type: "string" },
      storeId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        totalMessages: { type: "number" },
        totalSessions: { type: "number" },
        averageMessagesPerSession: { type: "number" },
        mostUsedServices: {
          type: "array",
          items: {
            type: "object",
            properties: {
              service: { type: "string" },
              usageCount: { type: "number" }
            }
          }
        },
        messagesByDay: {
          type: "array",
          items: {
            type: "object",
            properties: {
              date: { type: "string" },
              count: { type: "number" }
            }
          }
        }
      }
    }
  }
};
var ChatSchemas = {
  sendMessage: sendMessageSchema,
  getHistory: getChatHistorySchema,
  getSession: getChatSessionSchema,
  deleteSession: deleteChatSessionSchema,
  getToolbox: getToolboxSchema,
  getAnalytics: getAnalyticsSchema
};

// src/features/chat/chat.routes.ts
init_auth_middleware();
async function ChatRoutes(fastify2) {
  fastify2.post("/messages", {
    schema: ChatSchemas.sendMessage,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: ChatController.sendMessage
  });
  fastify2.post("/sessions/:sessionId/messages", {
    schema: ChatSchemas.sendMessage,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: ChatController.sendMessageToSession
  });
  fastify2.get("/messages", {
    schema: ChatSchemas.getHistory,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: ChatController.getHistory
  });
  fastify2.get("/messages/traditional", {
    schema: ChatSchemas.getHistory,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: ChatController.getHistoryTraditional
  });
  fastify2.get("/messages/:id", {
    preHandler: [authMiddleware],
    handler: ChatController.getMessage
  });
  fastify2.get("/sessions", {
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: ChatController.getSessions
  });
  fastify2.get("/sessions/:sessionId", {
    schema: ChatSchemas.getSession,
    preHandler: [authMiddleware],
    handler: ChatController.getSession
  });
  fastify2.get("/sessions/:sessionId/messages", {
    preHandler: [authMiddleware],
    handler: ChatController.getSessionMessages
  });
  fastify2.put("/sessions/:sessionId/title", {
    preHandler: [authMiddleware],
    handler: ChatController.updateSessionTitle
  });
  fastify2.patch("/sessions/:sessionId/title/intelligent", {
    preHandler: [authMiddleware],
    handler: ChatController.updateSessionTitleIntelligent
  });
  fastify2.delete("/sessions/:sessionId", {
    schema: ChatSchemas.deleteSession,
    preHandler: [authMiddleware],
    handler: ChatController.deleteSession
  });
  fastify2.get("/toolbox", {
    schema: ChatSchemas.getToolbox,
    preHandler: [authMiddleware],
    handler: ChatController.getToolbox
  });
  fastify2.post("/execute", {
    preHandler: [authMiddleware],
    handler: ChatController.executeCommand
  });
  fastify2.get("/analytics", {
    schema: ChatSchemas.getAnalytics,
    preHandler: [authMiddleware],
    handler: ChatController.getAnalytics
  });
  fastify2.get("/search", {
    preHandler: [authMiddleware],
    handler: ChatController.search
  });
  fastify2.delete("/cleanup/sessions", {
    preHandler: [authMiddleware],
    handler: ChatController.cleanupOldSessions
  });
  fastify2.delete("/cleanup/messages", {
    preHandler: [authMiddleware],
    handler: ChatController.cleanupOldMessages
  });
}

// src/services/llm/rag.ts
var import_tools = require("@langchain/core/tools");
var import_ollama2 = require("@langchain/ollama");
var import_retrieval = require("langchain/chains/retrieval");
var import_combine_documents = require("langchain/chains/combine_documents");
var import_prompts = require("@langchain/core/prompts");
var import_memory = require("langchain/vectorstores/memory");

// src/services/llm/movements.json
var movements_default = [
  {
    id: "cmgffctkq0001e8lc8lembpyv",
    type: "ENTRADA",
    quantity: 12,
    storeId: "cmg4iuzet0002e8vgr7xtjo10",
    productId: "cmg4ixgh90005e8vgqdn5k6qz",
    supplierId: null,
    batch: null,
    expiration: null,
    price: null,
    balanceAfter: 27,
    verified: false,
    verifiedAt: null,
    verifiedBy: null,
    verificationNote: null,
    cancelled: false,
    cancelledAt: null,
    cancelledBy: null,
    cancellationReason: null,
    createdAt: "2025-10-06T17:48:32.565Z",
    updatedAt: "2025-10-06T17:48:32.565Z",
    userId: "cmg4itq6j0000e8vgj7t4abbq",
    store: {},
    supplier: null,
    user: {}
  },
  {
    id: "cmgfemfu60003e8ak602dmvsz",
    type: "ENTRADA",
    quantity: 12,
    storeId: "cmg4iuzet0002e8vgr7xtjo10",
    productId: "cmg4ixgh90005e8vgqdn5k6qz",
    supplierId: null,
    batch: null,
    expiration: null,
    price: null,
    balanceAfter: 15,
    verified: false,
    verifiedAt: null,
    verifiedBy: null,
    verificationNote: null,
    cancelled: false,
    cancelledAt: null,
    cancelledBy: null,
    cancellationReason: null,
    createdAt: "2025-10-06T17:28:01.708Z",
    updatedAt: "2025-10-06T17:28:01.708Z",
    userId: "cmg4itq6j0000e8vgj7t4abbq",
    store: {},
    supplier: null,
    user: {}
  },
  {
    id: "cmgfembjm0001e8ak0e7tvwbv",
    type: "ENTRADA",
    quantity: 2,
    storeId: "cmg4iuzet0002e8vgr7xtjo10",
    productId: "cmg4ixgh90005e8vgqdn5k6qz",
    supplierId: null,
    batch: null,
    expiration: null,
    price: null,
    balanceAfter: 3,
    verified: false,
    verifiedAt: null,
    verifiedBy: null,
    verificationNote: null,
    cancelled: false,
    cancelledAt: null,
    cancelledBy: null,
    cancellationReason: null,
    createdAt: "2025-10-06T17:27:56.141Z",
    updatedAt: "2025-10-06T17:27:56.141Z",
    userId: "cmg4itq6j0000e8vgj7t4abbq",
    store: {},
    supplier: null,
    user: {}
  },
  {
    id: "cmgacsg6w0007e8j4p80rtch5",
    type: "SAIDA",
    quantity: 2,
    storeId: "cmg4iuzet0002e8vgr7xtjo10",
    productId: "cmg4ixgh90005e8vgqdn5k6qz",
    supplierId: null,
    batch: null,
    expiration: null,
    price: null,
    balanceAfter: 1,
    verified: false,
    verifiedAt: null,
    verifiedBy: null,
    verificationNote: null,
    cancelled: false,
    cancelledAt: null,
    cancelledBy: null,
    cancellationReason: null,
    createdAt: "2025-10-03T04:37:51.991Z",
    updatedAt: "2025-10-03T04:37:51.991Z",
    userId: "cmg4itq6j0000e8vgj7t4abbq",
    store: {},
    supplier: null,
    user: {}
  },
  {
    id: "cmgacrf420005e8j4n73dql7v",
    type: "SAIDA",
    quantity: 2,
    storeId: "cmg4iuzet0002e8vgr7xtjo10",
    productId: "cmg4ixgh90005e8vgqdn5k6qz",
    supplierId: null,
    batch: null,
    expiration: null,
    price: null,
    balanceAfter: 3,
    verified: false,
    verifiedAt: null,
    verifiedBy: null,
    verificationNote: null,
    cancelled: false,
    cancelledAt: null,
    cancelledBy: null,
    cancellationReason: null,
    createdAt: "2025-10-03T04:37:03.936Z",
    updatedAt: "2025-10-03T04:37:03.936Z",
    userId: "cmg4itq6j0000e8vgj7t4abbq",
    store: {},
    supplier: null,
    user: {}
  },
  {
    id: "cmgacr0400001e8j4qvyetx1w",
    type: "ENTRADA",
    quantity: 5,
    storeId: "cmg4iuzet0002e8vgr7xtjo10",
    productId: "cmg4ixgh90005e8vgqdn5k6qz",
    supplierId: null,
    batch: null,
    expiration: null,
    price: null,
    balanceAfter: 5,
    verified: false,
    verifiedAt: null,
    verifiedBy: null,
    verificationNote: null,
    cancelled: false,
    cancelledAt: null,
    cancelledBy: null,
    cancellationReason: null,
    createdAt: "2025-10-03T04:36:44.494Z",
    updatedAt: "2025-10-03T04:36:44.494Z",
    userId: "cmg4itq6j0000e8vgj7t4abbq",
    store: {},
    supplier: null,
    user: {}
  },
  {
    id: "cmgackw1d0001e8k8tpi6dl89",
    type: "SAIDA",
    quantity: 1,
    storeId: "cmg4iuzet0002e8vgr7xtjo10",
    productId: "cmg4ixgh90005e8vgqdn5k6qz",
    supplierId: null,
    batch: null,
    expiration: null,
    price: 25.5,
    balanceAfter: 0,
    verified: false,
    verifiedAt: null,
    verifiedBy: null,
    verificationNote: null,
    cancelled: false,
    cancelledAt: null,
    cancelledBy: null,
    cancellationReason: null,
    createdAt: "2025-10-03T04:31:59.276Z",
    updatedAt: "2025-10-03T04:31:59.276Z",
    userId: "cmg4itq6j0000e8vgj7t4abbq",
    store: {},
    supplier: null,
    user: {}
  },
  {
    id: "cmgacij4a0001e8fkqiqxiqis",
    type: "SAIDA",
    quantity: 1,
    storeId: "cmg4iuzet0002e8vgr7xtjo10",
    productId: "cmg4ixgh90005e8vgqdn5k6qz",
    supplierId: null,
    batch: null,
    expiration: null,
    price: 25.5,
    balanceAfter: 1,
    verified: false,
    verifiedAt: null,
    verifiedBy: null,
    verificationNote: null,
    cancelled: false,
    cancelledAt: null,
    cancelledBy: null,
    cancellationReason: null,
    createdAt: "2025-10-03T04:30:09.224Z",
    updatedAt: "2025-10-03T04:30:09.224Z",
    userId: "cmg4itq6j0000e8vgj7t4abbq",
    store: {},
    supplier: null,
    user: {}
  },
  {
    id: "cmgacb7r40005e8j8amptlfye",
    type: "SAIDA",
    quantity: 9,
    storeId: "cmg4iuzet0002e8vgr7xtjo10",
    productId: "cmg4ixgh90005e8vgqdn5k6qz",
    supplierId: null,
    batch: null,
    expiration: null,
    price: 25.5,
    balanceAfter: 2,
    verified: false,
    verifiedAt: null,
    verifiedBy: null,
    verificationNote: null,
    cancelled: false,
    cancelledAt: null,
    cancelledBy: null,
    cancellationReason: null,
    createdAt: "2025-10-03T04:24:27.902Z",
    updatedAt: "2025-10-03T04:24:27.902Z",
    userId: "cmg4itq6j0000e8vgj7t4abbq",
    store: {},
    supplier: null,
    user: {}
  },
  {
    id: "cmgac9icl0003e8j84v41e88d",
    type: "SAIDA",
    quantity: 20,
    storeId: "cmg4iuzet0002e8vgr7xtjo10",
    productId: "cmg4ixgh90005e8vgqdn5k6qz",
    supplierId: null,
    batch: null,
    expiration: null,
    price: 25.5,
    balanceAfter: 11,
    verified: false,
    verifiedAt: null,
    verifiedBy: null,
    verificationNote: null,
    cancelled: false,
    cancelledAt: null,
    cancelledBy: null,
    cancellationReason: null,
    createdAt: "2025-10-03T04:23:08.323Z",
    updatedAt: "2025-10-03T04:23:08.323Z",
    userId: "cmg4itq6j0000e8vgj7t4abbq",
    store: {},
    supplier: null,
    user: {}
  }
];

// src/services/llm/rag.ts
var model = new import_ollama2.ChatOllama({ model: "mistral" });
var getStockMovementsTool = (0, import_tools.tool)(
  async (input) => {
    const productId = input.productId;
    return movements_default;
  },
  {
    name: "get_stock_movements",
    description: "Busca entradas, sa\xEDdas e perdas de um produto pelo ID",
    schema: {
      type: "object",
      properties: {
        productId: { type: "string" }
      },
      required: ["productId"]
    }
  }
);
function generateDocuments(movements) {
  const entries = movements.filter((m) => m.type === "ENTRADA");
  entries.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
  return entries.map((m) => {
    const date = new Date(m.createdAt).toLocaleDateString("pt-BR");
    const time = new Date(m.createdAt).toLocaleTimeString("pt-BR");
    const price = m.price ? ` | Pre\xE7o: R$ ${m.price}` : "";
    const balance = m.balanceAfter ? ` | Saldo ap\xF3s: ${m.balanceAfter}` : "";
    return `Data: ${date} ${time} | Tipo: ${m.type} | Quantidade: ${m.quantity}${price}${balance}`;
  });
}
async function createRAGChain(productId) {
  const movements = await getStockMovementsTool.invoke({ productId });
  const documents = generateDocuments(movements);
  const vectorStore = await import_memory.MemoryVectorStore.fromTexts(
    documents,
    [{ id: productId }],
    new import_ollama2.OllamaEmbeddings({ model: "mistral" })
  );
  const documentChain = await (0, import_combine_documents.createStuffDocumentsChain)({
    llm: model,
    prompt: new import_prompts.PromptTemplate({
      template: "Voc\xEA \xE9 um assistente especializado em an\xE1lise de movimenta\xE7\xF5es de estoque. Responda a pergunta com base no contexto fornecido sobre as movimenta\xE7\xF5es do produto.\n\nContexto das movimenta\xE7\xF5es:\n{context}\n\nPergunta:\n{input}\n\nResponda de forma clara e precisa, utilizando as informa\xE7\xF5es do contexto.",
      inputVariables: ["context", "input"]
    })
  });
  return (0, import_retrieval.createRetrievalChain)({
    combineDocsChain: documentChain,
    retriever: vectorStore.asRetriever()
  });
}
async function queryRAG(productId, query) {
  try {
    const chain = await createRAGChain(productId);
    const result = await chain.invoke({ input: query });
    return result;
  } catch (error) {
    return {
      input: query,
      context: [],
      answer: "Erro ao processar a consulta. Verifique se o produto existe e possui movimenta\xE7\xF5es nesta loja."
    };
  }
}

// src/features/roadmap/commands/roadmap.commands.ts
init_prisma();
var RoadmapCommands = {
  async create(data) {
    return await db.roadmap.create({ data });
  },
  async update(id, data) {
    return await db.roadmap.update({
      where: { id },
      data
    });
  },
  async delete(id) {
    return await db.roadmap.delete({
      where: { id }
    });
  },
  async updateStatus(id, status) {
    return await db.roadmap.update({
      where: { id },
      data: { status }
    });
  }
};

// src/features/roadmap/queries/roadmap.queries.ts
init_prisma();
var RoadmapQueries = {
  async getById(id) {
    return await db.roadmap.findUnique({
      where: { id },
      include: {
        milestones: {
          orderBy: { order: "asc" }
        },
        store: {
          select: {
            id: true,
            name: true
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async list(params) {
    const { page = 1, limit = 10, search, status } = params;
    const skip2 = (page - 1) * limit;
    const where = {};
    if (status !== void 0) {
      where.status = status;
    }
    if (search) {
      where.OR = [
        { title: { contains: search, mode: "insensitive" } },
        { description: { contains: search, mode: "insensitive" } }
      ];
    }
    const [items, total] = await Promise.all([
      db.roadmap.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          _count: {
            select: { milestones: true }
          },
          store: {
            select: {
              id: true,
              name: true
            }
          },
          user: {
            select: {
              id: true,
              name: true
            }
          }
        }
      }),
      db.roadmap.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async search(term, limit = 10) {
    return await db.roadmap.findMany({
      where: {
        OR: [
          { title: { contains: term, mode: "insensitive" } },
          { description: { contains: term, mode: "insensitive" } }
        ]
      },
      take: limit,
      orderBy: { createdAt: "desc" }
    });
  },
  async getActive() {
    return await db.roadmap.findMany({
      where: { status: "ACTIVE" },
      orderBy: { createdAt: "desc" },
      include: {
        _count: {
          select: { milestones: true }
        },
        milestones: {
          where: {
            status: {
              in: ["IN_PROGRESS", "PENDING"]
            }
          },
          orderBy: { order: "asc" },
          take: 5
        }
      }
    });
  },
  async getStats() {
    const [total, active, inactive] = await Promise.all([
      db.roadmap.count(),
      db.roadmap.count({ where: { status: "ACTIVE" } }),
      db.roadmap.count({ where: { status: "COMPLETED" } })
    ]);
    return {
      total,
      active,
      inactive
    };
  }
};

// src/features/roadmap/roadmap.controller.ts
var RoadmapController = {
  // === CRUD BÁSICO ===
  async create(request, reply) {
    try {
      const data = { ...request.body };
      if (data.startDate) {
        data.startDate = new Date(data.startDate);
      }
      if (data.endDate) {
        data.endDate = new Date(data.endDate);
      }
      const result = await RoadmapCommands.create(data);
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Specific error message") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      const result = await RoadmapQueries.getById(id);
      if (!result) {
        return reply.status(404).send({
          error: "Roadmap not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Roadmap not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      if (updateData.startDate) {
        updateData.startDate = new Date(updateData.startDate);
      }
      if (updateData.endDate) {
        updateData.endDate = new Date(updateData.endDate);
      }
      const result = await RoadmapCommands.update(id, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Roadmap not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Validation error") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      await RoadmapCommands.delete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Roadmap not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { page = 1, limit = 10, search, status } = request.query;
      const result = await RoadmapQueries.list({
        page,
        limit,
        search,
        status
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (QUERIES) ===
  async getActive(request, reply) {
    try {
      const result = await RoadmapQueries.getActive();
      return reply.send({ roadmaps: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const result = await RoadmapQueries.getStats();
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { q, limit = 10 } = request.query;
      const result = await RoadmapQueries.search(q, limit);
      return reply.send({ roadmaps: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (COMMANDS) ===
  async updateStatus(request, reply) {
    try {
      const { id } = request.params;
      const { status } = request.body;
      const result = await RoadmapCommands.updateStatus(id, status);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Roadmap not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/roadmap/commands/milestone.commands.ts
init_prisma();
var MilestoneCommands = {
  async create(data) {
    const roadmap = await db.roadmap.findUnique({
      where: { id: data.roadmapId }
    });
    if (!roadmap) {
      throw new Error("Roadmap not found");
    }
    if (data.order === void 0) {
      const lastMilestone = await db.milestone.findFirst({
        where: { roadmapId: data.roadmapId },
        orderBy: { order: "desc" }
      });
      data.order = lastMilestone ? lastMilestone.order + 1 : 0;
    }
    return await db.milestone.create({
      data: {
        roadmapId: data.roadmapId,
        title: data.title,
        description: data.description,
        status: data.status || "PENDING",
        progress: data.progress || 0,
        order: data.order,
        startDate: data.startDate,
        endDate: data.endDate
      },
      include: {
        roadmap: {
          select: {
            id: true,
            title: true
          }
        }
      }
    });
  },
  async update(id, roadmapId, data) {
    const milestone = await db.milestone.findFirst({
      where: {
        id,
        roadmapId
      }
    });
    if (!milestone) {
      throw new Error("Milestone not found");
    }
    const updateData = { ...data };
    if (data.status === "COMPLETED" && milestone.status !== "COMPLETED") {
      updateData.completedAt = /* @__PURE__ */ new Date();
      updateData.progress = 100;
    }
    return await db.milestone.update({
      where: { id },
      data: updateData,
      include: {
        roadmap: {
          select: {
            id: true,
            title: true
          }
        }
      }
    });
  },
  async delete(id, roadmapId) {
    const milestone = await db.milestone.findFirst({
      where: {
        id,
        roadmapId
      }
    });
    if (!milestone) {
      throw new Error("Milestone not found");
    }
    return await db.milestone.delete({
      where: { id }
    });
  },
  async updateProgress(id, roadmapId, progress) {
    if (progress < 0 || progress > 100) {
      throw new Error("Progress must be between 0 and 100");
    }
    const milestone = await db.milestone.findFirst({
      where: {
        id,
        roadmapId
      }
    });
    if (!milestone) {
      throw new Error("Milestone not found");
    }
    const updateData = { progress };
    if (progress === 100 && milestone.status !== "COMPLETED") {
      updateData.status = "COMPLETED";
      updateData.completedAt = /* @__PURE__ */ new Date();
    }
    if (progress < 100 && milestone.status === "COMPLETED") {
      updateData.status = "IN_PROGRESS";
      updateData.completedAt = null;
    }
    return await db.milestone.update({
      where: { id },
      data: updateData
    });
  },
  async updateStatus(id, roadmapId, status) {
    const milestone = await db.milestone.findFirst({
      where: {
        id,
        roadmapId
      }
    });
    if (!milestone) {
      throw new Error("Milestone not found");
    }
    const updateData = { status };
    if (status === "COMPLETED" && milestone.status !== "COMPLETED") {
      updateData.completedAt = /* @__PURE__ */ new Date();
      updateData.progress = 100;
    }
    if (status !== "COMPLETED" && milestone.status === "COMPLETED") {
      updateData.completedAt = null;
    }
    return await db.milestone.update({
      where: { id },
      data: updateData
    });
  },
  async reorder(roadmapId, milestoneIds) {
    const milestones = await db.milestone.findMany({
      where: {
        id: { in: milestoneIds },
        roadmapId
      }
    });
    if (milestones.length !== milestoneIds.length) {
      throw new Error("Some milestones not found or do not belong to this roadmap");
    }
    const updates = milestoneIds.map(
      (id, index) => db.milestone.update({
        where: { id },
        data: { order: index }
      })
    );
    return await db.$transaction(updates);
  }
};

// src/features/roadmap/queries/milestone.queries.ts
init_prisma();
var MilestoneQueries = {
  async getById(id, roadmapId) {
    const milestone = await db.milestone.findFirst({
      where: {
        id,
        roadmapId
      },
      include: {
        roadmap: {
          select: {
            id: true,
            title: true,
            status: true
          }
        }
      }
    });
    if (!milestone) {
      throw new Error("Milestone not found");
    }
    return milestone;
  },
  async listByRoadmap(roadmapId, params) {
    const { status, page = 1, limit = 50 } = params || {};
    const skip2 = (page - 1) * limit;
    const where = { roadmapId };
    if (status) {
      where.status = status;
    }
    const [items, total] = await Promise.all([
      db.milestone.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { order: "asc" }
      }),
      db.milestone.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getByStatus(roadmapId, status) {
    return await db.milestone.findMany({
      where: {
        roadmapId,
        status
      },
      orderBy: { order: "asc" }
    });
  },
  async getStats(roadmapId) {
    const [
      total,
      pending,
      inProgress,
      completed,
      blocked,
      avgProgress
    ] = await Promise.all([
      db.milestone.count({ where: { roadmapId } }),
      db.milestone.count({ where: { roadmapId, status: "PENDING" } }),
      db.milestone.count({ where: { roadmapId, status: "IN_PROGRESS" } }),
      db.milestone.count({ where: { roadmapId, status: "COMPLETED" } }),
      db.milestone.count({ where: { roadmapId, status: "BLOCKED" } }),
      db.milestone.aggregate({
        where: { roadmapId },
        _avg: { progress: true }
      })
    ]);
    return {
      total,
      byStatus: {
        pending,
        inProgress,
        completed,
        blocked
      },
      averageProgress: Math.round(avgProgress._avg.progress || 0),
      completionRate: total > 0 ? Math.round(completed / total * 100) : 0
    };
  },
  async getUpcoming(roadmapId, limit = 5) {
    const now = /* @__PURE__ */ new Date();
    return await db.milestone.findMany({
      where: {
        roadmapId,
        status: {
          in: ["PENDING", "IN_PROGRESS"]
        },
        startDate: {
          gte: now
        }
      },
      orderBy: { startDate: "asc" },
      take: limit
    });
  },
  async getOverdue(roadmapId) {
    const now = /* @__PURE__ */ new Date();
    return await db.milestone.findMany({
      where: {
        roadmapId,
        status: {
          notIn: ["COMPLETED"]
        },
        endDate: {
          lt: now
        }
      },
      orderBy: { endDate: "asc" }
    });
  },
  async getInProgress(roadmapId) {
    return await db.milestone.findMany({
      where: {
        roadmapId,
        status: "IN_PROGRESS"
      },
      orderBy: { order: "asc" }
    });
  },
  async search(roadmapId, term, limit = 10) {
    return await db.milestone.findMany({
      where: {
        roadmapId,
        OR: [
          { title: { contains: term, mode: "insensitive" } },
          { description: { contains: term, mode: "insensitive" } }
        ]
      },
      orderBy: { order: "asc" },
      take: limit
    });
  },
  // Query para pegar todas as milestones ordenadas (útil para drag & drop)
  async getAllOrdered(roadmapId) {
    return await db.milestone.findMany({
      where: { roadmapId },
      orderBy: { order: "asc" }
    });
  },
  // Query para verificar se há milestones bloqueadas
  async hasBlocked(roadmapId) {
    const count = await db.milestone.count({
      where: {
        roadmapId,
        status: "BLOCKED"
      }
    });
    return count > 0;
  },
  // Query para pegar timeline completa
  async getTimeline(roadmapId) {
    return await db.milestone.findMany({
      where: {
        roadmapId,
        OR: [
          { startDate: { not: null } },
          { endDate: { not: null } }
        ]
      },
      orderBy: [
        { startDate: "asc" },
        { order: "asc" }
      ]
    });
  }
};

// src/features/roadmap/milestone.controller.ts
var MilestoneController = {
  // === CRUD BÁSICO ===
  async create(request, reply) {
    try {
      const { roadmapId } = request.params;
      const { title, description, status, progress, order, startDate, endDate } = request.body;
      const result = await MilestoneCommands.create({
        roadmapId,
        title,
        description,
        status,
        progress,
        order,
        startDate: startDate ? new Date(startDate) : void 0,
        endDate: endDate ? new Date(endDate) : void 0
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Roadmap not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { roadmapId, id } = request.params;
      const result = await MilestoneQueries.getById(id, roadmapId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Milestone not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { roadmapId, id } = request.params;
      const updateData = { ...request.body };
      if (updateData.startDate) {
        updateData.startDate = new Date(updateData.startDate).toISOString();
      }
      if (updateData.endDate) {
        updateData.endDate = new Date(updateData.endDate).toISOString();
      }
      const result = await MilestoneCommands.update(id, roadmapId, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Milestone not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Validation error") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { roadmapId, id } = request.params;
      await MilestoneCommands.delete(id, roadmapId);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Milestone not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { roadmapId } = request.params;
      const { status, page = 1, limit = 50 } = request.query;
      const result = await MilestoneQueries.listByRoadmap(roadmapId, {
        status,
        page,
        limit
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (QUERIES) ===
  async getByStatus(request, reply) {
    try {
      const { roadmapId } = request.params;
      const { status } = request.query;
      const result = await MilestoneQueries.getByStatus(roadmapId, status);
      return reply.send({ milestones: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const { roadmapId } = request.params;
      const result = await MilestoneQueries.getStats(roadmapId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getUpcoming(request, reply) {
    try {
      const { roadmapId } = request.params;
      const { limit = 5 } = request.query;
      const result = await MilestoneQueries.getUpcoming(roadmapId, limit);
      return reply.send({ milestones: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getOverdue(request, reply) {
    try {
      const { roadmapId } = request.params;
      const result = await MilestoneQueries.getOverdue(roadmapId);
      return reply.send({ milestones: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getInProgress(request, reply) {
    try {
      const { roadmapId } = request.params;
      const result = await MilestoneQueries.getInProgress(roadmapId);
      return reply.send({ milestones: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getTimeline(request, reply) {
    try {
      const { roadmapId } = request.params;
      const result = await MilestoneQueries.getTimeline(roadmapId);
      return reply.send({ timeline: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { roadmapId } = request.params;
      const { q, limit = 10 } = request.query;
      const result = await MilestoneQueries.search(roadmapId, q, limit);
      return reply.send({ milestones: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (COMMANDS) ===
  async updateProgress(request, reply) {
    try {
      const { roadmapId, id } = request.params;
      const { progress } = request.body;
      const result = await MilestoneCommands.updateProgress(id, roadmapId, progress);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Milestone not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Progress must be between 0 and 100") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async updateStatus(request, reply) {
    try {
      const { roadmapId, id } = request.params;
      const { status } = request.body;
      const result = await MilestoneCommands.updateStatus(id, roadmapId, status);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Milestone not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async reorder(request, reply) {
    try {
      const { roadmapId } = request.params;
      const { milestoneIds } = request.body;
      const result = await MilestoneCommands.reorder(roadmapId, milestoneIds);
      return reply.send({ milestones: result });
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("not found")) {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/roadmap/roadmap.schema.ts
var createRoadmapSchema = {
  body: {
    type: "object",
    required: ["title"],
    properties: {
      storeId: { type: "string" },
      userId: { type: "string" },
      title: { type: "string" },
      description: { type: "string" },
      status: { type: "string", enum: ["ACTIVE", "COMPLETED", "ARCHIVED"] },
      startDate: { type: "string", format: "date-time" },
      endDate: { type: "string", format: "date-time" }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: ["string", "null"] },
        userId: { type: ["string", "null"] },
        title: { type: "string" },
        description: { type: ["string", "null"] },
        status: { type: "string" },
        startDate: { type: ["string", "null"] },
        endDate: { type: ["string", "null"] },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var updateRoadmapSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      storeId: { type: "string" },
      userId: { type: "string" },
      title: { type: "string" },
      description: { type: "string" },
      status: { type: "string", enum: ["ACTIVE", "COMPLETED", "ARCHIVED"] },
      startDate: { type: "string", format: "date-time" },
      endDate: { type: "string", format: "date-time" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: ["string", "null"] },
        userId: { type: ["string", "null"] },
        title: { type: "string" },
        description: { type: ["string", "null"] },
        status: { type: "string" },
        startDate: { type: ["string", "null"] },
        endDate: { type: ["string", "null"] },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getRoadmapSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: ["string", "null"] },
        userId: { type: ["string", "null"] },
        title: { type: "string" },
        description: { type: ["string", "null"] },
        status: { type: "string" },
        startDate: { type: ["string", "null"] },
        endDate: { type: ["string", "null"] },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var listRoadmapsSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      status: { type: "string", enum: ["ACTIVE", "COMPLETED", "ARCHIVED"] }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              storeId: { type: ["string", "null"] },
              userId: { type: ["string", "null"] },
              title: { type: "string" },
              description: { type: ["string", "null"] },
              status: { type: "string" },
              startDate: { type: ["string", "null"] },
              endDate: { type: ["string", "null"] },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var deleteRoadmapSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var RoadmapSchemas = {
  create: createRoadmapSchema,
  update: updateRoadmapSchema,
  get: getRoadmapSchema,
  delete: deleteRoadmapSchema,
  list: listRoadmapsSchema
};

// src/features/roadmap/milestone.schema.ts
var createMilestoneSchema = {
  params: {
    type: "object",
    required: ["roadmapId"],
    properties: {
      roadmapId: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["title"],
    properties: {
      title: { type: "string", minLength: 1, maxLength: 200 },
      description: { type: "string", maxLength: 1e3 },
      status: {
        type: "string",
        enum: ["PENDING", "IN_PROGRESS", "COMPLETED", "BLOCKED"],
        default: "PENDING"
      },
      progress: { type: "number", minimum: 0, maximum: 100, default: 0 },
      order: { type: "number", minimum: 0 },
      startDate: { type: "string", format: "date-time" },
      endDate: { type: "string", format: "date-time" }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        roadmapId: { type: "string" },
        title: { type: "string" },
        description: { type: ["string", "null"] },
        status: { type: "string" },
        progress: { type: "number" },
        order: { type: "number" },
        startDate: { type: ["string", "null"], format: "date-time" },
        endDate: { type: ["string", "null"], format: "date-time" },
        completedAt: { type: ["string", "null"], format: "date-time" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var updateMilestoneSchema = {
  params: {
    type: "object",
    required: ["roadmapId", "id"],
    properties: {
      roadmapId: { type: "string" },
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      title: { type: "string", minLength: 1, maxLength: 200 },
      description: { type: "string", maxLength: 1e3 },
      status: {
        type: "string",
        enum: ["PENDING", "IN_PROGRESS", "COMPLETED", "BLOCKED"]
      },
      progress: { type: "number", minimum: 0, maximum: 100 },
      order: { type: "number", minimum: 0 },
      startDate: { type: "string", format: "date-time" },
      endDate: { type: "string", format: "date-time" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        roadmapId: { type: "string" },
        title: { type: "string" },
        description: { type: ["string", "null"] },
        status: { type: "string" },
        progress: { type: "number" },
        order: { type: "number" },
        startDate: { type: ["string", "null"], format: "date-time" },
        endDate: { type: ["string", "null"], format: "date-time" },
        completedAt: { type: ["string", "null"], format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getMilestoneSchema = {
  params: {
    type: "object",
    required: ["roadmapId", "id"],
    properties: {
      roadmapId: { type: "string" },
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        roadmapId: { type: "string" },
        title: { type: "string" },
        description: { type: ["string", "null"] },
        status: { type: "string" },
        progress: { type: "number" },
        order: { type: "number" },
        startDate: { type: ["string", "null"], format: "date-time" },
        endDate: { type: ["string", "null"], format: "date-time" },
        completedAt: { type: ["string", "null"], format: "date-time" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var listMilestonesSchema = {
  params: {
    type: "object",
    required: ["roadmapId"],
    properties: {
      roadmapId: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      status: {
        type: "string",
        enum: ["PENDING", "IN_PROGRESS", "COMPLETED", "BLOCKED"]
      },
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 50 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              roadmapId: { type: "string" },
              title: { type: "string" },
              description: { type: ["string", "null"] },
              status: { type: "string" },
              progress: { type: "number" },
              order: { type: "number" },
              startDate: { type: ["string", "null"], format: "date-time" },
              endDate: { type: ["string", "null"], format: "date-time" },
              completedAt: { type: ["string", "null"], format: "date-time" },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var deleteMilestoneSchema = {
  params: {
    type: "object",
    required: ["roadmapId", "id"],
    properties: {
      roadmapId: { type: "string" },
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var updateMilestoneProgressSchema = {
  params: {
    type: "object",
    required: ["roadmapId", "id"],
    properties: {
      roadmapId: { type: "string" },
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["progress"],
    properties: {
      progress: { type: "number", minimum: 0, maximum: 100 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        progress: { type: "number" },
        status: { type: "string" },
        completedAt: { type: ["string", "null"], format: "date-time" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var updateMilestoneStatusSchema = {
  params: {
    type: "object",
    required: ["roadmapId", "id"],
    properties: {
      roadmapId: { type: "string" },
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["status"],
    properties: {
      status: {
        type: "string",
        enum: ["PENDING", "IN_PROGRESS", "COMPLETED", "BLOCKED"]
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        status: { type: "string" },
        completedAt: { type: ["string", "null"], format: "date-time" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var reorderMilestonesSchema = {
  params: {
    type: "object",
    required: ["roadmapId"],
    properties: {
      roadmapId: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["milestoneIds"],
    properties: {
      milestoneIds: {
        type: "array",
        items: { type: "string" },
        minItems: 1
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        milestones: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              order: { type: "number" }
            }
          }
        }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var MilestoneSchemas = {
  create: createMilestoneSchema,
  update: updateMilestoneSchema,
  get: getMilestoneSchema,
  delete: deleteMilestoneSchema,
  list: listMilestonesSchema,
  updateProgress: updateMilestoneProgressSchema,
  updateStatus: updateMilestoneStatusSchema,
  reorder: reorderMilestonesSchema
};

// src/features/roadmap/roadmap.routes.ts
init_auth_middleware();
async function RoadmapRoutes(fastify2) {
  fastify2.get("/active", {
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: RoadmapController.getActive
  });
  fastify2.get("/stats", {
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: RoadmapController.getStats
  });
  fastify2.get("/search", {
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: RoadmapController.search
  });
  fastify2.post("/", {
    schema: RoadmapSchemas.create,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: RoadmapController.create
  });
  fastify2.get("/", {
    schema: RoadmapSchemas.list,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: RoadmapController.list
  });
  fastify2.get("/:id", {
    schema: RoadmapSchemas.get,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: RoadmapController.get
  });
  fastify2.put("/:id", {
    schema: RoadmapSchemas.update,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: RoadmapController.update
  });
  fastify2.delete("/:id", {
    schema: RoadmapSchemas.delete,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: RoadmapController.delete
  });
  fastify2.patch("/:id/status", {
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: RoadmapController.updateStatus
  });
  fastify2.get("/:roadmapId/milestones/stats", {
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: MilestoneController.getStats
  });
  fastify2.get("/:roadmapId/milestones/upcoming", {
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: MilestoneController.getUpcoming
  });
  fastify2.get("/:roadmapId/milestones/overdue", {
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: MilestoneController.getOverdue
  });
  fastify2.get("/:roadmapId/milestones/in-progress", {
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: MilestoneController.getInProgress
  });
  fastify2.get("/:roadmapId/milestones/timeline", {
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: MilestoneController.getTimeline
  });
  fastify2.get("/:roadmapId/milestones/search", {
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: MilestoneController.search
  });
  fastify2.post("/:roadmapId/milestones", {
    schema: MilestoneSchemas.create,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: MilestoneController.create
  });
  fastify2.get("/:roadmapId/milestones", {
    schema: MilestoneSchemas.list,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: MilestoneController.list
  });
  fastify2.get("/:roadmapId/milestones/:id", {
    schema: MilestoneSchemas.get,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: MilestoneController.get
  });
  fastify2.put("/:roadmapId/milestones/:id", {
    schema: MilestoneSchemas.update,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: MilestoneController.update
  });
  fastify2.delete("/:roadmapId/milestones/:id", {
    schema: MilestoneSchemas.delete,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: MilestoneController.delete
  });
  fastify2.patch("/:roadmapId/milestones/:id/progress", {
    schema: MilestoneSchemas.updateProgress,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: MilestoneController.updateProgress
  });
  fastify2.patch("/:roadmapId/milestones/:id/status", {
    schema: MilestoneSchemas.updateStatus,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: MilestoneController.updateStatus
  });
  fastify2.post("/:roadmapId/milestones/reorder", {
    schema: MilestoneSchemas.reorder,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: MilestoneController.reorder
  });
}

// src/features/upload/upload.controller.ts
var import_path2 = __toESM(require("path"));

// src/features/upload/commands/upload.commands.ts
init_prisma();
var UploadCommands = {
  async create(data) {
    const upload = await db.media.create({
      data: {
        url: data.url,
        name: data.name,
        type: data.type,
        size: data.size
      }
    });
    return upload;
  },
  async update(id, data) {
    const upload = await db.media.update({
      where: { id },
      data: {
        ...data.url && { url: data.url },
        ...data.name && { name: data.name },
        ...data.type && { type: data.type },
        ...data.size && { size: data.size }
      }
    });
    return upload;
  },
  async delete(id) {
    await db.productMedia.deleteMany({
      where: { mediaId: id }
    });
    await db.supplierMedia.deleteMany({
      where: { mediaId: id }
    });
    await db.userMedia.deleteMany({
      where: { mediaId: id }
    });
    await db.storeMedia.deleteMany({
      where: { mediaId: id }
    });
    await db.media.delete({
      where: { id }
    });
  },
  async attachToProduct(data) {
    if (data.entityType !== "product") {
      throw new Error("Invalid entity type for product attachment");
    }
    const attachment = await db.productMedia.create({
      data: {
        productId: data.entityId,
        mediaId: data.mediaId,
        isPrimary: data.isPrimary || false
      }
    });
    if (data.isPrimary) {
      await db.productMedia.updateMany({
        where: {
          productId: data.entityId,
          id: { not: attachment.id }
        },
        data: { isPrimary: false }
      });
    }
    return attachment;
  },
  async attachToSupplier(data) {
    if (data.entityType !== "supplier") {
      throw new Error("Invalid entity type for supplier attachment");
    }
    const attachment = await db.supplierMedia.create({
      data: {
        supplierId: data.entityId,
        mediaId: data.mediaId
      }
    });
    return attachment;
  },
  async attachToUser(data) {
    if (data.entityType !== "user") {
      throw new Error("Invalid entity type for user attachment");
    }
    const attachment = await db.userMedia.create({
      data: {
        userId: data.entityId,
        mediaId: data.mediaId
      }
    });
    return attachment;
  },
  async attachToStore(data) {
    if (data.entityType !== "store") {
      throw new Error("Invalid entity type for store attachment");
    }
    const attachment = await db.storeMedia.create({
      data: {
        storeId: data.entityId,
        mediaId: data.mediaId
      }
    });
    return attachment;
  },
  async detachFromProduct(mediaId, entityId) {
    const attachment = await db.productMedia.findFirst({
      where: {
        mediaId,
        productId: entityId
      }
    });
    if (!attachment) {
      throw new Error("Media attachment not found");
    }
    await db.productMedia.delete({
      where: { id: attachment.id }
    });
    return attachment;
  },
  async detachFromSupplier(mediaId, entityId) {
    const attachment = await db.supplierMedia.findFirst({
      where: {
        mediaId,
        supplierId: entityId
      }
    });
    if (!attachment) {
      throw new Error("Media attachment not found");
    }
    await db.supplierMedia.delete({
      where: { id: attachment.id }
    });
    return attachment;
  },
  async detachFromUser(mediaId, entityId) {
    const attachment = await db.userMedia.findFirst({
      where: {
        mediaId,
        userId: entityId
      }
    });
    if (!attachment) {
      throw new Error("Media attachment not found");
    }
    await db.userMedia.delete({
      where: { id: attachment.id }
    });
    return attachment;
  },
  async detachFromStore(mediaId, entityId) {
    const attachment = await db.storeMedia.findFirst({
      where: {
        mediaId,
        storeId: entityId
      }
    });
    if (!attachment) {
      throw new Error("Media attachment not found");
    }
    await db.storeMedia.delete({
      where: { id: attachment.id }
    });
    return attachment;
  },
  async setPrimaryForProduct(mediaId, productId) {
    await db.productMedia.updateMany({
      where: {
        productId,
        mediaId: { not: mediaId }
      },
      data: { isPrimary: false }
    });
    const attachment = await db.productMedia.updateMany({
      where: {
        mediaId,
        productId
      },
      data: { isPrimary: true }
    });
    return attachment;
  },
  async bulkDelete(mediaIds) {
    await Promise.all([
      db.productMedia.deleteMany({
        where: { mediaId: { in: mediaIds } }
      }),
      db.supplierMedia.deleteMany({
        where: { mediaId: { in: mediaIds } }
      }),
      db.userMedia.deleteMany({
        where: { mediaId: { in: mediaIds } }
      }),
      db.storeMedia.deleteMany({
        where: { mediaId: { in: mediaIds } }
      })
    ]);
    await db.media.deleteMany({
      where: { id: { in: mediaIds } }
    });
    return { deletedCount: mediaIds.length };
  }
};

// src/features/upload/queries/upload.queries.ts
init_prisma();
var UploadQueries = {
  async getById(id) {
    const upload = await db.media.findUnique({
      where: { id }
    });
    if (!upload) {
      throw new Error("Media not found");
    }
    return upload;
  },
  async list(filters) {
    const { page, limit, search, type, entityType, entityId } = filters;
    const skip2 = (page - 1) * limit;
    const where = {};
    if (search) {
      where.OR = [
        { name: { contains: search, mode: "insensitive" } },
        { type: { contains: search, mode: "insensitive" } }
      ];
    }
    if (type) {
      where.type = { contains: type, mode: "insensitive" };
    }
    let include = {};
    if (entityType && entityId) {
      switch (entityType) {
        case "product":
          include.productMedia = {
            where: { productId: entityId }
          };
          break;
        case "supplier":
          include.supplierMedia = {
            where: { supplierId: entityId }
          };
          break;
        case "user":
          include.userMedia = {
            where: { userId: entityId }
          };
          break;
        case "store":
          include.storeMedia = {
            where: { storeId: entityId }
          };
          break;
      }
    }
    const [uploads, total] = await Promise.all([
      db.media.findMany({
        where,
        include,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" }
      }),
      db.media.count({ where })
    ]);
    const filteredUploads = entityType && entityId ? uploads.filter((upload) => {
      switch (entityType) {
        case "product":
          return upload.productMedia && upload.productMedia.length > 0;
        case "supplier":
          return upload.supplierMedia && upload.supplierMedia.length > 0;
        case "user":
          return upload.userMedia && upload.userMedia.length > 0;
        case "store":
          return upload.storeMedia && upload.storeMedia.length > 0;
        default:
          return true;
      }
    }) : uploads;
    return {
      uploads: filteredUploads,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getByType(type, limit = 10) {
    const uploads = await db.media.findMany({
      where: {
        type: { contains: type, mode: "insensitive" }
      },
      take: limit,
      orderBy: { createdAt: "desc" }
    });
    return uploads;
  },
  async getRecent(limit = 20) {
    const uploads = await db.media.findMany({
      take: limit,
      orderBy: { createdAt: "desc" }
    });
    return uploads;
  },
  async getEntityMedia(entityType, entityId) {
    let media = [];
    switch (entityType) {
      case "product":
        media = await db.productMedia.findMany({
          where: { productId: entityId },
          include: {
            media: true
          },
          orderBy: [
            { isPrimary: "desc" }
          ]
        });
        break;
      case "supplier":
        media = await db.supplierMedia.findMany({
          where: { supplierId: entityId },
          include: {
            media: true
          },
          orderBy: { id: "desc" }
        });
        break;
      case "user":
        media = await db.userMedia.findMany({
          where: { userId: entityId },
          include: {
            media: true
          },
          orderBy: { id: "desc" }
        });
        break;
      case "store":
        media = await db.storeMedia.findMany({
          where: { storeId: entityId },
          include: {
            media: true
          },
          orderBy: { id: "desc" }
        });
        break;
      default:
        throw new Error("Invalid entity type");
    }
    return media.map((item) => ({
      id: item.id,
      mediaId: item.mediaId,
      entityType,
      entityId,
      isPrimary: "isPrimary" in item ? item.isPrimary : null,
      createdAt: item.createdAt,
      media: item.media
    }));
  },
  async getPrimaryMedia(entityType, entityId) {
    let media = null;
    switch (entityType) {
      case "product":
        const productMedia = await db.productMedia.findFirst({
          where: {
            productId: entityId,
            isPrimary: true
          },
          include: {
            media: true
          }
        });
        media = productMedia;
        break;
      case "supplier":
      case "user":
      case "store":
        const firstMedia = await this.getEntityMedia(entityType, entityId);
        media = firstMedia[0] || null;
        break;
      default:
        throw new Error("Invalid entity type");
    }
    return media;
  },
  async search(query, limit = 10) {
    const uploads = await db.media.findMany({
      where: {
        OR: [
          { name: { contains: query, mode: "insensitive" } },
          { type: { contains: query, mode: "insensitive" } }
        ]
      },
      take: limit,
      orderBy: { createdAt: "desc" }
    });
    return uploads;
  },
  async getStats() {
    const [total, byType, recentCount] = await Promise.all([
      db.media.count(),
      db.media.groupBy({
        by: ["type"],
        _count: { type: true },
        orderBy: { _count: { type: "desc" } }
      }),
      db.media.count({
        where: {
          createdAt: {
            gte: new Date(Date.now() - 24 * 60 * 60 * 1e3)
            // Últimas 24h
          }
        }
      })
    ]);
    return {
      total,
      byType: byType.map((item) => ({
        type: item.type || "unknown",
        count: item._count.type
      })),
      recentCount
    };
  },
  async getUnusedMedia(daysOld = 30) {
    const cutoffDate = new Date(Date.now() - daysOld * 24 * 60 * 60 * 1e3);
    const unusedMedia = await db.media.findMany({
      where: {
        createdAt: { lt: cutoffDate },
        AND: [
          { productMedia: { none: {} } },
          { supplierMedia: { none: {} } },
          { userMedia: { none: {} } },
          { storeMedia: { none: {} } }
        ]
      },
      orderBy: { createdAt: "asc" }
    });
    return unusedMedia;
  },
  async getMediaUsage(mediaId) {
    const [productUsage, supplierUsage, userUsage, storeUsage] = await Promise.all([
      db.productMedia.findMany({
        where: { mediaId },
        include: {
          product: {
            select: { id: true, name: true }
          }
        }
      }),
      db.supplierMedia.findMany({
        where: { mediaId },
        include: {
          supplier: {
            select: { id: true, corporateName: true }
          }
        }
      }),
      db.userMedia.findMany({
        where: { mediaId },
        include: {
          user: {
            select: { id: true, name: true, email: true }
          }
        }
      }),
      db.storeMedia.findMany({
        where: { mediaId },
        include: {
          store: {
            select: { id: true, name: true }
          }
        }
      })
    ]);
    return {
      products: productUsage,
      suppliers: supplierUsage,
      users: userUsage,
      stores: storeUsage,
      totalUsage: productUsage.length + supplierUsage.length + userUsage.length + storeUsage.length
    };
  },
  async getAllUsedFilePaths() {
    const media = await db.media.findMany({
      select: { url: true }
    });
    return media.map((m) => m.url);
  }
};

// src/features/upload/upload.service.ts
var import_fs = require("fs");
var import_path = __toESM(require("path"));
var import_crypto2 = require("crypto");
var UPLOAD_DIR = import_path.default.join(process.cwd(), "src", "uploads");
var MAX_FILE_SIZE = 10 * 1024 * 1024;
var ALLOWED_TYPES = [
  "image/jpeg",
  "image/png",
  "image/gif",
  "image/webp",
  "image/svg+xml",
  "application/pdf",
  "application/msword",
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
  "application/vnd.ms-excel",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
  "text/plain"
];
var UploadService = class _UploadService {
  constructor() {
    this.uploadDir = UPLOAD_DIR;
    this.ensureUploadDirectories();
  }
  static getInstance() {
    if (!_UploadService.instance) {
      _UploadService.instance = new _UploadService();
    }
    return _UploadService.instance;
  }
  // === INICIALIZAÇÃO ===
  async ensureUploadDirectories() {
    const directories = [
      UPLOAD_DIR,
      import_path.default.join(UPLOAD_DIR, "product"),
      import_path.default.join(UPLOAD_DIR, "supplier"),
      import_path.default.join(UPLOAD_DIR, "user"),
      import_path.default.join(UPLOAD_DIR, "store"),
      import_path.default.join(UPLOAD_DIR, "general")
    ];
    for (const dir of directories) {
      try {
        await import_fs.promises.access(dir);
      } catch {
        await import_fs.promises.mkdir(dir, { recursive: true });
      }
    }
  }
  // === CRIAR DIRETÓRIO DO USUÁRIO ===
  async ensureUserDirectory(userId) {
    const userDir = import_path.default.join(UPLOAD_DIR, "users", userId);
    try {
      await import_fs.promises.access(userDir);
    } catch {
      await import_fs.promises.mkdir(userDir, { recursive: true });
    }
    return userDir;
  }
  // === VALIDAÇÃO ===
  validateFile(file, config = {}) {
    const allowedTypes = config.allowedTypes || ALLOWED_TYPES;
    const maxFileSize = config.maxFileSize || MAX_FILE_SIZE;
    if (!allowedTypes.includes(file.mimetype)) {
      throw new Error(`Tipo de arquivo n\xE3o permitido: ${file.mimetype}`);
    }
    if (file.size > maxFileSize) {
      throw new Error(`Arquivo muito grande. M\xE1ximo permitido: ${maxFileSize / 1024 / 1024}MB`);
    }
  }
  // === GERAR NOME ÚNICO ===
  generateUniqueFilename(originalName) {
    const ext = import_path.default.extname(originalName);
    const name = import_path.default.basename(originalName, ext);
    const uuid = (0, import_crypto2.randomUUID)();
    return `${name}-${uuid}${ext}`;
  }
  // === UPLOAD ÚNICO ===
  async uploadSingle(file, config = {}) {
    try {
      this.validateFile(file, config);
      if (!file.path || typeof file.path !== "string") {
        throw new Error("Caminho do arquivo inv\xE1lido ou n\xE3o fornecido");
      }
      try {
        await import_fs.promises.access(file.path);
      } catch (error) {
        throw new Error(`Arquivo tempor\xE1rio n\xE3o encontrado: ${file.path}`);
      }
      const entityType = config.entityType || "general";
      let destinationDir;
      let publicUrl;
      if (config.userId) {
        const userDir = await this.ensureUserDirectory(config.userId);
        destinationDir = import_path.default.join(userDir, entityType);
        try {
          await import_fs.promises.access(destinationDir);
        } catch {
          await import_fs.promises.mkdir(destinationDir, { recursive: true });
        }
        publicUrl = `/uploads/users/${config.userId}/${entityType}`;
      } else {
        destinationDir = import_path.default.join(this.uploadDir, entityType);
        publicUrl = `/uploads/${entityType}`;
      }
      const uniqueFilename = this.generateUniqueFilename(file.originalname);
      const destination = import_path.default.join(destinationDir, uniqueFilename);
      await import_fs.promises.copyFile(file.path, destination);
      publicUrl = `${publicUrl}/${uniqueFilename}`;
      const result = {
        id: (0, import_crypto2.randomUUID)(),
        url: publicUrl,
        name: file.originalname,
        type: file.mimetype,
        size: file.size,
        path: destination
      };
      return result;
    } catch (error) {
      throw new Error(`Erro no upload: ${error.message}`);
    }
  }
  // === UPLOAD MÚLTIPLOS ===
  async uploadMultiple(files, config = {}) {
    const maxFiles = config.maxFiles || 10;
    if (files.length > maxFiles) {
      throw new Error(`M\xE1ximo de ${maxFiles} arquivos permitidos`);
    }
    const results = [];
    for (const file of files) {
      try {
        const result = await this.uploadSingle(file, config);
        results.push(result);
      } catch (error) {
        await this.cleanupFailedUploads(results);
        throw error;
      }
    }
    return results;
  }
  // === LIMPEZA DE ARQUIVOS FALHADOS ===
  async cleanupFailedUploads(uploadedFiles) {
    for (const file of uploadedFiles) {
      try {
        await import_fs.promises.unlink(file.path);
      } catch (error) {
        console.error(`Erro ao deletar arquivo ${file.path}:`, error);
      }
    }
  }
  // === DELETAR ARQUIVO ===
  async deleteFile(filePath) {
    try {
      await import_fs.promises.unlink(filePath);
    } catch (error) {
      throw new Error(`Erro ao deletar arquivo: ${error.message}`);
    }
  }
  // === DELETAR MÚLTIPLOS ARQUIVOS ===
  async deleteMultipleFiles(filePaths) {
    let deleted = 0;
    let failed = 0;
    for (const filePath of filePaths) {
      try {
        await this.deleteFile(filePath);
        deleted++;
      } catch (error) {
        failed++;
        console.error(`Erro ao deletar ${filePath}:`, error);
      }
    }
    return { deleted, failed };
  }
  // === OBTER INFORMAÇÕES DO ARQUIVO ===
  async getFileInfo(filePath) {
    try {
      const stats = await import_fs.promises.stat(filePath);
      return {
        exists: true,
        size: stats.size,
        stats
      };
    } catch (error) {
      return { exists: false };
    }
  }
  // === LISTAR ARQUIVOS DE UMA ENTIDADE ===
  async listEntityFiles(entityType) {
    try {
      const entityDir = import_path.default.join(this.uploadDir, entityType);
      const files = await import_fs.promises.readdir(entityDir);
      return files.filter((file) => {
        const filePath = import_path.default.join(entityDir, file);
        const stats = import_fs.promises.stat(filePath);
        return stats.then((s) => s.isFile()).catch(() => false);
      });
    } catch (error) {
      return [];
    }
  }
  // === LIMPEZA DE ARQUIVOS ÓRFÃOS ===
  async cleanupOrphanedFiles(usedFilePaths) {
    const allFiles = [];
    const directories = ["product", "supplier", "user", "store", "general"];
    for (const dir of directories) {
      const files = await this.listEntityFiles(dir);
      allFiles.push(...files.map((file) => import_path.default.join(this.uploadDir, dir, file)));
    }
    const orphanedFiles = allFiles.filter((file) => !usedFilePaths.includes(file));
    return await this.deleteMultipleFiles(orphanedFiles);
  }
  // === OBTER ESTATÍSTICAS ===
  async getStats() {
    const stats = {
      totalFiles: 0,
      totalSize: 0,
      byEntityType: {},
      byFileType: {}
    };
    const directories = ["product", "supplier", "user", "store", "general"];
    for (const dir of directories) {
      const files = await this.listEntityFiles(dir);
      let dirSize = 0;
      for (const file of files) {
        const filePath = import_path.default.join(this.uploadDir, dir, file);
        const fileInfo = await this.getFileInfo(filePath);
        if (fileInfo.exists && fileInfo.size) {
          dirSize += fileInfo.size;
          stats.totalSize += fileInfo.size;
          stats.totalFiles++;
          const ext = import_path.default.extname(file).toLowerCase();
          stats.byFileType[ext] = (stats.byFileType[ext] || 0) + 1;
        }
      }
      stats.byEntityType[dir] = {
        count: files.length,
        size: dirSize
      };
    }
    return stats;
  }
  // === UTILITÁRIOS ===
  // Verificar se é imagem
  isImage(mimetype) {
    return mimetype.startsWith("image/");
  }
  // Verificar se é vídeo
  isVideo(mimetype) {
    return mimetype.startsWith("video/");
  }
  // Verificar se é documento
  isDocument(mimetype) {
    const documentTypes = [
      "application/pdf",
      "application/msword",
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
      "application/vnd.ms-excel",
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
      "text/plain"
    ];
    return documentTypes.includes(mimetype);
  }
  // Formatar tamanho do arquivo
  formatFileSize(bytes) {
    const sizes = ["B", "KB", "MB", "GB"];
    const i = Math.floor(Math.log(bytes) / Math.log(1024));
    return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + " " + sizes[i];
  }
  // Obter ícone baseado no tipo
  getFileIcon(mimetype) {
    if (mimetype.startsWith("image/")) return "\u{1F5BC}\uFE0F";
    if (mimetype.startsWith("video/")) return "\u{1F3A5}";
    if (mimetype.startsWith("audio/")) return "\u{1F3B5}";
    if (mimetype === "application/pdf") return "\u{1F4D5}";
    if (mimetype.includes("word")) return "\u{1F4DD}";
    if (mimetype.includes("excel") || mimetype.includes("spreadsheet")) return "\u{1F4CA}";
    if (mimetype.includes("powerpoint") || mimetype.includes("presentation")) return "\u{1F4FD}\uFE0F";
    if (mimetype.includes("zip") || mimetype.includes("rar")) return "\u{1F4E6}";
    return "\u{1F4C4}";
  }
};
var uploadService = UploadService.getInstance();

// src/features/upload/upload.controller.ts
var UploadController = {
  // === CRUD BÁSICO ===
  async create(request, reply) {
    try {
      const { name, type, size } = request.body;
      const result = await UploadCommands.create({
        url: "",
        // Será preenchida pelo service
        name,
        type,
        size
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Validation error") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      const result = await UploadQueries.getById(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Media not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      const result = await UploadCommands.update(id, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Media not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Validation error") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      const media = await UploadQueries.getById(id);
      if (!media) {
        return reply.status(404).send({
          error: "Media not found"
        });
      }
      await UploadCommands.delete(id);
      try {
        const filePath = import_path2.default.join(process.cwd(), "src", "uploads", media.url.replace("/uploads/", ""));
        await uploadService.deleteFile(filePath);
      } catch (fileError) {
        request.log.warn(`Arquivo f\xEDsico n\xE3o encontrado: ${media.url}`);
      }
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Media not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { page = 1, limit = 10, search, type, entityType, entityId } = request.query;
      const result = await UploadQueries.list({
        page,
        limit,
        search,
        type,
        entityType,
        entityId
      });
      const protocol = request.headers["x-forwarded-proto"] || request.server.https ? "https" : "http";
      const host = request.headers["x-forwarded-host"] || request.headers.host || "localhost:3000";
      const responseData = {
        ...result,
        uploads: result.uploads?.map((upload) => ({
          ...upload,
          fullUrl: `${protocol}://${host}${upload.url}`
        })) || []
      };
      return reply.send(responseData);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (QUERIES) ===
  async getByType(request, reply) {
    try {
      const { type, limit = 10 } = request.query;
      const result = await UploadQueries.getByType(type, limit);
      const protocol = request.headers["x-forwarded-proto"] || request.server.https ? "https" : "http";
      const host = request.headers["x-forwarded-host"] || request.headers.host || "localhost:3000";
      const uploadsWithFullUrl = result.map((upload) => ({
        ...upload,
        fullUrl: `${protocol}://${host}${upload.url}`
      }));
      return reply.send({ uploads: uploadsWithFullUrl });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getRecent(request, reply) {
    try {
      const { limit = 20 } = request.query;
      const result = await UploadQueries.getRecent(limit);
      const protocol = request.headers["x-forwarded-proto"] || request.server.https ? "https" : "http";
      const host = request.headers["x-forwarded-host"] || request.headers.host || "localhost:3000";
      const uploadsWithFullUrl = result.map((upload) => ({
        ...upload,
        fullUrl: `${protocol}://${host}${upload.url}`
      }));
      return reply.send({ uploads: uploadsWithFullUrl });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getEntityMedia(request, reply) {
    try {
      const { entityType, entityId } = request.params;
      const result = await UploadQueries.getEntityMedia(entityType, entityId);
      const protocol = request.headers["x-forwarded-proto"] || request.server.https ? "https" : "http";
      const host = request.headers["x-forwarded-host"] || request.headers.host || "localhost:3000";
      const mediaWithFullUrl = result.map((media) => ({
        ...media,
        fullUrl: `${protocol}://${host}${media.url}`
      }));
      return reply.send({ media: mediaWithFullUrl });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invalid entity type") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getPrimaryMedia(request, reply) {
    try {
      const { entityType, entityId } = request.params;
      const result = await UploadQueries.getPrimaryMedia(entityType, entityId);
      if (!result) {
        return reply.status(404).send({
          error: "No media found"
        });
      }
      const protocol = request.headers["x-forwarded-proto"] || request.server.https ? "https" : "http";
      const host = request.headers["x-forwarded-host"] || request.headers.host || "localhost:3000";
      const resultWithFullUrl = {
        ...result,
        fullUrl: `${protocol}://${host}${result.url}`
      };
      return reply.send(resultWithFullUrl);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invalid entity type") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const result = await UploadQueries.getStats();
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { q, limit = 10 } = request.query;
      const result = await UploadQueries.search(q, limit);
      const protocol = request.headers["x-forwarded-proto"] || request.server.https ? "https" : "http";
      const host = request.headers["x-forwarded-host"] || request.headers.host || "localhost:3000";
      const uploadsWithFullUrl = result.map((upload) => ({
        ...upload,
        fullUrl: `${protocol}://${host}${upload.url}`
      }));
      return reply.send({ uploads: uploadsWithFullUrl });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getMediaUsage(request, reply) {
    try {
      const { id } = request.params;
      const result = await UploadQueries.getMediaUsage(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getUnusedMedia(request, reply) {
    try {
      const { daysOld = 30 } = request.query;
      const result = await UploadQueries.getUnusedMedia(daysOld);
      const protocol = request.headers["x-forwarded-proto"] || request.server.https ? "https" : "http";
      const host = request.headers["x-forwarded-host"] || request.headers.host || "localhost:3000";
      const uploadsWithFullUrl = result.map((upload) => ({
        ...upload,
        fullUrl: `${protocol}://${host}${upload.url}`
      }));
      return reply.send({ uploads: uploadsWithFullUrl });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (COMMANDS) ===
  async attachMedia(request, reply) {
    try {
      const { id } = request.params;
      const { entityType, entityId, isPrimary } = request.body;
      let result;
      switch (entityType) {
        case "product":
          result = await UploadCommands.attachToProduct({
            mediaId: id,
            entityType,
            entityId,
            isPrimary
          });
          break;
        case "supplier":
          result = await UploadCommands.attachToSupplier({
            mediaId: id,
            entityType,
            entityId
          });
          break;
        case "user":
          result = await UploadCommands.attachToUser({
            mediaId: id,
            entityType,
            entityId
          });
          break;
        case "store":
          result = await UploadCommands.attachToStore({
            mediaId: id,
            entityType,
            entityId
          });
          break;
        default:
          return reply.status(400).send({
            error: "Invalid entity type"
          });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invalid entity type for attachment") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async detachMedia(request, reply) {
    try {
      const { id } = request.params;
      const { entityType, entityId } = request.body;
      let result;
      switch (entityType) {
        case "product":
          result = await UploadCommands.detachFromProduct(id, entityId);
          break;
        case "supplier":
          result = await UploadCommands.detachFromSupplier(id, entityId);
          break;
        case "user":
          result = await UploadCommands.detachFromUser(id, entityId);
          break;
        case "store":
          result = await UploadCommands.detachFromStore(id, entityId);
          break;
        default:
          return reply.status(400).send({
            error: "Invalid entity type"
          });
      }
      return reply.send({ success: true });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Media attachment not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async setPrimaryMedia(request, reply) {
    try {
      const { id } = request.params;
      const { entityType, entityId } = request.body;
      let result;
      if (entityType === "product") {
        result = await UploadCommands.setPrimaryForProduct(id, entityId);
      } else {
        return reply.status(400).send({
          error: "Primary media is only supported for products"
        });
      }
      return reply.send({ success: true });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Media not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async bulkDelete(request, reply) {
    try {
      const { mediaIds } = request.body;
      const result = await UploadCommands.bulkDelete(mediaIds);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === UPLOAD DE ARQUIVOS FÍSICOS ===
  async uploadSingle(request, reply) {
    try {
      const data = await request.file();
      if (!data) {
        return reply.status(400).send({
          error: "Nenhum arquivo enviado"
        });
      }
      console.log("Estrutura do objeto data:", JSON.stringify({
        fieldname: data.fieldname,
        filename: data.filename,
        mimetype: data.mimetype,
        encoding: data.encoding,
        hasFile: !!data.file,
        fileKeys: data.file ? Object.keys(data.file) : "no file object",
        filePath: data.file?.path,
        fileFilename: data.file?.filename,
        // Verificar se é um stream
        isStream: data.file?.toBuffer ? "yes" : "no",
        // Verificar outras propriedades possíveis
        allKeys: Object.keys(data)
      }, null, 2));
      const { entityType = "general" } = request.body || request.query;
      const userId = request.user?.id;
      if (!userId) {
        return reply.status(401).send({
          error: "Usu\xE1rio n\xE3o autenticado"
        });
      }
      let filePath;
      let fileSize = 0;
      if (data.toBuffer) {
        console.log("Convertendo stream para buffer usando data.toBuffer...");
        const buffer = await data.toBuffer();
        fileSize = buffer.length;
        const tempPath = require("path").join(require("os").tmpdir(), `temp-${Date.now()}-${data.filename}`);
        await require("fs").promises.writeFile(tempPath, buffer);
        filePath = tempPath;
        console.log(`Arquivo tempor\xE1rio criado: ${tempPath}`);
      } else if (data.file && data.file.toBuffer) {
        console.log("Convertendo stream para buffer usando data.file.toBuffer...");
        const buffer = await data.file.toBuffer();
        fileSize = buffer.length;
        const tempPath = require("path").join(require("os").tmpdir(), `temp-${Date.now()}-${data.filename}`);
        await require("fs").promises.writeFile(tempPath, buffer);
        filePath = tempPath;
        console.log(`Arquivo tempor\xE1rio criado: ${tempPath}`);
      } else if (data.file && data.file.bytesRead) {
        filePath = data.file.path || data.file.filepath || data.file.filename;
        fileSize = data.file.bytesRead;
      } else {
        filePath = data.path || data.filepath || data.filename;
        fileSize = data.size || data.bytesRead || 0;
      }
      const fileData = {
        fieldname: data.fieldname || "file",
        filename: data.filename || "unknown",
        originalname: data.filename || "unknown",
        encoding: data.encoding || "7bit",
        mimetype: data.mimetype || "application/octet-stream",
        size: fileSize,
        destination: "",
        // Será definido pelo service
        path: filePath,
        url: ""
        // Será definido pelo service
      };
      if (!fileData.path) {
        console.error("Estrutura completa do data:", JSON.stringify(data, null, 2));
        return reply.status(400).send({
          error: "N\xE3o foi poss\xEDvel determinar o caminho do arquivo. Estrutura do objeto inesperada."
        });
      }
      const uploadResult = await uploadService.uploadSingle(fileData, {
        entityType,
        userId
      });
      const dbResult = await UploadCommands.create({
        url: uploadResult.url,
        name: uploadResult.name,
        type: uploadResult.type,
        size: uploadResult.size
      });
      if (filePath && filePath.includes("temp-")) {
        try {
          await require("fs").promises.unlink(filePath);
          console.log(`Arquivo tempor\xE1rio removido: ${filePath}`);
        } catch (cleanupError) {
          console.warn(`Erro ao remover arquivo tempor\xE1rio ${filePath}:`, cleanupError);
        }
      }
      const protocol = request.headers["x-forwarded-proto"] || request.server.https ? "https" : "http";
      const host = request.headers["x-forwarded-host"] || request.headers.host || "localhost:3000";
      const fullUrl = `${protocol}://${host}${uploadResult.url}`;
      return reply.status(201).send({
        ...dbResult,
        path: uploadResult.path,
        fullUrl
      });
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("n\xE3o permitido") || error.message.includes("muito grande")) {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async uploadMultiple(request, reply) {
    try {
      const files = request.files();
      const uploadedFiles = [];
      const { entityType = "general", maxFiles = 10 } = request.body || request.query;
      const userId = request.user?.id;
      if (!userId) {
        return reply.status(401).send({
          error: "Usu\xE1rio n\xE3o autenticado"
        });
      }
      for await (const file of files) {
        if (file.file) {
          const fileData = {
            fieldname: file.fieldname,
            filename: file.filename,
            originalname: file.filename,
            encoding: file.encoding,
            mimetype: file.mimetype,
            size: file.file.bytesRead,
            destination: "",
            // Será definido pelo service
            path: file.file.path || file.file.filename,
            // Usar filename se path não estiver disponível
            url: ""
            // Será definido pelo service
          };
          uploadedFiles.push(fileData);
        }
      }
      if (uploadedFiles.length === 0) {
        return reply.status(400).send({
          error: "Nenhum arquivo v\xE1lido enviado"
        });
      }
      const uploadResults = await uploadService.uploadMultiple(uploadedFiles, {
        entityType,
        userId,
        maxFiles
      });
      const dbResults = [];
      for (const uploadResult of uploadResults) {
        const dbResult = await UploadCommands.create({
          url: uploadResult.url,
          name: uploadResult.name,
          type: uploadResult.type,
          size: uploadResult.size
        });
        const protocol = request.headers["x-forwarded-proto"] || request.server.https ? "https" : "http";
        const host = request.headers["x-forwarded-host"] || request.headers.host || "localhost:3000";
        const fullUrl = `${protocol}://${host}${uploadResult.url}`;
        dbResults.push({
          ...dbResult,
          path: uploadResult.path,
          fullUrl
        });
      }
      return reply.status(201).send({
        uploads: dbResults,
        count: dbResults.length
      });
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("n\xE3o permitido") || error.message.includes("muito grande") || error.message.includes("M\xE1ximo")) {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === SERVIÇOS DE MANUTENÇÃO ===
  async cleanupOrphanedFiles(request, reply) {
    try {
      const usedFiles = await UploadQueries.getAllUsedFilePaths();
      const result = await uploadService.cleanupOrphanedFiles(usedFiles);
      return reply.send({
        message: "Limpeza conclu\xEDda",
        ...result
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getServiceConfig(request, reply) {
    try {
      const config = {
        maxFileSize: 10 * 1024 * 1024,
        // 10MB
        maxFiles: 10,
        allowedTypes: [
          "image/jpeg",
          "image/png",
          "image/gif",
          "image/webp",
          "image/svg+xml",
          "application/pdf",
          "application/msword",
          "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
          "application/vnd.ms-excel",
          "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
          "text/plain"
        ],
        uploadDir: uploadService["uploadDir"],
        entityTypes: ["product", "supplier", "user", "store", "general"]
      };
      return reply.send(config);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getFileSystemStats(request, reply) {
    try {
      const stats = await uploadService.getStats();
      return reply.send(stats);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/upload/upload.schema.ts
var createUploadSchema = {
  body: {
    type: "object",
    properties: {
      name: { type: "string", minLength: 1, maxLength: 255 },
      type: { type: "string", minLength: 1, maxLength: 100 },
      size: { type: "number", minimum: 0 }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        url: { type: "string" },
        name: { type: "string", nullable: true },
        type: { type: "string", nullable: true },
        size: { type: "number", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var listUploadsSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      type: { type: "string" },
      entityType: {
        type: "string",
        enum: ["product", "supplier", "user", "store"]
      },
      entityId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        uploads: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              url: { type: "string" },
              name: { type: "string", nullable: true },
              type: { type: "string", nullable: true },
              size: { type: "number", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getEntityMediaSchema = {
  params: {
    type: "object",
    required: ["entityType", "entityId"],
    properties: {
      entityType: {
        type: "string",
        enum: ["product", "supplier", "user", "store"]
      },
      entityId: { type: "string", minLength: 1 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        media: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              mediaId: { type: "string" },
              entityType: { type: "string" },
              entityId: { type: "string" },
              isPrimary: { type: "boolean", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              media: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  url: { type: "string" },
                  name: { type: "string", nullable: true },
                  type: { type: "string", nullable: true },
                  size: { type: "number", nullable: true }
                }
              }
            }
          }
        }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};

// src/features/upload/upload.route.ts
async function UploadRoutes(fastify2) {
  fastify2.addHook("preHandler", authMiddleware);
  fastify2.addHook("preHandler", storeContextMiddleware);
  await fastify2.register(require("@fastify/multipart"), {
    limits: {
      fileSize: 10 * 1024 * 1024,
      // 10MB
      files: 10
      // máximo 10 arquivos por request
    },
    attachFieldsToBody: false,
    // Manter arquivos separados do body
    sharedSchemaId: "MultipartFileType"
    // Schema para validação
  });
  fastify2.post("/", {
    schema: createUploadSchema,
    handler: UploadController.create
  });
  fastify2.get("/", {
    schema: listUploadsSchema,
    handler: UploadController.list
  });
  fastify2.get("/:id", {
    handler: UploadController.get
  });
  fastify2.put("/:id", {
    handler: UploadController.update
  });
  fastify2.delete("/:id", {
    handler: UploadController.delete
  });
  fastify2.post("/upload", {
    handler: UploadController.uploadSingle
  });
  fastify2.post("/upload-multiple", {
    handler: UploadController.uploadMultiple
  });
  fastify2.get("/type/:type", {
    handler: UploadController.getByType
  });
  fastify2.get("/recent", {
    handler: UploadController.getRecent
  });
  fastify2.get("/stats", {
    handler: UploadController.getStats
  });
  fastify2.get("/search", {
    handler: UploadController.search
  });
  fastify2.get("/:id/usage", {
    handler: UploadController.getMediaUsage
  });
  fastify2.get("/unused", {
    handler: UploadController.getUnusedMedia
  });
  fastify2.post("/:id/attach", {
    handler: UploadController.attachMedia
  });
  fastify2.post("/:id/detach", {
    handler: UploadController.detachMedia
  });
  fastify2.patch("/:id/set-primary", {
    handler: UploadController.setPrimaryMedia
  });
  fastify2.get("/entity/:entityType/:entityId", {
    schema: getEntityMediaSchema,
    handler: UploadController.getEntityMedia
  });
  fastify2.get("/entity/:entityType/:entityId/primary", {
    handler: UploadController.getPrimaryMedia
  });
  fastify2.post("/bulk-delete", {
    handler: UploadController.bulkDelete
  });
  fastify2.post("/cleanup-orphaned", {
    handler: UploadController.cleanupOrphanedFiles
  });
  fastify2.get("/service/config", {
    handler: UploadController.getServiceConfig
  });
  fastify2.get("/service/stats", {
    handler: UploadController.getFileSystemStats
  });
}

// src/features/quote/commands/quote.commands.ts
init_prisma();
var import_library = require("@prisma/client/runtime/library");
var QuoteCommands = {
  async create(data) {
    const { items, installments, ...quoteData } = data;
    const productIds = items.map((item) => item.productId);
    const existingProducts = await db.product.findMany({
      where: { id: { in: productIds } },
      select: { id: true, name: true }
    });
    if (existingProducts.length !== productIds.length) {
      const foundIds = existingProducts.map((p) => p.id);
      const notFoundIds = productIds.filter((id) => !foundIds.includes(id));
      throw new Error(`Products not found: ${notFoundIds.join(", ")}`);
    }
    let subtotal = new import_library.Decimal(0);
    const itemsWithSubtotal = items.map((item) => {
      const itemSubtotal = new import_library.Decimal(item.quantity * item.unitPrice).minus(item.discount || 0);
      subtotal = subtotal.plus(itemSubtotal);
      return {
        ...item,
        subtotal: itemSubtotal.toNumber()
      };
    });
    const total = subtotal.minus(quoteData.discount || 0).plus(quoteData.interest || 0);
    const quote = await db.quote.create({
      data: {
        ...quoteData,
        subtotal: new import_library.Decimal(subtotal),
        total: new import_library.Decimal(total),
        expiresAt: quoteData.expiresAt ? new Date(quoteData.expiresAt) : null,
        items: {
          create: itemsWithSubtotal.map((item) => ({
            productId: item.productId,
            quantity: item.quantity,
            unitPrice: item.unitPrice,
            subtotal: new import_library.Decimal(item.subtotal),
            discount: item.discount,
            note: item.note
          }))
        },
        ...installments && installments.length > 0 && {
          installments: {
            create: installments.map((installment) => ({
              number: installment.number,
              dueDate: new Date(installment.dueDate),
              amount: new import_library.Decimal(installment.amount),
              interest: installment.interest ? new import_library.Decimal(installment.interest) : null
            }))
          }
        }
      },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                unitOfMeasure: true,
                referencePrice: true
              }
            }
          }
        },
        installments: true,
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    return quote;
  },
  async update(id, data) {
    const existingQuote = await db.quote.findUnique({
      where: { id },
      include: { items: true, installments: true }
    });
    if (!existingQuote) {
      throw new Error("Quote not found");
    }
    if (existingQuote.status !== "DRAFT") {
      throw new Error("Only DRAFT quotes can be updated");
    }
    const { items, installments, ...updateData } = data;
    let subtotal = existingQuote.subtotal;
    let total = existingQuote.total;
    if (items) {
      const productIds = items.map((item) => item.productId);
      const existingProducts = await db.product.findMany({
        where: { id: { in: productIds } },
        select: { id: true }
      });
      if (existingProducts.length !== productIds.length) {
        const foundIds = existingProducts.map((p) => p.id);
        const notFoundIds = productIds.filter((id2) => !foundIds.includes(id2));
        throw new Error(`Products not found: ${notFoundIds.join(", ")}`);
      }
      subtotal = new import_library.Decimal(0);
      const itemsWithSubtotal = items.map((item) => {
        const itemSubtotal = new import_library.Decimal(item.quantity * item.unitPrice).minus(item.discount || 0);
        subtotal = subtotal.plus(itemSubtotal);
        return {
          ...item,
          subtotal: itemSubtotal.toNumber()
        };
      });
      const discount = updateData.discount || existingQuote.discount || 0;
      const interest = updateData.interest || existingQuote.interest || 0;
      total = subtotal.minus(discount).plus(interest);
    }
    const quote = await db.quote.update({
      where: { id },
      data: {
        ...updateData,
        subtotal: new import_library.Decimal(subtotal),
        total: new import_library.Decimal(total),
        expiresAt: updateData.expiresAt ? new Date(updateData.expiresAt) : void 0,
        ...items && {
          items: {
            deleteMany: {},
            create: items.map((item) => ({
              productId: item.productId,
              quantity: item.quantity,
              unitPrice: item.unitPrice,
              subtotal: new import_library.Decimal(item.quantity * item.unitPrice - (item.discount || 0)),
              discount: item.discount,
              note: item.note
            }))
          }
        },
        ...installments && {
          installments: {
            deleteMany: {},
            create: installments.map((installment) => ({
              number: installment.number,
              dueDate: new Date(installment.dueDate),
              amount: new import_library.Decimal(installment.amount),
              interest: installment.interest ? new import_library.Decimal(installment.interest) : null
            }))
          }
        }
      },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                unitOfMeasure: true,
                referencePrice: true
              }
            }
          }
        },
        installments: true,
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    return quote;
  },
  async delete(id) {
    const quote = await db.quote.findUnique({
      where: { id }
    });
    if (!quote) {
      throw new Error("Quote not found");
    }
    if (quote.status !== "DRAFT" && quote.status !== "CANCELED") {
      throw new Error("Only DRAFT or CANCELED quotes can be deleted");
    }
    return await db.quote.delete({
      where: { id }
    });
  },
  async updateStatus(id, status) {
    const quote = await db.quote.findUnique({
      where: { id }
    });
    if (!quote) {
      throw new Error("Quote not found");
    }
    return await db.quote.update({
      where: { id },
      data: { status },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                unitOfMeasure: true,
                referencePrice: true
              }
            }
          }
        },
        installments: true,
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async approve(publicId, authCode) {
    const quote = await db.quote.findFirst({
      where: {
        publicId,
        authCode,
        status: { in: ["PUBLISHED", "SENT", "VIEWED"] }
      },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                storeId: true
              }
            }
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    if (!quote) {
      throw new Error("Quote not found or not available for approval");
    }
    if (quote.expiresAt && /* @__PURE__ */ new Date() > quote.expiresAt) {
      throw new Error("Quote has expired");
    }
    const movements = await this.convertToMovements(quote.id);
    await db.quote.update({
      where: { id: quote.id },
      data: { status: "APPROVED" }
    });
    return {
      quote: {
        ...quote,
        status: "APPROVED"
      },
      movements
    };
  },
  async reject(publicId, authCode, reason) {
    const quote = await db.quote.findFirst({
      where: {
        publicId,
        authCode,
        status: { in: ["PUBLISHED", "SENT", "VIEWED"] }
      }
    });
    if (!quote) {
      throw new Error("Quote not found or not available for rejection");
    }
    const updatedQuote = await db.quote.update({
      where: { id: quote.id },
      data: {
        status: "REJECTED",
        observations: reason ? `${quote.observations || ""}
Rejection reason: ${reason}`.trim() : quote.observations
      },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                unitOfMeasure: true,
                referencePrice: true
              }
            }
          }
        },
        installments: true,
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    return updatedQuote;
  },
  async convertToMovements(quoteId) {
    const quote = await db.quote.findUnique({
      where: { id: quoteId },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                storeId: true
              }
            }
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    if (!quote) {
      throw new Error("Quote not found");
    }
    if (!["PUBLISHED", "SENT", "VIEWED", "APPROVED"].includes(quote.status)) {
      throw new Error("Quote cannot be converted to movements");
    }
    const movements = [];
    for (const item of quote.items) {
      try {
        const movement = await MovementCommands.create({
          type: "SAIDA",
          quantity: item.quantity,
          storeId: item.product.storeId,
          productId: item.productId,
          note: `Quote conversion - ${quote.title} (Item: ${item.product.name})`,
          userId: quote.userId
        });
        movements.push(movement);
      } catch (error) {
        console.error(`Error creating movement for item ${item.id}:`, error);
        throw new Error(`Failed to create movement for product ${item.product.name}`);
      }
    }
    await db.quote.update({
      where: { id: quoteId },
      data: { status: "CONVERTED" }
    });
    return movements;
  },
  async publish(id) {
    const quote = await db.quote.findUnique({
      where: { id }
    });
    if (!quote) {
      throw new Error("Quote not found");
    }
    if (quote.status !== "DRAFT") {
      throw new Error("Only DRAFT quotes can be published");
    }
    return await db.quote.update({
      where: { id },
      data: { status: "PUBLISHED" },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                unitOfMeasure: true,
                referencePrice: true
              }
            }
          }
        },
        installments: true,
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async send(id) {
    const quote = await db.quote.findUnique({
      where: { id }
    });
    if (!quote) {
      throw new Error("Quote not found");
    }
    if (quote.status !== "PUBLISHED") {
      throw new Error("Only PUBLISHED quotes can be sent");
    }
    return await db.quote.update({
      where: { id },
      data: { status: "SENT" },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                unitOfMeasure: true,
                referencePrice: true
              }
            }
          }
        },
        installments: true,
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  }
};

// src/features/quote/queries/quote.queries.ts
init_prisma();
var QuoteQueries = {
  async getById(id) {
    const quote = await db.quote.findUnique({
      where: { id },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                unitOfMeasure: true,
                referencePrice: true
              }
            }
          }
        },
        installments: true,
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    return quote;
  },
  async getByPublicId(publicId, authCode) {
    const quote = await db.quote.findFirst({
      where: {
        publicId,
        authCode
      },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                unitOfMeasure: true
              }
            }
          }
        },
        installments: true,
        user: {
          select: {
            name: true
          }
        }
      }
    });
    return quote;
  },
  async list(params) {
    const { page = 1, limit = 10, search, status, userId, startDate, endDate } = params;
    const skip2 = (page - 1) * limit;
    const where = {};
    if (status) {
      where.status = status;
    }
    if (userId) {
      where.userId = userId;
    }
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) {
        where.createdAt.gte = new Date(startDate);
      }
      if (endDate) {
        where.createdAt.lte = new Date(endDate);
      }
    }
    if (search) {
      where.OR = [
        { title: { contains: search, mode: "insensitive" } },
        { description: { contains: search, mode: "insensitive" } }
      ];
    }
    const [quotes, total] = await Promise.all([
      db.quote.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          items: {
            include: {
              product: {
                select: {
                  id: true,
                  name: true,
                  description: true,
                  unitOfMeasure: true,
                  referencePrice: true
                }
              }
            }
          },
          installments: true,
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      }),
      db.quote.count({ where })
    ]);
    return {
      items: quotes,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getByUser(userId, params) {
    const { page = 1, limit = 10, status } = params;
    const skip2 = (page - 1) * limit;
    const where = { userId };
    if (status) {
      where.status = status;
    }
    const [quotes, total] = await Promise.all([
      db.quote.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          items: {
            include: {
              product: {
                select: {
                  id: true,
                  name: true,
                  description: true,
                  unitOfMeasure: true,
                  referencePrice: true
                }
              }
            }
          },
          installments: true,
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      }),
      db.quote.count({ where })
    ]);
    return {
      items: quotes,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getByStatus(status, params) {
    const { page = 1, limit = 10, userId } = params;
    const skip2 = (page - 1) * limit;
    const where = { status };
    if (userId) {
      where.userId = userId;
    }
    const [quotes, total] = await Promise.all([
      db.quote.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          items: {
            include: {
              product: {
                select: {
                  id: true,
                  name: true,
                  description: true,
                  unitOfMeasure: true,
                  referencePrice: true
                }
              }
            }
          },
          installments: true,
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      }),
      db.quote.count({ where })
    ]);
    return {
      items: quotes,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getStats(userId) {
    const where = userId ? { userId } : {};
    const [
      total,
      draft,
      published,
      sent,
      viewed,
      approved,
      rejected,
      expired,
      converted,
      canceled,
      totalValue,
      averageValue,
      recentCount
    ] = await Promise.all([
      db.quote.count({ where }),
      db.quote.count({ where: { ...where, status: "DRAFT" } }),
      db.quote.count({ where: { ...where, status: "PUBLISHED" } }),
      db.quote.count({ where: { ...where, status: "SENT" } }),
      db.quote.count({ where: { ...where, status: "VIEWED" } }),
      db.quote.count({ where: { ...where, status: "APPROVED" } }),
      db.quote.count({ where: { ...where, status: "REJECTED" } }),
      db.quote.count({ where: { ...where, status: "EXPIRED" } }),
      db.quote.count({ where: { ...where, status: "CONVERTED" } }),
      db.quote.count({ where: { ...where, status: "CANCELED" } }),
      db.quote.aggregate({
        where,
        _sum: { total: true }
      }),
      db.quote.aggregate({
        where,
        _avg: { total: true }
      }),
      db.quote.count({
        where: {
          ...where,
          createdAt: {
            gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3)
            // últimos 30 dias
          }
        }
      })
    ]);
    return {
      total,
      byStatus: {
        DRAFT: draft,
        PUBLISHED: published,
        SENT: sent,
        VIEWED: viewed,
        APPROVED: approved,
        REJECTED: rejected,
        EXPIRED: expired,
        CONVERTED: converted,
        CANCELED: canceled
      },
      totalValue: totalValue._sum.total || 0,
      averageValue: averageValue._avg.total || 0,
      recentCount
    };
  },
  async search(term, limit = 10, userId) {
    const where = {
      OR: [
        { title: { contains: term, mode: "insensitive" } },
        { description: { contains: term, mode: "insensitive" } },
        { observations: { contains: term, mode: "insensitive" } }
      ]
    };
    if (userId) {
      where.userId = userId;
    }
    const quotes = await db.quote.findMany({
      where,
      take: limit,
      orderBy: { createdAt: "desc" },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                unitOfMeasure: true,
                referencePrice: true
              }
            }
          }
        },
        installments: true,
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    return quotes;
  },
  async getExpiredQuotes() {
    const now = /* @__PURE__ */ new Date();
    const quotes = await db.quote.findMany({
      where: {
        expiresAt: {
          lt: now
        },
        status: {
          in: ["PUBLISHED", "SENT", "VIEWED"]
        }
      },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true
              }
            }
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    return quotes;
  },
  async markAsExpired() {
    const now = /* @__PURE__ */ new Date();
    const result = await db.quote.updateMany({
      where: {
        expiresAt: {
          lt: now
        },
        status: {
          in: ["PUBLISHED", "SENT", "VIEWED"]
        }
      },
      data: {
        status: "EXPIRED"
      }
    });
    return result.count;
  },
  async getRecentQuotes(limit = 5, userId) {
    const where = userId ? { userId } : {};
    const quotes = await db.quote.findMany({
      where,
      take: limit,
      orderBy: { createdAt: "desc" },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true
              }
            }
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    return quotes;
  },
  async getQuoteAnalytics(quoteId) {
    const quote = await db.quote.findUnique({
      where: { id: quoteId },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                unitOfMeasure: true
              }
            }
          }
        },
        installments: true,
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    if (!quote) {
      throw new Error("Quote not found");
    }
    const totalItems = quote.items.length;
    const totalQuantity = quote.items.reduce((sum, item) => sum + item.quantity, 0);
    const totalInstallments = quote.installments.length;
    const averageItemValue = quote.items.length > 0 ? quote.total / quote.items.length : 0;
    const isExpired = quote.expiresAt ? /* @__PURE__ */ new Date() > quote.expiresAt : false;
    const daysUntilExpiry = quote.expiresAt ? Math.ceil((quote.expiresAt.getTime() - (/* @__PURE__ */ new Date()).getTime()) / (1e3 * 60 * 60 * 24)) : null;
    return {
      quote,
      analytics: {
        totalItems,
        totalQuantity,
        totalInstallments,
        averageItemValue,
        isExpired,
        daysUntilExpiry,
        status: quote.status,
        createdAt: quote.createdAt,
        updatedAt: quote.updatedAt
      }
    };
  }
};

// src/features/quote/quote.controller.ts
var QuoteController = {
  // === CRUD BÁSICO ===
  async create(request, reply) {
    try {
      const { title, description, paymentType, paymentTerms, paymentDueDays, expiresAt, observations, discount, interest, items, installments } = request.body;
      const userId = request.user?.id;
      if (!userId) {
        return reply.status(401).send({
          error: "Authentication required"
        });
      }
      const result = await QuoteCommands.create({
        userId,
        title,
        description,
        paymentType,
        paymentTerms,
        paymentDueDays,
        expiresAt,
        observations,
        discount,
        interest,
        items,
        installments
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("Products not found")) {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      const result = await QuoteQueries.getById(id);
      if (!result) {
        return reply.status(404).send({
          error: "Quote not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Quote not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      const result = await QuoteCommands.update(id, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Quote not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Only DRAFT quotes can be updated") {
        return reply.status(400).send({
          error: error.message
        });
      }
      if (error.message.includes("Products not found")) {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      await QuoteCommands.delete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Quote not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Only DRAFT or CANCELED quotes can be deleted") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { page = 1, limit = 10, search, status, userId, startDate, endDate } = request.query;
      const result = await QuoteQueries.list({
        page,
        limit,
        search,
        status,
        userId,
        startDate,
        endDate
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES PÚBLICAS (sem autenticação) ===
  async getPublic(request, reply) {
    try {
      const { publicId } = request.params;
      const { authCode } = request.query;
      const result = await QuoteQueries.getByPublicId(publicId, authCode);
      if (!result) {
        return reply.status(404).send({
          error: "Quote not found or invalid authorization code"
        });
      }
      if (result.expiresAt && /* @__PURE__ */ new Date() > result.expiresAt) {
        return reply.status(410).send({
          error: "Quote has expired"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Quote not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async approvePublic(request, reply) {
    try {
      const { publicId } = request.params;
      const { authCode } = request.body;
      const result = await QuoteCommands.approve(publicId, authCode);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Quote not found or not available for approval") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Quote has expired") {
        return reply.status(410).send({
          error: error.message
        });
      }
      if (error.message.includes("Failed to create movement")) {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async rejectPublic(request, reply) {
    try {
      const { publicId } = request.params;
      const { authCode, reason } = request.body;
      const result = await QuoteCommands.reject(publicId, authCode, reason);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Quote not found or not available for rejection") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (autenticadas) ===
  async updateStatus(request, reply) {
    try {
      const { id } = request.params;
      const { status } = request.body;
      const result = await QuoteCommands.updateStatus(id, status);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Quote not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async publish(request, reply) {
    try {
      const { id } = request.params;
      const result = await QuoteCommands.publish(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Quote not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Only DRAFT quotes can be published") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async send(request, reply) {
    try {
      const { id } = request.params;
      const result = await QuoteCommands.send(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Quote not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Only PUBLISHED quotes can be sent") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async convertToMovements(request, reply) {
    try {
      const { id } = request.params;
      const movements = await QuoteCommands.convertToMovements(id);
      return reply.send({
        message: "Quote converted to movements successfully",
        movements
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Quote not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Quote cannot be converted to movements") {
        return reply.status(400).send({
          error: error.message
        });
      }
      if (error.message.includes("Failed to create movement")) {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const { userId } = request.query;
      const result = await QuoteQueries.getStats(userId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByUser(request, reply) {
    try {
      const { userId } = request.params;
      const { page = 1, limit = 10, status } = request.query;
      const result = await QuoteQueries.getByUser(userId, {
        page,
        limit,
        status
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { q, limit = 10, userId } = request.query;
      const result = await QuoteQueries.search(q, limit, userId);
      return reply.send({ quotes: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByStatus(request, reply) {
    try {
      const { status } = request.params;
      const { page = 1, limit = 10, userId } = request.query;
      const result = await QuoteQueries.getByStatus(status, {
        page,
        limit,
        userId
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getRecent(request, reply) {
    try {
      const { limit = 5, userId } = request.query;
      const result = await QuoteQueries.getRecentQuotes(limit, userId);
      return reply.send({ quotes: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getAnalytics(request, reply) {
    try {
      const { id } = request.params;
      const result = await QuoteQueries.getQuoteAnalytics(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Quote not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async markExpired(request, reply) {
    try {
      const count = await QuoteQueries.markAsExpired();
      return reply.send({
        message: `${count} quotes marked as expired`,
        expiredCount: count
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/quote/quote.schema.ts
var createQuoteSchema = {
  body: {
    type: "object",
    required: ["title", "paymentType", "items"],
    properties: {
      title: { type: "string", minLength: 1 },
      description: { type: "string" },
      paymentType: {
        type: "string",
        enum: ["UNDEFINED", "PIX", "BOLETO", "CREDIT_CARD", "CASH", "TRANSFER"]
      },
      paymentTerms: { type: "string" },
      paymentDueDays: { type: "number", minimum: 1 },
      expiresAt: { type: "string", format: "date-time" },
      observations: { type: "string" },
      discount: { type: "number", minimum: 0 },
      interest: { type: "number", minimum: 0 },
      items: {
        type: "array",
        minItems: 1,
        items: {
          type: "object",
          required: ["productId", "quantity", "unitPrice"],
          properties: {
            productId: { type: "string", minLength: 1 },
            quantity: { type: "number", minimum: 0.01 },
            unitPrice: { type: "number", minimum: 0.01 },
            discount: { type: "number", minimum: 0 },
            note: { type: "string" }
          }
        }
      },
      installments: {
        type: "array",
        items: {
          type: "object",
          required: ["number", "dueDate", "amount"],
          properties: {
            number: { type: "number", minimum: 1 },
            dueDate: { type: "string", format: "date-time" },
            amount: { type: "number", minimum: 0.01 },
            interest: { type: "number", minimum: 0 }
          }
        }
      }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        title: { type: "string" },
        description: { type: "string", nullable: true },
        publicId: { type: "string" },
        authCode: { type: "string" },
        status: { type: "string" },
        total: { type: "number" },
        subtotal: { type: "number" },
        discount: { type: "number", nullable: true },
        interest: { type: "number", nullable: true },
        paymentType: { type: "string" },
        paymentTerms: { type: "string", nullable: true },
        paymentDueDays: { type: "number", nullable: true },
        expiresAt: { type: "string", format: "date-time", nullable: true },
        observations: { type: "string", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              productId: { type: "string" },
              quantity: { type: "number" },
              unitPrice: { type: "number" },
              subtotal: { type: "number" },
              discount: { type: "number", nullable: true },
              note: { type: "string", nullable: true },
              product: { type: "object" }
            }
          }
        },
        installments: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              number: { type: "number" },
              dueDate: { type: "string", format: "date-time" },
              amount: { type: "number" },
              interest: { type: "number", nullable: true }
            }
          }
        },
        user: { type: "object" }
      }
    }
  }
};
var updateQuoteSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      title: { type: "string", minLength: 1 },
      description: { type: "string" },
      paymentType: {
        type: "string",
        enum: ["UNDEFINED", "PIX", "BOLETO", "CREDIT_CARD", "CASH", "TRANSFER"]
      },
      paymentTerms: { type: "string" },
      paymentDueDays: { type: "number", minimum: 1 },
      expiresAt: { type: "string", format: "date-time" },
      observations: { type: "string" },
      discount: { type: "number", minimum: 0 },
      interest: { type: "number", minimum: 0 },
      items: {
        type: "array",
        minItems: 1,
        items: {
          type: "object",
          required: ["productId", "quantity", "unitPrice"],
          properties: {
            id: { type: "string" },
            productId: { type: "string", minLength: 1 },
            quantity: { type: "number", minimum: 0.01 },
            unitPrice: { type: "number", minimum: 0.01 },
            discount: { type: "number", minimum: 0 },
            note: { type: "string" }
          }
        }
      },
      installments: {
        type: "array",
        items: {
          type: "object",
          required: ["number", "dueDate", "amount"],
          properties: {
            id: { type: "string" },
            number: { type: "number", minimum: 1 },
            dueDate: { type: "string", format: "date-time" },
            amount: { type: "number", minimum: 0.01 },
            interest: { type: "number", minimum: 0 }
          }
        }
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        title: { type: "string" },
        description: { type: "string", nullable: true },
        publicId: { type: "string" },
        authCode: { type: "string" },
        status: { type: "string" },
        total: { type: "number" },
        subtotal: { type: "number" },
        discount: { type: "number", nullable: true },
        interest: { type: "number", nullable: true },
        paymentType: { type: "string" },
        paymentTerms: { type: "string", nullable: true },
        paymentDueDays: { type: "number", nullable: true },
        expiresAt: { type: "string", format: "date-time", nullable: true },
        observations: { type: "string", nullable: true },
        updatedAt: { type: "string", format: "date-time" },
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              productId: { type: "string" },
              quantity: { type: "number" },
              unitPrice: { type: "number" },
              subtotal: { type: "number" },
              discount: { type: "number", nullable: true },
              note: { type: "string", nullable: true },
              product: { type: "object" }
            }
          }
        },
        installments: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              number: { type: "number" },
              dueDate: { type: "string", format: "date-time" },
              amount: { type: "number" },
              interest: { type: "number", nullable: true }
            }
          }
        },
        user: { type: "object" }
      }
    }
  }
};
var getQuoteSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        title: { type: "string" },
        description: { type: "string", nullable: true },
        publicId: { type: "string" },
        authCode: { type: "string" },
        status: { type: "string" },
        total: { type: "number" },
        subtotal: { type: "number" },
        discount: { type: "number", nullable: true },
        interest: { type: "number", nullable: true },
        paymentType: { type: "string" },
        paymentTerms: { type: "string", nullable: true },
        paymentDueDays: { type: "number", nullable: true },
        expiresAt: { type: "string", format: "date-time", nullable: true },
        observations: { type: "string", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              productId: { type: "string" },
              quantity: { type: "number" },
              unitPrice: { type: "number" },
              subtotal: { type: "number" },
              discount: { type: "number", nullable: true },
              note: { type: "string", nullable: true },
              product: { type: "object" }
            }
          }
        },
        installments: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              number: { type: "number" },
              dueDate: { type: "string", format: "date-time" },
              amount: { type: "number" },
              interest: { type: "number", nullable: true }
            }
          }
        },
        user: { type: "object" }
      }
    }
  }
};
var getPublicQuoteSchema = {
  params: {
    type: "object",
    required: ["publicId"],
    properties: {
      publicId: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    required: ["authCode"],
    properties: {
      authCode: { type: "string", minLength: 1 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        title: { type: "string" },
        description: { type: "string", nullable: true },
        status: { type: "string" },
        total: { type: "number" },
        subtotal: { type: "number" },
        discount: { type: "number", nullable: true },
        interest: { type: "number", nullable: true },
        paymentType: { type: "string" },
        paymentTerms: { type: "string", nullable: true },
        paymentDueDays: { type: "number", nullable: true },
        expiresAt: { type: "string", format: "date-time", nullable: true },
        observations: { type: "string", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              quantity: { type: "number" },
              unitPrice: { type: "number" },
              subtotal: { type: "number" },
              discount: { type: "number", nullable: true },
              note: { type: "string", nullable: true },
              product: { type: "object" }
            }
          }
        },
        installments: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              number: { type: "number" },
              dueDate: { type: "string", format: "date-time" },
              amount: { type: "number" },
              interest: { type: "number", nullable: true }
            }
          }
        },
        user: { type: "object" }
      }
    }
  }
};
var listQuotesSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      status: {
        type: "string",
        enum: ["DRAFT", "PUBLISHED", "SENT", "VIEWED", "APPROVED", "REJECTED", "EXPIRED", "CONVERTED", "CANCELED"]
      },
      userId: { type: "string" },
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              userId: { type: "string" },
              title: { type: "string" },
              description: { type: "string", nullable: true },
              publicId: { type: "string" },
              authCode: { type: "string" },
              status: { type: "string" },
              total: { type: "number" },
              subtotal: { type: "number" },
              discount: { type: "number", nullable: true },
              interest: { type: "number", nullable: true },
              paymentType: { type: "string" },
              paymentTerms: { type: "string", nullable: true },
              paymentDueDays: { type: "number", nullable: true },
              expiresAt: { type: "string", format: "date-time", nullable: true },
              observations: { type: "string", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" },
              items: { type: "array" },
              installments: { type: "array" },
              user: { type: "object" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var deleteQuoteSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" }
  }
};
var updateQuoteStatusSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["status"],
    properties: {
      status: {
        type: "string",
        enum: ["DRAFT", "PUBLISHED", "SENT", "VIEWED", "APPROVED", "REJECTED", "EXPIRED", "CONVERTED", "CANCELED"]
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        status: { type: "string" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var approveQuoteSchema = {
  params: {
    type: "object",
    required: ["publicId"],
    properties: {
      publicId: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["authCode"],
    properties: {
      authCode: { type: "string", minLength: 1 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        quote: { type: "object" },
        movements: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              type: { type: "string" },
              quantity: { type: "number" },
              productId: { type: "string" },
              storeId: { type: "string" },
              note: { type: "string" },
              createdAt: { type: "string", format: "date-time" }
            }
          }
        }
      }
    }
  }
};
var rejectQuoteSchema = {
  params: {
    type: "object",
    required: ["publicId"],
    properties: {
      publicId: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["authCode"],
    properties: {
      authCode: { type: "string", minLength: 1 },
      reason: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        status: { type: "string" },
        observations: { type: "string", nullable: true },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var convertToMovementSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        quote: { type: "object" },
        movements: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              type: { type: "string" },
              quantity: { type: "number" },
              productId: { type: "string" },
              storeId: { type: "string" },
              note: { type: "string" },
              createdAt: { type: "string", format: "date-time" }
            }
          }
        }
      }
    }
  }
};
var getQuoteStatsSchema = {
  querystring: {
    type: "object",
    properties: {
      userId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        total: { type: "number" },
        byStatus: {
          type: "object",
          properties: {
            DRAFT: { type: "number" },
            PUBLISHED: { type: "number" },
            SENT: { type: "number" },
            VIEWED: { type: "number" },
            APPROVED: { type: "number" },
            REJECTED: { type: "number" },
            EXPIRED: { type: "number" },
            CONVERTED: { type: "number" },
            CANCELED: { type: "number" }
          }
        },
        totalValue: { type: "number" },
        averageValue: { type: "number" },
        recentCount: { type: "number" }
      }
    }
  }
};
var QuoteSchemas = {
  create: createQuoteSchema,
  update: updateQuoteSchema,
  get: getQuoteSchema,
  getPublic: getPublicQuoteSchema,
  list: listQuotesSchema,
  delete: deleteQuoteSchema,
  updateStatus: updateQuoteStatusSchema,
  approve: approveQuoteSchema,
  reject: rejectQuoteSchema,
  convertToMovement: convertToMovementSchema,
  getStats: getQuoteStatsSchema
};

// src/features/quote/quote.routes.ts
init_auth_middleware();
async function QuoteRoutes(fastify2) {
  fastify2.post("/", {
    schema: QuoteSchemas.create,
    preHandler: [authMiddleware],
    handler: QuoteController.create
  });
  fastify2.get("/", {
    schema: QuoteSchemas.list,
    preHandler: [authMiddleware],
    handler: QuoteController.list
  });
  fastify2.get("/:id", {
    schema: QuoteSchemas.get,
    preHandler: [authMiddleware],
    handler: QuoteController.get
  });
  fastify2.put("/:id", {
    schema: QuoteSchemas.update,
    preHandler: [authMiddleware],
    handler: QuoteController.update
  });
  fastify2.delete("/:id", {
    schema: QuoteSchemas.delete,
    preHandler: [authMiddleware],
    handler: QuoteController.delete
  });
  fastify2.patch("/:id/status", {
    schema: QuoteSchemas.updateStatus,
    preHandler: [authMiddleware],
    handler: QuoteController.updateStatus
  });
  fastify2.patch("/:id/publish", {
    schema: {
      params: {
        type: "object",
        required: ["id"],
        properties: {
          id: { type: "string" }
        }
      }
    },
    preHandler: [authMiddleware],
    handler: QuoteController.publish
  });
  fastify2.patch("/:id/send", {
    schema: {
      params: {
        type: "object",
        required: ["id"],
        properties: {
          id: { type: "string" }
        }
      }
    },
    preHandler: [authMiddleware],
    handler: QuoteController.send
  });
  fastify2.post("/:id/convert", {
    schema: QuoteSchemas.convertToMovement,
    preHandler: [authMiddleware],
    handler: QuoteController.convertToMovements
  });
  fastify2.get("/stats", {
    schema: QuoteSchemas.getStats,
    preHandler: [authMiddleware],
    handler: QuoteController.getStats
  });
  fastify2.get("/user/:userId", {
    schema: {
      params: {
        type: "object",
        required: ["userId"],
        properties: {
          userId: { type: "string" }
        }
      },
      querystring: {
        type: "object",
        properties: {
          page: { type: "number", minimum: 1, default: 1 },
          limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
          status: {
            type: "string",
            enum: ["DRAFT", "PUBLISHED", "SENT", "VIEWED", "APPROVED", "REJECTED", "EXPIRED", "CONVERTED", "CANCELED"]
          }
        }
      }
    },
    preHandler: [authMiddleware],
    handler: QuoteController.getByUser
  });
  fastify2.get("/status/:status", {
    schema: {
      params: {
        type: "object",
        required: ["status"],
        properties: {
          status: {
            type: "string",
            enum: ["DRAFT", "PUBLISHED", "SENT", "VIEWED", "APPROVED", "REJECTED", "EXPIRED", "CONVERTED", "CANCELED"]
          }
        }
      },
      querystring: {
        type: "object",
        properties: {
          page: { type: "number", minimum: 1, default: 1 },
          limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
          userId: { type: "string" }
        }
      }
    },
    preHandler: [authMiddleware],
    handler: QuoteController.getByStatus
  });
  fastify2.get("/search", {
    schema: {
      querystring: {
        type: "object",
        required: ["q"],
        properties: {
          q: { type: "string", minLength: 1 },
          limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
          userId: { type: "string" }
        }
      }
    },
    preHandler: [authMiddleware],
    handler: QuoteController.search
  });
  fastify2.get("/recent", {
    schema: {
      querystring: {
        type: "object",
        properties: {
          limit: { type: "number", minimum: 1, maximum: 50, default: 5 },
          userId: { type: "string" }
        }
      }
    },
    preHandler: [authMiddleware],
    handler: QuoteController.getRecent
  });
  fastify2.get("/:id/analytics", {
    schema: {
      params: {
        type: "object",
        required: ["id"],
        properties: {
          id: { type: "string" }
        }
      }
    },
    preHandler: [authMiddleware],
    handler: QuoteController.getAnalytics
  });
  fastify2.post("/mark-expired", {
    preHandler: [authMiddleware],
    handler: QuoteController.markExpired
  });
  fastify2.get("/public/:publicId", {
    schema: QuoteSchemas.getPublic,
    handler: QuoteController.getPublic
  });
  fastify2.post("/public/:publicId/approve", {
    schema: QuoteSchemas.approve,
    handler: QuoteController.approvePublic
  });
  fastify2.post("/public/:publicId/reject", {
    schema: QuoteSchemas.reject,
    handler: QuoteController.rejectPublic
  });
}

// src/features/plan/commands/plan.commands.ts
init_prisma();
var PlanCommands = {
  async create(data) {
    const existingPlan = await db.plan.findFirst({
      where: { name: data.name }
    });
    if (existingPlan) {
      throw new Error("Plan with this name already exists");
    }
    return await db.plan.create({
      data: {
        ...data,
        interval: data.interval
      },
      include: {
        customers: {
          select: {
            id: true,
            status: true,
            createdAt: true
          }
        }
      }
    });
  },
  async update(id, data) {
    const existingPlan = await db.plan.findUnique({
      where: { id }
    });
    if (!existingPlan) {
      throw new Error("Plan not found");
    }
    if (data.name && data.name !== existingPlan.name) {
      const planWithSameName = await db.plan.findFirst({
        where: {
          name: data.name,
          id: { not: id }
        }
      });
      if (planWithSameName) {
        throw new Error("Plan with this name already exists");
      }
    }
    return await db.plan.update({
      where: { id },
      data: {
        ...data,
        ...data.interval && { interval: data.interval }
      },
      include: {
        customers: {
          select: {
            id: true,
            status: true,
            createdAt: true
          }
        }
      }
    });
  },
  async delete(id) {
    const plan = await db.plan.findUnique({
      where: { id },
      include: {
        customers: {
          select: { id: true }
        }
      }
    });
    if (!plan) {
      throw new Error("Plan not found");
    }
    if (plan.customers.length > 0) {
      throw new Error(`Cannot delete plan. It has ${plan.customers.length} associated customers. Please reassign or delete the customers first.`);
    }
    return await db.plan.delete({
      where: { id }
    });
  },
  async forceDelete(id) {
    const plan = await db.plan.findUnique({
      where: { id }
    });
    if (!plan) {
      throw new Error("Plan not found");
    }
    await db.customer.updateMany({
      where: { planId: id },
      data: { planId: null }
    });
    return await db.plan.delete({
      where: { id }
    });
  },
  async updateStatus(id, active) {
    const plan = await db.plan.findUnique({
      where: { id }
    });
    if (!plan) {
      throw new Error("Plan not found");
    }
    return await db.plan.update({
      where: { id },
      data: {
        // Se houvesse um campo active, seria:
        // active: active
      },
      include: {
        customers: {
          select: {
            id: true,
            status: true,
            createdAt: true
          }
        }
      }
    });
  }
};

// src/features/plan/queries/plan.queries.ts
init_prisma();
var PlanQueries = {
  async getById(id) {
    const plan = await db.plan.findUnique({
      where: { id },
      include: {
        customers: {
          select: {
            id: true,
            status: true,
            createdAt: true,
            user: {
              select: {
                id: true,
                name: true,
                email: true
              }
            }
          }
        }
      }
    });
    if (!plan) {
      return null;
    }
    return {
      ...plan,
      customersCount: plan.customers.length
    };
  },
  async list(params) {
    const { page = 1, limit = 10, search, interval } = params;
    const skip2 = (page - 1) * limit;
    const where = {};
    if (interval) {
      where.interval = interval;
    }
    if (search) {
      where.OR = [
        { name: { contains: search, mode: "insensitive" } },
        { description: { contains: search, mode: "insensitive" } }
      ];
    }
    const [plans, total] = await Promise.all([
      db.plan.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { name: "asc" },
        include: {
          customers: {
            select: {
              id: true,
              status: true
            }
          }
        }
      }),
      db.plan.count({ where })
    ]);
    const itemsWithCount = plans.map((plan) => ({
      ...plan,
      customersCount: plan.customers.length
    }));
    return {
      items: itemsWithCount,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getActive() {
    const plans = await db.plan.findMany({
      orderBy: { name: "asc" },
      include: {
        customers: {
          select: {
            id: true,
            status: true
          }
        }
      }
    });
    return plans.map((plan) => ({
      ...plan,
      customersCount: plan.customers.length
    }));
  },
  async compare(planIds) {
    if (!planIds || planIds.length === 0) {
      throw new Error("At least one plan ID is required for comparison");
    }
    const plans = await db.plan.findMany({
      where: { id: { in: planIds } },
      orderBy: { price: "asc" },
      include: {
        customers: {
          select: {
            id: true,
            status: true
          }
        }
      }
    });
    if (plans.length === 0) {
      throw new Error("No plans found for comparison");
    }
    const prices = plans.map((plan) => Number(plan.price));
    const intervals = [...new Set(plans.map((plan) => plan.interval))];
    const allFeatures = /* @__PURE__ */ new Set();
    plans.forEach((plan) => {
      if (plan.features && typeof plan.features === "object") {
        Object.keys(plan.features).forEach((key) => allFeatures.add(key));
      }
    });
    const plansWithCount = plans.map((plan) => ({
      ...plan,
      customersCount: plan.customers.length
    }));
    return {
      plans: plansWithCount,
      comparison: {
        priceRange: {
          min: Math.min(...prices),
          max: Math.max(...prices)
        },
        intervals,
        features: Array.from(allFeatures)
      }
    };
  },
  async getCustomers(planId, params) {
    const { page = 1, limit = 10, status } = params;
    const skip2 = (page - 1) * limit;
    const plan = await db.plan.findUnique({
      where: { id: planId }
    });
    if (!plan) {
      throw new Error("Plan not found");
    }
    const where = {
      planId
    };
    if (status) {
      where.status = status;
    }
    const [customers, total] = await Promise.all([
      db.customer.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true,
              phone: true
            }
          },
          plan: {
            select: {
              id: true,
              name: true,
              price: true,
              interval: true
            }
          },
          invoices: {
            select: {
              id: true,
              amount: true,
              status: true,
              createdAt: true
            },
            orderBy: { createdAt: "desc" },
            take: 5
            // Últimas 5 faturas
          }
        }
      }),
      db.customer.count({ where })
    ]);
    return {
      plan: {
        id: plan.id,
        name: plan.name,
        price: plan.price,
        interval: plan.interval
      },
      customers,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getStats() {
    const [
      total,
      monthlyPlans,
      yearlyPlans,
      totalCustomers,
      revenueData
    ] = await Promise.all([
      db.plan.count(),
      db.plan.count({ where: { interval: "MONTHLY" } }),
      db.plan.count({ where: { interval: "YEARLY" } }),
      db.customer.count({
        where: { status: "ACTIVE" }
      }),
      db.invoice.aggregate({
        where: { status: "PAID" },
        _sum: { amount: true },
        _avg: { amount: true }
      })
    ]);
    const planRevenue = await db.plan.findMany({
      include: {
        customers: {
          where: { status: "ACTIVE" },
          include: {
            invoices: {
              where: { status: "PAID" },
              select: { amount: true }
            }
          }
        }
      }
    });
    let totalRevenue = 0;
    planRevenue.forEach((plan) => {
      plan.customers.forEach((customer) => {
        customer.invoices.forEach((invoice) => {
          totalRevenue += Number(invoice.amount);
        });
      });
    });
    return {
      total,
      active: total,
      // Assumindo que todos os planos são ativos
      inactive: 0,
      monthlyPlans,
      yearlyPlans,
      totalCustomers,
      totalRevenue,
      averagePrice: revenueData._avg.amount ? Number(revenueData._avg.amount) : 0
    };
  }
};

// src/features/plan/plan.controller.ts
var PlanController = {
  // === CRUD BÁSICO ===
  async create(request, reply) {
    try {
      const { name, description, price, interval, features } = request.body;
      const result = await PlanCommands.create({
        name,
        description,
        price,
        interval,
        features
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Plan with this name already exists") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      const result = await PlanQueries.getById(id);
      if (!result) {
        return reply.status(404).send({
          error: "Plan not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Plan not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      const result = await PlanCommands.update(id, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Plan not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Plan with this name already exists") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      await PlanCommands.delete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Plan not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message.includes("Cannot delete plan") && error.message.includes("associated customers")) {
        return reply.status(400).send({
          error: error.message,
          suggestion: "Use DELETE /plans/:id/force to delete the plan and remove all customer associations"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async forceDelete(request, reply) {
    try {
      const { id } = request.params;
      await PlanCommands.forceDelete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Plan not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { page = 1, limit = 10, search, interval } = request.query;
      const result = await PlanQueries.list({
        page,
        limit,
        search,
        interval
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (QUERIES) ===
  async getActive(request, reply) {
    try {
      const result = await PlanQueries.getActive();
      return reply.send({ plans: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async compare(request, reply) {
    try {
      const { planIds } = request.query;
      const result = await PlanQueries.compare(planIds);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "At least one plan ID is required for comparison") {
        return reply.status(400).send({
          error: error.message
        });
      }
      if (error.message === "No plans found for comparison") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getCustomers(request, reply) {
    try {
      const { id } = request.params;
      const { page = 1, limit = 10, status } = request.query;
      const result = await PlanQueries.getCustomers(id, {
        page,
        limit,
        status
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Plan not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const result = await PlanQueries.getStats();
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (COMMANDS) ===
  async updateStatus(request, reply) {
    try {
      const { id } = request.params;
      const { active } = request.body;
      const result = await PlanCommands.updateStatus(id, active);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Plan not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/plan/plan.schema.ts
var createPlanSchema = {
  body: {
    type: "object",
    required: ["name", "price", "interval"],
    properties: {
      name: { type: "string", minLength: 1 },
      description: { type: "string" },
      price: { type: "number", minimum: 0.01 },
      interval: {
        type: "string",
        enum: ["MONTHLY", "YEARLY"]
      },
      features: { type: "object" }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        description: { type: "string", nullable: true },
        price: { type: "number" },
        interval: { type: "string" },
        features: { type: "object", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        customers: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              status: { type: "string" },
              createdAt: { type: "string", format: "date-time" }
            }
          }
        }
      }
    }
  }
};
var updatePlanSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      name: { type: "string", minLength: 1 },
      description: { type: "string" },
      price: { type: "number", minimum: 0.01 },
      interval: {
        type: "string",
        enum: ["MONTHLY", "YEARLY"]
      },
      features: { type: "object" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        description: { type: "string", nullable: true },
        price: { type: "number" },
        interval: { type: "string" },
        features: { type: "object", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        customers: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              status: { type: "string" },
              createdAt: { type: "string", format: "date-time" }
            }
          }
        }
      }
    }
  }
};
var getPlanSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        description: { type: "string", nullable: true },
        price: { type: "number" },
        interval: { type: "string" },
        features: { type: "object", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        customersCount: { type: "number" },
        customers: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              status: { type: "string" },
              createdAt: { type: "string", format: "date-time" },
              user: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  email: { type: "string" }
                }
              }
            }
          }
        }
      }
    }
  }
};
var listPlansSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      interval: {
        type: "string",
        enum: ["MONTHLY", "YEARLY"]
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              price: { type: "number" },
              interval: { type: "string" },
              features: { type: "object", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" },
              customersCount: { type: "number" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var deletePlanSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" }
  }
};
var updatePlanStatusSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["active"],
    properties: {
      active: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        description: { type: "string", nullable: true },
        price: { type: "number" },
        interval: { type: "string" },
        features: { type: "object", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var comparePlansSchema = {
  querystring: {
    type: "object",
    required: ["planIds"],
    properties: {
      planIds: {
        type: "array",
        items: { type: "string", minLength: 1 },
        minItems: 1,
        uniqueItems: true
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        plans: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              price: { type: "number" },
              interval: { type: "string" },
              features: { type: "object", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" },
              customersCount: { type: "number" }
            }
          }
        },
        comparison: {
          type: "object",
          properties: {
            priceRange: {
              type: "object",
              properties: {
                min: { type: "number" },
                max: { type: "number" }
              }
            },
            intervals: {
              type: "array",
              items: {
                type: "string",
                enum: ["MONTHLY", "YEARLY"]
              }
            },
            features: {
              type: "array",
              items: { type: "string" }
            }
          }
        }
      }
    }
  }
};
var getPlanCustomersSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      status: {
        type: "string",
        enum: ["ACTIVE", "INACTIVE", "CANCELLED", "TRIAL"]
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        plan: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            price: { type: "number" },
            interval: { type: "string" }
          }
        },
        customers: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              status: { type: "string" },
              renewalDate: { type: "string", format: "date-time", nullable: true },
              trialEndsAt: { type: "string", format: "date-time", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              user: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  email: { type: "string" },
                  phone: { type: "string", nullable: true }
                }
              },
              plan: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  price: { type: "number" },
                  interval: { type: "string" }
                }
              },
              invoices: {
                type: "array",
                items: {
                  type: "object",
                  properties: {
                    id: { type: "string" },
                    amount: { type: "number" },
                    status: { type: "string" },
                    createdAt: { type: "string", format: "date-time" }
                  }
                }
              }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getPlanStatsSchema = {
  response: {
    200: {
      type: "object",
      properties: {
        total: { type: "number" },
        active: { type: "number" },
        inactive: { type: "number" },
        monthlyPlans: { type: "number" },
        yearlyPlans: { type: "number" },
        totalCustomers: { type: "number" },
        totalRevenue: { type: "number" },
        averagePrice: { type: "number" }
      }
    }
  }
};
var PlanSchemas = {
  create: createPlanSchema,
  update: updatePlanSchema,
  get: getPlanSchema,
  delete: deletePlanSchema,
  list: listPlansSchema,
  updateStatus: updatePlanStatusSchema,
  compare: comparePlansSchema,
  getCustomers: getPlanCustomersSchema,
  getStats: getPlanStatsSchema
};

// src/features/plan/plan.routes.ts
init_auth_middleware();
async function PlanRoutes(fastify2) {
  fastify2.post("/", {
    schema: PlanSchemas.create,
    preHandler: [authMiddleware],
    handler: PlanController.create
  });
  fastify2.get("/", {
    schema: PlanSchemas.list,
    handler: PlanController.list
  });
  fastify2.get("/:id", {
    schema: PlanSchemas.get,
    handler: PlanController.get
  });
  fastify2.put("/:id", {
    schema: PlanSchemas.update,
    preHandler: [authMiddleware],
    handler: PlanController.update
  });
  fastify2.delete("/:id", {
    schema: PlanSchemas.delete,
    preHandler: [authMiddleware],
    handler: PlanController.delete
  });
  fastify2.delete("/:id/force", {
    schema: PlanSchemas.delete,
    preHandler: [authMiddleware],
    handler: PlanController.forceDelete
  });
  fastify2.get("/active", {
    handler: PlanController.getActive
  });
  fastify2.get("/stats", {
    preHandler: [authMiddleware],
    handler: PlanController.getStats
  });
  fastify2.get("/compare", {
    schema: PlanSchemas.compare,
    handler: PlanController.compare
  });
  fastify2.get("/:id/customers", {
    schema: PlanSchemas.getCustomers,
    preHandler: [authMiddleware],
    handler: PlanController.getCustomers
  });
  fastify2.patch("/:id/status", {
    schema: PlanSchemas.updateStatus,
    preHandler: [authMiddleware],
    handler: PlanController.updateStatus
  });
}

// src/features/customer/commands/customer.commands.ts
init_prisma();
var CustomerCommands = {
  async create(data) {
    const { planId, ...createData } = data;
    const user = await db.user.findUnique({
      where: { id: data.userId }
    });
    if (!user) {
      throw new Error("User not found");
    }
    const existingCustomer = await db.customer.findUnique({
      where: { userId: data.userId }
    });
    if (existingCustomer) {
      throw new Error("User is already a customer");
    }
    if (planId) {
      const plan = await db.plan.findUnique({
        where: { id: planId }
      });
      if (!plan) {
        throw new Error("Plan not found");
      }
    }
    return await db.customer.create({
      data: {
        user: { connect: { id: data.userId } },
        status: data.status || "ACTIVE" /* ACTIVE */,
        renewalDate: data.renewalDate,
        trialEndsAt: data.trialEndsAt,
        ...planId && { plan: { connect: { id: planId } } }
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            phone: true
          }
        },
        plan: {
          select: {
            id: true,
            name: true,
            description: true,
            price: true,
            interval: true,
            features: true
          }
        }
      }
    });
  },
  async update(id, data) {
    const { planId, ...updateData } = data;
    const existingCustomer = await db.customer.findUnique({
      where: { id }
    });
    if (!existingCustomer) {
      throw new Error("Customer not found");
    }
    if (planId) {
      const plan = await db.plan.findUnique({
        where: { id: planId }
      });
      if (!plan) {
        throw new Error("Plan not found");
      }
    }
    return await db.customer.update({
      where: { id },
      data: {
        ...updateData,
        ...planId && { plan: { connect: { id: planId } } }
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            phone: true
          }
        },
        plan: {
          select: {
            id: true,
            name: true,
            description: true,
            price: true,
            interval: true,
            features: true
          }
        }
      }
    });
  },
  async delete(id) {
    const customer = await db.customer.findUnique({
      where: { id },
      include: {
        invoices: {
          select: { id: true }
        }
      }
    });
    if (!customer) {
      throw new Error("Customer not found");
    }
    if (customer.invoices.length > 0) {
      throw new Error(`Cannot delete customer. It has ${customer.invoices.length} associated invoices. Please delete the invoices first or use force delete.`);
    }
    return await db.customer.delete({
      where: { id }
    });
  },
  async forceDelete(id) {
    const customer = await db.customer.findUnique({
      where: { id }
    });
    if (!customer) {
      throw new Error("Customer not found");
    }
    await db.invoice.deleteMany({
      where: { customerId: id }
    });
    return await db.customer.delete({
      where: { id }
    });
  },
  async updatePlan(customerId, planId) {
    const customer = await db.customer.findUnique({
      where: { id: customerId }
    });
    if (!customer) {
      throw new Error("Customer not found");
    }
    const plan = await db.plan.findUnique({
      where: { id: planId }
    });
    if (!plan) {
      throw new Error("Plan not found");
    }
    return await db.customer.update({
      where: { id: customerId },
      data: {
        plan: { connect: { id: planId } },
        renewalDate: new Date(Date.now() + (plan.interval === "MONTHLY" ? 30 : 365) * 24 * 60 * 60 * 1e3)
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            phone: true
          }
        },
        plan: {
          select: {
            id: true,
            name: true,
            description: true,
            price: true,
            interval: true,
            features: true
          }
        }
      }
    });
  },
  async cancelSubscription(customerId, reason) {
    const customer = await db.customer.findUnique({
      where: { id: customerId }
    });
    if (!customer) {
      throw new Error("Customer not found");
    }
    return await db.customer.update({
      where: { id: customerId },
      data: {
        status: "CANCELLED" /* CANCELLED */,
        renewalDate: null
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            phone: true
          }
        },
        plan: {
          select: {
            id: true,
            name: true,
            description: true,
            price: true,
            interval: true,
            features: true
          }
        }
      }
    });
  },
  async renewSubscription(customerId, renewalDate) {
    const customer = await db.customer.findUnique({
      where: { id: customerId },
      include: {
        plan: true
      }
    });
    if (!customer) {
      throw new Error("Customer not found");
    }
    if (!customer.plan) {
      throw new Error("Customer has no active plan");
    }
    const newRenewalDate = renewalDate || new Date(Date.now() + (customer.plan.interval === "MONTHLY" ? 30 : 365) * 24 * 60 * 60 * 1e3);
    return await db.customer.update({
      where: { id: customerId },
      data: {
        status: "ACTIVE" /* ACTIVE */,
        renewalDate: newRenewalDate
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            phone: true
          }
        },
        plan: {
          select: {
            id: true,
            name: true,
            description: true,
            price: true,
            interval: true,
            features: true
          }
        }
      }
    });
  },
  async startTrial(customerId, trialDays) {
    const customer = await db.customer.findUnique({
      where: { id: customerId }
    });
    if (!customer) {
      throw new Error("Customer not found");
    }
    const trialEndsAt = new Date(Date.now() + trialDays * 24 * 60 * 60 * 1e3);
    return await db.customer.update({
      where: { id: customerId },
      data: {
        status: "TRIAL" /* TRIAL */,
        trialEndsAt,
        renewalDate: trialEndsAt
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            phone: true
          }
        },
        plan: {
          select: {
            id: true,
            name: true,
            description: true,
            price: true,
            interval: true,
            features: true
          }
        }
      }
    });
  },
  async updateStatus(customerId, status) {
    const customer = await db.customer.findUnique({
      where: { id: customerId }
    });
    if (!customer) {
      throw new Error("Customer not found");
    }
    return await db.customer.update({
      where: { id: customerId },
      data: { status },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            phone: true
          }
        },
        plan: {
          select: {
            id: true,
            name: true,
            description: true,
            price: true,
            interval: true,
            features: true
          }
        }
      }
    });
  }
};

// src/features/customer/queries/customer.queries.ts
init_prisma();
var CustomerQueries = {
  async getById(id) {
    const customer = await db.customer.findUnique({
      where: { id },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            phone: true
          }
        },
        plan: {
          select: {
            id: true,
            name: true,
            description: true,
            price: true,
            interval: true,
            features: true
          }
        },
        invoices: {
          select: {
            id: true,
            amount: true,
            status: true,
            createdAt: true,
            paymentDate: true
          },
          orderBy: { createdAt: "desc" },
          take: 10
          // Últimas 10 faturas
        }
      }
    });
    if (!customer) {
      return null;
    }
    return customer;
  },
  async getByUserId(userId) {
    const customer = await db.customer.findUnique({
      where: { userId },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            phone: true
          }
        },
        plan: {
          select: {
            id: true,
            name: true,
            description: true,
            price: true,
            interval: true,
            features: true
          }
        },
        invoices: {
          select: {
            id: true,
            amount: true,
            status: true,
            createdAt: true,
            paymentDate: true
          },
          orderBy: { createdAt: "desc" },
          take: 10
          // Últimas 10 faturas
        }
      }
    });
    if (!customer) {
      return null;
    }
    return customer;
  },
  async list(params) {
    const { page = 1, limit = 10, search, status, planId } = params;
    const skip2 = (page - 1) * limit;
    const where = {};
    if (status) {
      where.status = status;
    }
    if (planId) {
      where.planId = planId;
    }
    if (search) {
      where.OR = [
        {
          user: {
            name: { contains: search, mode: "insensitive" }
          }
        },
        {
          user: {
            email: { contains: search, mode: "insensitive" }
          }
        },
        {
          plan: {
            name: { contains: search, mode: "insensitive" }
          }
        }
      ];
    }
    const [customers, total] = await Promise.all([
      db.customer.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true,
              phone: true
            }
          },
          plan: {
            select: {
              id: true,
              name: true,
              description: true,
              price: true,
              interval: true,
              features: true
            }
          },
          invoices: {
            select: {
              id: true,
              amount: true,
              status: true,
              createdAt: true
            },
            orderBy: { createdAt: "desc" },
            take: 3
            // Últimas 3 faturas
          }
        }
      }),
      db.customer.count({ where })
    ]);
    return {
      items: customers,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getInvoices(customerId, params) {
    const { page = 1, limit = 10, status } = params;
    const skip2 = (page - 1) * limit;
    const customer = await db.customer.findUnique({
      where: { id: customerId }
    });
    if (!customer) {
      throw new Error("Customer not found");
    }
    const where = {
      customerId
    };
    if (status) {
      where.status = status;
    }
    const [invoices, total] = await Promise.all([
      db.invoice.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" }
      }),
      db.invoice.count({ where })
    ]);
    return {
      customer: {
        id: customer.id,
        userId: customer.userId,
        status: customer.status
      },
      invoices,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getSubscriptionStatus(customerId) {
    const customer = await db.customer.findUnique({
      where: { id: customerId },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            phone: true
          }
        },
        plan: {
          select: {
            id: true,
            name: true,
            description: true,
            price: true,
            interval: true,
            features: true
          }
        },
        invoices: {
          select: {
            id: true,
            amount: true,
            status: true,
            createdAt: true,
            paymentDate: true
          },
          orderBy: { createdAt: "desc" },
          take: 1
        }
      }
    });
    if (!customer) {
      throw new Error("Customer not found");
    }
    const isActive = customer.status === "ACTIVE";
    const isTrial = customer.status === "TRIAL";
    let daysRemaining;
    let nextBillingDate;
    if (isTrial && customer.trialEndsAt) {
      const now = /* @__PURE__ */ new Date();
      const diffTime = customer.trialEndsAt.getTime() - now.getTime();
      daysRemaining = Math.ceil(diffTime / (1e3 * 60 * 60 * 24));
      nextBillingDate = customer.trialEndsAt;
    } else if (customer.renewalDate) {
      nextBillingDate = customer.renewalDate;
    }
    const canUpgrade = isActive && customer.plan !== null;
    const canDowngrade = isActive && customer.plan !== null;
    const canCancel = isActive || isTrial;
    const nextInvoice = await db.invoice.findFirst({
      where: {
        customerId,
        status: "PENDING"
      },
      orderBy: { createdAt: "desc" }
    });
    const lastPayment = await db.invoice.findFirst({
      where: {
        customerId,
        status: "PAID"
      },
      orderBy: { paymentDate: "desc" }
    });
    return {
      customer,
      subscription: {
        isActive,
        isTrial,
        daysRemaining,
        nextBillingDate,
        canUpgrade,
        canDowngrade,
        canCancel
      },
      billing: {
        currentPlan: customer.plan,
        nextInvoice: nextInvoice ? {
          amount: Number(nextInvoice.amount),
          dueDate: nextInvoice.createdAt
        } : void 0,
        lastPayment: lastPayment ? {
          amount: Number(lastPayment.amount),
          date: lastPayment.paymentDate,
          status: lastPayment.status
        } : void 0
      }
    };
  },
  async getStats() {
    const [
      total,
      active,
      inactive,
      cancelled,
      trial
    ] = await Promise.all([
      db.customer.count(),
      db.customer.count({ where: { status: "ACTIVE" } }),
      db.customer.count({ where: { status: "INACTIVE" } }),
      db.customer.count({ where: { status: "CANCELLED" } }),
      db.customer.count({ where: { status: "TRIAL" } })
    ]);
    const revenueData = await db.invoice.aggregate({
      where: { status: "PAID" },
      _sum: { amount: true }
    });
    const totalRevenue = revenueData._sum.amount ? Number(revenueData._sum.amount) : 0;
    const averageRevenuePerCustomer = total > 0 ? totalRevenue / total : 0;
    const totalEverActive = await db.customer.count({
      where: {
        OR: [
          { status: "ACTIVE" },
          { status: "CANCELLED" }
        ]
      }
    });
    const churnRate = totalEverActive > 0 ? cancelled / totalEverActive * 100 : 0;
    const totalEverTrial = await db.customer.count({
      where: {
        OR: [
          { status: "TRIAL" },
          { status: "ACTIVE" },
          { status: "CANCELLED" }
        ]
      }
    });
    const conversionRate = totalEverTrial > 0 ? active / totalEverTrial * 100 : 0;
    return {
      total,
      active,
      inactive,
      cancelled,
      trial,
      totalRevenue,
      averageRevenuePerCustomer,
      churnRate,
      conversionRate
    };
  },
  async getActive() {
    const customers = await db.customer.findMany({
      where: { status: "ACTIVE" },
      orderBy: { createdAt: "desc" },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            phone: true
          }
        },
        plan: {
          select: {
            id: true,
            name: true,
            description: true,
            price: true,
            interval: true,
            features: true
          }
        }
      }
    });
    return customers;
  },
  async getTrial() {
    const customers = await db.customer.findMany({
      where: { status: "TRIAL" },
      orderBy: { trialEndsAt: "asc" },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            phone: true
          }
        },
        plan: {
          select: {
            id: true,
            name: true,
            description: true,
            price: true,
            interval: true,
            features: true
          }
        }
      }
    });
    return customers;
  },
  async getCancelled() {
    const customers = await db.customer.findMany({
      where: { status: "CANCELLED" },
      orderBy: { updatedAt: "desc" },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            phone: true
          }
        },
        plan: {
          select: {
            id: true,
            name: true,
            description: true,
            price: true,
            interval: true,
            features: true
          }
        }
      }
    });
    return customers;
  }
};

// src/features/customer/customer.controller.ts
var CustomerController = {
  // === CRUD BÁSICO ===
  async create(request, reply) {
    try {
      const { userId, planId, status, renewalDate, trialEndsAt } = request.body;
      const result = await CustomerCommands.create({
        userId,
        planId,
        status,
        renewalDate: renewalDate ? new Date(renewalDate) : void 0,
        trialEndsAt: trialEndsAt ? new Date(trialEndsAt) : void 0
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found") {
        return reply.status(400).send({
          error: error.message
        });
      }
      if (error.message === "User is already a customer") {
        return reply.status(400).send({
          error: error.message
        });
      }
      if (error.message === "Plan not found") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      const result = await CustomerQueries.getById(id);
      if (!result) {
        return reply.status(404).send({
          error: "Customer not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Customer not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      if (updateData.renewalDate) {
        updateData.renewalDate = new Date(updateData.renewalDate);
      }
      if (updateData.trialEndsAt) {
        updateData.trialEndsAt = new Date(updateData.trialEndsAt);
      }
      const result = await CustomerCommands.update(id, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Customer not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Plan not found") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      await CustomerCommands.delete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Customer not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message.includes("Cannot delete customer") && error.message.includes("associated invoices")) {
        return reply.status(400).send({
          error: error.message,
          suggestion: "Use DELETE /customers/:id/force to delete the customer and all associated invoices"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async forceDelete(request, reply) {
    try {
      const { id } = request.params;
      await CustomerCommands.forceDelete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Customer not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { page = 1, limit = 10, search, status, planId } = request.query;
      const result = await CustomerQueries.list({
        page,
        limit,
        search,
        status,
        planId
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (QUERIES) ===
  async getByUserId(request, reply) {
    try {
      const { userId } = request.params;
      const result = await CustomerQueries.getByUserId(userId);
      if (!result) {
        return reply.status(404).send({
          error: "Customer not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getActive(request, reply) {
    try {
      const result = await CustomerQueries.getActive();
      return reply.send({ customers: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getTrial(request, reply) {
    try {
      const result = await CustomerQueries.getTrial();
      return reply.send({ customers: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getCancelled(request, reply) {
    try {
      const result = await CustomerQueries.getCancelled();
      return reply.send({ customers: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const result = await CustomerQueries.getStats();
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getInvoices(request, reply) {
    try {
      const { id } = request.params;
      const { page = 1, limit = 10, status } = request.query;
      const result = await CustomerQueries.getInvoices(id, {
        page,
        limit,
        status
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Customer not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getSubscriptionStatus(request, reply) {
    try {
      const { id } = request.params;
      const result = await CustomerQueries.getSubscriptionStatus(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Customer not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (COMMANDS) ===
  async updatePlan(request, reply) {
    try {
      const { id } = request.params;
      const { planId } = request.body;
      const result = await CustomerCommands.updatePlan(id, planId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Customer not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Plan not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async cancel(request, reply) {
    try {
      const { id } = request.params;
      const { reason } = request.body;
      const result = await CustomerCommands.cancelSubscription(id, reason);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Customer not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async renew(request, reply) {
    try {
      const { id } = request.params;
      const { renewalDate } = request.body;
      const result = await CustomerCommands.renewSubscription(
        id,
        renewalDate ? new Date(renewalDate) : void 0
      );
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Customer not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Customer has no active plan") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async startTrial(request, reply) {
    try {
      const { id } = request.params;
      const { trialDays } = request.body;
      const result = await CustomerCommands.startTrial(id, trialDays);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Customer not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async updateStatus(request, reply) {
    try {
      const { id } = request.params;
      const { status } = request.body;
      const result = await CustomerCommands.updateStatus(id, status);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Customer not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/customer/customer.schema.ts
var createCustomerSchema = {
  body: {
    type: "object",
    required: ["userId"],
    properties: {
      userId: { type: "string", minLength: 1 },
      planId: { type: "string" },
      status: {
        type: "string",
        enum: ["ACTIVE", "INACTIVE", "CANCELLED", "TRIAL"],
        default: "ACTIVE"
      },
      renewalDate: { type: "string", format: "date-time" },
      trialEndsAt: { type: "string", format: "date-time" }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        planId: { type: "string", nullable: true },
        status: { type: "string" },
        renewalDate: { type: "string", format: "date-time", nullable: true },
        trialEndsAt: { type: "string", format: "date-time", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" },
            phone: { type: "string", nullable: true }
          }
        },
        plan: {
          type: "object",
          nullable: true,
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            description: { type: "string", nullable: true },
            price: { type: "number" },
            interval: { type: "string" },
            features: { type: "object", nullable: true }
          }
        }
      }
    }
  }
};
var updateCustomerSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      planId: { type: "string" },
      status: {
        type: "string",
        enum: ["ACTIVE", "INACTIVE", "CANCELLED", "TRIAL"]
      },
      renewalDate: { type: "string", format: "date-time" },
      trialEndsAt: { type: "string", format: "date-time" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        planId: { type: "string", nullable: true },
        status: { type: "string" },
        renewalDate: { type: "string", format: "date-time", nullable: true },
        trialEndsAt: { type: "string", format: "date-time", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" },
            phone: { type: "string", nullable: true }
          }
        },
        plan: {
          type: "object",
          nullable: true,
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            description: { type: "string", nullable: true },
            price: { type: "number" },
            interval: { type: "string" },
            features: { type: "object", nullable: true }
          }
        }
      }
    }
  }
};
var getCustomerSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        planId: { type: "string", nullable: true },
        status: { type: "string" },
        renewalDate: { type: "string", format: "date-time", nullable: true },
        trialEndsAt: { type: "string", format: "date-time", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" },
            phone: { type: "string", nullable: true }
          }
        },
        plan: {
          type: "object",
          nullable: true,
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            description: { type: "string", nullable: true },
            price: { type: "number" },
            interval: { type: "string" },
            features: { type: "object", nullable: true }
          }
        },
        invoices: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              amount: { type: "number" },
              status: { type: "string" },
              createdAt: { type: "string", format: "date-time" },
              paymentDate: { type: "string", format: "date-time", nullable: true }
            }
          }
        }
      }
    }
  }
};
var listCustomersSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      status: {
        type: "string",
        enum: ["ACTIVE", "INACTIVE", "CANCELLED", "TRIAL"]
      },
      planId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              userId: { type: "string" },
              planId: { type: "string", nullable: true },
              status: { type: "string" },
              renewalDate: { type: "string", format: "date-time", nullable: true },
              trialEndsAt: { type: "string", format: "date-time", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" },
              user: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  email: { type: "string" },
                  phone: { type: "string", nullable: true }
                }
              },
              plan: {
                type: "object",
                nullable: true,
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  description: { type: "string", nullable: true },
                  price: { type: "number" },
                  interval: { type: "string" },
                  features: { type: "object", nullable: true }
                }
              },
              invoices: {
                type: "array",
                items: {
                  type: "object",
                  properties: {
                    id: { type: "string" },
                    amount: { type: "number" },
                    status: { type: "string" },
                    createdAt: { type: "string", format: "date-time" }
                  }
                }
              }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var deleteCustomerSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" }
  }
};
var updateCustomerPlanSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["planId"],
    properties: {
      planId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        planId: { type: "string", nullable: true },
        status: { type: "string" },
        renewalDate: { type: "string", format: "date-time", nullable: true },
        trialEndsAt: { type: "string", format: "date-time", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" },
            phone: { type: "string", nullable: true }
          }
        },
        plan: {
          type: "object",
          nullable: true,
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            description: { type: "string", nullable: true },
            price: { type: "number" },
            interval: { type: "string" },
            features: { type: "object", nullable: true }
          }
        }
      }
    }
  }
};
var cancelCustomerSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      reason: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        planId: { type: "string", nullable: true },
        status: { type: "string" },
        renewalDate: { type: "string", format: "date-time", nullable: true },
        trialEndsAt: { type: "string", format: "date-time", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var renewCustomerSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      renewalDate: { type: "string", format: "date-time" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        planId: { type: "string", nullable: true },
        status: { type: "string" },
        renewalDate: { type: "string", format: "date-time", nullable: true },
        trialEndsAt: { type: "string", format: "date-time", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var startTrialSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["trialDays"],
    properties: {
      trialDays: { type: "number", minimum: 1, maximum: 365 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        planId: { type: "string", nullable: true },
        status: { type: "string" },
        renewalDate: { type: "string", format: "date-time", nullable: true },
        trialEndsAt: { type: "string", format: "date-time", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var getCustomerInvoicesSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      status: {
        type: "string",
        enum: ["PENDING", "PAID", "FAILED"]
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        customer: {
          type: "object",
          properties: {
            id: { type: "string" },
            userId: { type: "string" },
            status: { type: "string" }
          }
        },
        invoices: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              customerId: { type: "string" },
              amount: { type: "number" },
              status: { type: "string" },
              gatewayPaymentId: { type: "string", nullable: true },
              paymentDate: { type: "string", format: "date-time", nullable: true },
              createdAt: { type: "string", format: "date-time" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getSubscriptionStatusSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        customer: {
          type: "object",
          properties: {
            id: { type: "string" },
            userId: { type: "string" },
            planId: { type: "string", nullable: true },
            status: { type: "string" },
            renewalDate: { type: "string", format: "date-time", nullable: true },
            trialEndsAt: { type: "string", format: "date-time", nullable: true },
            createdAt: { type: "string", format: "date-time" },
            updatedAt: { type: "string", format: "date-time" }
          }
        },
        subscription: {
          type: "object",
          properties: {
            isActive: { type: "boolean" },
            isTrial: { type: "boolean" },
            daysRemaining: { type: "number", nullable: true },
            nextBillingDate: { type: "string", format: "date-time", nullable: true },
            canUpgrade: { type: "boolean" },
            canDowngrade: { type: "boolean" },
            canCancel: { type: "boolean" }
          }
        },
        billing: {
          type: "object",
          properties: {
            currentPlan: {
              type: "object",
              nullable: true,
              properties: {
                id: { type: "string" },
                name: { type: "string" },
                price: { type: "number" },
                interval: { type: "string" }
              }
            },
            nextInvoice: {
              type: "object",
              nullable: true,
              properties: {
                amount: { type: "number" },
                dueDate: { type: "string", format: "date-time" }
              }
            },
            lastPayment: {
              type: "object",
              nullable: true,
              properties: {
                amount: { type: "number" },
                date: { type: "string", format: "date-time" },
                status: { type: "string" }
              }
            }
          }
        }
      }
    }
  }
};
var getCustomerStatsSchema = {
  response: {
    200: {
      type: "object",
      properties: {
        total: { type: "number" },
        active: { type: "number" },
        inactive: { type: "number" },
        cancelled: { type: "number" },
        trial: { type: "number" },
        totalRevenue: { type: "number" },
        averageRevenuePerCustomer: { type: "number" },
        churnRate: { type: "number" },
        conversionRate: { type: "number" }
      }
    }
  }
};
var updateCustomerStatusSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["status"],
    properties: {
      status: {
        type: "string",
        enum: ["ACTIVE", "INACTIVE", "CANCELLED", "TRIAL"]
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        planId: { type: "string", nullable: true },
        status: { type: "string" },
        renewalDate: { type: "string", format: "date-time", nullable: true },
        trialEndsAt: { type: "string", format: "date-time", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var CustomerSchemas = {
  create: createCustomerSchema,
  update: updateCustomerSchema,
  get: getCustomerSchema,
  delete: deleteCustomerSchema,
  list: listCustomersSchema,
  updatePlan: updateCustomerPlanSchema,
  cancel: cancelCustomerSchema,
  renew: renewCustomerSchema,
  startTrial: startTrialSchema,
  getInvoices: getCustomerInvoicesSchema,
  getSubscriptionStatus: getSubscriptionStatusSchema,
  getStats: getCustomerStatsSchema,
  updateStatus: updateCustomerStatusSchema
};

// src/features/customer/customer.routes.ts
init_auth_middleware();
async function CustomerRoutes(fastify2) {
  fastify2.post("/", {
    schema: CustomerSchemas.create,
    preHandler: [authMiddleware],
    handler: CustomerController.create
  });
  fastify2.get("/", {
    schema: CustomerSchemas.list,
    preHandler: [authMiddleware],
    handler: CustomerController.list
  });
  fastify2.get("/:id", {
    schema: CustomerSchemas.get,
    handler: CustomerController.get
  });
  fastify2.put("/:id", {
    schema: CustomerSchemas.update,
    preHandler: [authMiddleware],
    handler: CustomerController.update
  });
  fastify2.delete("/:id", {
    schema: CustomerSchemas.delete,
    preHandler: [authMiddleware],
    handler: CustomerController.delete
  });
  fastify2.delete("/:id/force", {
    schema: CustomerSchemas.delete,
    preHandler: [authMiddleware],
    handler: CustomerController.forceDelete
  });
  fastify2.get("/user/:userId", {
    schema: {
      params: {
        type: "object",
        required: ["userId"],
        properties: {
          userId: { type: "string" }
        }
      }
    },
    handler: CustomerController.getByUserId
  });
  fastify2.get("/active", {
    handler: CustomerController.getActive
  });
  fastify2.get("/trial", {
    preHandler: [authMiddleware],
    handler: CustomerController.getTrial
  });
  fastify2.get("/cancelled", {
    preHandler: [authMiddleware],
    handler: CustomerController.getCancelled
  });
  fastify2.get("/stats", {
    preHandler: [authMiddleware],
    handler: CustomerController.getStats
  });
  fastify2.get("/:id/invoices", {
    schema: CustomerSchemas.getInvoices,
    handler: CustomerController.getInvoices
  });
  fastify2.get("/:id/subscription-status", {
    schema: CustomerSchemas.getSubscriptionStatus,
    handler: CustomerController.getSubscriptionStatus
  });
  fastify2.patch("/:id/plan", {
    schema: CustomerSchemas.updatePlan,
    preHandler: [authMiddleware],
    handler: CustomerController.updatePlan
  });
  fastify2.patch("/:id/cancel", {
    schema: CustomerSchemas.cancel,
    preHandler: [authMiddleware],
    handler: CustomerController.cancel
  });
  fastify2.patch("/:id/renew", {
    schema: CustomerSchemas.renew,
    preHandler: [authMiddleware],
    handler: CustomerController.renew
  });
  fastify2.patch("/:id/trial", {
    schema: CustomerSchemas.startTrial,
    preHandler: [authMiddleware],
    handler: CustomerController.startTrial
  });
  fastify2.patch("/:id/status", {
    schema: CustomerSchemas.updateStatus,
    preHandler: [authMiddleware],
    handler: CustomerController.updateStatus
  });
}

// src/features/invoice/commands/invoice.commands.ts
init_prisma();
var InvoiceCommands = {
  async create(data) {
    const { customerId, ...createData } = data;
    const customer = await db.customer.findUnique({
      where: { id: customerId },
      include: {
        user: true,
        plan: true
      }
    });
    if (!customer) {
      throw new Error("Customer not found");
    }
    return await db.invoice.create({
      data: {
        ...createData,
        status: data.status || "PENDING" /* PENDING */,
        customer: { connect: { id: customerId } }
      },
      include: {
        customer: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
                email: true,
                phone: true
              }
            },
            plan: {
              select: {
                id: true,
                name: true,
                description: true,
                price: true,
                interval: true
              }
            }
          }
        }
      }
    });
  },
  async update(id, data) {
    const existingInvoice = await db.invoice.findUnique({
      where: { id }
    });
    if (!existingInvoice) {
      throw new Error("Invoice not found");
    }
    return await db.invoice.update({
      where: { id },
      data: {
        ...data
      },
      include: {
        customer: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
                email: true,
                phone: true
              }
            },
            plan: {
              select: {
                id: true,
                name: true,
                description: true,
                price: true,
                interval: true
              }
            }
          }
        }
      }
    });
  },
  async delete(id) {
    const invoice = await db.invoice.findUnique({
      where: { id }
    });
    if (!invoice) {
      throw new Error("Invoice not found");
    }
    return await db.invoice.delete({
      where: { id }
    });
  },
  async updateStatus(id, status, paymentDate, gatewayPaymentId) {
    const invoice = await db.invoice.findUnique({
      where: { id }
    });
    if (!invoice) {
      throw new Error("Invoice not found");
    }
    const updateData = { status };
    if (status === "PAID" /* PAID */) {
      updateData.paymentDate = paymentDate || /* @__PURE__ */ new Date();
      if (gatewayPaymentId) {
        updateData.gatewayPaymentId = gatewayPaymentId;
      }
    }
    return await db.invoice.update({
      where: { id },
      data: updateData,
      include: {
        customer: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
                email: true,
                phone: true
              }
            },
            plan: {
              select: {
                id: true,
                name: true,
                description: true,
                price: true,
                interval: true
              }
            }
          }
        }
      }
    });
  },
  async retryPayment(id, gateway, paymentMethod) {
    const invoice = await db.invoice.findUnique({
      where: { id },
      include: {
        customer: {
          include: {
            user: true,
            plan: true
          }
        }
      }
    });
    if (!invoice) {
      throw new Error("Invoice not found");
    }
    if (invoice.status === "PAID" /* PAID */) {
      throw new Error("Invoice is already paid");
    }
    try {
      const paymentSuccess = Math.random() > 0.3;
      if (paymentSuccess) {
        await db.invoice.update({
          where: { id },
          data: {
            status: "PAID" /* PAID */,
            paymentDate: /* @__PURE__ */ new Date(),
            gatewayPaymentId: `gateway_${Date.now()}`
          }
        });
        return {
          success: true,
          gatewayResponse: {
            paymentId: `gateway_${Date.now()}`,
            status: "completed"
          }
        };
      } else {
        await db.invoice.update({
          where: { id },
          data: {
            status: "FAILED" /* FAILED */
          }
        });
        return {
          success: false,
          error: "Payment failed"
        };
      }
    } catch (error) {
      await db.invoice.update({
        where: { id },
        data: {
          status: "FAILED" /* FAILED */
        }
      });
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },
  async markAsPaid(id, gatewayPaymentId) {
    return await this.updateStatus(id, "PAID" /* PAID */, /* @__PURE__ */ new Date(), gatewayPaymentId);
  },
  async markAsFailed(id) {
    return await this.updateStatus(id, "FAILED" /* FAILED */);
  }
};

// src/features/invoice/queries/invoice.queries.ts
init_prisma();
var InvoiceQueries = {
  async getById(id) {
    const invoice = await db.invoice.findUnique({
      where: { id },
      include: {
        customer: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
                email: true,
                phone: true
              }
            },
            plan: {
              select: {
                id: true,
                name: true,
                description: true,
                price: true,
                interval: true
              }
            }
          }
        }
      }
    });
    if (!invoice) {
      return null;
    }
    return invoice;
  },
  async list(params) {
    const { page = 1, limit = 10, customerId, status, startDate, endDate } = params;
    const skip2 = (page - 1) * limit;
    const where = {};
    if (customerId) {
      where.customerId = customerId;
    }
    if (status) {
      where.status = status;
    }
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) {
        where.createdAt.gte = new Date(startDate);
      }
      if (endDate) {
        where.createdAt.lte = new Date(endDate);
      }
    }
    const [invoices, total] = await Promise.all([
      db.invoice.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          customer: {
            include: {
              user: {
                select: {
                  id: true,
                  name: true,
                  email: true,
                  phone: true
                }
              },
              plan: {
                select: {
                  id: true,
                  name: true,
                  description: true,
                  price: true,
                  interval: true
                }
              }
            }
          }
        }
      }),
      db.invoice.count({ where })
    ]);
    return {
      items: invoices,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getByCustomer(customerId, params) {
    const { page = 1, limit = 10, status } = params;
    const skip2 = (page - 1) * limit;
    const customer = await db.customer.findUnique({
      where: { id: customerId }
    });
    if (!customer) {
      throw new Error("Customer not found");
    }
    const where = {
      customerId
    };
    if (status) {
      where.status = status;
    }
    const [invoices, total] = await Promise.all([
      db.invoice.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" }
      }),
      db.invoice.count({ where })
    ]);
    return {
      customer: {
        id: customer.id,
        userId: customer.userId,
        status: customer.status
      },
      invoices,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getPending() {
    const invoices = await db.invoice.findMany({
      where: { status: "PENDING" },
      orderBy: { createdAt: "asc" },
      include: {
        customer: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
                email: true,
                phone: true
              }
            },
            plan: {
              select: {
                id: true,
                name: true,
                description: true,
                price: true,
                interval: true
              }
            }
          }
        }
      }
    });
    return invoices;
  },
  async getFailed() {
    const invoices = await db.invoice.findMany({
      where: { status: "FAILED" },
      orderBy: { createdAt: "desc" },
      include: {
        customer: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
                email: true,
                phone: true
              }
            },
            plan: {
              select: {
                id: true,
                name: true,
                description: true,
                price: true,
                interval: true
              }
            }
          }
        }
      }
    });
    return invoices;
  },
  async getStats() {
    const [
      total,
      pending,
      paid,
      failed,
      amountData
    ] = await Promise.all([
      db.invoice.count(),
      db.invoice.count({ where: { status: "PENDING" } }),
      db.invoice.count({ where: { status: "PAID" } }),
      db.invoice.count({ where: { status: "FAILED" } }),
      db.invoice.aggregate({
        _sum: { amount: true },
        _avg: { amount: true }
      })
    ]);
    const [totalPaid, totalPending, totalFailed] = await Promise.all([
      db.invoice.aggregate({
        where: { status: "PAID" },
        _sum: { amount: true }
      }),
      db.invoice.aggregate({
        where: { status: "PENDING" },
        _sum: { amount: true }
      }),
      db.invoice.aggregate({
        where: { status: "FAILED" },
        _sum: { amount: true }
      })
    ]);
    const totalAmount = amountData._sum.amount ? Number(amountData._sum.amount) : 0;
    const totalPaidAmount = totalPaid._sum.amount ? Number(totalPaid._sum.amount) : 0;
    const totalPendingAmount = totalPending._sum.amount ? Number(totalPending._sum.amount) : 0;
    const totalFailedAmount = totalFailed._sum.amount ? Number(totalFailed._sum.amount) : 0;
    const averageAmount = amountData._avg.amount ? Number(amountData._avg.amount) : 0;
    const conversionRate = total > 0 ? paid / total * 100 : 0;
    return {
      total,
      pending,
      paid,
      failed,
      totalAmount,
      totalPaid: totalPaidAmount,
      totalPending: totalPendingAmount,
      totalFailed: totalFailedAmount,
      averageAmount,
      conversionRate
    };
  },
  async generatePdf(invoiceId) {
    const invoice = await db.invoice.findUnique({
      where: { id: invoiceId },
      include: {
        customer: {
          include: {
            user: true,
            plan: true
          }
        }
      }
    });
    if (!invoice) {
      throw new Error("Invoice not found");
    }
    const pdfData = {
      invoice: {
        id: invoice.id,
        amount: Number(invoice.amount),
        status: invoice.status,
        createdAt: invoice.createdAt,
        paymentDate: invoice.paymentDate
      },
      customer: {
        name: invoice.customer.user.name,
        email: invoice.customer.user.email,
        phone: invoice.customer.user.phone
      },
      plan: invoice.customer.plan ? {
        name: invoice.customer.plan.name,
        description: invoice.customer.plan.description,
        price: Number(invoice.customer.plan.price),
        interval: invoice.customer.plan.interval
      } : null
    };
    return {
      success: true,
      pdfData,
      message: "PDF data prepared for generation"
    };
  },
  async getOverdueInvoices() {
    const thirtyDaysAgo = /* @__PURE__ */ new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    const overdueInvoices = await db.invoice.findMany({
      where: {
        status: "PENDING",
        createdAt: {
          lt: thirtyDaysAgo
        }
      },
      orderBy: { createdAt: "asc" },
      include: {
        customer: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
                email: true,
                phone: true
              }
            }
          }
        }
      }
    });
    return overdueInvoices;
  },
  async getRevenueByPeriod(startDate, endDate) {
    const invoices = await db.invoice.findMany({
      where: {
        status: "PAID",
        paymentDate: {
          gte: startDate,
          lte: endDate
        }
      },
      include: {
        customer: {
          include: {
            plan: true
          }
        }
      }
    });
    const totalRevenue = invoices.reduce((sum, invoice) => sum + Number(invoice.amount), 0);
    const revenueByPlan = invoices.reduce((acc, invoice) => {
      if (invoice.customer.plan) {
        const planId = invoice.customer.plan.id;
        if (!acc[planId]) {
          acc[planId] = {
            plan: invoice.customer.plan,
            revenue: 0,
            count: 0
          };
        }
        acc[planId].revenue += Number(invoice.amount);
        acc[planId].count += 1;
      }
      return acc;
    }, {});
    return {
      totalRevenue,
      invoiceCount: invoices.length,
      revenueByPlan: Object.values(revenueByPlan)
    };
  }
};

// src/features/invoice/invoice.controller.ts
var InvoiceController = {
  // === CRUD BÁSICO ===
  async create(request, reply) {
    try {
      const { customerId, amount, status, gatewayPaymentId, paymentDate } = request.body;
      const result = await InvoiceCommands.create({
        customerId,
        amount,
        status,
        gatewayPaymentId,
        paymentDate: paymentDate ? new Date(paymentDate) : void 0
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Customer not found") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      const result = await InvoiceQueries.getById(id);
      if (!result) {
        return reply.status(404).send({
          error: "Invoice not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invoice not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      if (updateData.paymentDate) {
        updateData.paymentDate = new Date(updateData.paymentDate);
      }
      const result = await InvoiceCommands.update(id, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invoice not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      await InvoiceCommands.delete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invoice not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { page = 1, limit = 10, customerId, status, startDate, endDate } = request.query;
      const result = await InvoiceQueries.list({
        page,
        limit,
        customerId,
        status,
        startDate,
        endDate
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (QUERIES) ===
  async getByCustomer(request, reply) {
    try {
      const { customerId } = request.params;
      const { page = 1, limit = 10, status } = request.query;
      const result = await InvoiceQueries.getByCustomer(customerId, {
        page,
        limit,
        status
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Customer not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getPending(request, reply) {
    try {
      const result = await InvoiceQueries.getPending();
      return reply.send({ invoices: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getFailed(request, reply) {
    try {
      const result = await InvoiceQueries.getFailed();
      return reply.send({ invoices: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const result = await InvoiceQueries.getStats();
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getPdf(request, reply) {
    try {
      const { id } = request.params;
      const result = await InvoiceQueries.generatePdf(id);
      if (!result.success) {
        return reply.status(400).send({
          error: "Failed to generate PDF"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invoice not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getOverdue(request, reply) {
    try {
      const result = await InvoiceQueries.getOverdueInvoices();
      return reply.send({ invoices: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getRevenue(request, reply) {
    try {
      const { startDate, endDate } = request.query;
      const start = startDate ? new Date(startDate) : new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3);
      const end = endDate ? new Date(endDate) : /* @__PURE__ */ new Date();
      const result = await InvoiceQueries.getRevenueByPeriod(start, end);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (COMMANDS) ===
  async updateStatus(request, reply) {
    try {
      const { id } = request.params;
      const { status, paymentDate, gatewayPaymentId } = request.body;
      const result = await InvoiceCommands.updateStatus(
        id,
        status,
        paymentDate ? new Date(paymentDate) : void 0,
        gatewayPaymentId
      );
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invoice not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async retryPayment(request, reply) {
    try {
      const { id } = request.params;
      const { gateway, paymentMethod } = request.body;
      const retryResult = await InvoiceCommands.retryPayment(id, gateway, paymentMethod);
      const invoice = await InvoiceQueries.getById(id);
      return reply.send({
        invoice,
        retryResult
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invoice not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Invoice is already paid") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async sendEmail(request, reply) {
    try {
      const { id } = request.params;
      const { email, includePdf } = request.body;
      const invoice = await InvoiceQueries.getById(id);
      if (!invoice) {
        return reply.status(404).send({
          error: "Invoice not found"
        });
      }
      const emailResult = {
        success: true,
        messageId: `email_${Date.now()}`
      };
      return reply.send({
        invoice,
        emailResult
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invoice not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async markAsPaid(request, reply) {
    try {
      const { id } = request.params;
      const { gatewayPaymentId } = request.body;
      const result = await InvoiceCommands.markAsPaid(id, gatewayPaymentId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invoice not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async markAsFailed(request, reply) {
    try {
      const { id } = request.params;
      const result = await InvoiceCommands.markAsFailed(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invoice not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/invoice/invoice.schema.ts
var createInvoiceSchema = {
  body: {
    type: "object",
    required: ["customerId", "amount"],
    properties: {
      customerId: { type: "string", minLength: 1 },
      amount: { type: "number", minimum: 0.01 },
      status: {
        type: "string",
        enum: ["PENDING", "PAID", "FAILED"],
        default: "PENDING"
      },
      gatewayPaymentId: { type: "string" },
      paymentDate: { type: "string", format: "date-time" }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        customerId: { type: "string" },
        amount: { type: "number" },
        status: { type: "string" },
        gatewayPaymentId: { type: "string", nullable: true },
        paymentDate: { type: "string", format: "date-time", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        customer: {
          type: "object",
          properties: {
            id: { type: "string" },
            userId: { type: "string" },
            status: { type: "string" },
            user: {
              type: "object",
              properties: {
                id: { type: "string" },
                name: { type: "string" },
                email: { type: "string" },
                phone: { type: "string", nullable: true }
              }
            },
            plan: {
              type: "object",
              nullable: true,
              properties: {
                id: { type: "string" },
                name: { type: "string" },
                description: { type: "string", nullable: true },
                price: { type: "number" },
                interval: { type: "string" }
              }
            }
          }
        }
      }
    }
  }
};
var updateInvoiceSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      amount: { type: "number", minimum: 0.01 },
      status: {
        type: "string",
        enum: ["PENDING", "PAID", "FAILED"]
      },
      gatewayPaymentId: { type: "string" },
      paymentDate: { type: "string", format: "date-time" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        customerId: { type: "string" },
        amount: { type: "number" },
        status: { type: "string" },
        gatewayPaymentId: { type: "string", nullable: true },
        paymentDate: { type: "string", format: "date-time", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        customer: {
          type: "object",
          properties: {
            id: { type: "string" },
            userId: { type: "string" },
            status: { type: "string" },
            user: {
              type: "object",
              properties: {
                id: { type: "string" },
                name: { type: "string" },
                email: { type: "string" },
                phone: { type: "string", nullable: true }
              }
            },
            plan: {
              type: "object",
              nullable: true,
              properties: {
                id: { type: "string" },
                name: { type: "string" },
                description: { type: "string", nullable: true },
                price: { type: "number" },
                interval: { type: "string" }
              }
            }
          }
        }
      }
    }
  }
};
var getInvoiceSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        customerId: { type: "string" },
        amount: { type: "number" },
        status: { type: "string" },
        gatewayPaymentId: { type: "string", nullable: true },
        paymentDate: { type: "string", format: "date-time", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        customer: {
          type: "object",
          properties: {
            id: { type: "string" },
            userId: { type: "string" },
            status: { type: "string" },
            user: {
              type: "object",
              properties: {
                id: { type: "string" },
                name: { type: "string" },
                email: { type: "string" },
                phone: { type: "string", nullable: true }
              }
            },
            plan: {
              type: "object",
              nullable: true,
              properties: {
                id: { type: "string" },
                name: { type: "string" },
                description: { type: "string", nullable: true },
                price: { type: "number" },
                interval: { type: "string" }
              }
            }
          }
        }
      }
    }
  }
};
var listInvoicesSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      customerId: { type: "string" },
      status: {
        type: "string",
        enum: ["PENDING", "PAID", "FAILED"]
      },
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              customerId: { type: "string" },
              amount: { type: "number" },
              status: { type: "string" },
              gatewayPaymentId: { type: "string", nullable: true },
              paymentDate: { type: "string", format: "date-time", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              customer: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  userId: { type: "string" },
                  status: { type: "string" },
                  user: {
                    type: "object",
                    properties: {
                      id: { type: "string" },
                      name: { type: "string" },
                      email: { type: "string" },
                      phone: { type: "string", nullable: true }
                    }
                  },
                  plan: {
                    type: "object",
                    nullable: true,
                    properties: {
                      id: { type: "string" },
                      name: { type: "string" },
                      description: { type: "string", nullable: true },
                      price: { type: "number" },
                      interval: { type: "string" }
                    }
                  }
                }
              }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var deleteInvoiceSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" }
  }
};
var updateInvoiceStatusSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["status"],
    properties: {
      status: {
        type: "string",
        enum: ["PENDING", "PAID", "FAILED"]
      },
      paymentDate: { type: "string", format: "date-time" },
      gatewayPaymentId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        customerId: { type: "string" },
        amount: { type: "number" },
        status: { type: "string" },
        gatewayPaymentId: { type: "string", nullable: true },
        paymentDate: { type: "string", format: "date-time", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        customer: {
          type: "object",
          properties: {
            id: { type: "string" },
            userId: { type: "string" },
            status: { type: "string" }
          }
        }
      }
    }
  }
};
var retryPaymentSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      gateway: { type: "string" },
      paymentMethod: { type: "object" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        invoice: {
          type: "object",
          properties: {
            id: { type: "string" },
            customerId: { type: "string" },
            amount: { type: "number" },
            status: { type: "string" },
            gatewayPaymentId: { type: "string", nullable: true },
            paymentDate: { type: "string", format: "date-time", nullable: true },
            createdAt: { type: "string", format: "date-time" }
          }
        },
        retryResult: {
          type: "object",
          properties: {
            success: { type: "boolean" },
            gatewayResponse: { type: "object", nullable: true },
            error: { type: "string", nullable: true }
          }
        }
      }
    }
  }
};
var getInvoicePdfSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        success: { type: "boolean" },
        pdfData: { type: "object" },
        message: { type: "string" }
      }
    }
  }
};
var sendInvoiceEmailSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      email: { type: "string", format: "email" },
      includePdf: { type: "boolean", default: false }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        invoice: {
          type: "object",
          properties: {
            id: { type: "string" },
            customerId: { type: "string" },
            amount: { type: "number" },
            status: { type: "string" }
          }
        },
        emailResult: {
          type: "object",
          properties: {
            success: { type: "boolean" },
            messageId: { type: "string", nullable: true },
            error: { type: "string", nullable: true }
          }
        }
      }
    }
  }
};
var getCustomerInvoicesSchema2 = {
  params: {
    type: "object",
    required: ["customerId"],
    properties: {
      customerId: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      status: {
        type: "string",
        enum: ["PENDING", "PAID", "FAILED"]
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        customer: {
          type: "object",
          properties: {
            id: { type: "string" },
            userId: { type: "string" },
            status: { type: "string" }
          }
        },
        invoices: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              customerId: { type: "string" },
              amount: { type: "number" },
              status: { type: "string" },
              gatewayPaymentId: { type: "string", nullable: true },
              paymentDate: { type: "string", format: "date-time", nullable: true },
              createdAt: { type: "string", format: "date-time" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getInvoiceStatsSchema = {
  response: {
    200: {
      type: "object",
      properties: {
        total: { type: "number" },
        pending: { type: "number" },
        paid: { type: "number" },
        failed: { type: "number" },
        totalAmount: { type: "number" },
        totalPaid: { type: "number" },
        totalPending: { type: "number" },
        totalFailed: { type: "number" },
        averageAmount: { type: "number" },
        conversionRate: { type: "number" }
      }
    }
  }
};
var getOverdueInvoicesSchema = {
  response: {
    200: {
      type: "object",
      properties: {
        invoices: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              customerId: { type: "string" },
              amount: { type: "number" },
              status: { type: "string" },
              createdAt: { type: "string", format: "date-time" },
              customer: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  userId: { type: "string" },
                  user: {
                    type: "object",
                    properties: {
                      id: { type: "string" },
                      name: { type: "string" },
                      email: { type: "string" },
                      phone: { type: "string", nullable: true }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
};
var getRevenueSchema = {
  querystring: {
    type: "object",
    properties: {
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        totalRevenue: { type: "number" },
        invoiceCount: { type: "number" },
        revenueByPlan: {
          type: "array",
          items: {
            type: "object",
            properties: {
              plan: { type: "object" },
              revenue: { type: "number" },
              count: { type: "number" }
            }
          }
        }
      }
    }
  }
};
var markAsPaidSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      gatewayPaymentId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        customerId: { type: "string" },
        amount: { type: "number" },
        status: { type: "string" },
        gatewayPaymentId: { type: "string", nullable: true },
        paymentDate: { type: "string", format: "date-time", nullable: true },
        createdAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var markAsFailedSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        customerId: { type: "string" },
        amount: { type: "number" },
        status: { type: "string" },
        gatewayPaymentId: { type: "string", nullable: true },
        paymentDate: { type: "string", format: "date-time", nullable: true },
        createdAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var InvoiceSchemas = {
  create: createInvoiceSchema,
  update: updateInvoiceSchema,
  get: getInvoiceSchema,
  delete: deleteInvoiceSchema,
  list: listInvoicesSchema,
  updateStatus: updateInvoiceStatusSchema,
  retryPayment: retryPaymentSchema,
  getPdf: getInvoicePdfSchema,
  sendEmail: sendInvoiceEmailSchema,
  getByCustomer: getCustomerInvoicesSchema2,
  getStats: getInvoiceStatsSchema,
  getOverdue: getOverdueInvoicesSchema,
  getRevenue: getRevenueSchema,
  markAsPaid: markAsPaidSchema,
  markAsFailed: markAsFailedSchema
};

// src/features/invoice/invoice.routes.ts
init_auth_middleware();
async function InvoiceRoutes(fastify2) {
  fastify2.post("/", {
    schema: InvoiceSchemas.create,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: InvoiceController.create
  });
  fastify2.get("/", {
    schema: InvoiceSchemas.list,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: InvoiceController.list
  });
  fastify2.get("/:id", {
    schema: InvoiceSchemas.get,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: InvoiceController.get
  });
  fastify2.put("/:id", {
    schema: InvoiceSchemas.update,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: InvoiceController.update
  });
  fastify2.delete("/:id", {
    schema: InvoiceSchemas.delete,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: InvoiceController.delete
  });
  fastify2.get("/customer/:customerId", {
    schema: InvoiceSchemas.getByCustomer,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: InvoiceController.getByCustomer
  });
  fastify2.get("/pending", {
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: InvoiceController.getPending
  });
  fastify2.get("/failed", {
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: InvoiceController.getFailed
  });
  fastify2.get("/overdue", {
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: InvoiceController.getOverdue
  });
  fastify2.get("/stats", {
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: InvoiceController.getStats
  });
  fastify2.get("/revenue", {
    schema: InvoiceSchemas.getRevenue,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: InvoiceController.getRevenue
  });
  fastify2.get("/:id/pdf", {
    schema: InvoiceSchemas.getPdf,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: InvoiceController.getPdf
  });
  fastify2.patch("/:id/status", {
    schema: InvoiceSchemas.updateStatus,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: InvoiceController.updateStatus
  });
  fastify2.post("/:id/retry", {
    schema: InvoiceSchemas.retryPayment,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: InvoiceController.retryPayment
  });
  fastify2.post("/:id/send-email", {
    schema: InvoiceSchemas.sendEmail,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: InvoiceController.sendEmail
  });
  fastify2.patch("/:id/mark-paid", {
    schema: InvoiceSchemas.markAsPaid,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: InvoiceController.markAsPaid
  });
  fastify2.patch("/:id/mark-failed", {
    schema: InvoiceSchemas.markAsFailed,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: InvoiceController.markAsFailed
  });
}

// src/services/payment/abacate-pay.service.ts
var AbacatePayService = {
  config: {
    name: "Abacate Pay",
    version: "1.0.0",
    supportedCurrencies: ["BRL"],
    supportedMethods: ["pix", "credit_card", "debit_card", "boleto"],
    environment: process.env.ABACATE_PAY_ENV === "production" ? "production" : "sandbox",
    apiKey: process.env.ABACATE_PAY_API_KEY,
    secretKey: process.env.ABACATE_PAY_SECRET_KEY,
    webhookUrl: process.env.ABACATE_PAY_WEBHOOK_URL
  },
  async createPayment(data) {
    try {
      console.log("Creating payment with Abacate Pay:", data);
      const paymentId = `abacate_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const success = data.amount > 0 && data.amount < 1e4;
      return {
        success,
        paymentId: success ? paymentId : void 0,
        status: success ? "pending" : "failed",
        gatewayResponse: {
          payment_id: paymentId,
          status: success ? "pending" : "failed",
          amount: data.amount,
          currency: data.currency || "BRL",
          created_at: (/* @__PURE__ */ new Date()).toISOString()
        },
        error: success ? void 0 : "Payment amount exceeds limit"
      };
    } catch (error) {
      return {
        success: false,
        status: "failed",
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },
  async getPaymentStatus(paymentId) {
    try {
      console.log("Getting payment status from Abacate Pay:", paymentId);
      const statuses = ["pending", "completed", "failed", "cancelled"];
      const randomStatus = statuses[Math.floor(Math.random() * statuses.length)];
      return {
        paymentId,
        status: randomStatus,
        amount: Math.random() * 1e3,
        currency: "BRL",
        gatewayResponse: {
          payment_id: paymentId,
          status: randomStatus,
          amount: Math.random() * 1e3,
          currency: "BRL",
          updated_at: (/* @__PURE__ */ new Date()).toISOString()
        }
      };
    } catch (error) {
      return {
        paymentId,
        status: "failed",
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },
  async cancelPayment(paymentId) {
    try {
      console.log("Cancelling payment with Abacate Pay:", paymentId);
    } catch (error) {
      console.error("Error cancelling payment:", error);
      throw error;
    }
  },
  async refundPayment(data) {
    try {
      console.log("Processing refund with Abacate Pay:", data);
      const refundId = `refund_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      return {
        success: true,
        refundId,
        amount: data.amount,
        gatewayResponse: {
          refund_id: refundId,
          payment_id: data.paymentId,
          amount: data.amount,
          reason: data.reason,
          status: "processed",
          created_at: (/* @__PURE__ */ new Date()).toISOString()
        }
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },
  async handleWebhook(payload, signature) {
    try {
      if (signature && !this.verifySignature(payload, signature)) {
        return {
          success: false,
          eventType: "unknown",
          error: "Invalid signature"
        };
      }
      const eventType = this.mapEventType(payload.type);
      return {
        success: true,
        eventType,
        paymentId: payload.data?.payment_id,
        invoiceId: payload.data?.invoice_id,
        customerId: payload.data?.customer_id,
        status: payload.data?.status,
        gatewayResponse: payload
      };
    } catch (error) {
      return {
        success: false,
        eventType: "unknown",
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },
  async isAvailable() {
    try {
      return this.config.apiKey !== void 0 && this.config.secretKey !== void 0;
    } catch (error) {
      return false;
    }
  },
  getConfig() {
    return { ...this.config };
  },
  async verifySignature(payload, signature) {
    return true;
  },
  async mapEventType(abacateEventType) {
    const eventMap = {
      "payment.created": "payment.created",
      "payment.completed": "payment.completed",
      "payment.failed": "payment.failed",
      "payment.cancelled": "payment.cancelled",
      "payment.refunded": "payment.refunded",
      "invoice.created": "invoice.created",
      "invoice.paid": "invoice.paid",
      "invoice.failed": "invoice.failed"
    };
    return eventMap[abacateEventType] || "payment.created";
  },
  // Métodos específicos do Abacate Pay
  async generatePixPayment(data) {
    const paymentData = {
      ...data,
      paymentMethod: "pix"
    };
    return this.createPayment(paymentData);
  },
  async generateBoletoPayment(data) {
    const paymentData = {
      ...data,
      paymentMethod: "boleto"
    };
    return this.createPayment(paymentData);
  },
  async createSubscription(data) {
    console.log("Creating subscription with Abacate Pay:", data);
    const subscriptionId = `sub_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    return {
      success: true,
      paymentId: subscriptionId,
      status: "completed",
      gatewayResponse: {
        subscription_id: subscriptionId,
        customer_id: data.customerId,
        plan_id: data.planId,
        amount: data.amount,
        interval: data.interval,
        status: "active",
        created_at: (/* @__PURE__ */ new Date()).toISOString()
      }
    };
  }
};

// src/services/payment/stripe.service.ts
var StripeService = class {
  constructor() {
    this.config = {
      name: "Stripe",
      version: "2023-10-16",
      supportedCurrencies: ["USD", "EUR", "BRL", "GBP", "CAD", "AUD"],
      supportedMethods: ["card", "bank_transfer", "wallet", "buy_now_pay_later"],
      environment: process.env.STRIPE_ENV === "production" ? "production" : "sandbox",
      apiKey: process.env.STRIPE_API_KEY,
      secretKey: process.env.STRIPE_SECRET_KEY,
      webhookUrl: process.env.STRIPE_WEBHOOK_URL
    };
  }
  async createPayment(data) {
    try {
      console.log("Creating payment with Stripe:", data);
      const paymentId = `pi_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const success = data.amount > 0 && data.amount < 5e4;
      return {
        success,
        paymentId: success ? paymentId : void 0,
        status: success ? "pending" : "failed",
        gatewayResponse: {
          id: paymentId,
          object: "payment_intent",
          status: success ? "requires_payment_method" : "failed",
          amount: Math.round(data.amount * 100),
          // Stripe usa centavos
          currency: data.currency || "usd",
          created: Math.floor(Date.now() / 1e3)
        },
        error: success ? void 0 : "Payment amount exceeds limit"
      };
    } catch (error) {
      return {
        success: false,
        status: "failed",
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  async getPaymentStatus(paymentId) {
    try {
      console.log("Getting payment status from Stripe:", paymentId);
      const statuses = ["pending", "completed", "failed", "cancelled"];
      const randomStatus = statuses[Math.floor(Math.random() * statuses.length)];
      return {
        paymentId,
        status: randomStatus,
        amount: Math.random() * 1e3,
        currency: "usd",
        gatewayResponse: {
          id: paymentId,
          object: "payment_intent",
          status: randomStatus,
          amount: Math.round(Math.random() * 1e5),
          currency: "usd",
          updated: Math.floor(Date.now() / 1e3)
        }
      };
    } catch (error) {
      return {
        paymentId,
        status: "failed",
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  async cancelPayment(paymentId) {
    try {
      console.log("Cancelling payment with Stripe:", paymentId);
    } catch (error) {
      console.error("Error cancelling payment:", error);
      throw error;
    }
  }
  async refundPayment(data) {
    try {
      console.log("Processing refund with Stripe:", data);
      const refundId = `re_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      return {
        success: true,
        refundId,
        amount: data.amount,
        gatewayResponse: {
          id: refundId,
          object: "refund",
          payment_intent: data.paymentId,
          amount: data.amount ? Math.round(data.amount * 100) : void 0,
          reason: data.reason,
          status: "succeeded",
          created: Math.floor(Date.now() / 1e3)
        }
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  async handleWebhook(payload, signature) {
    try {
      if (signature && !this.verifySignature(payload, signature)) {
        return {
          success: false,
          eventType: "unknown",
          error: "Invalid signature"
        };
      }
      const eventType = this.mapEventType(payload.type);
      return {
        success: true,
        eventType,
        paymentId: payload.data?.object?.id,
        invoiceId: payload.data?.object?.metadata?.invoice_id,
        customerId: payload.data?.object?.customer,
        status: payload.data?.object?.status,
        gatewayResponse: payload
      };
    } catch (error) {
      return {
        success: false,
        eventType: "unknown",
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  async isAvailable() {
    try {
      return this.config.apiKey !== void 0 && this.config.secretKey !== void 0;
    } catch (error) {
      return false;
    }
  }
  getConfig() {
    return { ...this.config };
  }
  verifySignature(payload, signature) {
    return true;
  }
  mapEventType(stripeEventType) {
    const eventMap = {
      "payment_intent.created": "payment.created",
      "payment_intent.succeeded": "payment.completed",
      "payment_intent.payment_failed": "payment.failed",
      "payment_intent.canceled": "payment.cancelled",
      "charge.dispute.created": "payment.refunded",
      "invoice.created": "invoice.created",
      "invoice.payment_succeeded": "invoice.paid",
      "invoice.payment_failed": "invoice.failed",
      "customer.subscription.created": "subscription.created",
      "customer.subscription.updated": "subscription.updated",
      "customer.subscription.deleted": "subscription.cancelled"
    };
    return eventMap[stripeEventType] || "payment.created";
  }
  // Métodos específicos do Stripe
  async createPaymentIntent(data) {
    return this.createPayment(data);
  }
  async createCustomer(data) {
    console.log("Creating customer with Stripe:", data);
    const customerId = `cus_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    return {
      success: true,
      customerId
    };
  }
  async createSubscription(data) {
    console.log("Creating subscription with Stripe:", data);
    const subscriptionId = `sub_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    return {
      success: true,
      paymentId: subscriptionId,
      status: "completed",
      gatewayResponse: {
        id: subscriptionId,
        object: "subscription",
        customer: data.customerId,
        status: "active",
        current_period_start: Math.floor(Date.now() / 1e3),
        current_period_end: Math.floor(Date.now() / 1e3) + 30 * 24 * 60 * 60,
        created: Math.floor(Date.now() / 1e3)
      }
    };
  }
  async createSetupIntent(customerId) {
    console.log("Creating setup intent with Stripe:", customerId);
    const setupIntentId = `seti_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    return {
      success: true,
      paymentId: setupIntentId,
      status: "completed",
      gatewayResponse: {
        id: setupIntentId,
        object: "setup_intent",
        customer: customerId,
        status: "succeeded",
        created: Math.floor(Date.now() / 1e3)
      }
    };
  }
};

// src/services/payment/payment.service.ts
var PaymentService = {
  gateways: {
    "abacate-pay": AbacatePayService,
    stripe: StripeService
  },
  async processPayment(gatewayName, data) {
    const gateway = this.gateways[gatewayName];
    if (!gateway) {
      throw new Error(`Gateway '${gatewayName}' not found`);
    }
    return gateway.createPayment(data);
  },
  async getPaymentStatus(gatewayName, paymentId) {
    const gateway = this.gateways[gatewayName];
    if (!gateway) {
      throw new Error(`Gateway '${gatewayName}' not found`);
    }
    try {
      return await gateway.getPaymentStatus(paymentId);
    } catch (error) {
      throw new Error(`Error getting payment status via ${gatewayName}: ${error}`);
    }
  },
  async cancelPayment(gatewayName, paymentId) {
    const gateway = this.gateways[gatewayName];
    if (!gateway) {
      throw new Error(`Gateway '${gatewayName}' not found`);
    }
    return gateway.cancelPayment(paymentId);
  },
  async refundPayment(gatewayName, data) {
    const gateway = this.getGateway(gatewayName);
    if (!gateway) {
      return {
        success: false,
        error: `Gateway '${gatewayName}' not found`
      };
    }
    try {
      return await gateway.refundPayment(data);
    } catch (error) {
      console.error(`Error processing refund via ${gatewayName}:`, error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },
  async handleWebhook(gatewayName, payload, signature) {
    const gateway = this.getGateway(gatewayName);
    if (!gateway) {
      return {
        success: false,
        eventType: "unknown",
        error: `Gateway '${gatewayName}' not found`
      };
    }
    try {
      return await gateway.handleWebhook(payload, signature);
    } catch (error) {
      console.error(`Error handling webhook for ${gatewayName}:`, error);
      return {
        success: false,
        eventType: "unknown",
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },
  async retryFailedPayment(gatewayName, data, maxRetries = 3) {
    let attempts = 0;
    let lastError;
    while (attempts < maxRetries) {
      attempts++;
      const result = await this.processPayment(gatewayName, data);
      if (result.success) {
        return result;
      }
      lastError = result.error;
      if (attempts < maxRetries) {
        const delay = Math.pow(2, attempts) * 1e3;
        await new Promise((resolve) => setTimeout(resolve, delay));
      }
    }
    return {
      success: false,
      status: "failed",
      error: `Payment failed after ${maxRetries} attempts. Last error: ${lastError}`
    };
  },
  getGateway(gatewayName) {
    return this.gateways.get(gatewayName);
  },
  getAvailableGateways() {
    return Array.from(this.gateways.entries()).map(([name, gateway]) => ({
      name,
      config: gateway.getConfig()
    }));
  },
  async getGatewayHealth() {
    const healthChecks = await Promise.allSettled(
      Array.from(this.gateways.entries()).map(async ([name, gateway]) => {
        try {
          const available = await gateway.isAvailable();
          return { name, available };
        } catch (error) {
          return {
            name,
            available: false,
            error: error instanceof Error ? error.message : "Unknown error"
          };
        }
      })
    );
    return healthChecks.map(
      (result) => result.status === "fulfilled" ? result.value : {
        name: "unknown",
        available: false,
        error: "Health check failed"
      }
    );
  },
  // Método para determinar o melhor gateway baseado nos dados do pagamento
  async selectBestGateway(data) {
    const availableGateways = await this.getGatewayHealth();
    const workingGateways = availableGateways.filter((g) => g.available);
    if (workingGateways.length === 0) {
      return null;
    }
    if (data.currency === "BRL") {
      const abacatePay = workingGateways.find((g) => g.name === "abacate-pay");
      if (abacatePay) {
        return "abacate-pay";
      }
    }
    const stripe = workingGateways.find((g) => g.name === "stripe");
    if (stripe) {
      return "stripe";
    }
    return workingGateways[0]?.name || null;
  },
  // Método para processar pagamento com gateway automático
  async processPaymentAuto(data) {
    const selectedGateway = await this.selectBestGateway(data);
    if (!selectedGateway) {
      return {
        success: false,
        status: "failed",
        error: "No payment gateways available",
        gateway: "none"
      };
    }
    const result = await this.processPayment(selectedGateway, data);
    return {
      ...result,
      gateway: selectedGateway
    };
  }
};

// src/services/payment/webhook-handler.ts
var WebhookHandler = {
  async processWebhook(gatewayName, payload, signature) {
    try {
      const result = await PaymentService.handleWebhook(
        gatewayName,
        payload,
        signature
      );
      if (!result.success) {
        return {
          success: false,
          error: result.error
        };
      }
      const webhookEvent = {
        id: payload.id || `webhook_${Date.now()}`,
        type: result.eventType,
        data: {
          paymentId: result.paymentId,
          invoiceId: result.invoiceId,
          customerId: result.customerId,
          amount: payload.data?.object?.amount || payload.data?.amount,
          currency: payload.data?.object?.currency || payload.data?.currency,
          status: result.status,
          metadata: payload.data?.object?.metadata || payload.data?.metadata
        },
        createdAt: /* @__PURE__ */ new Date(),
        gateway: gatewayName
      };
      await WebhookHandler.processEvent(webhookEvent);
      return {
        success: true,
        event: webhookEvent
      };
    } catch (error) {
      console.error("Error processing webhook:", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },
  async processEvent(event) {
    try {
      console.log(`Processing webhook event: ${event.type}`, event);
      switch (event.type) {
        case "payment.completed":
          await WebhookHandler.handlePaymentCompleted(event);
          break;
        case "payment.failed":
          await WebhookHandler.handlePaymentFailed(event);
          break;
        case "payment.cancelled":
          await WebhookHandler.handlePaymentCancelled(event);
          break;
        case "payment.refunded":
          await WebhookHandler.handlePaymentRefunded(event);
          break;
        case "invoice.paid":
          await WebhookHandler.handleInvoicePaid(event);
          break;
        case "invoice.failed":
          await WebhookHandler.handleInvoiceFailed(event);
          break;
        case "subscription.created":
          await WebhookHandler.handleSubscriptionCreated(event);
          break;
        case "subscription.updated":
          await WebhookHandler.handleSubscriptionUpdated(event);
          break;
        case "subscription.cancelled":
          await WebhookHandler.handleSubscriptionCancelled(event);
          break;
        case "subscription.renewed":
          await WebhookHandler.handleSubscriptionRenewed(event);
          break;
        default:
          console.log(`Unhandled webhook event type: ${event.type}`);
      }
    } catch (error) {
      console.error(`Error processing event ${event.type}:`, error);
      throw error;
    }
  },
  async handlePaymentCompleted(event) {
    if (event.data.invoiceId) {
      console.log(`Updating invoice ${event.data.invoiceId} to PAID`);
    }
    if (event.data.customerId) {
      console.log(`Sending payment confirmation email to customer ${event.data.customerId}`);
    }
  },
  async handlePaymentFailed(event) {
    if (event.data.invoiceId) {
      console.log(`Updating invoice ${event.data.invoiceId} to FAILED`);
    }
    if (event.data.customerId) {
      console.log(`Sending payment failed email to customer ${event.data.customerId}`);
    }
  },
  async handlePaymentCancelled(event) {
    if (event.data.invoiceId) {
      console.log(`Updating invoice ${event.data.invoiceId} to CANCELLED`);
    }
  },
  async handlePaymentRefunded(event) {
    if (event.data.invoiceId) {
      console.log(`Processing refund for invoice ${event.data.invoiceId}`);
    }
  },
  async handleInvoicePaid(event) {
    if (event.data.invoiceId) {
      console.log(`Invoice ${event.data.invoiceId} marked as paid`);
    }
    if (event.data.customerId) {
      console.log(`Updating customer ${event.data.customerId} subscription status`);
    }
  },
  async handleInvoiceFailed(event) {
    if (event.data.invoiceId) {
      console.log(`Invoice ${event.data.invoiceId} failed`);
    }
  },
  async handleSubscriptionCreated(event) {
    if (event.data.customerId) {
      console.log(`Subscription created for customer ${event.data.customerId}`);
    }
  },
  async handleSubscriptionUpdated(event) {
    if (event.data.customerId) {
      console.log(`Subscription updated for customer ${event.data.customerId}`);
    }
  },
  async handleSubscriptionCancelled(event) {
    if (event.data.customerId) {
      console.log(`Subscription cancelled for customer ${event.data.customerId}`);
    }
  },
  async handleSubscriptionRenewed(event) {
    if (event.data.customerId) {
      console.log(`Subscription renewed for customer ${event.data.customerId}`);
    }
  },
  // Método para verificar a integridade do webhook
  async verifyWebhook(gatewayName, payload, signature) {
    try {
      const result = await PaymentService.handleWebhook(
        gatewayName,
        payload,
        signature
      );
      return result.success;
    } catch (error) {
      console.error("Error verifying webhook:", error);
      return false;
    }
  },
  // Método para listar todos os tipos de eventos suportados
  getSupportedEvents() {
    return [
      "payment.created",
      "payment.completed",
      "payment.failed",
      "payment.cancelled",
      "payment.refunded",
      "invoice.created",
      "invoice.paid",
      "invoice.failed",
      "subscription.created",
      "subscription.updated",
      "subscription.cancelled",
      "subscription.renewed"
    ];
  }
};

// src/features/webhook/webhook.service.ts
var WebhookService = {
  async processWebhook(gateway, payload, signature) {
    try {
      const availableGateways = PaymentService.getAvailableGateways();
      const gatewayExists = availableGateways.some((g) => g.name === gateway);
      if (!gatewayExists) {
        return {
          success: false,
          error: `Gateway '${gateway}' not supported`
        };
      }
      const result = await WebhookHandler.processWebhook(
        gateway,
        payload,
        signature
      );
      await WebhookService.logWebhook({
        gateway,
        eventType: result.event?.type || "unknown",
        eventId: result.event?.id,
        success: result.success,
        payload,
        response: result.event,
        error: result.error,
        processedAt: /* @__PURE__ */ new Date()
      });
      return {
        success: result.success,
        eventId: result.event?.id,
        eventType: result.event?.type,
        error: result.error
      };
    } catch (error) {
      await WebhookService.logWebhook({
        gateway,
        eventType: "error",
        success: false,
        payload,
        error: error instanceof Error ? error.message : "Unknown error",
        processedAt: /* @__PURE__ */ new Date()
      });
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },
  async verifyWebhook(gateway, payload, signature) {
    try {
      return await WebhookHandler.verifyWebhook(
        gateway,
        payload,
        signature
      );
    } catch (error) {
      console.error("Error verifying webhook:", error);
      return false;
    }
  },
  async getWebhookLogs(params) {
    const mockLogs = [
      {
        id: "log_1",
        gateway: "stripe",
        eventType: "payment.completed",
        eventId: "evt_123",
        success: true,
        payload: { type: "payment_intent.succeeded" },
        processedAt: new Date(Date.now() - 1e3 * 60 * 5),
        // 5 minutos atrás
        createdAt: new Date(Date.now() - 1e3 * 60 * 5)
      },
      {
        id: "log_2",
        gateway: "abacate-pay",
        eventType: "payment.failed",
        eventId: "evt_456",
        success: false,
        payload: { type: "payment_failed" },
        error: "Payment declined",
        processedAt: new Date(Date.now() - 1e3 * 60 * 10),
        // 10 minutos atrás
        createdAt: new Date(Date.now() - 1e3 * 60 * 10)
      }
    ];
    let filteredLogs = mockLogs;
    if (params.gateway) {
      filteredLogs = filteredLogs.filter((log) => log.gateway === params.gateway);
    }
    if (params.eventType) {
      filteredLogs = filteredLogs.filter((log) => log.eventType === params.eventType);
    }
    if (params.success !== void 0) {
      filteredLogs = filteredLogs.filter((log) => log.success === params.success);
    }
    if (params.startDate) {
      const startDate = new Date(params.startDate);
      filteredLogs = filteredLogs.filter((log) => log.processedAt >= startDate);
    }
    if (params.endDate) {
      const endDate = new Date(params.endDate);
      filteredLogs = filteredLogs.filter((log) => log.processedAt <= endDate);
    }
    const page = params.page || 1;
    const limit = params.limit || 10;
    const skip2 = (page - 1) * limit;
    const items = filteredLogs.slice(skip2, skip2 + limit);
    const total = filteredLogs.length;
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getWebhookStats() {
    const mockStats = {
      total: 150,
      successful: 142,
      failed: 8,
      byGateway: {
        "stripe": {
          total: 100,
          successful: 95,
          failed: 5
        },
        "abacate-pay": {
          total: 50,
          successful: 47,
          failed: 3
        }
      },
      byEventType: {
        "payment.completed": 95,
        "payment.failed": 8,
        "payment.cancelled": 2,
        "invoice.paid": 45,
        "invoice.failed": 3
      },
      last24Hours: {
        total: 25,
        successful: 24,
        failed: 1
      }
    };
    return mockStats;
  },
  async getWebhookHealth() {
    try {
      const gatewayHealth = await PaymentService.getGatewayHealth();
      const gateways = gatewayHealth.map((gateway) => ({
        name: gateway.name,
        available: gateway.available,
        lastWebhook: new Date(Date.now() - Math.random() * 1e3 * 60 * 60),
        // Mock
        errorRate: Math.random() * 5
        // Mock: 0-5% error rate
      }));
      const availableGateways = gateways.filter((g) => g.available).length;
      const totalGateways = gateways.length;
      return {
        gateways,
        overall: {
          available: availableGateways > 0,
          totalGateways,
          availableGateways
        }
      };
    } catch (error) {
      console.error("Error getting webhook health:", error);
      return {
        gateways: [],
        overall: {
          available: false,
          totalGateways: 0,
          availableGateways: 0
        }
      };
    }
  },
  async getSupportedEvents() {
    return WebhookHandler.getSupportedEvents();
  },
  async retryFailedWebhook(webhookId) {
    try {
      console.log(`Retrying failed webhook: ${webhookId}`);
      return {
        success: true
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },
  async deleteWebhookLog(webhookId) {
    try {
      console.log(`Deleting webhook log: ${webhookId}`);
      return {
        success: true
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },
  async logWebhook(data) {
    console.log("Webhook logged:", {
      ...data,
      id: `webhook_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      createdAt: /* @__PURE__ */ new Date()
    });
  }
};

// src/features/webhook/webhook.controller.ts
var WebhookController = {
  async processAbacatePay(request, reply) {
    try {
      const { payload } = request.body;
      const signature = request.headers["x-abacate-signature"] || request.headers["x-signature"];
      const result = await WebhookService.processWebhook(
        "abacate-pay",
        payload,
        signature
      );
      if (!result.success) {
        return reply.status(400).send({
          error: result.error
        });
      }
      return reply.status(200).send({
        success: true,
        eventId: result.eventId,
        eventType: result.eventType,
        gateway: "abacate-pay",
        processedAt: /* @__PURE__ */ new Date()
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async processStripe(request, reply) {
    try {
      const payload = request.body;
      const signature = request.headers["stripe-signature"];
      const result = await WebhookService.processWebhook(
        "stripe",
        payload,
        signature
      );
      if (!result.success) {
        return reply.status(400).send({
          error: result.error
        });
      }
      return reply.status(200).send({
        success: true,
        eventId: result.eventId,
        eventType: result.eventType,
        gateway: "stripe",
        processedAt: /* @__PURE__ */ new Date()
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async processGeneric(request, reply) {
    try {
      const { gateway } = request.params;
      const payload = request.body;
      const signature = request.headers["x-signature"] || request.headers["x-hub-signature"];
      const result = await WebhookService.processWebhook(
        gateway,
        payload,
        signature
      );
      if (!result.success) {
        return reply.status(400).send({
          error: result.error
        });
      }
      return reply.status(200).send({
        success: true,
        eventId: result.eventId,
        eventType: result.eventType,
        gateway,
        processedAt: /* @__PURE__ */ new Date()
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getLogs(request, reply) {
    try {
      const { page = 1, limit = 10, gateway, eventType, success, startDate, endDate } = request.query;
      const result = await WebhookService.getWebhookLogs({
        page,
        limit,
        gateway,
        eventType,
        success,
        startDate,
        endDate
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const result = await WebhookService.getWebhookStats();
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getHealth(request, reply) {
    try {
      const result = await WebhookService.getWebhookHealth();
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getSupportedEvents(request, reply) {
    try {
      const result = await WebhookService.getSupportedEvents();
      return reply.send({
        events: result
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async retryFailed(request, reply) {
    try {
      const { id } = request.params;
      const result = await WebhookService.retryFailedWebhook(id);
      if (!result.success) {
        return reply.status(400).send({
          error: result.error
        });
      }
      return reply.send({
        success: true,
        message: "Webhook retry initiated"
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async deleteLog(request, reply) {
    try {
      const { id } = request.params;
      const result = await WebhookService.deleteWebhookLog(id);
      if (!result.success) {
        return reply.status(400).send({
          error: result.error
        });
      }
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/webhook/webhook.routes.ts
async function WebhookRoutes(fastify2) {
  fastify2.post("/abacate-pay", {
    config: {
      // Configurações específicas para webhooks
      rawBody: true
      // Para preservar o body original para verificação de assinatura
    },
    handler: WebhookController.processAbacatePay
  });
  fastify2.post("/stripe", {
    config: {
      rawBody: true
    },
    handler: WebhookController.processStripe
  });
  fastify2.post("/:gateway", {
    config: {
      rawBody: true
    },
    handler: WebhookController.processGeneric
  });
  fastify2.get("/logs", {
    schema: {
      querystring: {
        type: "object",
        properties: {
          page: { type: "number", minimum: 1, default: 1 },
          limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
          gateway: { type: "string" },
          eventType: { type: "string" },
          success: { type: "boolean" },
          startDate: { type: "string", format: "date" },
          endDate: { type: "string", format: "date" }
        }
      },
      response: {
        200: {
          type: "object",
          properties: {
            items: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  gateway: { type: "string" },
                  eventType: { type: "string" },
                  eventId: { type: "string", nullable: true },
                  success: { type: "boolean" },
                  payload: { type: "object" },
                  response: { type: "object", nullable: true },
                  error: { type: "string", nullable: true },
                  processedAt: { type: "string", format: "date-time" },
                  createdAt: { type: "string", format: "date-time" }
                }
              }
            },
            pagination: {
              type: "object",
              properties: {
                page: { type: "number" },
                limit: { type: "number" },
                total: { type: "number" },
                totalPages: { type: "number" }
              }
            }
          }
        }
      }
    },
    preHandler: [(init_auth_middleware(), __toCommonJS(auth_middleware_exports)).authMiddleware],
    handler: WebhookController.getLogs
  });
  fastify2.get("/stats", {
    schema: {
      response: {
        200: {
          type: "object",
          properties: {
            total: { type: "number" },
            successful: { type: "number" },
            failed: { type: "number" },
            byGateway: {
              type: "object",
              additionalProperties: {
                type: "object",
                properties: {
                  total: { type: "number" },
                  successful: { type: "number" },
                  failed: { type: "number" }
                }
              }
            },
            byEventType: {
              type: "object",
              additionalProperties: { type: "number" }
            },
            last24Hours: {
              type: "object",
              properties: {
                total: { type: "number" },
                successful: { type: "number" },
                failed: { type: "number" }
              }
            }
          }
        }
      }
    },
    preHandler: [(init_auth_middleware(), __toCommonJS(auth_middleware_exports)).authMiddleware],
    handler: WebhookController.getStats
  });
  fastify2.get("/health", {
    schema: {
      response: {
        200: {
          type: "object",
          properties: {
            gateways: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  name: { type: "string" },
                  available: { type: "boolean" },
                  lastWebhook: { type: "string", format: "date-time", nullable: true },
                  errorRate: { type: "number", nullable: true }
                }
              }
            },
            overall: {
              type: "object",
              properties: {
                available: { type: "boolean" },
                totalGateways: { type: "number" },
                availableGateways: { type: "number" }
              }
            }
          }
        }
      }
    },
    handler: WebhookController.getHealth
  });
  fastify2.get("/events", {
    schema: {
      response: {
        200: {
          type: "object",
          properties: {
            events: {
              type: "array",
              items: { type: "string" }
            }
          }
        }
      }
    },
    handler: WebhookController.getSupportedEvents
  });
  fastify2.post("/:id/retry", {
    schema: {
      params: {
        type: "object",
        required: ["id"],
        properties: {
          id: { type: "string" }
        }
      },
      response: {
        200: {
          type: "object",
          properties: {
            success: { type: "boolean" },
            message: { type: "string" }
          }
        }
      }
    },
    preHandler: [(init_auth_middleware(), __toCommonJS(auth_middleware_exports)).authMiddleware],
    handler: WebhookController.retryFailed
  });
  fastify2.delete("/:id/log", {
    schema: {
      params: {
        type: "object",
        required: ["id"],
        properties: {
          id: { type: "string" }
        }
      },
      response: {
        204: { type: "null" }
      }
    },
    preHandler: [(init_auth_middleware(), __toCommonJS(auth_middleware_exports)).authMiddleware],
    handler: WebhookController.deleteLog
  });
}

// src/features/crm/commands/crm.commands.ts
init_prisma();
var CrmCommands = {
  async create(data) {
    if (data.stageId) {
      const stage = await db.crmStage.findFirst({
        where: {
          id: data.stageId,
          storeId: data.storeId
        }
      });
      if (!stage) {
        throw new Error("Stage not found or does not belong to the same store");
      }
    }
    return await db.crmClient.create({
      data: {
        storeId: data.storeId,
        name: data.name,
        email: data.email,
        phone: data.phone,
        cpfCnpj: data.cpfCnpj,
        company: data.company,
        notes: data.notes,
        stageId: data.stageId
      },
      include: {
        stage: true
      }
    });
  },
  async update(id, data, storeId) {
    const client = await db.crmClient.findFirst({
      where: {
        id,
        storeId
      }
    });
    if (!client) {
      throw new Error("Client not found or does not belong to the store");
    }
    if (data.stageId) {
      const stage = await db.crmStage.findFirst({
        where: {
          id: data.stageId,
          storeId
        }
      });
      if (!stage) {
        throw new Error("Stage not found or does not belong to the same store");
      }
    }
    return await db.crmClient.update({
      where: { id },
      data,
      include: {
        stage: true
      }
    });
  },
  async delete(id, storeId) {
    const client = await db.crmClient.findFirst({
      where: {
        id,
        storeId
      }
    });
    if (!client) {
      throw new Error("Client not found or does not belong to the store");
    }
    return await db.crmClient.delete({
      where: { id }
    });
  },
  async transitionStage(clientId, stageId, storeId) {
    const client = await db.crmClient.findFirst({
      where: {
        id: clientId,
        storeId
      }
    });
    if (!client) {
      throw new Error("Client not found or does not belong to the store");
    }
    if (stageId) {
      const stage = await db.crmStage.findFirst({
        where: {
          id: stageId,
          storeId
        }
      });
      if (!stage) {
        throw new Error("Stage not found or does not belong to the same store");
      }
    }
    return await db.crmClient.update({
      where: { id: clientId },
      data: { stageId },
      include: {
        stage: true
      }
    });
  }
};

// src/features/crm/queries/crm.queries.ts
init_prisma();
var CrmQueries = {
  async getById(id, storeId) {
    return await db.crmClient.findFirst({
      where: {
        id,
        storeId
      },
      include: {
        stage: true
      }
    });
  },
  async list(params, storeId) {
    const { page = 1, limit = 10, search, stageId } = params;
    const skip2 = (Number(page) - 1) * Number(limit);
    const take = Number(limit);
    console.log("\u{1F50D} DEBUG list: params:", { page, limit, skip: skip2, take, search, stageId });
    const where = {
      storeId
    };
    if (stageId) {
      where.stageId = stageId;
    }
    if (search) {
      where.OR = [
        { name: { contains: search, mode: "insensitive" } },
        { email: { contains: search, mode: "insensitive" } },
        { phone: { contains: search, mode: "insensitive" } },
        { cpfCnpj: { contains: search, mode: "insensitive" } },
        { company: { contains: search, mode: "insensitive" } },
        { notes: { contains: search, mode: "insensitive" } }
      ];
    }
    const [items, total] = await Promise.all([
      db.crmClient.findMany({
        where,
        skip: skip2,
        take,
        orderBy: { createdAt: "desc" },
        include: {
          stage: true
        }
      }),
      db.crmClient.count({ where })
    ]);
    return {
      items,
      pagination: {
        page: Number(page),
        limit: Number(limit),
        total,
        totalPages: Math.ceil(total / Number(limit))
      }
    };
  },
  async listGroupedByStage(storeId) {
    console.log("\u{1F50D} DEBUG listGroupedByStage: Starting with storeId:", storeId);
    try {
      console.log("\u{1F4CA} Searching for stages...");
      const stages = await db.crmStage.findMany({
        where: { storeId },
        orderBy: { order: "asc" },
        include: {
          clients: {
            orderBy: { createdAt: "desc" }
          }
        }
      });
      console.log("\u2705 Found stages:", stages.length);
      console.log("\u{1F4CB} Stages data:", JSON.stringify(stages, null, 2));
      console.log("\u{1F4CA} Searching for clients without stage...");
      const clientsWithoutStage = await db.crmClient.findMany({
        where: {
          storeId,
          stageId: null
        },
        orderBy: { createdAt: "desc" }
      });
      console.log("\u2705 Found clients without stage:", clientsWithoutStage.length);
      const stagesWithClients = [...stages];
      if (clientsWithoutStage.length > 0) {
        console.log("\u{1F4DD} Adding virtual stage for clients without stage");
        stagesWithClients.push({
          id: null,
          name: "Sem Stage",
          color: "#6B7280",
          order: -1,
          createdAt: /* @__PURE__ */ new Date(),
          storeId,
          clients: clientsWithoutStage
        });
      }
      console.log("\u{1F4CA} Counting total clients...");
      const totalClients = await db.crmClient.count({
        where: { storeId }
      });
      console.log("\u2705 Total clients in store:", totalClients);
      const result = {
        stages: stagesWithClients,
        totalClients
      };
      console.log("\u{1F3AF} Final result:", JSON.stringify(result, null, 2));
      return result;
    } catch (error) {
      console.error("\u274C Error in listGroupedByStage:", error);
      throw error;
    }
  },
  async search(term, limit = 10, storeId) {
    return await db.crmClient.findMany({
      where: {
        storeId,
        OR: [
          { name: { contains: term, mode: "insensitive" } },
          { email: { contains: term, mode: "insensitive" } },
          { phone: { contains: term, mode: "insensitive" } },
          { cpfCnpj: { contains: term, mode: "insensitive" } },
          { company: { contains: term, mode: "insensitive" } },
          { notes: { contains: term, mode: "insensitive" } }
        ]
      },
      take: limit,
      orderBy: { createdAt: "desc" },
      include: {
        stage: true
      }
    });
  },
  async getStats(storeId) {
    const [totalClients, clientsByStage] = await Promise.all([
      db.crmClient.count({
        where: { storeId }
      }),
      db.crmStage.findMany({
        where: { storeId },
        include: {
          _count: {
            select: { clients: true }
          }
        },
        orderBy: { order: "asc" }
      })
    ]);
    const clientsWithoutStage = await db.crmClient.count({
      where: {
        storeId,
        stageId: null
      }
    });
    return {
      totalClients,
      clientsByStage: clientsByStage.map((stage) => ({
        stageId: stage.id,
        stageName: stage.name,
        clientsCount: stage._count.clients
      })),
      clientsWithoutStage
    };
  }
};

// src/features/crm/commands/crm.stage.commands.ts
init_prisma();
var CrmStageCommands = {
  async create(data) {
    return await db.crmStage.create({
      data: {
        storeId: data.storeId,
        name: data.name,
        color: data.color,
        order: data.order
      }
    });
  },
  async update(id, data, storeId) {
    const stage = await db.crmStage.findFirst({
      where: {
        id,
        storeId
      }
    });
    if (!stage) {
      throw new Error("Stage not found or does not belong to the store");
    }
    return await db.crmStage.update({
      where: { id },
      data
    });
  },
  async delete(id, storeId) {
    const stage = await db.crmStage.findFirst({
      where: {
        id,
        storeId
      }
    });
    if (!stage) {
      throw new Error("Stage not found or does not belong to the store");
    }
    const clientsCount = await db.crmClient.count({
      where: {
        stageId: id,
        storeId
      }
    });
    if (clientsCount > 0) {
      throw new Error("Cannot delete stage with clients. Move clients to another stage first.");
    }
    return await db.crmStage.delete({
      where: { id }
    });
  },
  async reorder(id, newOrder, storeId) {
    const stage = await db.crmStage.findFirst({
      where: {
        id,
        storeId
      }
    });
    if (!stage) {
      throw new Error("Stage not found or does not belong to the store");
    }
    return await db.crmStage.update({
      where: { id },
      data: { order: newOrder }
    });
  }
};

// src/features/crm/queries/crm.stage.queries.ts
init_prisma();
var CrmStageQueries = {
  async getById(id, storeId) {
    return await db.crmStage.findFirst({
      where: {
        id,
        storeId
      },
      include: {
        _count: {
          select: { clients: true }
        }
      }
    });
  },
  async list(storeId, params = {}) {
    const { page = 1, limit = 10 } = params;
    const skip2 = (page - 1) * limit;
    const [items, total] = await Promise.all([
      db.crmStage.findMany({
        where: { storeId },
        skip: skip2,
        take: limit,
        orderBy: { order: "asc" },
        include: {
          _count: {
            select: { clients: true }
          }
        }
      }),
      db.crmStage.count({
        where: { storeId }
      })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getNextOrder(storeId) {
    const lastStage = await db.crmStage.findFirst({
      where: { storeId },
      orderBy: { order: "desc" }
    });
    return lastStage ? lastStage.order + 1 : 1;
  },
  async getStats(storeId) {
    const [totalStages, stagesWithClients] = await Promise.all([
      db.crmStage.count({
        where: { storeId }
      }),
      db.crmStage.findMany({
        where: { storeId },
        include: {
          _count: {
            select: { clients: true }
          }
        },
        orderBy: { order: "asc" }
      })
    ]);
    const totalClients = stagesWithClients.reduce((sum, stage) => sum + stage._count.clients, 0);
    return {
      totalStages,
      totalClients,
      stagesWithClients: stagesWithClients.map((stage) => ({
        id: stage.id,
        name: stage.name,
        color: stage.color,
        order: stage.order,
        clientsCount: stage._count.clients
      }))
    };
  }
};

// src/features/crm/crm.controller.ts
var CrmController = {
  // === ENDPOINT DE TESTE TEMPORÁRIO ===
  async testGrouped(request, reply) {
    try {
      const storeId = request.store?.id;
      console.log("\u{1F9EA} TEST: storeId:", storeId);
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CrmQueries.listGroupedByStage(storeId);
      return reply.send({
        success: true,
        storeId,
        result
      });
    } catch (error) {
      console.error("\u274C TEST Error:", error);
      return reply.status(500).send({
        error: "Test failed",
        details: error.message
      });
    }
  },
  // === CRUD BÁSICO DE CLIENTES ===
  async createClient(request, reply) {
    try {
      const { name, email, phone, cpfCnpj, company, notes, stageId } = request.body;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CrmCommands.create({
        storeId,
        name,
        email,
        phone,
        cpfCnpj,
        company,
        notes,
        stageId
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Stage not found or does not belong to the same store") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getClient(request, reply) {
    try {
      const { id } = request.params;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CrmQueries.getById(id, storeId);
      if (!result) {
        return reply.status(404).send({
          error: "Client not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async updateClient(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CrmCommands.update(id, updateData, storeId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Client not found or does not belong to the store") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Stage not found or does not belong to the same store") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async deleteClient(request, reply) {
    try {
      const { id } = request.params;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      await CrmCommands.delete(id, storeId);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Client not found or does not belong to the store") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async listClients(request, reply) {
    try {
      const { page = 1, limit = 10, search, stageId, grouped } = request.query;
      const storeId = request.store?.id;
      console.log("\u{1F50D} DEBUG listClients:");
      console.log("- Query params:", { page, limit, search, stageId, grouped });
      console.log("- StoreId:", storeId);
      console.log("- Request user:", request.user);
      console.log("- Request store:", request.store);
      if (!storeId) {
        console.log("\u274C No storeId found");
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      if (grouped) {
        console.log("\u{1F4CA} Calling listGroupedByStage...");
        const result2 = await CrmQueries.listGroupedByStage(storeId);
        console.log("\u2705 listGroupedByStage result:", JSON.stringify(result2, null, 2));
        return reply.send(result2);
      }
      const result = await CrmQueries.list({
        page: Number(page),
        limit: Number(limit),
        search,
        stageId
      }, storeId);
      return reply.send(result);
    } catch (error) {
      console.error("\u274C Error in listClients:", error);
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async searchClients(request, reply) {
    try {
      const { q, limit = 10 } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CrmQueries.search(q, limit, storeId);
      return reply.send({ clients: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async transitionStage(request, reply) {
    try {
      const { id } = request.params;
      const { stageId } = request.body;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CrmCommands.transitionStage(id, stageId, storeId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Client not found or does not belong to the store") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Stage not found or does not belong to the same store") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CrmQueries.getStats(storeId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === CRUD BÁSICO DE STAGES ===
  async createStage(request, reply) {
    try {
      const { name, color, order } = request.body;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const finalOrder = order || await CrmStageQueries.getNextOrder(storeId);
      const result = await CrmStageCommands.create({
        storeId,
        name,
        color,
        order: finalOrder
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStage(request, reply) {
    try {
      const { id } = request.params;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CrmStageQueries.getById(id, storeId);
      if (!result) {
        return reply.status(404).send({
          error: "Stage not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async updateStage(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CrmStageCommands.update(id, updateData, storeId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Stage not found or does not belong to the store") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async deleteStage(request, reply) {
    try {
      const { id } = request.params;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      await CrmStageCommands.delete(id, storeId);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Stage not found or does not belong to the store") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Cannot delete stage with clients. Move clients to another stage first.") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async listStages(request, reply) {
    try {
      const { page = 1, limit = 10 } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CrmStageQueries.list(storeId, { page, limit });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async reorderStage(request, reply) {
    try {
      const { id } = request.params;
      const { order } = request.body;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CrmStageCommands.reorder(id, order, storeId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Stage not found or does not belong to the store") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStageStats(request, reply) {
    try {
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CrmStageQueries.getStats(storeId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/crm/crm.schema.ts
var createCrmClientSchema = {
  body: {
    type: "object",
    required: ["name"],
    properties: {
      name: { type: "string", minLength: 1 },
      email: { type: "string", format: "email" },
      phone: { type: "string" },
      cpfCnpj: { type: "string" },
      company: { type: "string" },
      notes: { type: "string" },
      stageId: { type: "string" }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: "string" },
        stageId: { type: "string" },
        name: { type: "string" },
        email: { type: "string" },
        phone: { type: "string" },
        cpfCnpj: { type: "string" },
        company: { type: "string" },
        notes: { type: "string" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        stage: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            color: { type: "string" },
            order: { type: "number" }
          }
        }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var updateCrmClientSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      name: { type: "string", minLength: 1 },
      email: { type: "string", format: "email" },
      phone: { type: "string" },
      cpfCnpj: { type: "string" },
      company: { type: "string" },
      notes: { type: "string" },
      stageId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: "string" },
        stageId: { type: "string" },
        name: { type: "string" },
        email: { type: "string" },
        phone: { type: "string" },
        cpfCnpj: { type: "string" },
        company: { type: "string" },
        notes: { type: "string" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        stage: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            color: { type: "string" },
            order: { type: "number" }
          }
        }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getCrmClientSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: "string" },
        stageId: { type: "string" },
        name: { type: "string" },
        email: { type: "string" },
        phone: { type: "string" },
        cpfCnpj: { type: "string" },
        company: { type: "string" },
        notes: { type: "string" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        stage: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            color: { type: "string" },
            order: { type: "number" }
          }
        }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var listCrmClientsSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      stageId: { type: "string" },
      grouped: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      oneOf: [
        {
          // Schema para grouped=true
          properties: {
            stages: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  id: { type: ["string", "null"] },
                  name: { type: "string" },
                  color: { type: "string" },
                  order: { type: "number" },
                  clients: {
                    type: "array",
                    items: {
                      type: "object",
                      properties: {
                        id: { type: "string" },
                        name: { type: "string" },
                        email: { type: "string" },
                        phone: { type: "string" },
                        company: { type: "string" },
                        createdAt: { type: "string", format: "date-time" }
                      }
                    }
                  }
                }
              }
            },
            totalClients: { type: "number" }
          }
        },
        {
          // Schema para grouped=false (padrão)
          properties: {
            items: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  storeId: { type: "string" },
                  stageId: { type: "string" },
                  name: { type: "string" },
                  email: { type: "string" },
                  phone: { type: "string" },
                  cpfCnpj: { type: "string" },
                  company: { type: "string" },
                  notes: { type: "string" },
                  createdAt: { type: "string", format: "date-time" },
                  updatedAt: { type: "string", format: "date-time" },
                  stage: {
                    type: "object",
                    properties: {
                      id: { type: "string" },
                      name: { type: "string" },
                      color: { type: "string" },
                      order: { type: "number" }
                    }
                  }
                }
              }
            },
            pagination: {
              type: "object",
              properties: {
                page: { type: "number" },
                limit: { type: "number" },
                total: { type: "number" },
                totalPages: { type: "number" }
              }
            }
          }
        }
      ]
    }
  }
};
var listCrmClientsGroupedSchema = {
  querystring: {
    type: "object",
    properties: {
      grouped: { type: "boolean", default: true }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        stages: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: ["string", "null"] },
              name: { type: "string" },
              color: { type: "string" },
              order: { type: "number" },
              clients: {
                type: "array",
                items: {
                  type: "object",
                  properties: {
                    id: { type: "string" },
                    name: { type: "string" },
                    email: { type: "string" },
                    phone: { type: "string" },
                    company: { type: "string" },
                    createdAt: { type: "string", format: "date-time" }
                  }
                }
              }
            }
          }
        },
        totalClients: { type: "number" }
      }
    }
  }
};
var deleteCrmClientSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var transitionStageSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["stageId"],
    properties: {
      stageId: { type: ["string", "null"] }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: "string" },
        stageId: { type: "string" },
        name: { type: "string" },
        stage: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            color: { type: "string" },
            order: { type: "number" }
          }
        }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var createCrmStageSchema = {
  body: {
    type: "object",
    required: ["name"],
    properties: {
      name: { type: "string", minLength: 1 },
      color: { type: "string" },
      order: { type: "number", minimum: 1 }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: "string" },
        name: { type: "string" },
        color: { type: "string" },
        order: { type: "number" },
        createdAt: { type: "string", format: "date-time" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var updateCrmStageSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      name: { type: "string", minLength: 1 },
      color: { type: "string" },
      order: { type: "number", minimum: 1 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: "string" },
        name: { type: "string" },
        color: { type: "string" },
        order: { type: "number" },
        createdAt: { type: "string", format: "date-time" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getCrmStageSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: "string" },
        name: { type: "string" },
        color: { type: "string" },
        order: { type: "number" },
        createdAt: { type: "string", format: "date-time" },
        _count: {
          type: "object",
          properties: {
            clients: { type: "number" }
          }
        }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var listCrmStagesSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              storeId: { type: "string" },
              name: { type: "string" },
              color: { type: "string" },
              order: { type: "number" },
              createdAt: { type: "string", format: "date-time" },
              _count: {
                type: "object",
                properties: {
                  clients: { type: "number" }
                }
              }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var deleteCrmStageSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var reorderCrmStageSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["order"],
    properties: {
      order: { type: "number", minimum: 1 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: "string" },
        name: { type: "string" },
        color: { type: "string" },
        order: { type: "number" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var CrmSchemas = {
  // Client schemas
  createClient: createCrmClientSchema,
  updateClient: updateCrmClientSchema,
  getClient: getCrmClientSchema,
  deleteClient: deleteCrmClientSchema,
  listClients: listCrmClientsSchema,
  listClientsGrouped: listCrmClientsGroupedSchema,
  transitionStage: transitionStageSchema,
  // Stage schemas
  createStage: createCrmStageSchema,
  updateStage: updateCrmStageSchema,
  getStage: getCrmStageSchema,
  deleteStage: deleteCrmStageSchema,
  listStages: listCrmStagesSchema,
  reorderStage: reorderCrmStageSchema
};

// src/features/crm/crm.routes.ts
async function CrmRoutes(fastify2) {
  fastify2.addHook("preHandler", authMiddleware);
  fastify2.addHook("preHandler", storeContextMiddleware);
  fastify2.get("/test-grouped", {
    handler: CrmController.testGrouped
  });
  fastify2.post("/clients", {
    schema: CrmSchemas.createClient,
    handler: CrmController.createClient
  });
  fastify2.get("/clients", {
    // schema: CrmSchemas.listClients, // Temporariamente desabilitado para debug
    handler: CrmController.listClients
  });
  fastify2.get("/clients/grouped", {
    schema: CrmSchemas.listClientsGrouped,
    handler: CrmController.listClients
  });
  fastify2.get("/clients/:id", {
    schema: CrmSchemas.getClient,
    handler: CrmController.getClient
  });
  fastify2.put("/clients/:id", {
    schema: CrmSchemas.updateClient,
    handler: CrmController.updateClient
  });
  fastify2.delete("/clients/:id", {
    schema: CrmSchemas.deleteClient,
    handler: CrmController.deleteClient
  });
  fastify2.patch("/clients/:id/stage", {
    schema: CrmSchemas.transitionStage,
    handler: CrmController.transitionStage
  });
  fastify2.get("/clients/search", {
    handler: CrmController.searchClients
  });
  fastify2.get("/clients/stats", {
    handler: CrmController.getStats
  });
  fastify2.post("/stages", {
    schema: CrmSchemas.createStage,
    handler: CrmController.createStage
  });
  fastify2.get("/stages", {
    schema: CrmSchemas.listStages,
    handler: CrmController.listStages
  });
  fastify2.get("/stages/:id", {
    schema: CrmSchemas.getStage,
    handler: CrmController.getStage
  });
  fastify2.put("/stages/:id", {
    schema: CrmSchemas.updateStage,
    handler: CrmController.updateStage
  });
  fastify2.delete("/stages/:id", {
    schema: CrmSchemas.deleteStage,
    handler: CrmController.deleteStage
  });
  fastify2.patch("/stages/:id/reorder", {
    schema: CrmSchemas.reorderStage,
    handler: CrmController.reorderStage
  });
  fastify2.get("/stages/stats", {
    handler: CrmController.getStageStats
  });
}

// src/features/user-preferences/commands/user-preferences.commands.ts
init_prisma();
var UserPreferencesCommands = {
  async create(data) {
    try {
      const user = await db.user.findUnique({
        where: { id: data.userId }
      });
      if (!user) {
        throw new Error("User not found");
      }
      const existingPreferences = await db.userPreferences.findUnique({
        where: { userId: data.userId }
      });
      if (existingPreferences) {
        throw new Error("User preferences already exist for this user");
      }
      const preferences = await db.userPreferences.create({
        data: {
          userId: data.userId,
          theme: data.theme || "light",
          primaryColor: data.primaryColor,
          sidebarCollapsed: data.sidebarCollapsed || false,
          compactMode: data.compactMode || false,
          language: data.language || "pt-BR",
          currency: data.currency || "BRL",
          timezone: data.timezone || "America/Sao_Paulo",
          dateFormat: data.dateFormat || "DD/MM/YYYY",
          timeFormat: data.timeFormat || "24h",
          numberFormat: data.numberFormat || "pt-BR",
          emailNotifications: data.emailNotifications !== void 0 ? data.emailNotifications : true,
          pushNotifications: data.pushNotifications !== void 0 ? data.pushNotifications : true,
          smsNotifications: data.smsNotifications || false,
          notificationTypes: data.notificationTypes,
          dashboardLayout: data.dashboardLayout,
          defaultPage: data.defaultPage,
          itemsPerPage: data.itemsPerPage || 20,
          defaultStoreId: data.defaultStoreId,
          autoRefresh: data.autoRefresh !== void 0 ? data.autoRefresh : true,
          refreshInterval: data.refreshInterval || 30,
          customSettings: data.customSettings
        },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      });
      return preferences;
    } catch (error) {
      throw new Error(`Failed to create user preferences: ${error.message}`);
    }
  },
  // ================================
  // UPDATE OPERATIONS
  // ================================
  async update(id, data) {
    try {
      const existingPreferences = await db.userPreferences.findUnique({
        where: { id }
      });
      if (!existingPreferences) {
        throw new Error("User preferences not found");
      }
      const updatedPreferences = await db.userPreferences.update({
        where: { id },
        data: {
          ...data,
          updatedAt: /* @__PURE__ */ new Date()
        },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      });
      return updatedPreferences;
    } catch (error) {
      throw new Error(`Failed to update user preferences: ${error.message}`);
    }
  },
  async updateByUserId(userId, data) {
    try {
      const user = await db.user.findUnique({
        where: { id: userId }
      });
      if (!user) {
        throw new Error("User not found");
      }
      const existingPreferences = await db.userPreferences.findUnique({
        where: { userId }
      });
      if (!existingPreferences) {
        return await UserPreferencesCommands.create({ ...data, userId });
      }
      const updatedPreferences = await db.userPreferences.update({
        where: { userId },
        data: {
          ...data,
          updatedAt: /* @__PURE__ */ new Date()
        },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      });
      return updatedPreferences;
    } catch (error) {
      throw new Error(`Failed to update user preferences: ${error.message}`);
    }
  },
  // ================================
  // DELETE OPERATIONS
  // ================================
  async delete(id) {
    try {
      const existingPreferences = await db.userPreferences.findUnique({
        where: { id }
      });
      if (!existingPreferences) {
        throw new Error("User preferences not found");
      }
      await db.userPreferences.delete({
        where: { id }
      });
      return { success: true, message: "User preferences deleted successfully" };
    } catch (error) {
      throw new Error(`Failed to delete user preferences: ${error.message}`);
    }
  },
  async deleteByUserId(userId) {
    try {
      const user = await db.user.findUnique({
        where: { id: userId }
      });
      if (!user) {
        throw new Error("User not found");
      }
      const existingPreferences = await db.userPreferences.findUnique({
        where: { userId }
      });
      if (!existingPreferences) {
        throw new Error("User preferences not found");
      }
      await db.userPreferences.delete({
        where: { userId }
      });
      return { success: true, message: "User preferences deleted successfully" };
    } catch (error) {
      throw new Error(`Failed to delete user preferences: ${error.message}`);
    }
  },
  // ================================
  // RESET OPERATIONS
  // ================================
  async resetToDefaults(id) {
    try {
      const existingPreferences = await db.userPreferences.findUnique({
        where: { id }
      });
      if (!existingPreferences) {
        throw new Error("User preferences not found");
      }
      const resetPreferences = await db.userPreferences.update({
        where: { id },
        data: {
          theme: "light",
          primaryColor: null,
          sidebarCollapsed: false,
          compactMode: false,
          language: "pt-BR",
          currency: "BRL",
          timezone: "America/Sao_Paulo",
          dateFormat: "DD/MM/YYYY",
          timeFormat: "24h",
          numberFormat: "pt-BR",
          emailNotifications: true,
          pushNotifications: true,
          smsNotifications: false,
          notificationTypes: null,
          dashboardLayout: null,
          defaultPage: null,
          itemsPerPage: 20,
          defaultStoreId: null,
          autoRefresh: true,
          refreshInterval: 30,
          customSettings: null,
          updatedAt: /* @__PURE__ */ new Date()
        },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      });
      return resetPreferences;
    } catch (error) {
      throw new Error(`Failed to reset user preferences: ${error.message}`);
    }
  },
  async resetToDefaultsByUserId(userId) {
    try {
      const user = await db.user.findUnique({
        where: { id: userId }
      });
      if (!user) {
        throw new Error("User not found");
      }
      const existingPreferences = await db.userPreferences.findUnique({
        where: { userId }
      });
      if (!existingPreferences) {
        throw new Error("User preferences not found");
      }
      const resetPreferences = await db.userPreferences.update({
        where: { userId },
        data: {
          theme: "light",
          primaryColor: null,
          sidebarCollapsed: false,
          compactMode: false,
          language: "pt-BR",
          currency: "BRL",
          timezone: "America/Sao_Paulo",
          dateFormat: "DD/MM/YYYY",
          timeFormat: "24h",
          numberFormat: "pt-BR",
          emailNotifications: true,
          pushNotifications: true,
          smsNotifications: false,
          notificationTypes: null,
          dashboardLayout: null,
          defaultPage: null,
          itemsPerPage: 20,
          defaultStoreId: null,
          autoRefresh: true,
          refreshInterval: 30,
          customSettings: null,
          updatedAt: /* @__PURE__ */ new Date()
        },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      });
      return resetPreferences;
    } catch (error) {
      throw new Error(`Failed to reset user preferences: ${error.message}`);
    }
  },
  // ================================
  // BULK OPERATIONS
  // ================================
  async bulkUpdate(filters, data) {
    try {
      const result = await db.userPreferences.updateMany({
        where: filters,
        data: {
          ...data,
          updatedAt: /* @__PURE__ */ new Date()
        }
      });
      return {
        success: true,
        count: result.count,
        message: `${result.count} user preferences updated successfully`
      };
    } catch (error) {
      throw new Error(`Failed to bulk update user preferences: ${error.message}`);
    }
  },
  async bulkDelete(filters) {
    try {
      const result = await db.userPreferences.deleteMany({
        where: filters
      });
      return {
        success: true,
        count: result.count,
        message: `${result.count} user preferences deleted successfully`
      };
    } catch (error) {
      throw new Error(`Failed to bulk delete user preferences: ${error.message}`);
    }
  }
};

// src/features/user-preferences/user-preferences.controller.ts
var UserPreferencesController = {
  // === CRUD BÁSICO ===
  async create(request, reply) {
    try {
      const preferencesData = request.body;
      if ("storeId" in preferencesData) {
        preferencesData.defaultStoreId = preferencesData.storeId;
        delete preferencesData.storeId;
      }
      const result = await UserPreferencesCommands.create(preferencesData);
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "User preferences already exist for this user") {
        return reply.status(409).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      const result = await UserPreferencesQueries.getById(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User preferences not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      if ("storeId" in updateData) {
        updateData.defaultStoreId = updateData.storeId;
        delete updateData.storeId;
      }
      const result = await UserPreferencesCommands.update(id, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User preferences not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      await UserPreferencesCommands.delete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "User preferences not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { page = 1, limit = 10, search, theme, language, currency } = request.query;
      const result = await UserPreferencesQueries.list({
        page,
        limit,
        search,
        theme,
        language,
        currency
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (QUERIES) ===
  async getByUserId(request, reply) {
    try {
      const userId = request.user?.id;
      if (!userId) {
        return reply.status(401).send({
          error: "User not authenticated"
        });
      }
      const result = await UserPreferencesQueries.getByUserId(userId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User preferences not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByUserIdOrCreate(request, reply) {
    try {
      const userId = request.user?.id;
      if (!userId) {
        return reply.status(401).send({
          error: "User not authenticated"
        });
      }
      const result = await UserPreferencesQueries.getByUserIdOrCreate(userId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async updateByUserId(request, reply) {
    try {
      const userId = request.user?.id;
      if (!userId) {
        return reply.status(401).send({
          error: "User not authenticated"
        });
      }
      const updateData = request.body;
      if ("storeId" in updateData) {
        updateData.defaultStoreId = updateData.storeId;
        delete updateData.storeId;
      }
      const result = await UserPreferencesCommands.updateByUserId(userId, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async deleteByUserId(request, reply) {
    try {
      const userId = request.user?.id;
      if (!userId) {
        return reply.status(401).send({
          error: "User not authenticated"
        });
      }
      await UserPreferencesCommands.deleteByUserId(userId);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found" || error.message === "User preferences not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByTheme(request, reply) {
    try {
      const { theme } = request.query;
      const result = await UserPreferencesQueries.getByTheme(theme);
      return reply.send({ preferences: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByLanguage(request, reply) {
    try {
      const { language } = request.query;
      const result = await UserPreferencesQueries.getByLanguage(language);
      return reply.send({ preferences: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByCurrency(request, reply) {
    try {
      const { currency } = request.query;
      const result = await UserPreferencesQueries.getByCurrency(currency);
      return reply.send({ preferences: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getWithCustomSettings(request, reply) {
    try {
      const result = await UserPreferencesQueries.getWithCustomSettings();
      return reply.send({ preferences: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const result = await UserPreferencesQueries.getStats();
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { q, limit = 10 } = request.query;
      const result = await UserPreferencesQueries.search(q, limit);
      return reply.send({ preferences: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (COMMANDS) ===
  async resetToDefaults(request, reply) {
    try {
      const { id } = request.params;
      const result = await UserPreferencesCommands.resetToDefaults(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User preferences not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async resetToDefaultsByUserId(request, reply) {
    try {
      const userId = request.user?.id;
      if (!userId) {
        return reply.status(401).send({
          error: "User not authenticated"
        });
      }
      const result = await UserPreferencesCommands.resetToDefaultsByUserId(userId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found" || error.message === "User preferences not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async validatePreferences(request, reply) {
    try {
      const preferencesData = request.body;
      const result = await UserPreferencesQueries.validatePreferences(preferencesData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/user-preferences/user-preferences.schema.ts
var createUserPreferencesSchema = {
  body: {
    type: "object",
    required: ["userId"],
    properties: {
      userId: {
        type: "string",
        description: "User ID"
      },
      theme: {
        type: "string",
        enum: ["light", "dark", "auto"],
        default: "light",
        description: "Theme preference"
      },
      primaryColor: {
        type: "string",
        pattern: "^#[0-9A-Fa-f]{6}$",
        description: "Primary color in hex format"
      },
      sidebarCollapsed: {
        type: "boolean",
        default: false,
        description: "Whether sidebar is collapsed"
      },
      compactMode: {
        type: "boolean",
        default: false,
        description: "Whether to use compact mode"
      },
      language: {
        type: "string",
        default: "pt-BR",
        description: "Language preference"
      },
      currency: {
        type: "string",
        default: "BRL",
        description: "Currency preference"
      },
      timezone: {
        type: "string",
        default: "America/Sao_Paulo",
        description: "Timezone preference"
      },
      dateFormat: {
        type: "string",
        enum: ["DD/MM/YYYY", "MM/DD/YYYY", "YYYY-MM-DD"],
        default: "DD/MM/YYYY",
        description: "Date format preference"
      },
      timeFormat: {
        type: "string",
        enum: ["12h", "24h"],
        default: "24h",
        description: "Time format preference"
      },
      numberFormat: {
        type: "string",
        default: "pt-BR",
        description: "Number format preference"
      },
      emailNotifications: {
        type: "boolean",
        default: true,
        description: "Email notifications enabled"
      },
      pushNotifications: {
        type: "boolean",
        default: true,
        description: "Push notifications enabled"
      },
      smsNotifications: {
        type: "boolean",
        default: false,
        description: "SMS notifications enabled"
      },
      notificationTypes: {
        type: "object",
        description: "Specific notification types configuration"
      },
      dashboardLayout: {
        type: "object",
        description: "Dashboard layout configuration"
      },
      defaultPage: {
        type: "string",
        description: "Default page to load"
      },
      itemsPerPage: {
        type: "integer",
        minimum: 5,
        maximum: 100,
        default: 20,
        description: "Number of items per page"
      },
      defaultStoreId: {
        type: "string",
        description: "Default store ID"
      },
      autoRefresh: {
        type: "boolean",
        default: true,
        description: "Auto refresh enabled"
      },
      refreshInterval: {
        type: "integer",
        minimum: 10,
        maximum: 300,
        default: 30,
        description: "Refresh interval in seconds"
      },
      customSettings: {
        type: "object",
        description: "Custom settings configuration"
      }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        theme: { type: "string" },
        language: { type: "string" },
        currency: { type: "string" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    409: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var updateUserPreferencesSchema = {
  params: {
    type: "object",
    properties: {
      id: {
        type: "string",
        description: "User preferences ID"
      }
    },
    required: ["id"]
  },
  body: {
    type: "object",
    properties: {
      theme: {
        type: "string",
        enum: ["light", "dark", "auto"],
        description: "Theme preference"
      },
      primaryColor: {
        type: "string",
        pattern: "^#[0-9A-Fa-f]{6}$",
        description: "Primary color in hex format"
      },
      sidebarCollapsed: {
        type: "boolean",
        description: "Whether sidebar is collapsed"
      },
      compactMode: {
        type: "boolean",
        description: "Whether to use compact mode"
      },
      language: {
        type: "string",
        description: "Language preference"
      },
      currency: {
        type: "string",
        description: "Currency preference"
      },
      timezone: {
        type: "string",
        description: "Timezone preference"
      },
      dateFormat: {
        type: "string",
        enum: ["DD/MM/YYYY", "MM/DD/YYYY", "YYYY-MM-DD"],
        description: "Date format preference"
      },
      timeFormat: {
        type: "string",
        enum: ["12h", "24h"],
        description: "Time format preference"
      },
      numberFormat: {
        type: "string",
        description: "Number format preference"
      },
      emailNotifications: {
        type: "boolean",
        description: "Email notifications enabled"
      },
      pushNotifications: {
        type: "boolean",
        description: "Push notifications enabled"
      },
      smsNotifications: {
        type: "boolean",
        description: "SMS notifications enabled"
      },
      notificationTypes: {
        type: "object",
        description: "Specific notification types configuration"
      },
      dashboardLayout: {
        type: "object",
        description: "Dashboard layout configuration"
      },
      defaultPage: {
        type: "string",
        description: "Default page to load"
      },
      itemsPerPage: {
        type: "integer",
        minimum: 5,
        maximum: 100,
        description: "Number of items per page"
      },
      defaultStoreId: {
        type: "string",
        description: "Default store ID"
      },
      autoRefresh: {
        type: "boolean",
        description: "Auto refresh enabled"
      },
      refreshInterval: {
        type: "integer",
        minimum: 10,
        maximum: 300,
        description: "Refresh interval in seconds"
      },
      customSettings: {
        type: "object",
        description: "Custom settings configuration"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        theme: { type: "string" },
        language: { type: "string" },
        currency: { type: "string" },
        updatedAt: { type: "string", format: "date-time" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getUserPreferencesSchema = {
  params: {
    type: "object",
    properties: {
      id: {
        type: "string",
        description: "User preferences ID"
      }
    },
    required: ["id"]
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        theme: { type: "string" },
        primaryColor: { type: "string" },
        sidebarCollapsed: { type: "boolean" },
        compactMode: { type: "boolean" },
        language: { type: "string" },
        currency: { type: "string" },
        timezone: { type: "string" },
        dateFormat: { type: "string" },
        timeFormat: { type: "string" },
        numberFormat: { type: "string" },
        emailNotifications: { type: "boolean" },
        pushNotifications: { type: "boolean" },
        smsNotifications: { type: "boolean" },
        notificationTypes: { type: "object" },
        dashboardLayout: { type: "object" },
        defaultPage: { type: "string" },
        itemsPerPage: { type: "integer" },
        defaultStoreId: { type: "string" },
        autoRefresh: { type: "boolean" },
        refreshInterval: { type: "integer" },
        customSettings: { type: "object" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" }
          }
        }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var updateUserPreferencesMeSchema = {
  body: {
    type: "object",
    properties: {
      theme: {
        type: "string",
        enum: ["light", "dark", "auto"],
        description: "Theme preference"
      },
      primaryColor: {
        type: "string",
        pattern: "^#[0-9A-Fa-f]{6}$",
        description: "Primary color in hex format"
      },
      sidebarCollapsed: {
        type: "boolean",
        description: "Whether sidebar is collapsed"
      },
      compactMode: {
        type: "boolean",
        description: "Whether to use compact mode"
      },
      language: {
        type: "string",
        description: "Language preference"
      },
      currency: {
        type: "string",
        description: "Currency preference"
      },
      timezone: {
        type: "string",
        description: "Timezone preference"
      },
      dateFormat: {
        type: "string",
        description: "Date format preference"
      },
      timeFormat: {
        type: "string",
        enum: ["12h", "24h"],
        description: "Time format preference"
      },
      numberFormat: {
        type: "string",
        description: "Number format preference"
      },
      emailNotifications: {
        type: "boolean",
        description: "Email notifications preference"
      },
      pushNotifications: {
        type: "boolean",
        description: "Push notifications preference"
      },
      smsNotifications: {
        type: "boolean",
        description: "SMS notifications preference"
      },
      notificationTypes: {
        type: "object",
        description: "Notification types configuration"
      },
      dashboardLayout: {
        type: "object",
        description: "Dashboard layout configuration"
      },
      defaultPage: {
        type: "string",
        description: "Default page preference"
      },
      itemsPerPage: {
        type: "number",
        minimum: 1,
        maximum: 100,
        description: "Items per page preference"
      },
      defaultStoreId: {
        type: "string",
        description: "Default store ID"
      },
      autoRefresh: {
        type: "boolean",
        description: "Auto refresh preference"
      },
      refreshInterval: {
        type: "number",
        minimum: 1e3,
        maximum: 3e5,
        description: "Refresh interval in milliseconds"
      },
      customSettings: {
        type: "object",
        description: "Custom settings configuration"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        theme: { type: "string" },
        primaryColor: { type: "string" },
        sidebarCollapsed: { type: "boolean" },
        compactMode: { type: "boolean" },
        language: { type: "string" },
        currency: { type: "string" },
        timezone: { type: "string" },
        dateFormat: { type: "string" },
        timeFormat: { type: "string" },
        numberFormat: { type: "string" },
        emailNotifications: { type: "boolean" },
        pushNotifications: { type: "boolean" },
        smsNotifications: { type: "boolean" },
        notificationTypes: { type: "object" },
        dashboardLayout: { type: "object" },
        defaultPage: { type: "string" },
        itemsPerPage: { type: "number" },
        defaultStoreId: { type: "string" },
        autoRefresh: { type: "boolean" },
        refreshInterval: { type: "number" },
        customSettings: { type: "object" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" }
          }
        }
      }
    },
    401: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getUserPreferencesMeSchema = {
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        theme: { type: "string" },
        primaryColor: { type: "string" },
        sidebarCollapsed: { type: "boolean" },
        compactMode: { type: "boolean" },
        language: { type: "string" },
        currency: { type: "string" },
        timezone: { type: "string" },
        dateFormat: { type: "string" },
        timeFormat: { type: "string" },
        numberFormat: { type: "string" },
        emailNotifications: { type: "boolean" },
        pushNotifications: { type: "boolean" },
        smsNotifications: { type: "boolean" },
        notificationTypes: { type: "object" },
        dashboardLayout: { type: "object" },
        defaultPage: { type: "string" },
        itemsPerPage: { type: "number" },
        defaultStoreId: { type: "string" },
        autoRefresh: { type: "boolean" },
        refreshInterval: { type: "number" },
        customSettings: { type: "object" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" }
          }
        }
      }
    },
    401: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var deleteUserPreferencesSchema = {
  params: {
    type: "object",
    properties: {
      id: {
        type: "string",
        description: "User preferences ID"
      }
    },
    required: ["id"]
  },
  response: {
    204: {
      type: "null"
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var listUserPreferencesSchema = {
  querystring: {
    type: "object",
    properties: {
      page: {
        type: "integer",
        minimum: 1,
        default: 1,
        description: "Page number"
      },
      limit: {
        type: "integer",
        minimum: 1,
        maximum: 100,
        default: 10,
        description: "Items per page"
      },
      search: {
        type: "string",
        description: "Search term"
      },
      theme: {
        type: "string",
        enum: ["light", "dark", "auto"],
        description: "Filter by theme"
      },
      language: {
        type: "string",
        description: "Filter by language"
      },
      currency: {
        type: "string",
        description: "Filter by currency"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        preferences: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              userId: { type: "string" },
              theme: { type: "string" },
              language: { type: "string" },
              currency: { type: "string" },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "integer" },
            limit: { type: "integer" },
            total: { type: "integer" },
            totalPages: { type: "integer" }
          }
        }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getUserPreferencesStatsSchema = {
  response: {
    200: {
      type: "object",
      properties: {
        totalPreferences: { type: "integer" },
        themeDistribution: {
          type: "object",
          properties: {
            light: { type: "integer" },
            dark: { type: "integer" },
            auto: { type: "integer" }
          }
        },
        languageDistribution: {
          type: "object",
          additionalProperties: { type: "integer" }
        },
        currencyDistribution: {
          type: "object",
          additionalProperties: { type: "integer" }
        },
        averageItemsPerPage: { type: "integer" },
        notificationsEnabled: { type: "integer" },
        notificationsDisabled: { type: "integer" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var searchUserPreferencesSchema = {
  querystring: {
    type: "object",
    properties: {
      q: {
        type: "string",
        description: "Search query"
      },
      limit: {
        type: "integer",
        minimum: 1,
        maximum: 50,
        default: 10,
        description: "Maximum number of results"
      }
    },
    required: ["q"]
  },
  response: {
    200: {
      type: "object",
      properties: {
        preferences: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              userId: { type: "string" },
              theme: { type: "string" },
              language: { type: "string" },
              currency: { type: "string" },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" }
            }
          }
        }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var validateUserPreferencesSchema = {
  body: {
    type: "object",
    properties: {
      theme: {
        type: "string",
        enum: ["light", "dark", "auto"]
      },
      dateFormat: {
        type: "string",
        enum: ["DD/MM/YYYY", "MM/DD/YYYY", "YYYY-MM-DD"]
      },
      timeFormat: {
        type: "string",
        enum: ["12h", "24h"]
      },
      itemsPerPage: {
        type: "integer",
        minimum: 5,
        maximum: 100
      },
      refreshInterval: {
        type: "integer",
        minimum: 10,
        maximum: 300
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        isValid: { type: "boolean" },
        errors: {
          type: "array",
          items: { type: "string" }
        },
        warnings: {
          type: "array",
          items: { type: "string" }
        }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};

// src/features/user-preferences/user-preferences.routes.ts
async function UserPreferencesRoutes(fastify2) {
  fastify2.addHook("preHandler", authMiddleware);
  fastify2.addHook("preHandler", storeContextMiddleware);
  fastify2.post("/", {
    schema: createUserPreferencesSchema,
    handler: UserPreferencesController.create
  });
  fastify2.get("/", {
    schema: listUserPreferencesSchema,
    handler: UserPreferencesController.list
  });
  fastify2.get("/:id", {
    schema: getUserPreferencesSchema,
    handler: UserPreferencesController.get
  });
  fastify2.put("/:id", {
    schema: updateUserPreferencesSchema,
    handler: UserPreferencesController.update
  });
  fastify2.delete("/:id", {
    schema: deleteUserPreferencesSchema,
    handler: UserPreferencesController.delete
  });
  fastify2.get("/me", {
    schema: getUserPreferencesMeSchema,
    handler: UserPreferencesController.getByUserId
  });
  fastify2.get("/me/or-create", {
    schema: getUserPreferencesMeSchema,
    handler: UserPreferencesController.getByUserIdOrCreate
  });
  fastify2.put("/me", {
    schema: updateUserPreferencesMeSchema,
    handler: UserPreferencesController.updateByUserId
  });
  fastify2.delete("/me", {
    schema: getUserPreferencesMeSchema,
    handler: UserPreferencesController.deleteByUserId
  });
  fastify2.get("/theme/:theme", {
    handler: UserPreferencesController.getByTheme
  });
  fastify2.get("/language/:language", {
    handler: UserPreferencesController.getByLanguage
  });
  fastify2.get("/currency/:currency", {
    handler: UserPreferencesController.getByCurrency
  });
  fastify2.get("/custom-settings", {
    handler: UserPreferencesController.getWithCustomSettings
  });
  fastify2.get("/stats", {
    schema: getUserPreferencesStatsSchema,
    handler: UserPreferencesController.getStats
  });
  fastify2.get("/search", {
    schema: searchUserPreferencesSchema,
    handler: UserPreferencesController.search
  });
  fastify2.patch("/:id/reset", {
    schema: getUserPreferencesSchema,
    handler: UserPreferencesController.resetToDefaults
  });
  fastify2.patch("/me/reset", {
    schema: getUserPreferencesMeSchema,
    handler: UserPreferencesController.resetToDefaultsByUserId
  });
  fastify2.post("/validate", {
    schema: validateUserPreferencesSchema,
    handler: UserPreferencesController.validatePreferences
  });
}

// src/server.ts
var fastify = (0, import_fastify.default)({
  logger: true,
  requestTimeout: 6e4,
  // 30 segundos para timeout de requisições
  keepAliveTimeout: 5e3,
  // 5 segundos para keep-alive
  bodyLimit: 1048576,
  // 1MB para limite do body
  maxParamLength: 200
  // Limite de caracteres para parâmetros de rota
});
fastify.register(import_cors.default, {
  origin: true,
  // Permite todas as origens em desenvolvimento
  credentials: true,
  // Permite cookies e headers de autenticação
  methods: ["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"],
  allowedHeaders: ["Content-Type", "Authorization", "X-Requested-With"]
});
fastify.register(prismaPlugin);
fastify.register(require("@fastify/static"), {
  root: require("path").join(process.cwd(), "src", "uploads"),
  prefix: "/uploads/",
  decorateReply: false
});
connectPrisma(fastify);
fastify.get("/health", async (request, reply) => {
  try {
    const prisma2 = request.server.prisma;
    await prisma2.$queryRaw`SELECT 1`;
    return reply.send({
      status: "ok",
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      uptime: process.uptime(),
      database: "connected"
    });
  } catch (error) {
    request.log.error(error);
    return reply.status(503).send({
      status: "error",
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      uptime: process.uptime(),
      database: "disconnected",
      error: "Database connection failed"
    });
  }
});
fastify.get("/llm/rag", {
  preHandler: [authMiddleware, storeContextMiddleware]
}, async (request, reply) => {
  try {
    const productId = "cmg4ixgh90005e8vgqdn5k6qz";
    const query = "Qual a \xFAltima movimenta\xE7\xE3o de entrada do produto?";
    const response = await queryRAG(productId, query);
    return reply.send(response);
  } catch (error) {
    console.error("Error in RAG:", error);
    return reply.status(500).send({ error: "RAG processing failed" });
  }
});
fastify.register(AuthRoutes, { prefix: "/auth" });
fastify.register(UserRoutes, { prefix: "/users" });
fastify.register(ProductRoutes, { prefix: "/products" });
fastify.register(SupplierRoutes, { prefix: "/suppliers" });
fastify.register(StoreRoutes, { prefix: "/stores" });
fastify.register(CategoryRoutes, { prefix: "/categories" });
fastify.register(MovementRoutes, { prefix: "/movements" });
fastify.register(PermissionRoutes, { prefix: "/permissions" });
fastify.register(ReportRoutes, { prefix: "/reports" });
fastify.register(NotificationRoutes, { prefix: "/notifications" });
fastify.register(ChatRoutes, { prefix: "/chat" });
fastify.register(RoadmapRoutes, { prefix: "/roadmaps" });
fastify.register(UploadRoutes, { prefix: "/uploads" });
fastify.register(QuoteRoutes, { prefix: "/quotes" });
fastify.register(PlanRoutes, { prefix: "/plans" });
fastify.register(CustomerRoutes, { prefix: "/customers" });
fastify.register(InvoiceRoutes, { prefix: "/invoices" });
fastify.register(WebhookRoutes, { prefix: "/webhooks" });
fastify.register(CrmRoutes, { prefix: "/crm" });
fastify.register(UserPreferencesRoutes, { prefix: "/preferences" });
var PORT = Number(process.env.PORT) || 3e3;
var HOST = "0.0.0.0";
fastify.listen({ port: PORT, host: HOST }).then(() => {
  fastify.log.info(`\u{1F680} Servidor rodando na porta ${PORT}`);
  console.log(`\u2705 Servidor rodando em http://${HOST}:${PORT}`);
}).catch((err) => {
  fastify.log.error(err);
  console.error("\u274C Falha ao iniciar o servidor:", err);
  process.exit(1);
});
/*! Bundled license information:

decimal.js/decimal.mjs:
  (*!
   *  decimal.js v10.5.0
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js
   *  Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>
   *  MIT Licence
   *)
*/
