var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/plugins/prisma.ts
async function prismaPlugin(app) {
  app.decorate("prisma", prisma);
  app.addHook("onClose", async () => {
    await prisma.$disconnect();
  });
}
async function connectPrisma(app) {
  try {
    await prisma.$connect();
    console.log("\u2705 Prisma conectado com sucesso ao banco de dados");
    app.log.info("Prisma conectado com sucesso ao banco de dados");
  } catch (error) {
    app.log.error("Falha ao conectar com o banco de dados:");
    console.log("\u274C Falha ao conectar com o banco de dados:");
    console.error(error);
    process.exit(1);
  }
}
var import_client, prisma, db;
var init_prisma = __esm({
  "src/plugins/prisma.ts"() {
    import_client = require("@prisma/client");
    prisma = new import_client.PrismaClient();
    db = prisma;
  }
});

// src/features/auth/queries/auth.queries.ts
var AuthQueries;
var init_auth_queries = __esm({
  "src/features/auth/queries/auth.queries.ts"() {
    init_prisma();
    AuthQueries = {
      async getById(id) {
        const user = await prisma.user.findUnique({
          where: { id, status: true },
          select: {
            id: true,
            email: true,
            name: true,
            emailVerified: true,
            status: true,
            roles: true,
            lastLoginAt: true,
            createdAt: true,
            updatedAt: true
          }
        });
        return user;
      },
      async getByEmail(email) {
        const user = await prisma.user.findUnique({
          where: { email, status: true },
          select: {
            id: true,
            email: true,
            name: true,
            emailVerified: true,
            status: true,
            roles: true,
            lastLoginAt: true,
            createdAt: true,
            updatedAt: true
          }
        });
        return user;
      },
      async getByResetToken(token) {
        const user = await prisma.user.findFirst({
          where: {
            resetPasswordToken: token,
            resetPasswordExpires: {
              gt: /* @__PURE__ */ new Date()
            },
            status: true
          },
          select: {
            id: true,
            email: true,
            name: true,
            emailVerified: true,
            status: true,
            roles: true,
            lastLoginAt: true,
            createdAt: true,
            updatedAt: true
          }
        });
        return user;
      },
      async getByVerificationToken(token) {
        const user = await prisma.user.findFirst({
          where: {
            emailVerificationToken: token,
            emailVerified: false,
            status: true
          },
          select: {
            id: true,
            email: true,
            name: true,
            emailVerified: true,
            status: true,
            roles: true,
            lastLoginAt: true,
            createdAt: true,
            updatedAt: true
          }
        });
        return user;
      },
      async getActiveUsers() {
        const users = await prisma.user.findMany({
          where: { status: true },
          select: {
            id: true,
            email: true,
            name: true,
            emailVerified: true,
            status: true,
            roles: true,
            lastLoginAt: true,
            createdAt: true,
            updatedAt: true
          },
          orderBy: { createdAt: "desc" }
        });
        return users;
      },
      async getVerifiedUsers() {
        const users = await prisma.user.findMany({
          where: {
            status: true,
            emailVerified: true
          },
          select: {
            id: true,
            email: true,
            name: true,
            emailVerified: true,
            status: true,
            roles: true,
            lastLoginAt: true,
            createdAt: true,
            updatedAt: true
          },
          orderBy: { createdAt: "desc" }
        });
        return users;
      },
      async getUnverifiedUsers() {
        const users = await prisma.user.findMany({
          where: {
            status: true,
            emailVerified: false
          },
          select: {
            id: true,
            email: true,
            name: true,
            emailVerified: true,
            status: true,
            roles: true,
            lastLoginAt: true,
            createdAt: true,
            updatedAt: true
          },
          orderBy: { createdAt: "desc" }
        });
        return users;
      },
      async getUserStats() {
        const [
          totalUsers,
          activeUsers,
          verifiedUsers,
          unverifiedUsers,
          recentLogins
        ] = await Promise.all([
          this.prisma.user.count(),
          this.prisma.user.count({ where: { status: true } }),
          this.prisma.user.count({
            where: {
              status: true,
              emailVerified: true
            }
          }),
          this.prisma.user.count({
            where: {
              status: true,
              emailVerified: false
            }
          }),
          this.prisma.user.count({
            where: {
              status: true,
              lastLoginAt: {
                gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1e3)
                // Last 7 days
              }
            }
          })
        ]);
        return {
          totalUsers,
          activeUsers,
          verifiedUsers,
          unverifiedUsers,
          recentLogins
        };
      },
      async searchUsers(searchTerm, limit = 10) {
        const users = await prisma.user.findMany({
          where: {
            status: true,
            OR: [
              { name: { contains: searchTerm, mode: "insensitive" } },
              { email: { contains: searchTerm, mode: "insensitive" } }
            ]
          },
          select: {
            id: true,
            email: true,
            name: true,
            emailVerified: true,
            status: true,
            roles: true,
            lastLoginAt: true,
            createdAt: true,
            updatedAt: true
          },
          take: limit,
          orderBy: { createdAt: "desc" }
        });
        return users;
      },
      async getUsersWithPendingVerification() {
        const users = await prisma.user.findMany({
          where: {
            status: true,
            emailVerified: false,
            emailVerificationToken: {
              not: null
            }
          },
          select: {
            id: true,
            email: true,
            name: true,
            emailVerified: true,
            emailVerificationToken: true,
            createdAt: true
          },
          orderBy: { createdAt: "desc" }
        });
        return users;
      },
      async getUsersWithPendingReset() {
        const users = await prisma.user.findMany({
          where: {
            status: true,
            resetPasswordToken: {
              not: null
            },
            resetPasswordExpires: {
              gt: /* @__PURE__ */ new Date()
            }
          },
          select: {
            id: true,
            email: true,
            name: true,
            resetPasswordToken: true,
            resetPasswordExpires: true,
            createdAt: true
          },
          orderBy: { createdAt: "desc" }
        });
        return users;
      },
      // Verify if user exists by email
      async userExists(email) {
        const count = await prisma.user.count({
          where: { email }
        });
        return count > 0;
      },
      // Verify if email is already verified
      async isEmailVerified(email) {
        const user = await prisma.user.findUnique({
          where: { email },
          select: { emailVerified: true }
        });
        return user?.emailVerified || false;
      },
      // Get user profile for authenticated user
      async getUserProfile(userId) {
        const user = await prisma.user.findUnique({
          where: { id: userId, status: true },
          select: {
            id: true,
            email: true,
            name: true,
            emailVerified: true,
            status: true,
            roles: true,
            lastLoginAt: true,
            phone: true,
            createdAt: true,
            updatedAt: true
          }
        });
        if (!user) {
          throw new Error("User not found");
        }
        return user;
      },
      // Get store owned by user
      async getStoreByOwner(userId) {
        const store = await prisma.store.findFirst({
          where: {
            ownerId: userId,
            status: true
          },
          select: {
            id: true,
            name: true,
            cnpj: true,
            email: true,
            phone: true,
            status: true,
            cep: true,
            city: true,
            state: true,
            address: true,
            createdAt: true,
            updatedAt: true
          }
        });
        return store;
      },
      // Get user profile permissions
      async getProfilePermissions(userId, filters) {
        const { storeId, active, page = 1, limit = 10 } = filters;
        const user = await prisma.user.findUnique({
          where: { id: userId, status: true },
          select: { id: true, roles: true }
        });
        if (!user) {
          throw new Error("User not found");
        }
        const customPermissionsWhere = { userId };
        if (storeId) customPermissionsWhere.storeId = storeId;
        if (active !== void 0) {
          if (active) {
            customPermissionsWhere.OR = [
              { expiresAt: null },
              { expiresAt: { gt: /* @__PURE__ */ new Date() } }
            ];
          } else {
            customPermissionsWhere.expiresAt = { lte: /* @__PURE__ */ new Date() };
          }
        }
        const [customPermissions, customPermissionsTotal] = await Promise.all([
          prisma.userPermission.findMany({
            where: customPermissionsWhere,
            skip: (page - 1) * limit,
            take: limit,
            orderBy: { createdAt: "desc" },
            include: {
              creator: {
                select: { id: true, name: true, email: true }
              }
            }
          }),
          prisma.userPermission.count({ where: customPermissionsWhere })
        ]);
        const storePermissionsWhere = { userId };
        if (storeId) storePermissionsWhere.storeId = storeId;
        if (active !== void 0) {
          if (active) {
            storePermissionsWhere.OR = [
              { expiresAt: null },
              { expiresAt: { gt: /* @__PURE__ */ new Date() } }
            ];
          } else {
            storePermissionsWhere.expiresAt = { lte: /* @__PURE__ */ new Date() };
          }
        }
        const [storePermissions, storePermissionsTotal] = await Promise.all([
          prisma.storePermission.findMany({
            where: storePermissionsWhere,
            skip: (page - 1) * limit,
            take: limit,
            orderBy: { createdAt: "desc" },
            include: {
              store: {
                select: { id: true, name: true }
              },
              creator: {
                select: { id: true, name: true, email: true }
              }
            }
          }),
          prisma.storePermission.count({ where: storePermissionsWhere })
        ]);
        const effectivePermissions = await this.getUserEffectivePermissions(userId, { storeId });
        return {
          userId: user.id,
          userRoles: user.roles,
          storeId: storeId || null,
          effectivePermissions: effectivePermissions.effectivePermissions,
          customPermissions: customPermissions.map((p) => ({
            ...p,
            conditions: p.conditions ? JSON.parse(p.conditions) : null
          })),
          storePermissions: storePermissions.map((p) => ({
            ...p,
            permissions: JSON.parse(p.permissions),
            conditions: p.conditions ? JSON.parse(p.conditions) : null
          })),
          pagination: {
            page,
            limit,
            total: customPermissionsTotal + storePermissionsTotal,
            pages: Math.ceil((customPermissionsTotal + storePermissionsTotal) / limit)
          }
        };
      },
      // Get user effective permissions (helper method)
      async getUserEffectivePermissions(userId, context) {
        const { storeId } = context;
        const user = await prisma.user.findUnique({
          where: { id: userId },
          select: { id: true, roles: true }
        });
        if (!user) {
          throw new Error("User not found");
        }
        const customPermissions = await prisma.userPermission.findMany({
          where: {
            userId,
            ...storeId ? { storeId } : {}
          }
        });
        let storePermissions = [];
        if (storeId) {
          storePermissions = await prisma.storePermission.findMany({
            where: { userId, storeId }
          });
        }
        const effectivePermissions = [];
        if (user.roles.includes("admin")) {
          effectivePermissions.push("*");
        } else if (user.roles.includes("manager")) {
          effectivePermissions.push("read", "create", "update", "delete");
        } else if (user.roles.includes("user")) {
          effectivePermissions.push("read");
        }
        customPermissions.forEach((perm) => {
          if (perm.grant && (!perm.expiresAt || perm.expiresAt > /* @__PURE__ */ new Date())) {
            if (!effectivePermissions.includes(perm.action)) {
              effectivePermissions.push(perm.action);
            }
          }
        });
        storePermissions.forEach((perm) => {
          if (!perm.expiresAt || perm.expiresAt > /* @__PURE__ */ new Date()) {
            const permissions = JSON.parse(perm.permissions);
            permissions.forEach((action) => {
              if (!effectivePermissions.includes(action)) {
                effectivePermissions.push(action);
              }
            });
          }
        });
        return {
          userId,
          userRoles: user.roles,
          storeId,
          effectivePermissions,
          customPermissions: customPermissions.map((p) => ({
            ...p,
            conditions: p.conditions ? JSON.parse(p.conditions) : null
          })),
          storePermissions: storePermissions.map((p) => ({
            ...p,
            permissions: JSON.parse(p.permissions),
            conditions: p.conditions ? JSON.parse(p.conditions) : null
          }))
        };
      }
    };
  }
});

// src/services/email/templates/welcome.ts
var generateWelcomeEmailHTML, generateWelcomeEmailText;
var init_welcome = __esm({
  "src/services/email/templates/welcome.ts"() {
    generateWelcomeEmailHTML = (data) => {
      return `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Bem-vindo ao 25Stock</title>
      <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0; }
        .content { background: #f9f9f9; padding: 30px; border-radius: 0 0 10px 10px; }
        .button { display: inline-block; background: #667eea; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; margin: 20px 0; }
        .footer { text-align: center; margin-top: 30px; color: #666; font-size: 14px; }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="header">
          <h1>\u{1F389} Bem-vindo ao 25Stock!</h1>
          <p>Sua conta foi criada com sucesso</p>
        </div>
        <div class="content">
          <h2>Ol\xE1, ${data.name}!</h2>
          <p>\xC9 um prazer t\xEA-lo conosco no 25Stock, a plataforma completa para gest\xE3o de estoque.</p>
          <p>Com sua conta, voc\xEA poder\xE1:</p>
          <ul>
            <li>Gerenciar produtos e categorias</li>
            <li>Controlar movimenta\xE7\xF5es de estoque</li>
            <li>Gerar relat\xF3rios detalhados</li>
            <li>Colaborar com sua equipe</li>
            <li>E muito mais!</li>
          </ul>
          <p>Clique no bot\xE3o abaixo para acessar sua conta:</p>
          <a href="${data.loginUrl}" class="button">Acessar Minha Conta</a>
          <p>Se voc\xEA n\xE3o criou esta conta, pode ignorar este email.</p>
        </div>
        <div class="footer">
          <p>Este \xE9 um email autom\xE1tico, n\xE3o responda a esta mensagem.</p>
          <p>&copy; 2024 25Stock. Todos os direitos reservados.</p>
        </div>
      </div>
    </body>
    </html>
  `;
    };
    generateWelcomeEmailText = (data) => {
      return `
Bem-vindo ao 25Stock!

Ol\xE1, ${data.name}!

\xC9 um prazer t\xEA-lo conosco no 25Stock, a plataforma completa para gest\xE3o de estoque.

Com sua conta, voc\xEA poder\xE1:
- Gerenciar produtos e categorias
- Controlar movimenta\xE7\xF5es de estoque
- Gerar relat\xF3rios detalhados
- Colaborar com sua equipe
- E muito mais!

Acesse sua conta em: ${data.loginUrl}

Se voc\xEA n\xE3o criou esta conta, pode ignorar este email.

---
Este \xE9 um email autom\xE1tico, n\xE3o responda a esta mensagem.
\xA9 2024 25Stock. Todos os direitos reservados.
  `;
    };
  }
});

// src/services/email/templates/reset_password.ts
var generatePasswordResetEmailHTML, generatePasswordResetEmailText;
var init_reset_password = __esm({
  "src/services/email/templates/reset_password.ts"() {
    generatePasswordResetEmailHTML = (data) => {
      return `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Redefini\xE7\xE3o de Senha - 25Stock</title>
      <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0; }
        .content { background: #f9f9f9; padding: 30px; border-radius: 0 0 10px 10px; }
        .code-box { background: #fff; border: 2px solid #e74c3c; padding: 20px; text-align: center; border-radius: 10px; margin: 20px 0; }
        .reset-code { font-size: 32px; font-weight: bold; color: #e74c3c; letter-spacing: 5px; margin: 10px 0; }
        .warning { background: #fff3cd; border: 1px solid #ffeaa7; padding: 15px; border-radius: 5px; margin: 20px 0; }
        .footer { text-align: center; margin-top: 30px; color: #666; font-size: 14px; }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="header">
          <h1>\u{1F510} Redefini\xE7\xE3o de Senha</h1>
          <p>25Stock - Sistema de Gest\xE3o de Estoque</p>
        </div>
        <div class="content">
          <h2>Ol\xE1, ${data.name}!</h2>
          <p>Recebemos uma solicita\xE7\xE3o para redefinir a senha da sua conta no 25Stock.</p>
          <p>Use o c\xF3digo abaixo para redefinir sua senha:</p>
          <div class="code-box">
            <p style="margin: 0 0 10px 0; color: #666;">Seu c\xF3digo de redefini\xE7\xE3o:</p>
            <div class="reset-code">${data.resetCode}</div>
          </div>
          <div class="warning">
            <strong>\u26A0\uFE0F Importante:</strong>
            <ul>
              <li>Este c\xF3digo expira em ${data.expiresIn}</li>
              <li>Se voc\xEA n\xE3o solicitou esta redefini\xE7\xE3o, ignore este email</li>
              <li>Sua senha atual continuar\xE1 funcionando at\xE9 ser alterada</li>
              <li>N\xE3o compartilhe este c\xF3digo com ningu\xE9m</li>
            </ul>
          </div>
          <p>Digite este c\xF3digo na tela de redefini\xE7\xE3o de senha do aplicativo.</p>
        </div>
        <div class="footer">
          <p>Este \xE9 um email autom\xE1tico, n\xE3o responda a esta mensagem.</p>
          <p>&copy; 2024 25Stock. Todos os direitos reservados.</p>
        </div>
      </div>
    </body>
    </html>
  `;
    };
    generatePasswordResetEmailText = (data) => {
      return `
Redefini\xE7\xE3o de Senha - 25Stock

Ol\xE1, ${data.name}!

Recebemos uma solicita\xE7\xE3o para redefinir a senha da sua conta no 25Stock.

Use o c\xF3digo abaixo para redefinir sua senha:

SEU C\xD3DIGO DE REDEFINI\xC7\xC3O: ${data.resetCode}

IMPORTANTE:
- Este c\xF3digo expira em ${data.expiresIn}
- Se voc\xEA n\xE3o solicitou esta redefini\xE7\xE3o, ignore este email
- Sua senha atual continuar\xE1 funcionando at\xE9 ser alterada
- N\xE3o compartilhe este c\xF3digo com ningu\xE9m

Digite este c\xF3digo na tela de redefini\xE7\xE3o de senha do aplicativo.

---
Este \xE9 um email autom\xE1tico, n\xE3o responda a esta mensagem.
\xA9 2024 25Stock. Todos os direitos reservados.
  `;
    };
  }
});

// src/services/email/templates/stock_low.ts
var generateStockLowEmailHTML, generateStockLowEmailText;
var init_stock_low = __esm({
  "src/services/email/templates/stock_low.ts"() {
    generateStockLowEmailHTML = (data) => {
      return `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>${data.title} - 25Stock</title>
      <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0; }
        .content { background: #f9f9f9; padding: 30px; border-radius: 0 0 10px 10px; }
        .button { display: inline-block; background: #f39c12; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; margin: 20px 0; }
        .warning { background: #fff3cd; border: 1px solid #ffeaa7; padding: 15px; border-radius: 5px; margin: 20px 0; }
        .footer { text-align: center; margin-top: 30px; color: #666; font-size: 14px; }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="header">
          <h1>\u26A0\uFE0F ${data.title}</h1>
          <p>25Stock - Sistema de Gest\xE3o de Estoque</p>
        </div>
        <div class="content">
          <h2>Ol\xE1, ${data.name}!</h2>
          <div class="warning">
            <strong>\u{1F6A8} Aten\xE7\xE3o:</strong>
            <p>${data.message}</p>
          </div>
          <p>\xC9 recomendado que voc\xEA fa\xE7a um novo pedido para este produto o quanto antes para evitar a falta de estoque.</p>
          ${data.actionUrl ? `<a href="${data.actionUrl}" class="button">${data.actionText || "Ver Produto"}</a>` : ""}
        </div>
        <div class="footer">
          <p>Este \xE9 um email autom\xE1tico, n\xE3o responda a esta mensagem.</p>
          <p>&copy; 2024 25Stock. Todos os direitos reservados.</p>
        </div>
      </div>
    </body>
    </html>
  `;
    };
    generateStockLowEmailText = (data) => {
      return `
${data.title} - 25Stock

Ol\xE1, ${data.name}!

\u{1F6A8} ATEN\xC7\xC3O: ${data.message}

\xC9 recomendado que voc\xEA fa\xE7a um novo pedido para este produto o quanto antes para evitar a falta de estoque.

${data.actionUrl ? `Acesse: ${data.actionUrl}` : ""}

---
Este \xE9 um email autom\xE1tico, n\xE3o responda a esta mensagem.
\xA9 2024 25Stock. Todos os direitos reservados.
  `;
    };
  }
});

// src/services/email/templates/notification.ts
var generateNotificationEmailHTML, generateNotificationEmailText;
var init_notification = __esm({
  "src/services/email/templates/notification.ts"() {
    generateNotificationEmailHTML = (data) => {
      return `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>${data.title} - 25Stock</title>
      <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0; }
        .content { background: #f9f9f9; padding: 30px; border-radius: 0 0 10px 10px; }
        .button { display: inline-block; background: #3498db; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; margin: 20px 0; }
        .footer { text-align: center; margin-top: 30px; color: #666; font-size: 14px; }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="header">
          <h1>\u{1F4E2} ${data.title}</h1>
          <p>25Stock - Sistema de Gest\xE3o de Estoque</p>
        </div>
        <div class="content">
          <h2>Ol\xE1, ${data.name}!</h2>
          <p>${data.message}</p>
          ${data.actionUrl ? `<a href="${data.actionUrl}" class="button">${data.actionText || "Ver Detalhes"}</a>` : ""}
        </div>
        <div class="footer">
          <p>Este \xE9 um email autom\xE1tico, n\xE3o responda a esta mensagem.</p>
          <p>&copy; 2024 25Stock. Todos os direitos reservados.</p>
        </div>
      </div>
    </body>
    </html>
  `;
    };
    generateNotificationEmailText = (data) => {
      return `
${data.title} - 25Stock

Ol\xE1, ${data.name}!

${data.message}

${data.actionUrl ? `Acesse: ${data.actionUrl}` : ""}

---
Este \xE9 um email autom\xE1tico, n\xE3o responda a esta mensagem.
\xA9 2024 25Stock. Todos os direitos reservados.
  `;
    };
  }
});

// src/services/email/templates/store_invite.ts
var generateStoreInviteEmailHTML, generateStoreInviteEmailText;
var init_store_invite = __esm({
  "src/services/email/templates/store_invite.ts"() {
    generateStoreInviteEmailHTML = (data) => {
      return `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Convite para Loja - 25Stock</title>
      <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0; }
        .content { background: #f9f9f9; padding: 30px; border-radius: 0 0 10px 10px; }
        .button { display: inline-block; background: #27ae60; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; margin: 20px 0; }
        .info { background: #e8f5e8; border: 1px solid #27ae60; padding: 15px; border-radius: 5px; margin: 20px 0; }
        .footer { text-align: center; margin-top: 30px; color: #666; font-size: 14px; }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="header">
          <h1>\u{1F3EA} Convite para Loja</h1>
          <p>25Stock - Sistema de Gest\xE3o de Estoque</p>
        </div>
        <div class="content">
          <h2>Ol\xE1, ${data.name}!</h2>
          <p><strong>${data.inviterName}</strong> convidou voc\xEA para colaborar na loja <strong>"${data.storeName}"</strong> no 25Stock.</p>
          <div class="info">
            <strong>\u{1F4CB} Detalhes do Convite:</strong>
            <ul>
              <li><strong>Loja:</strong> ${data.storeName}</li>
              <li><strong>Convidado por:</strong> ${data.inviterName}</li>
              <li><strong>Expira em:</strong> ${data.expiresIn}</li>
            </ul>
          </div>
          <p>Clique no bot\xE3o abaixo para aceitar o convite:</p>
          <a href="${data.acceptUrl}" class="button">Aceitar Convite</a>
          <p>Se voc\xEA n\xE3o conhece esta pessoa ou n\xE3o deseja participar desta loja, pode ignorar este email.</p>
        </div>
        <div class="footer">
          <p>Este \xE9 um email autom\xE1tico, n\xE3o responda a esta mensagem.</p>
          <p>&copy; 2024 25Stock. Todos os direitos reservados.</p>
        </div>
      </div>
    </body>
    </html>
  `;
    };
    generateStoreInviteEmailText = (data) => {
      return `
Convite para Loja - 25Stock

Ol\xE1, ${data.name}!

${data.inviterName} convidou voc\xEA para colaborar na loja "${data.storeName}" no 25Stock.

Detalhes do Convite:
- Loja: ${data.storeName}
- Convidado por: ${data.inviterName}
- Expira em: ${data.expiresIn}

Aceite o convite em: ${data.acceptUrl}

Se voc\xEA n\xE3o conhece esta pessoa ou n\xE3o deseja participar desta loja, pode ignorar este email.

---
Este \xE9 um email autom\xE1tico, n\xE3o responda a esta mensagem.
\xA9 2024 25Stock. Todos os direitos reservados.
  `;
    };
  }
});

// src/services/email/templates/email_verification.ts
var generateEmailVerificationHTML, generateEmailVerificationText;
var init_email_verification = __esm({
  "src/services/email/templates/email_verification.ts"() {
    generateEmailVerificationHTML = (data) => {
      return `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Confirma\xE7\xE3o de Email - 25Stock</title>
      <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0; }
        .content { background: #f9f9f9; padding: 30px; border-radius: 0 0 10px 10px; }
        .code-container { background: #fff; border: 2px solid #667eea; padding: 20px; border-radius: 10px; text-align: center; margin: 20px 0; }
        .verification-code { font-size: 32px; font-weight: bold; color: #667eea; letter-spacing: 8px; margin: 10px 0; }
        .button { display: inline-block; background: #667eea; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; margin: 20px 0; }
        .warning { background: #fff3cd; border: 1px solid #ffeaa7; padding: 15px; border-radius: 5px; margin: 20px 0; }
        .footer { text-align: center; margin-top: 30px; color: #666; font-size: 14px; }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="header">
          <h1>\u{1F510} Confirma\xE7\xE3o de Email</h1>
          <p>25Stock - Sistema de Gest\xE3o de Estoque</p>
        </div>
        <div class="content">
          <h2>Ol\xE1, ${data.name}!</h2>
          <p>Bem-vindo ao 25Stock! Para confirmar sua conta, use o c\xF3digo de verifica\xE7\xE3o abaixo:</p>
          
          <div class="code-container">
            <p style="margin: 0 0 10px 0; font-size: 18px; color: #666;">Seu c\xF3digo de verifica\xE7\xE3o \xE9:</p>
            <div class="verification-code">${data.verificationCode}</div>
            <p style="margin: 10px 0 0 0; font-size: 14px; color: #666;">Este c\xF3digo expira em ${data.expiresIn}</p>
          </div>

          <p>Digite este c\xF3digo no aplicativo para confirmar seu email e ativar sua conta.</p>
          
          <div class="warning">
            <strong>\u26A0\uFE0F Importante:</strong>
            <ul>
              <li>Este c\xF3digo \xE9 v\xE1lido por ${data.expiresIn}</li>
              <li>N\xE3o compartilhe este c\xF3digo com ningu\xE9m</li>
              <li>Se voc\xEA n\xE3o solicitou esta conta, ignore este email</li>
            </ul>
          </div>

          <p>Se voc\xEA n\xE3o conseguir usar o c\xF3digo, pode solicitar um novo c\xF3digo de verifica\xE7\xE3o no aplicativo.</p>
        </div>
        <div class="footer">
          <p>Este \xE9 um email autom\xE1tico, n\xE3o responda a esta mensagem.</p>
          <p>&copy; 2024 25Stock. Todos os direitos reservados.</p>
        </div>
      </div>
    </body>
    </html>
  `;
    };
    generateEmailVerificationText = (data) => {
      return `
Confirma\xE7\xE3o de Email - 25Stock

Ol\xE1, ${data.name}!

Bem-vindo ao 25Stock! Para confirmar sua conta, use o c\xF3digo de verifica\xE7\xE3o abaixo:

C\xD3DIGO DE VERIFICA\xC7\xC3O: ${data.verificationCode}

Este c\xF3digo expira em ${data.expiresIn}

Digite este c\xF3digo no aplicativo para confirmar seu email e ativar sua conta.

IMPORTANTE:
- Este c\xF3digo \xE9 v\xE1lido por ${data.expiresIn}
- N\xE3o compartilhe este c\xF3digo com ningu\xE9m
- Se voc\xEA n\xE3o solicitou esta conta, ignore este email

Se voc\xEA n\xE3o conseguir usar o c\xF3digo, pode solicitar um novo c\xF3digo de verifica\xE7\xE3o no aplicativo.

---
Este \xE9 um email autom\xE1tico, n\xE3o responda a esta mensagem.
\xA9 2024 25Stock. Todos os direitos reservados.
  `;
    };
  }
});

// src/services/email/templates/index.ts
var init_templates = __esm({
  "src/services/email/templates/index.ts"() {
    init_welcome();
    init_reset_password();
    init_stock_low();
    init_notification();
    init_store_invite();
    init_email_verification();
  }
});

// src/services/email/email.service.ts
var import_resend, resend, EmailService;
var init_email_service = __esm({
  "src/services/email/email.service.ts"() {
    import_resend = require("resend");
    init_templates();
    resend = new import_resend.Resend(process.env.RESEND_API_KEY);
    EmailService = {
      /**
       * Envia email de boas-vindas para novos usuários
       */
      sendWelcomeEmail: async (data) => {
        try {
          const html = generateWelcomeEmailHTML(data);
          const text = generateWelcomeEmailText(data);
          const result = await resend.emails.send({
            from: process.env.FROM_EMAIL || "noreply@25stock.com",
            to: data.email,
            subject: `Bem-vindo ao 25Stock, ${data.name}!`,
            html,
            text
          });
          console.log("Welcome email sent:", result.data?.id);
          return true;
        } catch (error) {
          console.error("Error sending welcome email:", error);
          return false;
        }
      },
      /**
       * Envia email de redefinição de senha
       */
      sendPasswordResetEmail: async (data) => {
        try {
          const html = generatePasswordResetEmailHTML(data);
          const text = generatePasswordResetEmailText(data);
          const result = await resend.emails.send({
            from: process.env.FROM_EMAIL || "noreply@25stock.com",
            to: data.email,
            subject: "Redefini\xE7\xE3o de senha - 25Stock",
            html,
            text
          });
          console.log("Password reset email sent:", result.data?.id);
          return true;
        } catch (error) {
          console.error("Error sending password reset email:", error);
          return false;
        }
      },
      /**
       * Envia email de notificação
       */
      sendNotificationEmail: async (data) => {
        try {
          const html = generateNotificationEmailHTML(data);
          const text = generateNotificationEmailText(data);
          const result = await resend.emails.send({
            from: process.env.FROM_EMAIL || "noreply@25stock.com",
            to: data.email,
            subject: `Notifica\xE7\xE3o - ${data.title}`,
            html,
            text
          });
          console.log("Notification email sent:", result.data?.id);
          return true;
        } catch (error) {
          console.error("Error sending notification email:", error);
          return false;
        }
      },
      /**
       * Envia convite para loja
       */
      sendStoreInviteEmail: async (data) => {
        try {
          const html = generateStoreInviteEmailHTML(data);
          const text = generateStoreInviteEmailText(data);
          const result = await resend.emails.send({
            from: process.env.FROM_EMAIL || "noreply@25stock.com",
            to: data.email,
            subject: `Convite para loja ${data.storeName} - 25Stock`,
            html,
            text
          });
          console.log("Store invite email sent:", result.data?.id);
          return true;
        } catch (error) {
          console.error("Error sending store invite email:", error);
          return false;
        }
      },
      /**
       * Envia email de notificação de estoque baixo
       */
      sendStockLowEmail: async (data) => {
        try {
          const html = generateStockLowEmailHTML(data);
          const text = generateStockLowEmailText(data);
          const result = await resend.emails.send({
            from: process.env.FROM_EMAIL || "noreply@25stock.com",
            to: data.email,
            subject: `\u26A0\uFE0F ${data.title} - 25Stock`,
            html,
            text
          });
          console.log("Stock low email sent:", result.data?.id);
          return true;
        } catch (error) {
          console.error("Error sending stock low email:", error);
          return false;
        }
      },
      /**
       * Envia email de verificação com código de 6 dígitos
       */
      sendEmailVerification: async (data) => {
        try {
          const html = generateEmailVerificationHTML(data);
          const text = generateEmailVerificationText(data);
          const result = await resend.emails.send({
            from: process.env.FROM_EMAIL || "noreply@25stock.com",
            to: data.email,
            subject: `Confirma\xE7\xE3o de Email - 25Stock`,
            html,
            text
          });
          console.log("Email verification sent:", result.data?.id);
          return true;
        } catch (error) {
          console.error("Error sending email verification:", error);
          return false;
        }
      },
      /**
       * Envia email genérico
       */
      sendEmail: async (template) => {
        try {
          const result = await resend.emails.send({
            from: process.env.FROM_EMAIL || "noreply@25stock.com",
            to: template.to,
            subject: template.subject,
            html: template.html,
            text: template.text
          });
          console.log("Email sent:", result.data?.id);
          return true;
        } catch (error) {
          console.error("Error sending email:", error);
          return false;
        }
      }
    };
  }
});

// src/features/auth/commands/auth.commands.ts
var import_bcryptjs2, import_jsonwebtoken, import_crypto, import_google_auth_library, AuthCommands;
var init_auth_commands = __esm({
  "src/features/auth/commands/auth.commands.ts"() {
    import_bcryptjs2 = __toESM(require("bcryptjs"));
    import_jsonwebtoken = __toESM(require("jsonwebtoken"));
    import_crypto = __toESM(require("crypto"));
    init_prisma();
    init_auth_queries();
    init_email_service();
    import_google_auth_library = require("google-auth-library");
    AuthCommands = {
      async register(data) {
        const { name, email, password, phone } = data;
        const existingUser = await db.user.findUnique({
          where: { email }
        });
        if (existingUser) {
          throw new Error("User already exists with this email");
        }
        const hashedPassword = await import_bcryptjs2.default.hash(password, 12);
        const emailVerificationCode = AuthCommands.generateVerificationCode();
        const emailVerificationCodeExpires = new Date(Date.now() + 15 * 60 * 1e3);
        const emailVerificationToken = AuthCommands.generateVerificationToken();
        const user = await db.user.create({
          data: {
            name,
            email,
            phone,
            password: hashedPassword,
            emailVerificationToken,
            emailVerificationCode,
            emailVerificationCodeExpires,
            emailVerified: false
          },
          select: {
            id: true,
            name: true,
            email: true,
            phone: true,
            emailVerified: true,
            createdAt: true
          }
        });
        try {
          await EmailService.sendEmailVerification({
            name,
            email,
            verificationCode: emailVerificationCode,
            expiresIn: "15 minutos"
          });
        } catch (error) {
          console.error("Failed to send verification email:", error);
        }
        return user;
      },
      async login(data) {
        const { email, password } = data;
        const user = await db.user.findUnique({
          where: { email, status: true }
        });
        if (!user) {
          throw new Error("Invalid credentials");
        }
        const isValidPassword = await import_bcryptjs2.default.compare(password, user.password);
        if (!isValidPassword) {
          throw new Error("Invalid credentials");
        }
        if (!user.emailVerified) {
          throw new Error("Email verification required");
        }
        await db.user.update({
          where: { id: user.id },
          data: { lastLoginAt: /* @__PURE__ */ new Date() }
        });
        const store = await AuthQueries.getStoreByOwner(user.id);
        const token = AuthCommands.generateJWT({
          userId: user.id,
          email: user.email,
          roles: user.roles
        });
        return {
          user: {
            id: user.id,
            name: user.name,
            email: user.email,
            emailVerified: user.emailVerified,
            lastLoginAt: /* @__PURE__ */ new Date()
          },
          store: store || void 0,
          token
        };
      },
      async forgotPassword(email) {
        const user = await db.user.findUnique({
          where: { email, status: true }
        });
        if (!user) {
          throw new Error("User not found");
        }
        const resetCode = AuthCommands.generateVerificationCode();
        const resetExpires = new Date(Date.now() + 15 * 60 * 1e3);
        await db.user.update({
          where: { id: user.id },
          data: {
            resetPasswordCode: resetCode,
            resetPasswordExpires: resetExpires
          }
        });
        try {
          await EmailService.sendPasswordResetEmail({
            name: user.name,
            email: user.email,
            resetCode,
            expiresIn: "15 minutos"
          });
        } catch (error) {
          console.error("Failed to send reset password email:", error);
        }
        return { message: "Reset password code sent to email" };
      },
      async verifyResetCode(email, code) {
        const user = await db.user.findFirst({
          where: {
            email,
            resetPasswordCode: code,
            resetPasswordExpires: {
              gt: /* @__PURE__ */ new Date()
            }
          }
        });
        if (!user) {
          throw new Error("Invalid or expired reset code");
        }
        if (user.resetPasswordExpires && user.resetPasswordExpires < /* @__PURE__ */ new Date()) {
          throw new Error("Reset code expired");
        }
        return { message: "Reset code verified successfully" };
      },
      async resetPassword(email, code, newPassword) {
        const user = await db.user.findFirst({
          where: {
            email,
            resetPasswordCode: code,
            resetPasswordExpires: {
              gt: /* @__PURE__ */ new Date()
            }
          }
        });
        if (!user) {
          throw new Error("Invalid or expired reset code");
        }
        if (user.resetPasswordExpires && user.resetPasswordExpires < /* @__PURE__ */ new Date()) {
          throw new Error("Reset code expired");
        }
        const hashedPassword = await import_bcryptjs2.default.hash(newPassword, 12);
        await db.user.update({
          where: { id: user.id },
          data: {
            password: hashedPassword,
            resetPasswordCode: null,
            resetPasswordExpires: null
          }
        });
        return { message: "Password reset successfully" };
      },
      async verifyEmail(token) {
        const user = await db.user.findFirst({
          where: {
            emailVerificationToken: token,
            emailVerified: false
          }
        });
        if (!user) {
          throw new Error("Invalid verification token");
        }
        await db.user.update({
          where: { id: user.id },
          data: {
            emailVerified: true,
            emailVerificationToken: null
          }
        });
        return { message: "Email verified successfully" };
      },
      async verifyEmailCode(email, code) {
        const user = await db.user.findFirst({
          where: {
            email,
            emailVerificationCode: code,
            emailVerificationCodeExpires: {
              gt: /* @__PURE__ */ new Date()
            },
            emailVerified: false
          }
        });
        if (!user) {
          throw new Error("Invalid verification code");
        }
        if (user.emailVerificationCodeExpires && user.emailVerificationCodeExpires < /* @__PURE__ */ new Date()) {
          throw new Error("Verification code expired");
        }
        const updatedUser = await db.user.update({
          where: { id: user.id },
          data: {
            emailVerified: true,
            emailVerificationToken: null,
            emailVerificationCode: null,
            emailVerificationCodeExpires: null
          },
          select: {
            id: true,
            name: true,
            email: true,
            emailVerified: true,
            createdAt: true
          }
        });
        return updatedUser;
      },
      async resendVerification(email) {
        const user = await db.user.findUnique({
          where: { email, status: true }
        });
        if (!user) {
          throw new Error("User not found");
        }
        if (user.emailVerified) {
          throw new Error("Email already verified");
        }
        const emailVerificationCode = AuthCommands.generateVerificationCode();
        const emailVerificationCodeExpires = new Date(Date.now() + 15 * 60 * 1e3);
        const emailVerificationToken = AuthCommands.generateVerificationToken();
        await db.user.update({
          where: { id: user.id },
          data: {
            emailVerificationCode,
            emailVerificationCodeExpires,
            emailVerificationToken
          }
        });
        try {
          await EmailService.sendEmailVerification({
            name: user.name,
            email: user.email,
            verificationCode: emailVerificationCode,
            expiresIn: "15 minutos"
          });
        } catch (error) {
          console.error("Failed to send verification email:", error);
        }
        return { message: "Verification email sent" };
      },
      async refreshToken(userId) {
        const user = await db.user.findUnique({
          where: { id: userId, status: true }
        });
        if (!user) {
          throw new Error("User not found");
        }
        const token = AuthCommands.generateJWT({
          userId: user.id,
          email: user.email,
          roles: user.roles
        });
        return { token, message: "Token refreshed successfully" };
      },
      // Helper methods
      generateJWT(payload) {
        const secret = process.env.JWT_SECRET || "your-secret-key";
        return import_jsonwebtoken.default.sign(payload, secret, { expiresIn: "7d" });
      },
      generateResetToken() {
        return import_crypto.default.randomBytes(32).toString("hex");
      },
      generateVerificationToken() {
        return import_crypto.default.randomBytes(32).toString("hex");
      },
      generateVerificationCode() {
        return Math.floor(1e5 + Math.random() * 9e5).toString();
      },
      // Verify JWT token
      verifyToken(token) {
        const secret = process.env.JWT_SECRET || "your-secret-key";
        return import_jsonwebtoken.default.verify(token, secret);
      },
      // Extract token from Authorization header
      extractToken(authHeader) {
        if (!authHeader || !authHeader.startsWith("Bearer ")) {
          throw new Error("Invalid authorization header");
        }
        return authHeader.substring(7);
      },
      async updateProfile(userId, data) {
        const { name, email } = data;
        if (email) {
          const existingUser = await db.user.findFirst({
            where: {
              email,
              id: { not: userId }
            }
          });
          if (existingUser) {
            throw new Error("Email already exists");
          }
        }
        const updateData = {};
        if (name) updateData.name = name;
        if (email) {
          updateData.email = email;
          updateData.emailVerified = false;
          updateData.emailVerificationToken = AuthCommands.generateVerificationToken();
        }
        const user = await db.user.update({
          where: { id: userId },
          data: updateData,
          select: {
            id: true,
            email: true,
            name: true,
            emailVerified: true,
            status: true,
            roles: true,
            lastLoginAt: true,
            createdAt: true,
            updatedAt: true
          }
        });
        return user;
      },
      async googleLogin(token) {
        if (!process.env.GOOGLE_CLIENT_ID) {
          throw new Error("Google OAuth configuration missing");
        }
        const client = new import_google_auth_library.OAuth2Client(process.env.GOOGLE_CLIENT_ID);
        try {
          const ticket = await client.verifyIdToken({
            idToken: token,
            audience: process.env.GOOGLE_CLIENT_ID
          });
          const payload = ticket.getPayload();
          if (!payload || !payload.email || !payload.name) {
            throw new Error("Invalid Google token payload");
          }
          let user = await db.user.findUnique({
            where: { email: payload.email }
          });
          if (!user) {
            user = await db.user.create({
              data: {
                name: payload.name,
                email: payload.email,
                emailVerified: true,
                // Google já verifica o email
                status: true,
                roles: ["USER"],
                // Role padrão
                phone: "",
                // Campo obrigatório mas não temos do Google
                password: "",
                // Campo obrigatório mas não usamos para login Google
                lastLoginAt: /* @__PURE__ */ new Date(),
                // User preferences defaults
                theme: "light",
                language: "pt-BR",
                currency: "BRL",
                timezone: "America/Sao_Paulo",
                dateFormat: "DD/MM/YYYY",
                timeFormat: "24h",
                dashboard: null
              }
            });
          } else {
            await db.user.update({
              where: { id: user.id },
              data: { lastLoginAt: /* @__PURE__ */ new Date() }
            });
          }
          if (!user.status) {
            throw new Error("User account is disabled");
          }
          const store = await AuthQueries.getStoreByOwner(user.id);
          const jwtToken = AuthCommands.generateJWT({
            userId: user.id,
            email: user.email,
            roles: user.roles
          });
          return {
            user: {
              id: user.id,
              name: user.name,
              email: user.email,
              emailVerified: user.emailVerified,
              lastLoginAt: user.lastLoginAt
            },
            store: store || void 0,
            token: jwtToken
          };
        } catch (error) {
          console.error("Google Login Error:", error);
          if (error.message === "Google OAuth configuration missing") {
            throw new Error("Google OAuth configuration missing");
          }
          if (error.message === "Invalid Google token payload") {
            throw new Error("Invalid Google token");
          }
          if (error.message === "User account is disabled") {
            throw new Error("User account is disabled");
          }
          throw new Error("Invalid Google token");
        }
      }
    };
  }
});

// src/middlewares/auth.middleware.ts
var auth_middleware_exports = {};
__export(auth_middleware_exports, {
  authMiddleware: () => authMiddleware,
  optionalAuthMiddleware: () => optionalAuthMiddleware
});
var authMiddleware, optionalAuthMiddleware;
var init_auth_middleware = __esm({
  "src/middlewares/auth.middleware.ts"() {
    init_auth_commands();
    init_auth_queries();
    authMiddleware = async (request, reply) => {
      try {
        const authHeader = request.headers.authorization;
        if (!authHeader) {
          return reply.status(401).send({
            error: "Authorization header required"
          });
        }
        const token = AuthCommands.extractToken(authHeader);
        const payload = AuthCommands.verifyToken(token);
        const user = await AuthQueries.getUserProfile(payload.userId);
        if (!user || !user.status) {
          return reply.status(401).send({
            error: "User not found or inactive"
          });
        }
        request.user = user;
        request.token = token;
        return;
      } catch (error) {
        request.log.error(error);
        if (error.message === "Invalid authorization header") {
          return reply.status(401).send({
            error: "Invalid authorization header format"
          });
        }
        if (error.name === "JsonWebTokenError") {
          return reply.status(401).send({
            error: "Invalid token"
          });
        }
        if (error.name === "TokenExpiredError") {
          return reply.status(401).send({
            error: "Token expired"
          });
        }
        return reply.status(500).send({
          error: "Internal server error"
        });
      }
    };
    optionalAuthMiddleware = async (request, reply) => {
      try {
        const authHeader = request.headers.authorization;
        if (!authHeader) {
          return;
        }
        const token = AuthCommands.extractToken(authHeader);
        const payload = AuthCommands.verifyToken(token);
        const user = await AuthQueries.getUserProfile(payload.userId);
        if (user && user.status) {
          request.user = user;
          request.token = token;
        }
        return;
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : "Unknown error";
        request.log.warn(`Optional auth failed: ${errorMessage}`);
        return;
      }
    };
  }
});

// src/server.ts
var import_fastify = __toESM(require("fastify"));
var import_cors = __toESM(require("@fastify/cors"));
init_prisma();

// src/features/user/commands/user.commands.ts
var import_bcryptjs = __toESM(require("bcryptjs"));
init_prisma();
var UserCommands = {
  async create(data) {
    const existingUser = await db.user.findUnique({
      where: { email: data.email }
    });
    if (existingUser) {
      throw new Error("User with this email already exists");
    }
    const hashedPassword = await import_bcryptjs.default.hash(data.password, 12);
    const user = await db.user.create({
      data: {
        email: data.email,
        password: hashedPassword,
        name: data.name,
        roles: data.roles || ["user"]
      },
      select: {
        id: true,
        email: true,
        name: true,
        roles: true,
        status: true,
        createdAt: true
      }
    });
    return user;
  },
  async update(id, data) {
    const existingUser = await db.user.findUnique({
      where: { id }
    });
    if (!existingUser) {
      throw new Error("User not found");
    }
    const updateData = { ...data };
    if (updateData.password) {
      updateData.password = await import_bcryptjs.default.hash(updateData.password, 12);
    }
    if (updateData.email && updateData.email !== existingUser.email) {
      const emailExists = await db.user.findUnique({
        where: { email: updateData.email }
      });
      if (emailExists) {
        throw new Error("Email already exists");
      }
    }
    const user = await db.user.update({
      where: { id },
      data: updateData,
      select: {
        id: true,
        email: true,
        name: true,
        roles: true,
        status: true,
        emailVerified: true,
        updatedAt: true
      }
    });
    return user;
  },
  async delete(id) {
    const existingUser = await db.user.findUnique({
      where: { id }
    });
    if (!existingUser) {
      throw new Error("User not found");
    }
    await db.user.update({
      where: { id },
      data: { status: false }
    });
    return { success: true };
  },
  async verifyEmail(id) {
    const user = await db.user.update({
      where: { id },
      data: { emailVerified: true },
      select: {
        id: true,
        email: true,
        emailVerified: true,
        updatedAt: true
      }
    });
    return user;
  },
  async updateLastLogin(id) {
    await db.user.update({
      where: { id },
      data: { lastLoginAt: /* @__PURE__ */ new Date() }
    });
    return { success: true };
  }
};

// src/utils/pagination.ts
var PaginationUtils = {
  /**
   * Normaliza os parâmetros de paginação
   */
  normalizeParams(params, options = {}) {
    const {
      defaultPage = 1,
      defaultLimit = 10,
      maxLimit = 100
    } = options;
    const page = Math.max(1, params.page || defaultPage);
    const limit = Math.min(maxLimit, Math.max(1, params.limit || defaultLimit));
    const skip = (page - 1) * limit;
    return { page, limit, skip };
  },
  /**
   * Cria o objeto de paginação com metadados
   */
  createPaginationMeta(page, limit, total) {
    const totalPages = Math.ceil(total / limit);
    return {
      page,
      limit,
      total,
      totalPages,
      hasNext: page < totalPages,
      hasPrev: page > 1
    };
  },
  /**
   * Executa uma consulta paginada com Prisma
   */
  async paginate(prisma2, model2, options) {
    const {
      where = {},
      select,
      include,
      orderBy = { createdAt: "desc" },
      params = {},
      paginationOptions = {}
    } = options;
    const { page, limit, skip } = this.normalizeParams(params, paginationOptions);
    const queryOptions = {
      where,
      skip,
      take: limit,
      orderBy
    };
    if (select) {
      queryOptions.select = select;
    }
    if (include) {
      queryOptions.include = include;
    }
    const [data, total] = await Promise.all([
      prisma2[model2].findMany(queryOptions),
      prisma2[model2].count({ where })
    ]);
    return {
      data,
      pagination: this.createPaginationMeta(page, limit, total)
    };
  },
  /**
   * Cria um helper para queries específicas com paginação
   */
  createPaginatedQuery(model2, defaultOptions = {}) {
    return async (prisma2, params) => {
      const { where, ...paginationParams } = params;
      return this.paginate(prisma2, model2, {
        ...defaultOptions,
        where: where || {},
        params: paginationParams
      });
    };
  },
  /**
   * Utilitário para transformar dados paginados em formato específico
   */
  transformPaginationResult(result, dataKey, transformer) {
    const transformedData = transformer ? result.data.map(transformer) : result.data;
    return {
      [dataKey]: transformedData,
      pagination: result.pagination
    };
  }
};

// src/features/user/querys/user.query.ts
init_prisma();
var UserQueries = {
  async getById(id) {
    const user = await db.user.findUnique({
      where: { id },
      select: {
        id: true,
        email: true,
        name: true,
        roles: true,
        status: true,
        emailVerified: true,
        lastLoginAt: true,
        createdAt: true,
        updatedAt: true
      }
    });
    if (!user) {
      throw new Error("User not found");
    }
    return user;
  },
  async getByEmail(email) {
    const user = await db.user.findUnique({
      where: { email },
      select: {
        id: true,
        email: true,
        name: true,
        roles: true,
        status: true,
        emailVerified: true,
        lastLoginAt: true,
        createdAt: true,
        updatedAt: true
      }
    });
    return user;
  },
  async getByEmailWithPassword(email) {
    const user = await db.user.findUnique({
      where: { email },
      select: {
        id: true,
        email: true,
        password: true,
        name: true,
        roles: true,
        status: true,
        emailVerified: true,
        lastLoginAt: true,
        createdAt: true,
        updatedAt: true
      }
    });
    return user;
  },
  async list(filters) {
    const where = {};
    if (filters.search) {
      where.OR = [
        { email: { contains: filters.search, mode: "insensitive" } },
        { name: { contains: filters.search, mode: "insensitive" } }
      ];
    }
    if (filters.status !== void 0) {
      where.status = filters.status;
    }
    if (filters.roles && filters.roles.length > 0) {
      where.roles = {
        hasSome: filters.roles
      };
    }
    const result = await PaginationUtils.paginate(db, "user", {
      where,
      select: {
        id: true,
        email: true,
        name: true,
        roles: true,
        status: true,
        emailVerified: true,
        lastLoginAt: true,
        createdAt: true
      },
      orderBy: { createdAt: "desc" },
      params: {
        page: filters.page,
        limit: filters.limit
      },
      paginationOptions: {
        defaultPage: 1,
        defaultLimit: 10,
        maxLimit: 100
      }
    });
    return PaginationUtils.transformPaginationResult(
      result,
      "users"
    );
  },
  async getByRole(role) {
    const users = await db.user.findMany({
      where: {
        roles: {
          has: role
        },
        status: true
      },
      select: {
        id: true,
        email: true,
        name: true,
        roles: true,
        status: true,
        emailVerified: true,
        lastLoginAt: true,
        createdAt: true
      },
      orderBy: { createdAt: "desc" }
    });
    return users;
  },
  async getActive() {
    const users = await db.user.findMany({
      where: { status: true },
      select: {
        id: true,
        email: true,
        name: true,
        roles: true,
        emailVerified: true,
        lastLoginAt: true,
        createdAt: true
      },
      orderBy: { createdAt: "desc" }
    });
    return users;
  },
  async getStats() {
    const [total, active, inactive, verified, unverified] = await Promise.all([
      db.user.count(),
      db.user.count({ where: { status: true } }),
      db.user.count({ where: { status: false } }),
      db.user.count({ where: { emailVerified: true } }),
      db.user.count({ where: { emailVerified: false } })
    ]);
    return {
      total,
      active,
      inactive,
      verified,
      unverified
    };
  },
  async checkEmailExists(email) {
    const user = await db.user.findUnique({
      where: { email },
      select: { id: true }
    });
    return !!user;
  },
  async search(searchTerm, limit = 10) {
    const users = await db.user.findMany({
      where: {
        OR: [
          { email: { contains: searchTerm, mode: "insensitive" } },
          { name: { contains: searchTerm, mode: "insensitive" } }
        ],
        status: true
      },
      select: {
        id: true,
        email: true,
        name: true,
        roles: true,
        emailVerified: true
      },
      take: limit,
      orderBy: { name: "asc" }
    });
    return users;
  }
};

// src/features/user/user.controller.ts
var UserController = {
  async create(request, reply) {
    try {
      const { email, password, name, roles = ["user"] } = request.body;
      const user = await UserCommands.create({
        email,
        password,
        name,
        roles
      });
      return reply.status(201).send(user);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User with this email already exists") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      const user = await UserQueries.getById(id);
      return reply.send(user);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      const user = await UserCommands.update(id, updateData);
      return reply.send(user);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Email already exists") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      await UserCommands.delete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const {
        page = 1,
        limit = 10,
        search,
        status
      } = request.query;
      const result = await UserQueries.list({
        page,
        limit,
        search,
        status
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // Funções adicionais usando queries
  async getByEmail(request, reply) {
    try {
      const { email } = request.query;
      const user = await UserQueries.getByEmail(email);
      if (!user) {
        return reply.status(404).send({
          error: "User not found"
        });
      }
      return reply.send(user);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByRole(request, reply) {
    try {
      const { role } = request.params;
      const users = await UserQueries.getByRole(role);
      return reply.send({ users });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getActive(request, reply) {
    try {
      const users = await UserQueries.getActive();
      return reply.send({ users });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const stats = await UserQueries.getStats();
      return reply.send(stats);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { q, limit = 10 } = request.query;
      const users = await UserQueries.search(q, limit);
      return reply.send({ users });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // Funções adicionais usando commands
  async verifyEmail(request, reply) {
    try {
      const { id } = request.params;
      const user = await UserCommands.verifyEmail(id);
      return reply.send(user);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async updateLastLogin(request, reply) {
    try {
      const { id } = request.params;
      await UserCommands.updateLastLogin(id);
      return reply.send({ success: true });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/user/user.schema.ts
var createUserSchema = {
  body: {
    type: "object",
    required: ["email", "password", "name"],
    properties: {
      email: { type: "string", format: "email" },
      password: { type: "string", minLength: 6 },
      name: { type: "string", minLength: 2 },
      roles: {
        type: "array",
        items: { type: "string" },
        default: ["user"]
      }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        email: { type: "string" },
        name: { type: "string" },
        roles: { type: "array", items: { type: "string" } },
        status: { type: "boolean" },
        createdAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var getUserSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        email: { type: "string" },
        name: { type: "string" },
        roles: { type: "array", items: { type: "string" } },
        status: { type: "boolean" },
        emailVerified: { type: "boolean" },
        lastLoginAt: { type: "string", format: "date-time" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var updateUserSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      email: { type: "string", format: "email" },
      password: { type: "string", minLength: 6 },
      name: { type: "string", minLength: 2 },
      roles: { type: "array", items: { type: "string" } },
      status: { type: "boolean" },
      emailVerified: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        email: { type: "string" },
        name: { type: "string" },
        roles: { type: "array", items: { type: "string" } },
        status: { type: "boolean" },
        emailVerified: { type: "boolean" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var deleteUserSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" }
  }
};
var listUsersSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      status: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        users: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              email: { type: "string" },
              name: { type: "string" },
              roles: { type: "array", items: { type: "string" } },
              status: { type: "boolean" },
              emailVerified: { type: "boolean" },
              lastLoginAt: { type: "string", format: "date-time" },
              createdAt: { type: "string", format: "date-time" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var UserSchemas = {
  create: createUserSchema,
  get: getUserSchema,
  update: updateUserSchema,
  delete: deleteUserSchema,
  list: listUsersSchema
};

// src/features/user/user.routes.ts
async function UserRoutes(fastify2) {
  fastify2.post("/", {
    schema: UserSchemas.create,
    handler: UserController.create
  });
  fastify2.get("/", {
    schema: UserSchemas.list,
    handler: UserController.list
  });
  fastify2.get("/:id", {
    schema: UserSchemas.get,
    handler: UserController.get
  });
  fastify2.put("/:id", {
    schema: UserSchemas.update,
    handler: UserController.update
  });
  fastify2.delete("/:id", {
    schema: UserSchemas.delete,
    handler: UserController.delete
  });
  fastify2.get("/email", {
    handler: UserController.getByEmail
  });
  fastify2.get("/role/:role", {
    handler: UserController.getByRole
  });
  fastify2.get("/active", {
    handler: UserController.getActive
  });
  fastify2.get("/stats", {
    handler: UserController.getStats
  });
  fastify2.get("/search", {
    handler: UserController.search
  });
  fastify2.patch("/:id/verify-email", {
    handler: UserController.verifyEmail
  });
  fastify2.patch("/:id/last-login", {
    handler: UserController.updateLastLogin
  });
}

// src/features/auth/auth.controller.ts
init_auth_commands();
init_auth_queries();

// src/features/user-preferences/queries/user-preferences.query.ts
init_prisma();
var UserPreferencesQueries = {
  // ================================
  // GET OPERATIONS
  // ================================
  async getById(id) {
    try {
      const preferences = await db.userPreferences.findUnique({
        where: { id },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      });
      if (!preferences) {
        throw new Error("User preferences not found");
      }
      return preferences;
    } catch (error) {
      throw new Error(`Failed to get user preferences: ${error.message}`);
    }
  },
  async getByUserId(userId) {
    try {
      const preferences = await db.userPreferences.findUnique({
        where: { userId },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      });
      if (!preferences) {
        throw new Error("User preferences not found");
      }
      return preferences;
    } catch (error) {
      throw new Error(`Failed to get user preferences: ${error.message}`);
    }
  },
  async getByUserIdOrCreate(userId) {
    try {
      const user = await db.user.findUnique({
        where: { id: userId },
        select: { id: true, name: true, email: true }
      });
      if (!user) {
        throw new Error("User not found");
      }
      let preferences = await db.userPreferences.findUnique({
        where: { userId },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      });
      if (!preferences) {
        preferences = await db.userPreferences.create({
          data: {
            userId,
            theme: "light",
            language: "pt-BR",
            currency: "BRL",
            timezone: "America/Sao_Paulo",
            dateFormat: "DD/MM/YYYY",
            timeFormat: "24h",
            numberFormat: "pt-BR",
            emailNotifications: true,
            pushNotifications: true,
            smsNotifications: false,
            itemsPerPage: 20,
            autoRefresh: true,
            refreshInterval: 30
          },
          include: {
            user: {
              select: {
                id: true,
                name: true,
                email: true
              }
            }
          }
        });
      }
      return preferences;
    } catch (error) {
      throw new Error(`Failed to get or create user preferences: ${error.message}`);
    }
  },
  // ================================
  // LIST OPERATIONS
  // ================================
  async list(filters = {}) {
    try {
      const {
        page = 1,
        limit = 10,
        search,
        theme,
        language,
        currency,
        timezone,
        hasCustomSettings,
        notificationsEnabled
      } = filters;
      const skip = (page - 1) * limit;
      const where = {};
      if (search) {
        where.OR = [
          {
            user: {
              name: {
                contains: search,
                mode: "insensitive"
              }
            }
          },
          {
            user: {
              email: {
                contains: search,
                mode: "insensitive"
              }
            }
          }
        ];
      }
      if (theme) {
        where.theme = theme;
      }
      if (language) {
        where.language = language;
      }
      if (currency) {
        where.currency = currency;
      }
      if (timezone) {
        where.timezone = timezone;
      }
      if (hasCustomSettings !== void 0) {
        if (hasCustomSettings) {
          where.customSettings = {
            not: null
          };
        } else {
          where.customSettings = null;
        }
      }
      if (notificationsEnabled !== void 0) {
        where.emailNotifications = notificationsEnabled;
      }
      const [preferences, total] = await Promise.all([
        db.userPreferences.findMany({
          where,
          skip,
          take: limit,
          orderBy: {
            updatedAt: "desc"
          },
          include: {
            user: {
              select: {
                id: true,
                name: true,
                email: true
              }
            }
          }
        }),
        db.userPreferences.count({ where })
      ]);
      return {
        preferences,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit)
        }
      };
    } catch (error) {
      throw new Error(`Failed to list user preferences: ${error.message}`);
    }
  },
  // ================================
  // SEARCH OPERATIONS
  // ================================
  async search(searchTerm, limit = 10) {
    try {
      const preferences = await db.userPreferences.findMany({
        where: {
          OR: [
            {
              user: {
                name: {
                  contains: searchTerm,
                  mode: "insensitive"
                }
              }
            },
            {
              user: {
                email: {
                  contains: searchTerm,
                  mode: "insensitive"
                }
              }
            },
            {
              language: {
                contains: searchTerm,
                mode: "insensitive"
              }
            },
            {
              currency: {
                contains: searchTerm,
                mode: "insensitive"
              }
            }
          ]
        },
        take: limit,
        orderBy: {
          updatedAt: "desc"
        },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      });
      return preferences;
    } catch (error) {
      throw new Error(`Failed to search user preferences: ${error.message}`);
    }
  },
  // ================================
  // STATS OPERATIONS
  // ================================
  async getStats() {
    try {
      const [
        totalPreferences,
        themeStats,
        languageStats,
        currencyStats,
        itemsPerPageStats,
        notificationsStats
      ] = await Promise.all([
        db.userPreferences.count(),
        db.userPreferences.groupBy({
          by: ["theme"],
          _count: {
            theme: true
          }
        }),
        db.userPreferences.groupBy({
          by: ["language"],
          _count: {
            language: true
          }
        }),
        db.userPreferences.groupBy({
          by: ["currency"],
          _count: {
            currency: true
          }
        }),
        db.userPreferences.aggregate({
          _avg: {
            itemsPerPage: true
          }
        }),
        db.userPreferences.groupBy({
          by: ["emailNotifications"],
          _count: {
            emailNotifications: true
          }
        })
      ]);
      const themeDistribution = {
        light: 0,
        dark: 0,
        auto: 0
      };
      themeStats.forEach((stat) => {
        if (stat.theme === "light") themeDistribution.light = stat._count.theme;
        if (stat.theme === "dark") themeDistribution.dark = stat._count.theme;
        if (stat.theme === "auto") themeDistribution.auto = stat._count.theme;
      });
      const languageDistribution = {};
      languageStats.forEach((stat) => {
        languageDistribution[stat.language] = stat._count.language;
      });
      const currencyDistribution = {};
      currencyStats.forEach((stat) => {
        currencyDistribution[stat.currency] = stat._count.currency;
      });
      let notificationsEnabled = 0;
      let notificationsDisabled = 0;
      notificationsStats.forEach((stat) => {
        if (stat.emailNotifications) {
          notificationsEnabled = stat._count.emailNotifications;
        } else {
          notificationsDisabled = stat._count.emailNotifications;
        }
      });
      return {
        totalPreferences,
        themeDistribution,
        languageDistribution,
        currencyDistribution,
        averageItemsPerPage: Math.round(itemsPerPageStats._avg.itemsPerPage || 20),
        notificationsEnabled,
        notificationsDisabled
      };
    } catch (error) {
      throw new Error(`Failed to get user preferences stats: ${error.message}`);
    }
  },
  // ================================
  // FILTER OPERATIONS
  // ================================
  async getByTheme(theme) {
    try {
      const preferences = await db.userPreferences.findMany({
        where: { theme },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        },
        orderBy: {
          updatedAt: "desc"
        }
      });
      return preferences;
    } catch (error) {
      throw new Error(`Failed to get user preferences by theme: ${error.message}`);
    }
  },
  async getByLanguage(language) {
    try {
      const preferences = await db.userPreferences.findMany({
        where: { language },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        },
        orderBy: {
          updatedAt: "desc"
        }
      });
      return preferences;
    } catch (error) {
      throw new Error(`Failed to get user preferences by language: ${error.message}`);
    }
  },
  async getByCurrency(currency) {
    try {
      const preferences = await db.userPreferences.findMany({
        where: { currency },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        },
        orderBy: {
          updatedAt: "desc"
        }
      });
      return preferences;
    } catch (error) {
      throw new Error(`Failed to get user preferences by currency: ${error.message}`);
    }
  },
  async getWithCustomSettings() {
    try {
      const preferences = await db.userPreferences.findMany({
        where: {
          customSettings: {
            not: null
          }
        },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        },
        orderBy: {
          updatedAt: "desc"
        }
      });
      return preferences;
    } catch (error) {
      throw new Error(`Failed to get user preferences with custom settings: ${error.message}`);
    }
  },
  // ================================
  // VALIDATION OPERATIONS
  // ================================
  async validatePreferences(data) {
    try {
      const errors = [];
      const warnings = [];
      if (data.theme && !["light", "dark", "auto"].includes(data.theme)) {
        errors.push("Theme must be one of: light, dark, auto");
      }
      if (data.dateFormat && !["DD/MM/YYYY", "MM/DD/YYYY", "YYYY-MM-DD"].includes(data.dateFormat)) {
        errors.push("Date format must be one of: DD/MM/YYYY, MM/DD/YYYY, YYYY-MM-DD");
      }
      if (data.timeFormat && !["12h", "24h"].includes(data.timeFormat)) {
        errors.push("Time format must be one of: 12h, 24h");
      }
      if (data.itemsPerPage && (data.itemsPerPage < 5 || data.itemsPerPage > 100)) {
        warnings.push("Items per page should be between 5 and 100");
      }
      if (data.refreshInterval && (data.refreshInterval < 10 || data.refreshInterval > 300)) {
        warnings.push("Refresh interval should be between 10 and 300 seconds");
      }
      return {
        isValid: errors.length === 0,
        errors,
        warnings
      };
    } catch (error) {
      throw new Error(`Failed to validate user preferences: ${error.message}`);
    }
  }
};

// src/features/auth/auth.controller.ts
var AuthController = {
  // === AUTH CRUD ===
  async register(request, reply) {
    try {
      const { name, email, password, phone } = request.body;
      const user = await AuthCommands.register({
        name,
        email,
        phone,
        password
      });
      return reply.status(201).send({
        user,
        message: "Usu\xE1rio registrado com sucesso. Verifique seu email para o c\xF3digo de confirma\xE7\xE3o de 6 d\xEDgitos."
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "User already exists with this email") {
        return reply.status(409).send({
          error: "J\xE1 existe um usu\xE1rio com este email"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async login(request, reply) {
    try {
      const { email, password } = request.body;
      const result = await AuthCommands.login({
        email,
        password
      });
      return reply.send({
        user: result.user,
        store: result.store,
        token: result.token,
        message: "Login successful",
        preferences: await UserPreferencesQueries.getByUserIdOrCreate(result.user.id)
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invalid credentials") {
        return reply.status(401).send({
          error: error.message
        });
      }
      if (error.message === "Email verification required") {
        return reply.status(403).send({
          error: "Necess\xE1rio verificar o email"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async forgotPassword(request, reply) {
    try {
      const { email } = request.body;
      await AuthCommands.forgotPassword(email);
      return reply.send({
        message: "If the email exists, a reset password code has been sent."
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found") {
        return reply.status(404).send({
          error: "If the email exists, a reset password code has been sent."
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async verifyResetCode(request, reply) {
    try {
      const { email, code } = request.body;
      await AuthCommands.verifyResetCode(email, code);
      return reply.send({
        message: "Reset code verified successfully"
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invalid or expired reset code") {
        return reply.status(401).send({
          error: error.message
        });
      }
      if (error.message === "Reset code expired") {
        return reply.status(401).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async resetPassword(request, reply) {
    try {
      const { email, code, password } = request.body;
      await AuthCommands.resetPassword(email, code, password);
      return reply.send({
        message: "Password reset successfully"
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invalid or expired reset code") {
        return reply.status(401).send({
          error: error.message
        });
      }
      if (error.message === "Reset code expired") {
        return reply.status(401).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async verifyEmail(request, reply) {
    try {
      const { token } = request.body;
      await AuthCommands.verifyEmail(token);
      return reply.send({
        message: "Email verified successfully"
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invalid verification token") {
        return reply.status(401).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async verifyEmailCode(request, reply) {
    try {
      const { email, code } = request.body;
      const user = await AuthCommands.verifyEmailCode(email, code);
      return reply.send({
        message: "Email verified successfully",
        user: {
          id: user.id,
          name: user.name,
          email: user.email,
          emailVerified: user.emailVerified
        }
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invalid verification code" || error.message === "Verification code expired") {
        return reply.status(401).send({
          error: error.message
        });
      }
      if (error.message === "User not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async resendVerification(request, reply) {
    try {
      const { email } = request.body;
      await AuthCommands.resendVerification(email);
      return reply.send({
        message: "Verification email sent successfully"
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Email already verified") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async refreshToken(request, reply) {
    try {
      const authHeader = request.headers.authorization;
      if (!authHeader) {
        return reply.status(401).send({
          error: "Authorization header required"
        });
      }
      const token = AuthCommands.extractToken(authHeader);
      const payload = AuthCommands.verifyToken(token);
      const result = await AuthCommands.refreshToken(payload.userId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invalid authorization header" || error.message === "User not found") {
        return reply.status(401).send({
          error: "Invalid token"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async logout(request, reply) {
    try {
      return reply.send({
        message: "Logout successful"
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === QUERIES ===
  async getProfile(request, reply) {
    try {
      const authHeader = request.headers.authorization;
      if (!authHeader) {
        return reply.status(401).send({
          error: "Authorization header required"
        });
      }
      const token = AuthCommands.extractToken(authHeader);
      const payload = AuthCommands.verifyToken(token);
      const user = await AuthQueries.getUserProfile(payload.userId);
      return reply.send({ user });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invalid authorization header" || error.message === "User not found") {
        return reply.status(401).send({
          error: "Invalid token"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async updateProfile(request, reply) {
    try {
      const authHeader = request.headers.authorization;
      if (!authHeader) {
        return reply.status(401).send({
          error: "Authorization header required"
        });
      }
      const token = AuthCommands.extractToken(authHeader);
      const payload = AuthCommands.verifyToken(token);
      const { name, email } = request.body;
      if (!name && !email) {
        return reply.status(400).send({
          error: "At least one field (name or email) must be provided"
        });
      }
      const user = await AuthCommands.updateProfile(payload.userId, { name, email });
      return reply.send({
        user,
        message: "Profile updated successfully"
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invalid authorization header") {
        return reply.status(401).send({
          error: "Invalid token"
        });
      }
      if (error.message === "Email already exists") {
        return reply.status(409).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getProfilePermissions(request, reply) {
    try {
      const authHeader = request.headers.authorization;
      if (!authHeader) {
        return reply.status(401).send({
          error: "Authorization header required"
        });
      }
      const token = AuthCommands.extractToken(authHeader);
      const payload = AuthCommands.verifyToken(token);
      const { storeId, active, page, limit } = request.query;
      const permissions = await AuthQueries.getProfilePermissions(payload.userId, {
        storeId,
        active,
        page,
        limit
      });
      return reply.send(permissions);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invalid authorization header") {
        return reply.status(401).send({
          error: "Invalid token"
        });
      }
      if (error.message === "User not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getActive(request, reply) {
    try {
      const users = await AuthQueries.getActiveUsers();
      return reply.send({ users });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getVerified(request, reply) {
    try {
      const users = await AuthQueries.getVerifiedUsers();
      return reply.send({ users });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getUnverified(request, reply) {
    try {
      const users = await AuthQueries.getUnverifiedUsers();
      return reply.send({ users });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const stats = await AuthQueries.getUserStats();
      return reply.send(stats);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { q, limit = 10 } = request.query;
      const users = await AuthQueries.searchUsers(q, limit);
      return reply.send({ users });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getPendingVerification(request, reply) {
    try {
      const users = await AuthQueries.getUsersWithPendingVerification();
      return reply.send({ users });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getPendingReset(request, reply) {
    try {
      const users = await AuthQueries.getUsersWithPendingReset();
      return reply.send({ users });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async googleLogin(request, reply) {
    try {
      const { id_token } = request.body;
      const result = await AuthCommands.googleLogin(id_token);
      return reply.send({
        user: result.user,
        store: result.store,
        token: result.token,
        message: "Google login successful",
        preferences: await UserPreferencesQueries.getByUserIdOrCreate(result.user.id)
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Google OAuth configuration missing") {
        return reply.status(500).send({
          error: "Google OAuth n\xE3o configurado no servidor"
        });
      }
      if (error.message === "Invalid Google token") {
        return reply.status(401).send({
          error: "Token do Google inv\xE1lido"
        });
      }
      if (error.message === "User account is disabled") {
        return reply.status(403).send({
          error: "Conta de usu\xE1rio desabilitada"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/auth/auth.schema.ts
var registerSchema = {
  body: {
    type: "object",
    required: ["name", "email", "password"],
    properties: {
      name: {
        type: "string",
        minLength: 2,
        maxLength: 100,
        description: "User full name"
      },
      email: {
        type: "string",
        format: "email",
        description: "User email address"
      },
      password: {
        type: "string",
        minLength: 6,
        maxLength: 100,
        description: "User password (minimum 6 characters)"
      }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" },
            emailVerified: { type: "boolean" },
            createdAt: { type: "string", format: "date-time" }
          }
        },
        message: { type: "string" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    409: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var loginSchema = {
  body: {
    type: "object",
    required: ["email", "password"],
    properties: {
      email: {
        type: "string",
        format: "email",
        description: "User email address"
      },
      password: {
        type: "string",
        description: "User password"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" },
            emailVerified: { type: "boolean" },
            lastLoginAt: { type: "string", format: "date-time" }
          }
        },
        token: { type: "string" },
        message: { type: "string" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    401: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var forgotPasswordSchema = {
  body: {
    type: "object",
    required: ["email"],
    properties: {
      email: {
        type: "string",
        format: "email",
        description: "User email address"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        message: { type: "string" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var verifyResetCodeSchema = {
  body: {
    type: "object",
    required: ["email", "code"],
    properties: {
      email: {
        type: "string",
        format: "email",
        description: "User email address"
      },
      code: {
        type: "string",
        pattern: "^[0-9]{6}$",
        description: "6-digit reset code"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        message: { type: "string" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    401: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var resetPasswordSchema = {
  body: {
    type: "object",
    required: ["email", "code", "password"],
    properties: {
      email: {
        type: "string",
        format: "email",
        description: "User email address"
      },
      code: {
        type: "string",
        pattern: "^[0-9]{6}$",
        description: "6-digit reset code"
      },
      password: {
        type: "string",
        minLength: 6,
        maxLength: 100,
        description: "New password (minimum 6 characters)"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        message: { type: "string" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    401: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var verifyEmailSchema = {
  body: {
    type: "object",
    required: ["token"],
    properties: {
      token: {
        type: "string",
        description: "Email verification token"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        message: { type: "string" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    401: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var verifyEmailCodeSchema = {
  body: {
    type: "object",
    required: ["email", "code"],
    properties: {
      email: {
        type: "string",
        format: "email",
        description: "User email address"
      },
      code: {
        type: "string",
        pattern: "^[0-9]{6}$",
        description: "6-digit verification code"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        message: { type: "string" },
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" },
            emailVerified: { type: "boolean" }
          }
        }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    401: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var resendVerificationSchema = {
  body: {
    type: "object",
    required: ["email"],
    properties: {
      email: {
        type: "string",
        format: "email",
        description: "User email address"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        message: { type: "string" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var refreshTokenSchema = {
  headers: {
    type: "object",
    properties: {
      authorization: {
        type: "string",
        description: "Bearer token"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        token: { type: "string" },
        message: { type: "string" }
      }
    },
    401: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var logoutSchema = {
  headers: {
    type: "object",
    properties: {
      authorization: {
        type: "string",
        description: "Bearer token"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        message: { type: "string" }
      }
    },
    401: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var updateProfileSchema = {
  headers: {
    type: "object",
    properties: {
      authorization: {
        type: "string",
        description: "Bearer token"
      }
    }
  },
  body: {
    type: "object",
    properties: {
      name: {
        type: "string",
        minLength: 2,
        maxLength: 100,
        description: "User full name"
      },
      email: {
        type: "string",
        format: "email",
        description: "User email address"
      }
    },
    additionalProperties: false
  },
  response: {
    200: {
      type: "object",
      properties: {
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" },
            emailVerified: { type: "boolean" },
            status: { type: "boolean" },
            roles: {
              type: "array",
              items: { type: "string" }
            },
            lastLoginAt: { type: ["string", "null"], format: "date-time" },
            createdAt: { type: "string", format: "date-time" },
            updatedAt: { type: "string", format: "date-time" }
          }
        },
        message: { type: "string" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    401: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    409: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var googleLoginSchema = {
  body: {
    type: "object",
    required: ["id_token"],
    properties: {
      id_token: {
        type: "string",
        description: "Google ID token from client-side authentication"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" },
            emailVerified: { type: "boolean" },
            lastLoginAt: { type: ["string", "null"], format: "date-time" }
          }
        },
        store: {
          type: ["object", "null"],
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            cnpj: { type: "string" },
            email: { type: ["string", "null"] },
            phone: { type: ["string", "null"] },
            status: { type: "boolean" },
            cep: { type: ["string", "null"] },
            city: { type: ["string", "null"] },
            state: { type: ["string", "null"] },
            address: { type: ["string", "null"] },
            createdAt: { type: "string", format: "date-time" },
            updatedAt: { type: "string", format: "date-time" }
          }
        },
        token: { type: "string" },
        message: { type: "string" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    401: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getProfilePermissionsSchema = {
  headers: {
    type: "object",
    properties: {
      authorization: {
        type: "string",
        description: "Bearer token"
      }
    }
  },
  querystring: {
    type: "object",
    properties: {
      storeId: {
        type: "string",
        description: "Store ID to filter permissions"
      },
      active: {
        type: "boolean",
        description: "Filter active permissions only"
      },
      page: {
        type: "number",
        minimum: 1,
        default: 1,
        description: "Page number for pagination"
      },
      limit: {
        type: "number",
        minimum: 1,
        maximum: 100,
        default: 10,
        description: "Number of items per page"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        userId: { type: "string" },
        userRoles: {
          type: "array",
          items: { type: "string" }
        },
        storeId: { type: ["string", "null"] },
        effectivePermissions: {
          type: "array",
          items: { type: "string" }
        },
        customPermissions: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              action: { type: "string" },
              resource: { type: ["string", "null"] },
              storeId: { type: ["string", "null"] },
              grant: { type: "boolean" },
              conditions: { type: ["object", "null"] },
              expiresAt: { type: ["string", "null"], format: "date-time" },
              reason: { type: ["string", "null"] },
              createdAt: { type: "string", format: "date-time" },
              createdBy: { type: "string" },
              creator: {
                type: ["object", "null"],
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  email: { type: "string" }
                }
              }
            }
          }
        },
        storePermissions: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              storeId: { type: "string" },
              storeRole: { type: "string" },
              permissions: {
                type: "array",
                items: { type: "string" }
              },
              conditions: { type: ["object", "null"] },
              expiresAt: { type: ["string", "null"], format: "date-time" },
              createdAt: { type: "string", format: "date-time" },
              createdBy: { type: "string" },
              store: {
                type: ["object", "null"],
                properties: {
                  id: { type: "string" },
                  name: { type: "string" }
                }
              },
              creator: {
                type: ["object", "null"],
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  email: { type: "string" }
                }
              }
            }
          }
        },
        pagination: {
          type: ["object", "null"],
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            pages: { type: "number" }
          }
        }
      }
    },
    401: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};

// src/features/auth/auth.routes.ts
async function AuthRoutes(fastify2) {
  fastify2.post("/signup", {
    schema: registerSchema,
    handler: AuthController.register
  });
  fastify2.post("/signin", {
    schema: loginSchema,
    handler: AuthController.login
  });
  fastify2.post("/forgot-password", {
    schema: forgotPasswordSchema,
    handler: AuthController.forgotPassword
  });
  fastify2.post("/verify-reset-code", {
    schema: verifyResetCodeSchema,
    handler: AuthController.verifyResetCode
  });
  fastify2.post("/reset-password", {
    schema: resetPasswordSchema,
    handler: AuthController.resetPassword
  });
  fastify2.post("/verify-email", {
    schema: verifyEmailSchema,
    handler: AuthController.verifyEmail
  });
  fastify2.post("/verify-email-code", {
    schema: verifyEmailCodeSchema,
    handler: AuthController.verifyEmailCode
  });
  fastify2.post("/google", {
    schema: googleLoginSchema,
    handler: AuthController.googleLogin
  });
  fastify2.post("/resend-verification", {
    schema: resendVerificationSchema,
    handler: AuthController.resendVerification
  });
  fastify2.post("/refresh-token", {
    schema: refreshTokenSchema,
    handler: AuthController.refreshToken
  });
  fastify2.post("/logout", {
    schema: logoutSchema,
    handler: AuthController.logout
  });
  fastify2.get("/profile", {
    handler: AuthController.getProfile
  });
  fastify2.put("/profile", {
    schema: updateProfileSchema,
    handler: AuthController.updateProfile
  });
  fastify2.get("/profile/permissions", {
    schema: getProfilePermissionsSchema,
    handler: AuthController.getProfilePermissions
  });
  fastify2.get("/users/active", {
    handler: AuthController.getActive
  });
  fastify2.get("/users/verified", {
    handler: AuthController.getVerified
  });
  fastify2.get("/users/unverified", {
    handler: AuthController.getUnverified
  });
  fastify2.get("/stats", {
    handler: AuthController.getStats
  });
  fastify2.get("/search", {
    handler: AuthController.search
  });
  fastify2.get("/users/pending-verification", {
    handler: AuthController.getPendingVerification
  });
  fastify2.get("/users/pending-reset", {
    handler: AuthController.getPendingReset
  });
}

// src/features/product/commands/product.commands.ts
init_prisma();
var getUserStore = async (userId) => {
  const ownedStore = await db.store.findFirst({
    where: { ownerId: userId },
    select: { id: true, name: true }
  });
  if (ownedStore) {
    return ownedStore;
  }
  const storeUser = await db.storeUser.findFirst({
    where: { userId },
    include: {
      store: {
        select: { id: true, name: true }
      }
    }
  });
  if (storeUser) {
    return storeUser.store;
  }
  throw new Error("User has no associated store");
};
var ProductCommands = {
  async create(data) {
    const { categoryIds, supplierId, storeId, ...createData } = data;
    if (categoryIds && categoryIds.length > 0) {
      const existingCategories = await db.category.findMany({
        where: { id: { in: categoryIds } },
        select: { id: true }
      });
      if (existingCategories.length !== categoryIds.length) {
        const foundIds = existingCategories.map((c) => c.id);
        const notFoundIds = categoryIds.filter((id) => !foundIds.includes(id));
        throw new Error(`Categories not found: ${notFoundIds.join(", ")}`);
      }
    }
    const product = await db.product.create({
      data: {
        ...createData,
        unitOfMeasure: createData.unitOfMeasure,
        status: data.status ?? true,
        ...supplierId && { supplier: { connect: { id: supplierId } } },
        store: { connect: { id: storeId } }
      }
    });
    if (categoryIds && categoryIds.length > 0) {
      await db.productCategory.createMany({
        data: categoryIds.map((categoryId) => ({
          productId: product.id,
          categoryId
        }))
      });
    }
    return await db.product.findUnique({
      where: { id: product.id },
      include: {
        categories: {
          include: {
            category: {
              select: {
                id: true,
                name: true,
                description: true,
                code: true,
                color: true,
                icon: true
              }
            }
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true,
            cnpj: true,
            tradeName: true
          }
        },
        store: {
          select: {
            id: true,
            name: true,
            cnpj: true
          }
        }
      }
    });
  },
  async update(id, data) {
    const { categoryIds, supplierId, storeId, ...updateData } = data;
    if (categoryIds && categoryIds.length > 0) {
      const existingCategories = await db.category.findMany({
        where: { id: { in: categoryIds } },
        select: { id: true }
      });
      if (existingCategories.length !== categoryIds.length) {
        const foundIds = existingCategories.map((c) => c.id);
        const notFoundIds = categoryIds.filter((id2) => !foundIds.includes(id2));
        throw new Error(`Categories not found: ${notFoundIds.join(", ")}`);
      }
    }
    let categoryUpdate = {};
    if (categoryIds !== void 0) {
      if (categoryIds.length === 0) {
        categoryUpdate = {
          categories: {
            deleteMany: {}
          }
        };
      } else {
        categoryUpdate = {
          categories: {
            deleteMany: {},
            create: categoryIds.map((categoryId) => ({
              category: { connect: { id: categoryId } }
            }))
          }
        };
      }
    }
    return await db.product.update({
      where: { id },
      data: {
        ...updateData,
        ...updateData.unitOfMeasure && { unitOfMeasure: updateData.unitOfMeasure },
        ...supplierId !== void 0 && supplierId ? { supplier: { connect: { id: supplierId } } } : supplierId === null ? { supplier: { disconnect: true } } : {},
        ...storeId && { store: { connect: { id: storeId } } },
        ...categoryUpdate
      },
      include: {
        categories: {
          select: {
            category: {
              select: {
                id: true,
                name: true,
                description: true,
                code: true,
                color: true,
                icon: true
              }
            }
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true,
            cnpj: true,
            tradeName: true
          }
        },
        store: {
          select: {
            id: true,
            name: true,
            cnpj: true
          }
        }
      }
    });
  },
  async delete(id) {
    const product = await db.product.findUnique({
      where: { id },
      include: {
        movements: {
          select: { id: true }
        }
      }
    });
    if (!product) {
      throw new Error("Product not found");
    }
    if (product.movements.length > 0) {
      throw new Error(`Cannot delete product. It has ${product.movements.length} associated movements. Please delete the movements first or use force delete.`);
    }
    return await db.product.delete({
      where: { id }
    });
  },
  async forceDelete(id) {
    const product = await db.product.findUnique({
      where: { id }
    });
    if (!product) {
      throw new Error("Product not found");
    }
    await db.movement.deleteMany({
      where: { productId: id }
    });
    return await db.product.delete({
      where: { id }
    });
  },
  async updateStatus(id, status) {
    return await db.product.update({
      where: { id },
      data: { status },
      include: {
        categories: {
          select: {
            category: {
              select: {
                id: true,
                name: true,
                description: true,
                code: true,
                color: true,
                icon: true
              }
            }
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true,
            cnpj: true,
            tradeName: true
          }
        },
        store: {
          select: {
            id: true,
            name: true,
            cnpj: true
          }
        }
      }
    });
  },
  // === FUNÇÕES ADICIONAIS DE PRODUTO ===
  async verifySku(productId, sku) {
    const product = await db.product.findUnique({
      where: { id: productId }
    });
    if (!product) {
      throw new Error("Product not found");
    }
    const existingProduct = await db.product.findFirst({
      where: {
        id: { not: productId },
        name: sku
        // Assumindo que SKU é o nome do produto
      }
    });
    return {
      available: !existingProduct,
      message: existingProduct ? "SKU already exists" : "SKU available"
    };
  },
  async updateStock(productId, quantity, type, note, userId) {
    const product = await db.product.findUnique({
      where: { id: productId }
    });
    if (!product) {
      throw new Error("Product not found");
    }
    let newStock = 0;
    if (type === "ENTRADA") {
      newStock = quantity;
    } else {
      newStock = -quantity;
    }
    const movement = await db.movement.create({
      data: {
        type,
        quantity,
        storeId: product.storeId,
        productId,
        note,
        userId,
        balanceAfter: newStock
      },
      include: {
        supplier: {
          select: {
            id: true,
            corporateName: true,
            cnpj: true
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    return {
      product: {
        id: product.id,
        name: product.name,
        currentStock: newStock
      },
      movement
    };
  },
  async createMovement(productId, data) {
    const product = await db.product.findUnique({
      where: { id: productId }
    });
    if (!product) {
      throw new Error("Product not found");
    }
    if (data.supplierId) {
      const supplier = await db.supplier.findUnique({
        where: { id: data.supplierId }
      });
      if (!supplier) {
        throw new Error("Supplier not found");
      }
    }
    const movement = await db.movement.create({
      data: {
        type: data.type,
        quantity: data.quantity,
        storeId: product.storeId,
        productId,
        supplierId: data.supplierId,
        batch: data.batch,
        expiration: data.expiration ? new Date(data.expiration) : null,
        price: data.price,
        note: data.note,
        userId: data.userId,
        balanceAfter: data.quantity
        // Assumindo que é o estoque após a movimentação
      },
      include: {
        product: {
          select: {
            id: true,
            name: true,
            unitOfMeasure: true
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true,
            cnpj: true
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        },
        store: {
          select: {
            id: true,
            name: true,
            cnpj: true
          }
        }
      }
    });
    return movement;
  },
  async getProductStock(productId) {
    const product = await db.product.findUnique({
      where: { id: productId },
      include: {
        movements: {
          orderBy: { createdAt: "desc" },
          take: 1
        }
      }
    });
    if (!product) {
      throw new Error("Product not found");
    }
    const movements = await db.movement.findMany({
      where: { productId },
      select: {
        type: true,
        quantity: true
      }
    });
    let currentStock = 0;
    movements.forEach((movement) => {
      if (movement.type === "ENTRADA") {
        currentStock += movement.quantity;
      } else {
        currentStock -= movement.quantity;
      }
    });
    let status = "OK";
    const stockPercentage = currentStock / product.stockMax * 100;
    if (currentStock <= 0) {
      status = "CRITICAL";
    } else if (currentStock <= product.stockMin) {
      status = "LOW";
    } else if (currentStock > product.stockMax) {
      status = "OVERSTOCK";
    }
    return {
      id: product.id,
      name: product.name,
      currentStock,
      stockMin: product.stockMin,
      stockMax: product.stockMax,
      alertPercentage: product.alertPercentage,
      status,
      lastMovement: product.movements[0] ? {
        type: product.movements[0].type,
        quantity: product.movements[0].quantity,
        date: product.movements[0].createdAt
      } : null
    };
  },
  // === MÉTODOS PARA GERENCIAR CATEGORIAS DO PRODUTO ===
  async addCategories(productId, categoryIds) {
    const product = await db.product.findUnique({
      where: { id: productId }
    });
    if (!product) {
      throw new Error("Product not found");
    }
    const existingCategories = await db.category.findMany({
      where: { id: { in: categoryIds } },
      select: { id: true }
    });
    if (existingCategories.length !== categoryIds.length) {
      const foundIds = existingCategories.map((c) => c.id);
      const notFoundIds = categoryIds.filter((id) => !foundIds.includes(id));
      throw new Error(`Categories not found: ${notFoundIds.join(", ")}`);
    }
    const existingProductCategories = await db.productCategory.findMany({
      where: {
        productId,
        categoryId: { in: categoryIds }
      },
      select: { categoryId: true }
    });
    const existingCategoryIds = existingProductCategories.map((pc) => pc.categoryId);
    const newCategoryIds = categoryIds.filter((id) => !existingCategoryIds.includes(id));
    if (newCategoryIds.length === 0) {
      throw new Error("All provided categories are already associated with this product");
    }
    await db.productCategory.createMany({
      data: newCategoryIds.map((categoryId) => ({
        productId,
        categoryId
      }))
    });
    const updatedCategories = await db.productCategory.findMany({
      where: { productId },
      select: {
        category: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true,
            color: true,
            icon: true
          }
        }
      }
    });
    return {
      message: `${newCategoryIds.length} categories added successfully`,
      addedCount: newCategoryIds.length,
      categories: updatedCategories.map((pc) => pc.category)
    };
  },
  async removeCategories(productId, categoryIds) {
    const product = await db.product.findUnique({
      where: { id: productId }
    });
    if (!product) {
      throw new Error("Product not found");
    }
    const result = await db.productCategory.deleteMany({
      where: {
        productId,
        categoryId: { in: categoryIds }
      }
    });
    return {
      message: `${result.count} categories removed successfully`,
      removedCount: result.count
    };
  },
  async setCategories(productId, categoryIds) {
    const product = await db.product.findUnique({
      where: { id: productId }
    });
    if (!product) {
      throw new Error("Product not found");
    }
    if (categoryIds.length > 0) {
      const existingCategories = await db.category.findMany({
        where: { id: { in: categoryIds } },
        select: { id: true }
      });
      if (existingCategories.length !== categoryIds.length) {
        const foundIds = existingCategories.map((c) => c.id);
        const notFoundIds = categoryIds.filter((id) => !foundIds.includes(id));
        throw new Error(`Categories not found: ${notFoundIds.join(", ")}`);
      }
    }
    await db.productCategory.deleteMany({
      where: { productId }
    });
    if (categoryIds.length > 0) {
      await db.productCategory.createMany({
        data: categoryIds.map((categoryId) => ({
          productId,
          categoryId
        }))
      });
    }
    const updatedCategories = await db.productCategory.findMany({
      where: { productId },
      select: {
        category: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true,
            color: true,
            icon: true
          }
        }
      }
    });
    return {
      message: "Categories updated successfully",
      categories: updatedCategories.map((pc) => pc.category)
    };
  },
  async bulkDelete(ids) {
    if (!ids || ids.length === 0) {
      throw new Error("No product IDs provided");
    }
    const errors = [];
    let deletedCount = 0;
    for (const id of ids) {
      try {
        const product = await db.product.findUnique({
          where: { id },
          include: {
            movements: {
              select: { id: true }
            }
          }
        });
        if (!product) {
          errors.push(`Product ${id} not found`);
          continue;
        }
        if (product.movements.length > 0) {
          await db.movement.deleteMany({
            where: { productId: id }
          });
        }
        await db.product.delete({
          where: { id }
        });
        deletedCount++;
      } catch (error) {
        errors.push(`Failed to delete product ${id}: ${error.message}`);
      }
    }
    return {
      deleted: deletedCount,
      errors
    };
  }
};

// src/features/product/queries/product.queries.ts
init_prisma();
async function calculateCurrentStock(productId) {
  const movements = await db.movement.findMany({
    where: { productId },
    select: {
      type: true,
      quantity: true
    }
  });
  let currentStock = 0;
  movements.forEach((movement) => {
    if (movement.type === "ENTRADA") {
      currentStock += movement.quantity;
    } else {
      currentStock -= movement.quantity;
    }
  });
  return currentStock;
}
var ProductQueries = {
  async getById(id, storeId) {
    const product = await db.product.findUnique({
      where: { id, storeId },
      include: {
        categories: {
          select: {
            category: {
              select: {
                id: true,
                name: true,
                description: true,
                code: true,
                color: true,
                icon: true
              }
            }
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true,
            cnpj: true,
            tradeName: true
          }
        },
        store: {
          select: {
            id: true,
            name: true,
            cnpj: true
          }
        }
      }
    });
    if (!product) {
      return null;
    }
    const currentStock = await calculateCurrentStock(product.id);
    const transformedProduct = {
      ...product,
      categories: product.categories.map((pc) => pc.category),
      currentStock
    };
    return transformedProduct;
  },
  async list(params) {
    const { page = 1, limit = 10, search, status, categoryIds, supplierId, storeId } = params;
    const skip = (page - 1) * limit;
    const where = {};
    if (status !== void 0) {
      where.status = status;
    }
    if (categoryIds && categoryIds.length > 0) {
      where.categories = {
        some: {
          categoryId: { in: categoryIds }
        }
      };
    }
    if (supplierId) {
      where.supplierId = supplierId;
    }
    if (storeId) {
      where.storeId = storeId;
    }
    if (search) {
      where.OR = [
        { name: { contains: search, mode: "insensitive" } },
        { description: { contains: search, mode: "insensitive" } }
      ];
    }
    const [products, total] = await Promise.all([
      db.product.findMany({
        where,
        skip,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          categories: {
            select: {
              category: {
                select: {
                  id: true,
                  name: true,
                  description: true,
                  code: true,
                  color: true,
                  icon: true
                }
              }
            }
          },
          supplier: {
            select: {
              id: true,
              corporateName: true,
              cnpj: true,
              tradeName: true
            }
          },
          store: {
            select: {
              id: true,
              name: true,
              cnpj: true
            }
          }
        }
      }),
      db.product.count({ where })
    ]);
    const itemsWithStock = await Promise.all(
      products.map(async (product) => {
        const currentStock = await calculateCurrentStock(product.id);
        return {
          ...product,
          categories: product.categories.map((pc) => pc.category),
          currentStock
        };
      })
    );
    return {
      items: itemsWithStock,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async search(term, params = {}) {
    const { page = 1, limit = 10, storeId } = params;
    const skip = (page - 1) * limit;
    const where = {
      OR: [
        { name: { contains: term, mode: "insensitive" } },
        { description: { contains: term, mode: "insensitive" } },
        { categories: { some: { category: { name: { contains: term, mode: "insensitive" } } } } },
        { supplier: { corporateName: { contains: term, mode: "insensitive" } } },
        { supplier: { tradeName: { contains: term, mode: "insensitive" } } }
      ]
    };
    if (storeId) {
      where.storeId = storeId;
    }
    const [products, total] = await Promise.all([
      db.product.findMany({
        where,
        skip,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          categories: {
            select: {
              category: {
                select: {
                  id: true,
                  name: true,
                  description: true,
                  code: true,
                  color: true,
                  icon: true
                }
              }
            }
          },
          supplier: {
            select: {
              id: true,
              corporateName: true,
              cnpj: true,
              tradeName: true
            }
          },
          store: {
            select: {
              id: true,
              name: true,
              cnpj: true
            }
          }
        }
      }),
      db.product.count({ where })
    ]);
    const productsWithStock = await Promise.all(
      products.map(async (product) => {
        const currentStock = await calculateCurrentStock(product.id);
        return {
          ...product,
          categories: product.categories.map((pc) => pc.category),
          currentStock
        };
      })
    );
    return {
      items: productsWithStock,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getActive(storeId) {
    const products = await db.product.findMany({
      where: {
        status: true,
        storeId
      },
      orderBy: { createdAt: "desc" },
      include: {
        categories: {
          select: {
            category: {
              select: {
                id: true,
                name: true,
                description: true,
                code: true,
                color: true,
                icon: true
              }
            }
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true,
            cnpj: true,
            tradeName: true
          }
        },
        store: {
          select: {
            id: true,
            name: true,
            cnpj: true
          }
        }
      }
    });
    const productsWithStock = await Promise.all(
      products.map(async (product) => {
        const currentStock = await calculateCurrentStock(product.id);
        return {
          ...product,
          categories: product.categories.map((pc) => pc.category),
          currentStock
        };
      })
    );
    return productsWithStock;
  },
  async getStats(storeId) {
    const [total, active, inactive] = await Promise.all([
      db.product.count({ where: { storeId } }),
      db.product.count({ where: { status: true, storeId } }),
      db.product.count({ where: { status: false, storeId } })
    ]);
    return {
      total,
      active,
      inactive
    };
  },
  async getByCategory(categoryId, storeId) {
    const products = await db.product.findMany({
      where: {
        categories: {
          some: {
            categoryId
          }
        }
      },
      orderBy: { createdAt: "desc" },
      include: {
        categories: {
          select: {
            category: {
              select: {
                id: true,
                name: true,
                description: true,
                code: true,
                color: true,
                icon: true
              }
            }
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true,
            cnpj: true,
            tradeName: true
          }
        },
        store: {
          select: {
            id: true,
            name: true,
            cnpj: true
          }
        }
      }
    });
    const productsWithStock = await Promise.all(
      products.map(async (product) => {
        const currentStock = await calculateCurrentStock(product.id);
        return {
          ...product,
          categories: product.categories.map((pc) => pc.category),
          currentStock
        };
      })
    );
    return productsWithStock;
  },
  async getBySupplier(supplierId, storeId) {
    const products = await db.product.findMany({
      where: { supplierId },
      orderBy: { createdAt: "desc" },
      include: {
        categories: {
          select: {
            category: {
              select: {
                id: true,
                name: true,
                description: true,
                code: true,
                color: true,
                icon: true
              }
            }
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true,
            cnpj: true,
            tradeName: true
          }
        },
        store: {
          select: {
            id: true,
            name: true,
            cnpj: true
          }
        }
      }
    });
    const productsWithStock = await Promise.all(
      products.map(async (product) => {
        const currentStock = await calculateCurrentStock(product.id);
        return {
          ...product,
          currentStock
        };
      })
    );
    return productsWithStock;
  },
  async getByStore(storeId) {
    const products = await db.product.findMany({
      where: { storeId },
      orderBy: { createdAt: "desc" },
      include: {
        categories: {
          select: {
            category: {
              select: {
                id: true,
                name: true,
                description: true,
                code: true,
                color: true,
                icon: true
              }
            }
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true,
            cnpj: true,
            tradeName: true
          }
        },
        store: {
          select: {
            id: true,
            name: true,
            cnpj: true
          }
        }
      }
    });
    const productsWithStock = await Promise.all(
      products.map(async (product) => {
        const currentStock = await calculateCurrentStock(product.id);
        return {
          ...product,
          categories: product.categories.map((pc) => pc.category),
          currentStock
        };
      })
    );
    return productsWithStock;
  },
  // === FUNÇÕES ADICIONAIS DE PRODUTO ===
  async getProductMovements(productId, params) {
    const { page = 1, limit = 10, type, startDate, endDate } = params;
    const skip = (page - 1) * limit;
    const product = await db.product.findUnique({
      where: { id: productId }
    });
    if (!product) {
      throw new Error("Product not found");
    }
    const where = {
      productId
    };
    if (type) {
      where.type = type;
    }
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) {
        where.createdAt.gte = new Date(startDate);
      }
      if (endDate) {
        where.createdAt.lte = new Date(endDate);
      }
    }
    const [items, total] = await Promise.all([
      db.movement.findMany({
        where,
        skip,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          product: {
            select: {
              id: true,
              name: true,
              unitOfMeasure: true
            }
          },
          supplier: {
            select: {
              id: true,
              corporateName: true,
              cnpj: true
            }
          },
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          },
          store: {
            select: {
              id: true,
              name: true,
              cnpj: true
            }
          }
        }
      }),
      db.movement.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getProductStockHistory(productId, limit = 30) {
    const product = await db.product.findUnique({
      where: { id: productId }
    });
    if (!product) {
      throw new Error("Product not found");
    }
    const movements = await db.movement.findMany({
      where: { productId },
      take: limit,
      orderBy: { createdAt: "desc" },
      include: {
        supplier: {
          select: {
            id: true,
            corporateName: true,
            cnpj: true
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    let currentStock = 0;
    const stockHistory = movements.map((movement) => {
      if (movement.type === "ENTRADA") {
        currentStock += movement.quantity;
      } else {
        currentStock -= movement.quantity;
      }
      return {
        ...movement,
        balanceAfter: currentStock
      };
    }).reverse();
    return {
      product: {
        id: product.id,
        name: product.name,
        stockMin: product.stockMin,
        stockMax: product.stockMax,
        alertPercentage: product.alertPercentage
      },
      currentStock,
      history: stockHistory
    };
  },
  async getLowStockProducts(storeId) {
    const where = {
      status: true
    };
    if (storeId) {
      where.storeId = storeId;
    }
    const products = await db.product.findMany({
      where,
      include: {
        movements: {
          select: {
            type: true,
            quantity: true
          }
        },
        categories: {
          select: {
            category: {
              select: {
                id: true,
                name: true
              }
            }
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true
          }
        },
        store: {
          select: {
            id: true,
            name: true
          }
        }
      }
    });
    const lowStockProducts = products.filter((product) => {
      let currentStock = 0;
      product.movements.forEach((movement) => {
        if (movement.type === "ENTRADA") {
          currentStock += movement.quantity;
        } else {
          currentStock -= movement.quantity;
        }
      });
      return currentStock <= product.stockMin;
    }).map((product) => {
      let currentStock = 0;
      product.movements.forEach((movement) => {
        if (movement.type === "ENTRADA") {
          currentStock += movement.quantity;
        } else {
          currentStock -= movement.quantity;
        }
      });
      return {
        ...product,
        categories: product.categories.map((pc) => pc.category),
        currentStock,
        stockStatus: currentStock <= 0 ? "CRITICAL" : "LOW"
      };
    });
    return lowStockProducts;
  },
  async getProductAnalytics(productId) {
    const product = await db.product.findUnique({
      where: { id: productId }
    });
    if (!product) {
      throw new Error("Product not found");
    }
    const movements = await db.movement.findMany({
      where: { productId },
      include: {
        supplier: {
          select: {
            id: true,
            corporateName: true
          }
        }
      }
    });
    const totalMovements = movements.length;
    const entradaMovements = movements.filter((m) => m.type === "ENTRADA");
    const saidaMovements = movements.filter((m) => m.type === "SAIDA");
    const perdaMovements = movements.filter((m) => m.type === "PERDA");
    const totalEntrada = entradaMovements.reduce((sum, m) => sum + m.quantity, 0);
    const totalSaida = saidaMovements.reduce((sum, m) => sum + m.quantity, 0);
    const totalPerda = perdaMovements.reduce((sum, m) => sum + m.quantity, 0);
    const currentStock = totalEntrada - totalSaida - totalPerda;
    const monthlyMovements = movements.reduce((acc, movement) => {
      const month = movement.createdAt.toISOString().substring(0, 7);
      if (!acc[month]) {
        acc[month] = { entrada: 0, saida: 0, perda: 0 };
      }
      acc[month][movement.type.toLowerCase()] += movement.quantity;
      return acc;
    }, {});
    const supplierStats = movements.filter((m) => m.supplierId).reduce((acc, movement) => {
      const supplierId = movement.supplierId;
      if (!acc[supplierId]) {
        acc[supplierId] = {
          supplier: movement.supplier,
          totalMovements: 0,
          totalQuantity: 0
        };
      }
      acc[supplierId].totalMovements++;
      acc[supplierId].totalQuantity += movement.quantity;
      return acc;
    }, {});
    return {
      product: {
        id: product.id,
        name: product.name,
        stockMin: product.stockMin,
        stockMax: product.stockMax,
        alertPercentage: product.alertPercentage
      },
      currentStock,
      statistics: {
        totalMovements,
        totalEntrada,
        totalSaida,
        totalPerda,
        monthlyMovements,
        supplierStats: Object.values(supplierStats)
      }
    };
  },
  // === MÉTODOS PARA GERENCIAR CATEGORIAS DO PRODUTO ===
  async getCategories(productId) {
    const product = await db.product.findUnique({
      where: { id: productId }
    });
    if (!product) {
      throw new Error("Product not found");
    }
    const categories = await db.productCategory.findMany({
      where: { productId },
      select: {
        category: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true,
            color: true,
            icon: true
          }
        }
      }
    });
    return {
      categories: categories.map((pc) => pc.category)
    };
  },
  async getProductsByCategories(categoryIds, storeId, params) {
    const { page = 1, limit = 10, search, status } = params;
    const skip = (page - 1) * limit;
    const where = {
      categories: {
        some: {
          categoryId: { in: categoryIds }
        }
      }
    };
    if (status !== void 0) {
      where.status = status;
    }
    if (search) {
      where.OR = [
        { name: { contains: search, mode: "insensitive" } },
        { description: { contains: search, mode: "insensitive" } }
      ];
    }
    const [products, total] = await Promise.all([
      db.product.findMany({
        where,
        skip,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          categories: {
            select: {
              category: {
                select: {
                  id: true,
                  name: true,
                  description: true,
                  code: true,
                  color: true,
                  icon: true
                }
              }
            }
          },
          supplier: {
            select: {
              id: true,
              corporateName: true,
              cnpj: true,
              tradeName: true
            }
          },
          store: {
            select: {
              id: true,
              name: true,
              cnpj: true
            }
          }
        }
      }),
      db.product.count({ where })
    ]);
    const totalPages = Math.ceil(total / limit);
    const transformedProducts = products.map((product) => ({
      ...product,
      categories: product.categories.map((pc) => pc.category)
    }));
    return {
      products: transformedProducts,
      pagination: {
        page,
        limit,
        total,
        totalPages
      }
    };
  }
};

// src/features/product/product.controller.ts
var ProductController = {
  // === CRUD BÁSICO ===
  async create(request, reply) {
    try {
      const { name, description, unitOfMeasure, referencePrice, categoryIds, supplierId, storeId, stockMin, stockMax, alertPercentage, status } = request.body;
      let finalStoreId = storeId;
      if (!finalStoreId) {
        if (!request.user?.id) {
          return reply.status(401).send({
            error: "Authentication required to determine store"
          });
        }
        const userStore = await getUserStore(request.user.id);
        finalStoreId = userStore.id;
      }
      const result = await ProductCommands.create({
        name,
        description,
        unitOfMeasure,
        referencePrice,
        categoryIds,
        supplierId,
        storeId: finalStoreId,
        stockMin,
        stockMax,
        alertPercentage,
        status
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product with this name already exists") {
        return reply.status(400).send({
          error: error.message
        });
      }
      if (error.message.includes("Categories not found")) {
        return reply.status(400).send({
          error: error.message
        });
      }
      if (error.message === "User has no associated store") {
        return reply.status(400).send({
          error: "User has no associated store. Please provide a storeId or ensure user has access to a store."
        });
      }
      if (error.code === "P2003") {
        return reply.status(400).send({
          error: "Invalid supplier or store reference"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await ProductQueries.getById(id, storeId);
      if (!result) {
        return reply.status(404).send({
          error: "Product not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      const result = await ProductCommands.update(id, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.code === "P2025") {
        return reply.status(404).send({
          error: "Product not found"
        });
      }
      if (error.code === "P2002") {
        return reply.status(400).send({
          error: "Product with this name already exists"
        });
      }
      if (error.message.includes("Categories not found")) {
        return reply.status(400).send({
          error: error.message
        });
      }
      if (error.code === "P2003") {
        return reply.status(400).send({
          error: "Invalid supplier or store reference"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      await ProductCommands.delete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message.includes("Cannot delete product") && error.message.includes("associated movements")) {
        return reply.status(400).send({
          error: error.message,
          suggestion: "Use DELETE /products/:id/force to delete the product and all its movements"
        });
      }
      if (error.code === "P2003") {
        return reply.status(400).send({
          error: "Cannot delete product due to foreign key constraints"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async forceDelete(request, reply) {
    try {
      const { id } = request.params;
      await ProductCommands.forceDelete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { page = 1, limit = 10, search, status, categoryIds, supplierId } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await ProductQueries.list({
        page,
        limit,
        search,
        status,
        categoryIds: categoryIds ? Array.isArray(categoryIds) ? categoryIds : [categoryIds] : void 0,
        supplierId,
        storeId
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (QUERIES) ===
  async getActive(request, reply) {
    try {
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await ProductQueries.getActive(storeId);
      return reply.send({ products: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await ProductQueries.getStats(storeId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { q, limit = 10, page = 1 } = request.query;
      const storeId = request.store?.id;
      const result = await ProductQueries.search(q, {
        page,
        limit,
        storeId
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByCategory(request, reply) {
    try {
      const { categoryId } = request.params;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await ProductQueries.getByCategory(categoryId, storeId);
      return reply.send({ products: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getBySupplier(request, reply) {
    try {
      const { supplierId } = request.params;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await ProductQueries.getBySupplier(supplierId, storeId);
      return reply.send({ products: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByStore(request, reply) {
    try {
      const { storeId } = request.params;
      const result = await ProductQueries.getByStore(storeId);
      return reply.send({ products: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (COMMANDS) ===
  async updateStatus(request, reply) {
    try {
      const { id } = request.params;
      const { status } = request.body;
      const result = await ProductCommands.updateStatus(id, status);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.code === "P2025") {
        return reply.status(404).send({
          error: "Product not found"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS DE PRODUTO ===
  async verifySku(request, reply) {
    try {
      const { id: productId } = request.params;
      const { sku } = request.body;
      const result = await ProductCommands.verifySku(productId, sku);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async updateStock(request, reply) {
    try {
      const { id: productId } = request.params;
      const { quantity, type, note } = request.body;
      const userId = request.user?.id;
      const result = await ProductCommands.updateStock(productId, quantity, type, note, userId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getMovements(request, reply) {
    try {
      const { id: productId } = request.params;
      const { page = 1, limit = 10, type, startDate, endDate } = request.query;
      const result = await ProductQueries.getProductMovements(productId, {
        page,
        limit,
        type,
        startDate,
        endDate
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async createMovement(request, reply) {
    try {
      const { id: productId } = request.params;
      const { type, quantity, supplierId, batch, expiration, price, note } = request.body;
      const userId = request.user?.id;
      const result = await ProductCommands.createMovement(productId, {
        type,
        quantity,
        supplierId,
        batch,
        expiration,
        price,
        note,
        userId
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Supplier not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStock(request, reply) {
    try {
      const { id: productId } = request.params;
      const result = await ProductCommands.getProductStock(productId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStockHistory(request, reply) {
    try {
      const { id: productId } = request.params;
      const { limit = 30 } = request.query;
      const result = await ProductQueries.getProductStockHistory(productId, limit);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getLowStock(request, reply) {
    try {
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await ProductQueries.getLowStockProducts(storeId);
      return reply.send({ products: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getAnalytics(request, reply) {
    try {
      const { id: productId } = request.params;
      const result = await ProductQueries.getProductAnalytics(productId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === MÉTODOS PARA GERENCIAR CATEGORIAS DO PRODUTO ===
  async addCategories(request, reply) {
    try {
      const { id } = request.params;
      const { categoryIds } = request.body;
      const result = await ProductCommands.addCategories(id, categoryIds);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message.includes("Categories not found") || error.message.includes("already associated")) {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async removeCategories(request, reply) {
    try {
      const { id } = request.params;
      const { categoryIds } = request.body;
      const result = await ProductCommands.removeCategories(id, categoryIds);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async setCategories(request, reply) {
    try {
      const { id } = request.params;
      const { categoryIds } = request.body;
      const result = await ProductCommands.setCategories(id, categoryIds);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message.includes("Categories not found")) {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getCategories(request, reply) {
    try {
      const { id } = request.params;
      const result = await ProductQueries.getCategories(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async bulkDelete(request, reply) {
    try {
      const { ids } = request.body;
      if (!ids || !Array.isArray(ids) || ids.length === 0) {
        return reply.status(400).send({
          error: "Product IDs are required and must be a non-empty array"
        });
      }
      const result = await ProductCommands.bulkDelete(ids);
      return reply.send({
        deleted: result.deleted,
        errors: result.errors,
        message: `Successfully deleted ${result.deleted} products${result.errors.length > 0 ? ` with ${result.errors.length} errors` : ""}`
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: error.message || "Internal server error"
      });
    }
  }
};

// src/features/product/product.schema.ts
var createProductSchema = {
  body: {
    type: "object",
    required: ["name", "unitOfMeasure", "referencePrice", "stockMin", "stockMax", "alertPercentage"],
    properties: {
      name: { type: "string", minLength: 1 },
      description: { type: "string" },
      unitOfMeasure: {
        type: "string",
        enum: ["UNIDADE", "KG", "L", "ML", "M", "CM", "MM", "UN", "DZ", "CX", "PCT", "KIT", "PAR", "H", "D"]
      },
      referencePrice: { type: "number", minimum: 0.01 },
      categoryIds: {
        type: "array",
        items: { type: "string", minLength: 1 },
        minItems: 1,
        uniqueItems: true
      },
      supplierId: { type: ["string", "null"], minLength: 1 },
      storeId: { type: "string", minLength: 1 },
      stockMin: { type: "number", minimum: 0 },
      stockMax: { type: "number", minimum: 0 },
      alertPercentage: { type: "number", minimum: 0, maximum: 100 },
      status: { type: "boolean", default: true }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        description: { type: "string", nullable: true },
        unitOfMeasure: { type: "string" },
        referencePrice: { type: "number" },
        supplierId: { type: "string" },
        storeId: { type: "string" },
        stockMin: { type: "number" },
        stockMax: { type: "number" },
        alertPercentage: { type: "number" },
        status: { type: "boolean" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        categories: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              code: { type: "string", nullable: true },
              color: { type: "string", nullable: true },
              icon: { type: "string", nullable: true }
            }
          }
        },
        supplier: { type: "object" },
        store: { type: "object" }
      }
    }
  }
};
var updateProductSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      name: { type: "string", minLength: 1 },
      description: { type: "string" },
      unitOfMeasure: {
        type: "string",
        enum: ["UNIDADE", "KG", "L", "ML", "M", "CM", "MM", "UN", "DZ", "CX", "PCT", "KIT", "PAR", "H", "D"]
      },
      referencePrice: { type: "number", minimum: 0.01 },
      categoryIds: {
        type: "array",
        items: { type: "string", minLength: 1 },
        minItems: 1,
        uniqueItems: true
      },
      supplierId: { type: ["string", "null"], minLength: 1 },
      storeId: { type: "string", minLength: 1 },
      stockMin: { type: "number", minimum: 0 },
      stockMax: { type: "number", minimum: 0 },
      alertPercentage: { type: "number", minimum: 0, maximum: 100 },
      status: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        description: { type: "string", nullable: true },
        unitOfMeasure: { type: "string" },
        referencePrice: { type: "number" },
        supplierId: { type: "string" },
        storeId: { type: "string" },
        stockMin: { type: "number" },
        stockMax: { type: "number" },
        alertPercentage: { type: "number" },
        status: { type: "boolean" },
        updatedAt: { type: "string", format: "date-time" },
        categories: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              code: { type: "string", nullable: true },
              color: { type: "string", nullable: true },
              icon: { type: "string", nullable: true }
            }
          }
        },
        supplier: { type: "object" },
        store: { type: "object" }
      }
    }
  }
};
var getProductSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        description: { type: "string", nullable: true },
        unitOfMeasure: { type: "string" },
        referencePrice: { type: "number" },
        categories: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              code: { type: "string", nullable: true },
              color: { type: "string", nullable: true },
              icon: { type: "string", nullable: true }
            }
          }
        },
        supplierId: { type: "string" },
        storeId: { type: "string" },
        stockMin: { type: "number" },
        stockMax: { type: "number" },
        alertPercentage: { type: "number" },
        status: { type: "boolean" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        category: { type: "object" },
        supplier: { type: "object" },
        store: { type: "object" }
      }
    }
  }
};
var listProductsSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      status: { type: "boolean" },
      categoryIds: {
        type: "array",
        items: { type: "string", minLength: 1 },
        uniqueItems: true
      },
      supplierId: { type: "string" },
      storeId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              unitOfMeasure: { type: "string" },
              referencePrice: { type: "number" },
              categories: {
                type: "array",
                items: {
                  type: "object",
                  properties: {
                    id: { type: "string" },
                    name: { type: "string" },
                    description: { type: "string", nullable: true },
                    code: { type: "string", nullable: true },
                    color: { type: "string", nullable: true },
                    icon: { type: "string", nullable: true }
                  }
                }
              },
              supplierId: { type: "string" },
              storeId: { type: "string" },
              stockMin: { type: "number" },
              stockMax: { type: "number" },
              alertPercentage: { type: "number" },
              status: { type: "boolean" },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" },
              category: { type: "object" },
              supplier: { type: "object" },
              store: { type: "object" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var deleteProductSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" }
  }
};
var updateStatusSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["status"],
    properties: {
      status: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        status: { type: "boolean" },
        category: { type: "object" },
        supplier: { type: "object" },
        store: { type: "object" }
      }
    }
  }
};
var verifySkuSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["sku"],
    properties: {
      sku: { type: "string", minLength: 1 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        available: { type: "boolean" },
        message: { type: "string" }
      }
    }
  }
};
var updateStockSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["quantity", "type"],
    properties: {
      quantity: { type: "number", minimum: 0.01 },
      type: {
        type: "string",
        enum: ["ENTRADA", "SAIDA", "PERDA"]
      },
      note: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        product: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            currentStock: { type: "number" }
          }
        },
        movement: {
          type: "object",
          properties: {
            id: { type: "string" },
            type: { type: "string" },
            quantity: { type: "number" },
            note: { type: "string", nullable: true },
            balanceAfter: { type: "number" },
            createdAt: { type: "string", format: "date-time" },
            supplier: { type: "object", nullable: true },
            user: { type: "object", nullable: true }
          }
        }
      }
    }
  }
};
var getProductMovementsSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      type: {
        type: "string",
        enum: ["ENTRADA", "SAIDA", "PERDA"]
      },
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              type: { type: "string" },
              quantity: { type: "number" },
              batch: { type: "string", nullable: true },
              expiration: { type: "string", format: "date-time", nullable: true },
              price: { type: "number", nullable: true },
              note: { type: "string", nullable: true },
              balanceAfter: { type: "number", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              product: { type: "object" },
              supplier: { type: "object", nullable: true },
              user: { type: "object", nullable: true },
              store: { type: "object" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var createProductMovementSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["type", "quantity"],
    properties: {
      type: {
        type: "string",
        enum: ["ENTRADA", "SAIDA", "PERDA"]
      },
      quantity: { type: "number", minimum: 0.01 },
      supplierId: { type: "string" },
      batch: { type: "string" },
      expiration: { type: "string", format: "date" },
      price: { type: "number", minimum: 0 },
      note: { type: "string" }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        type: { type: "string" },
        quantity: { type: "number" },
        batch: { type: "string", nullable: true },
        expiration: { type: "string", format: "date-time", nullable: true },
        price: { type: "number", nullable: true },
        note: { type: "string", nullable: true },
        balanceAfter: { type: "number" },
        createdAt: { type: "string", format: "date-time" },
        product: { type: "object" },
        supplier: { type: "object", nullable: true },
        user: { type: "object", nullable: true },
        store: { type: "object" }
      }
    }
  }
};
var getProductStockSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        currentStock: { type: "number" },
        stockMin: { type: "number" },
        stockMax: { type: "number" },
        alertPercentage: { type: "number" },
        status: {
          type: "string",
          enum: ["OK", "LOW", "CRITICAL", "OVERSTOCK"]
        },
        lastMovement: {
          type: "object",
          nullable: true,
          properties: {
            type: { type: "string" },
            quantity: { type: "number" },
            date: { type: "string", format: "date-time" }
          }
        }
      }
    }
  }
};
var getProductStockHistorySchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      limit: { type: "number", minimum: 1, maximum: 100, default: 30 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        product: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            stockMin: { type: "number" },
            stockMax: { type: "number" },
            alertPercentage: { type: "number" }
          }
        },
        currentStock: { type: "number" },
        history: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              type: { type: "string" },
              quantity: { type: "number" },
              batch: { type: "string", nullable: true },
              expiration: { type: "string", format: "date-time", nullable: true },
              price: { type: "number", nullable: true },
              note: { type: "string", nullable: true },
              balanceAfter: { type: "number" },
              createdAt: { type: "string", format: "date-time" },
              supplier: { type: "object", nullable: true },
              user: { type: "object", nullable: true }
            }
          }
        }
      }
    }
  }
};
var getLowStockProductsSchema = {
  querystring: {
    type: "object",
    properties: {
      storeId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        products: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              currentStock: { type: "number" },
              stockMin: { type: "number" },
              stockMax: { type: "number" },
              stockStatus: {
                type: "string",
                enum: ["LOW", "CRITICAL"]
              },
              category: { type: "object", nullable: true },
              supplier: { type: "object", nullable: true },
              store: { type: "object" }
            }
          }
        }
      }
    }
  }
};
var getProductAnalyticsSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        product: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            stockMin: { type: "number" },
            stockMax: { type: "number" },
            alertPercentage: { type: "number" }
          }
        },
        currentStock: { type: "number" },
        statistics: {
          type: "object",
          properties: {
            totalMovements: { type: "number" },
            totalEntrada: { type: "number" },
            totalSaida: { type: "number" },
            totalPerda: { type: "number" },
            monthlyMovements: { type: "object" },
            supplierStats: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  supplier: { type: "object" },
                  totalMovements: { type: "number" },
                  totalQuantity: { type: "number" }
                }
              }
            }
          }
        }
      }
    }
  }
};
var addProductCategoriesSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["categoryIds"],
    properties: {
      categoryIds: {
        type: "array",
        items: { type: "string", minLength: 1 },
        minItems: 1,
        uniqueItems: true
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        message: { type: "string" },
        addedCount: { type: "number" },
        categories: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              code: { type: "string", nullable: true },
              color: { type: "string", nullable: true },
              icon: { type: "string", nullable: true }
            }
          }
        }
      }
    }
  }
};
var removeProductCategoriesSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["categoryIds"],
    properties: {
      categoryIds: {
        type: "array",
        items: { type: "string", minLength: 1 },
        minItems: 1,
        uniqueItems: true
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        message: { type: "string" },
        removedCount: { type: "number" }
      }
    }
  }
};
var setProductCategoriesSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["categoryIds"],
    properties: {
      categoryIds: {
        type: "array",
        items: { type: "string", minLength: 1 },
        uniqueItems: true
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        message: { type: "string" },
        categories: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              code: { type: "string", nullable: true },
              color: { type: "string", nullable: true },
              icon: { type: "string", nullable: true }
            }
          }
        }
      }
    }
  }
};
var getProductCategoriesSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        categories: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              code: { type: "string", nullable: true },
              color: { type: "string", nullable: true },
              icon: { type: "string", nullable: true }
            }
          }
        }
      }
    }
  }
};
var getProductsByCategorySchema = {
  params: {
    type: "object",
    required: ["categoryId"],
    properties: {
      categoryId: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      status: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        products: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              unitOfMeasure: { type: "string" },
              referencePrice: { type: "number" },
              stockMin: { type: "number" },
              stockMax: { type: "number" },
              alertPercentage: { type: "number" },
              status: { type: "boolean" },
              createdAt: { type: "string", format: "date-time" },
              supplier: { type: "object", nullable: true },
              store: { type: "object" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var bulkDeleteProductsSchema = {
  body: {
    type: "object",
    required: ["ids"],
    properties: {
      ids: {
        type: "array",
        items: { type: "string", minLength: 1 },
        minItems: 1
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        deleted: { type: "number" },
        errors: {
          type: "array",
          items: { type: "string" }
        }
      }
    }
  }
};
var ProductSchemas = {
  create: createProductSchema,
  update: updateProductSchema,
  get: getProductSchema,
  delete: deleteProductSchema,
  list: listProductsSchema,
  updateStatus: updateStatusSchema,
  bulkDelete: bulkDeleteProductsSchema,
  // Funções adicionais
  verifySku: verifySkuSchema,
  updateStock: updateStockSchema,
  getMovements: getProductMovementsSchema,
  createMovement: createProductMovementSchema,
  getStock: getProductStockSchema,
  getStockHistory: getProductStockHistorySchema,
  getLowStock: getLowStockProductsSchema,
  getAnalytics: getProductAnalyticsSchema,
  // Gerenciar categorias
  addCategories: addProductCategoriesSchema,
  removeCategories: removeProductCategoriesSchema,
  setCategories: setProductCategoriesSchema,
  getCategories: getProductCategoriesSchema,
  getByCategory: getProductsByCategorySchema
};

// src/features/product/product.routes.ts
init_auth_middleware();

// src/middlewares/store-context.middleware.ts
init_prisma();
var getUserStore2 = async (userId) => {
  console.log("getUserStore: Searching for store for user:", userId);
  console.log("getUserStore: Checking owned stores...");
  const ownedStore = await db.store.findFirst({
    where: { ownerId: userId },
    select: { id: true, name: true }
  });
  if (ownedStore) {
    console.log("getUserStore: Found owned store:", ownedStore);
    return ownedStore;
  }
  console.log("getUserStore: Checking store user access...");
  const storeUser = await db.storeUser.findFirst({
    where: { userId },
    include: {
      store: {
        select: { id: true, name: true }
      }
    }
  });
  if (storeUser) {
    console.log("getUserStore: Found store user access:", storeUser);
    return storeUser.store;
  }
  console.log("getUserStore: No store found for user");
  return null;
};
var storeContextMiddleware = async (request, reply) => {
  try {
    console.log("StoreContextMiddleware: Starting...");
    if (!request.user?.id) {
      console.log("StoreContextMiddleware: User not authenticated");
      return reply.status(401).send({
        error: "User not authenticated"
      });
    }
    console.log("StoreContextMiddleware: User authenticated:", request.user.id);
    console.log("StoreContextMiddleware: Getting store for user...");
    const userStore = await getUserStore2(request.user.id);
    if (!userStore) {
      console.log("StoreContextMiddleware: User has no associated store");
      return reply.status(400).send({
        error: "User has no associated store. Please create a store or provide storeId in request."
      });
    }
    console.log("StoreContextMiddleware: Found user store:", userStore);
    request.store = userStore;
    if (request.body && typeof request.body === "object" && !("storeId" in request.body)) {
      console.log("StoreContextMiddleware: Adding storeId to request body");
      request.body.storeId = userStore.id;
    }
    console.log("StoreContextMiddleware: Completed successfully");
    return;
  } catch (error) {
    console.log("StoreContextMiddleware: Error:", error);
    request.log.error(error);
    return reply.status(500).send({
      error: "Internal server error"
    });
  }
};

// src/features/product/product.routes.ts
async function ProductRoutes(fastify2) {
  fastify2.addHook("preHandler", authMiddleware);
  fastify2.addHook("preHandler", storeContextMiddleware);
  fastify2.post("/", {
    schema: ProductSchemas.create,
    handler: ProductController.create
  });
  fastify2.get("/", {
    schema: ProductSchemas.list,
    handler: ProductController.list
  });
  fastify2.get("/:id", {
    schema: ProductSchemas.get,
    handler: ProductController.get
  });
  fastify2.put("/:id", {
    schema: ProductSchemas.update,
    handler: ProductController.update
  });
  fastify2.delete("/:id", {
    schema: ProductSchemas.delete,
    handler: ProductController.delete
  });
  fastify2.delete("/:id/force", {
    schema: ProductSchemas.delete,
    handler: ProductController.forceDelete
  });
  fastify2.get("/active", {
    handler: ProductController.getActive
  });
  fastify2.get("/stats", {
    handler: ProductController.getStats
  });
  fastify2.get("/search", {
    schema: {
      querystring: {
        type: "object",
        properties: {
          q: { type: "string" },
          limit: { type: "number" }
        },
        required: ["q"]
      }
    },
    handler: ProductController.search
  });
  fastify2.post("/bulk-delete", {
    schema: ProductSchemas.bulkDelete,
    handler: ProductController.bulkDelete
  });
  fastify2.get("/category/:categoryId", {
    schema: {
      params: {
        type: "object",
        properties: {
          categoryId: { type: "string" }
        },
        required: ["categoryId"]
      }
    },
    handler: ProductController.getByCategory
  });
  fastify2.get("/supplier/:supplierId", {
    schema: {
      params: {
        type: "object",
        properties: {
          supplierId: { type: "string" }
        },
        required: ["supplierId"]
      }
    },
    handler: ProductController.getBySupplier
  });
  fastify2.get("/store/:storeId", {
    schema: {
      params: {
        type: "object",
        properties: {
          storeId: { type: "string" }
        },
        required: ["storeId"]
      }
    },
    handler: ProductController.getByStore
  });
  fastify2.patch("/:id/status", {
    schema: ProductSchemas.updateStatus,
    handler: ProductController.updateStatus
  });
  fastify2.post("/:id/categories", {
    schema: ProductSchemas.addCategories,
    handler: ProductController.addCategories
  });
  fastify2.delete("/:id/categories", {
    schema: ProductSchemas.removeCategories,
    handler: ProductController.removeCategories
  });
  fastify2.put("/:id/categories", {
    schema: ProductSchemas.setCategories,
    handler: ProductController.setCategories
  });
  fastify2.get("/:id/categories", {
    schema: ProductSchemas.getCategories,
    handler: ProductController.getCategories
  });
}

// src/features/supplier/commands/supplier.commands.ts
init_prisma();
var SupplierCommands = {
  async create(data) {
    const existingSupplier = await db.supplier.findUnique({
      where: {
        cnpj_storeId: {
          cnpj: data.cnpj,
          storeId: data.storeId || null
        }
      }
    });
    if (existingSupplier) {
      throw new Error("CNPJ already exists");
    }
    const responsiblesData = data.responsibles?.map((responsible) => ({
      name: responsible.name,
      phone: responsible.phone,
      email: responsible.email,
      cpf: responsible.cpf,
      status: true
    })) || [];
    return await db.supplier.create({
      data: {
        corporateName: data.corporateName,
        cnpj: data.cnpj,
        tradeName: data.tradeName,
        cep: data.cep,
        city: data.city,
        state: data.state,
        address: data.address,
        storeId: data.storeId,
        status: true,
        responsibles: {
          create: responsiblesData
        }
      },
      include: {
        responsibles: true,
        products: {
          select: {
            id: true,
            name: true,
            status: true
          }
        }
      }
    });
  },
  async update(id, data) {
    const existingSupplier = await db.supplier.findUnique({
      where: { id }
    });
    if (!existingSupplier) {
      throw new Error("Supplier not found");
    }
    if (data.cnpj && data.cnpj !== existingSupplier.cnpj) {
      const cnpjExists = await db.supplier.findUnique({
        where: {
          cnpj_storeId: {
            cnpj: data.cnpj,
            storeId: existingSupplier.storeId
          }
        }
      });
      if (cnpjExists) {
        throw new Error("CNPJ already exists");
      }
    }
    return await db.supplier.update({
      where: { id },
      data,
      include: {
        responsibles: true,
        products: {
          select: {
            id: true,
            name: true,
            status: true
          }
        }
      }
    });
  },
  async delete(id) {
    const existingSupplier = await db.supplier.findUnique({
      where: { id }
    });
    if (!existingSupplier) {
      throw new Error("Supplier not found");
    }
    const productsCount = await db.product.count({
      where: { supplierId: id }
    });
    if (productsCount > 0) {
      throw new Error("Cannot delete supplier with associated products");
    }
    return await db.supplier.delete({
      where: { id }
    });
  },
  async toggleStatus(id) {
    const supplier = await db.supplier.findUnique({
      where: { id }
    });
    if (!supplier) {
      throw new Error("Supplier not found");
    }
    return await db.supplier.update({
      where: { id },
      data: { status: !supplier.status },
      include: {
        responsibles: true,
        products: {
          select: {
            id: true,
            name: true,
            status: true
          }
        }
      }
    });
  }
};

// src/features/supplier/queries/supplier.queries.ts
init_prisma();
var SupplierQueries = {
  async getById(id) {
    const supplier = await db.supplier.findUnique({
      where: { id },
      include: {
        responsibles: true,
        products: {
          select: {
            id: true,
            name: true,
            status: true,
            referencePrice: true,
            stockMin: true,
            stockMax: true
          }
        }
      }
    });
    if (!supplier) {
      throw new Error("Supplier not found");
    }
    return supplier;
  },
  async list(params) {
    const { page = 1, limit = 10, search, status, storeId } = params;
    const skip = (page - 1) * limit;
    const where = {};
    if (search) {
      where.OR = [
        { corporateName: { contains: search, mode: "insensitive" } },
        { tradeName: { contains: search, mode: "insensitive" } },
        { cnpj: { contains: search } },
        { city: { contains: search, mode: "insensitive" } },
        { state: { contains: search, mode: "insensitive" } }
      ];
    }
    if (status !== void 0) {
      where.status = status;
    }
    if (storeId) {
      where.storeId = storeId;
    }
    const [suppliers, total] = await Promise.all([
      db.supplier.findMany({
        where,
        skip,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          responsibles: {
            where: { status: true }
          },
          products: {
            select: {
              id: true,
              name: true,
              status: true
            }
          }
        }
      }),
      db.supplier.count({ where })
    ]);
    return {
      items: suppliers,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getByCnpj(cnpj, storeId) {
    const supplier = await db.supplier.findUnique({
      where: { cnpj_storeId: { cnpj, storeId: storeId || null } },
      include: {
        responsibles: true,
        products: {
          select: {
            id: true,
            name: true,
            status: true
          }
        }
      }
    });
    if (!supplier) {
      throw new Error("Supplier not found");
    }
    return supplier;
  },
  async getByCity(city) {
    return await db.supplier.findMany({
      where: {
        city: { contains: city, mode: "insensitive" },
        status: true
      },
      orderBy: { corporateName: "asc" },
      include: {
        responsibles: {
          where: { status: true }
        }
      }
    });
  },
  async getByState(state) {
    return await db.supplier.findMany({
      where: {
        state: { contains: state, mode: "insensitive" },
        status: true
      },
      orderBy: { corporateName: "asc" },
      include: {
        responsibles: {
          where: { status: true }
        }
      }
    });
  },
  async getActive() {
    return await db.supplier.findMany({
      where: { status: true },
      orderBy: { corporateName: "asc" },
      select: {
        id: true,
        corporateName: true,
        tradeName: true,
        cnpj: true,
        city: true,
        state: true
      }
    });
  },
  async search(term, storeId, params = {}) {
    const { page = 1, limit = 10 } = params;
    const skip = (page - 1) * limit;
    const where = {
      status: true,
      storeId,
      OR: [
        { corporateName: { contains: term, mode: "insensitive" } },
        { tradeName: { contains: term, mode: "insensitive" } },
        { cnpj: { contains: term } }
      ]
    };
    const [items, total] = await Promise.all([
      db.supplier.findMany({
        where,
        skip,
        take: limit,
        orderBy: { corporateName: "asc" },
        select: {
          id: true,
          corporateName: true,
          tradeName: true,
          cnpj: true,
          city: true,
          state: true
        }
      }),
      db.supplier.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getStats() {
    const [total, active, inactive, withProducts] = await Promise.all([
      db.supplier.count(),
      db.supplier.count({ where: { status: true } }),
      db.supplier.count({ where: { status: false } }),
      db.supplier.count({
        where: {
          products: {
            some: {}
          }
        }
      })
    ]);
    return {
      total,
      active,
      inactive,
      withProducts,
      withoutProducts: total - withProducts
    };
  },
  async getTopSuppliers(limit = 5) {
    return await db.supplier.findMany({
      where: { status: true },
      orderBy: {
        products: {
          _count: "desc"
        }
      },
      take: limit,
      select: {
        id: true,
        corporateName: true,
        tradeName: true,
        cnpj: true,
        _count: {
          select: { products: true }
        }
      }
    });
  }
};

// src/features/supplier/supplier.controller.ts
var SupplierController = {
  // === CRUD BÁSICO ===
  async create(request, reply) {
    try {
      const { corporateName, cnpj, tradeName, cep, city, state, address, storeId, responsibles } = request.body;
      const contextStoreId = request.store?.id;
      const result = await SupplierCommands.create({
        corporateName,
        cnpj,
        tradeName,
        cep,
        city,
        state,
        address,
        storeId: storeId || contextStoreId,
        responsibles
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "CNPJ already exists") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      const result = await SupplierQueries.getById(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Supplier not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      const result = await SupplierCommands.update(id, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Supplier not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "CNPJ already exists") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      await SupplierCommands.delete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Supplier not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Cannot delete supplier with associated products") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { page = 1, limit = 10, search, status } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await SupplierQueries.list({
        page,
        limit,
        search,
        status,
        storeId
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (QUERIES) ===
  async getByCnpj(request, reply) {
    try {
      const { cnpj } = request.params;
      const storeId = request.store?.id;
      const result = await SupplierQueries.getByCnpj(cnpj, storeId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Supplier not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByCity(request, reply) {
    try {
      const { city } = request.params;
      const result = await SupplierQueries.getByCity(city);
      return reply.send({ suppliers: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByState(request, reply) {
    try {
      const { state } = request.params;
      const result = await SupplierQueries.getByState(state);
      return reply.send({ suppliers: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getActive(request, reply) {
    try {
      const result = await SupplierQueries.getActive();
      return reply.send({ suppliers: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const result = await SupplierQueries.getStats();
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { q, page = 1, limit = 10 } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await SupplierQueries.search(q, storeId, { page, limit });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getTopSuppliers(request, reply) {
    try {
      const { limit = 5 } = request.query;
      const result = await SupplierQueries.getTopSuppliers(limit);
      return reply.send({ suppliers: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (COMMANDS) ===
  async toggleStatus(request, reply) {
    try {
      const { id } = request.params;
      const result = await SupplierCommands.toggleStatus(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Supplier not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/supplier/supplier.schema.ts
var createSupplierSchema = {
  body: {
    type: "object",
    required: ["corporateName", "cnpj"],
    properties: {
      corporateName: { type: "string", minLength: 1 },
      cnpj: { type: "string", minLength: 14 },
      tradeName: { type: "string" },
      cep: { type: "string" },
      city: { type: "string" },
      state: { type: "string" },
      address: { type: "string" },
      storeId: { type: "string" },
      responsibles: {
        type: "array",
        items: {
          type: "object",
          required: ["name"],
          properties: {
            name: { type: "string", minLength: 1 },
            phone: { type: "string" },
            email: { type: "string", format: "email" },
            cpf: { type: "string" }
          }
        }
      }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        corporateName: { type: "string" },
        cnpj: { type: "string" },
        tradeName: { type: "string", nullable: true },
        cep: { type: "string", nullable: true },
        city: { type: "string", nullable: true },
        state: { type: "string", nullable: true },
        address: { type: "string", nullable: true },
        status: { type: "boolean" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        responsibles: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              phone: { type: "string", nullable: true },
              email: { type: "string", nullable: true },
              cpf: { type: "string", nullable: true },
              status: { type: "boolean" }
            }
          }
        }
      }
    }
  }
};
var updateSupplierSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      corporateName: { type: "string", minLength: 1 },
      cnpj: { type: "string", minLength: 14 },
      tradeName: { type: "string" },
      status: { type: "boolean" },
      cep: { type: "string" },
      city: { type: "string" },
      state: { type: "string" },
      address: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        corporateName: { type: "string" },
        cnpj: { type: "string" },
        tradeName: { type: "string", nullable: true },
        cep: { type: "string", nullable: true },
        city: { type: "string", nullable: true },
        state: { type: "string", nullable: true },
        address: { type: "string", nullable: true },
        status: { type: "boolean" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var getSupplierSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        corporateName: { type: "string" },
        cnpj: { type: "string" },
        tradeName: { type: "string", nullable: true },
        cep: { type: "string", nullable: true },
        city: { type: "string", nullable: true },
        state: { type: "string", nullable: true },
        address: { type: "string", nullable: true },
        status: { type: "boolean" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var deleteSupplierSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" }
  }
};
var listSuppliersSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      status: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              corporateName: { type: "string" },
              cnpj: { type: "string" },
              tradeName: { type: "string", nullable: true },
              cep: { type: "string", nullable: true },
              city: { type: "string", nullable: true },
              state: { type: "string", nullable: true },
              address: { type: "string", nullable: true },
              status: { type: "boolean" },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" },
              responsibles: {
                type: "array",
                items: {
                  type: "object",
                  properties: {
                    id: { type: "string" },
                    name: { type: "string" },
                    email: { type: "string" },
                    phone: { type: "string", nullable: true },
                    status: { type: "boolean" }
                  }
                }
              },
              products: {
                type: "array",
                items: {
                  type: "object",
                  properties: {
                    id: { type: "string" },
                    name: { type: "string" },
                    status: { type: "boolean" }
                  }
                }
              }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getSupplierByCnpjSchema = {
  params: {
    type: "object",
    required: ["cnpj"],
    properties: {
      cnpj: { type: "string", minLength: 14 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        corporateName: { type: "string" },
        cnpj: { type: "string" },
        tradeName: { type: "string", nullable: true },
        cep: { type: "string", nullable: true },
        city: { type: "string", nullable: true },
        state: { type: "string", nullable: true },
        address: { type: "string", nullable: true },
        status: { type: "boolean" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var getSuppliersByCitySchema = {
  params: {
    type: "object",
    required: ["city"],
    properties: {
      city: { type: "string", minLength: 1 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        suppliers: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              corporateName: { type: "string" },
              cnpj: { type: "string" },
              tradeName: { type: "string", nullable: true },
              cep: { type: "string", nullable: true },
              city: { type: "string", nullable: true },
              state: { type: "string", nullable: true },
              address: { type: "string", nullable: true },
              status: { type: "boolean" },
              createdAt: { type: "string", format: "date-time" }
            }
          }
        }
      }
    }
  }
};
var getSuppliersByStateSchema = {
  params: {
    type: "object",
    required: ["state"],
    properties: {
      state: { type: "string", minLength: 1 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        suppliers: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              corporateName: { type: "string" },
              cnpj: { type: "string" },
              tradeName: { type: "string", nullable: true },
              cep: { type: "string", nullable: true },
              city: { type: "string", nullable: true },
              state: { type: "string", nullable: true },
              address: { type: "string", nullable: true },
              status: { type: "boolean" },
              createdAt: { type: "string", format: "date-time" }
            }
          }
        }
      }
    }
  }
};
var searchSuppliersSchema = {
  querystring: {
    type: "object",
    required: ["q"],
    properties: {
      q: { type: "string", minLength: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        suppliers: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              corporateName: { type: "string" },
              cnpj: { type: "string" },
              tradeName: { type: "string", nullable: true },
              cep: { type: "string", nullable: true },
              city: { type: "string", nullable: true },
              state: { type: "string", nullable: true },
              address: { type: "string", nullable: true },
              status: { type: "boolean" },
              createdAt: { type: "string", format: "date-time" }
            }
          }
        }
      }
    }
  }
};
var SupplierSchemas = {
  create: createSupplierSchema,
  update: updateSupplierSchema,
  get: getSupplierSchema,
  delete: deleteSupplierSchema,
  list: listSuppliersSchema,
  getByCnpj: getSupplierByCnpjSchema,
  getByCity: getSuppliersByCitySchema,
  getByState: getSuppliersByStateSchema,
  search: searchSuppliersSchema
};

// src/features/supplier/commands/supplier-responsible.commands.ts
init_prisma();
var SupplierResponsibleCommands = {
  async create({ supplierId, data }) {
    const supplier = await db.supplier.findUnique({
      where: { id: supplierId }
    });
    if (!supplier) {
      throw new Error("Supplier not found");
    }
    if (data.email) {
      const existingEmail = await db.supplierResponsible.findFirst({
        where: {
          supplierId,
          email: data.email
        }
      });
      if (existingEmail) {
        throw new Error("Email already exists for this supplier");
      }
    }
    if (data.cpf) {
      const existingCpf = await db.supplierResponsible.findFirst({
        where: {
          supplierId,
          cpf: data.cpf
        }
      });
      if (existingCpf) {
        throw new Error("CPF already exists for this supplier");
      }
    }
    return await db.supplierResponsible.create({
      data: {
        ...data,
        supplierId,
        status: true
      }
    });
  },
  async update({ supplierId, responsibleId, data }) {
    const existingResponsible = await db.supplierResponsible.findFirst({
      where: {
        id: responsibleId,
        supplierId
      }
    });
    if (!existingResponsible) {
      throw new Error("Responsible not found for this supplier");
    }
    if (data.email) {
      const existingEmail = await db.supplierResponsible.findFirst({
        where: {
          supplierId,
          email: data.email,
          id: { not: responsibleId }
        }
      });
      if (existingEmail) {
        throw new Error("Email already exists for another responsible of this supplier");
      }
    }
    if (data.cpf) {
      const existingCpf = await db.supplierResponsible.findFirst({
        where: {
          supplierId,
          cpf: data.cpf,
          id: { not: responsibleId }
        }
      });
      if (existingCpf) {
        throw new Error("CPF already exists for another responsible of this supplier");
      }
    }
    return await db.supplierResponsible.update({
      where: { id: responsibleId },
      data
    });
  },
  async delete({ supplierId, responsibleId }) {
    const existingResponsible = await db.supplierResponsible.findFirst({
      where: {
        id: responsibleId,
        supplierId
      }
    });
    if (!existingResponsible) {
      throw new Error("Responsible not found for this supplier");
    }
    await db.supplierResponsible.delete({
      where: { id: responsibleId }
    });
  },
  async toggleStatus({ supplierId, responsibleId }) {
    const existingResponsible = await db.supplierResponsible.findFirst({
      where: {
        id: responsibleId,
        supplierId
      }
    });
    if (!existingResponsible) {
      throw new Error("Responsible not found for this supplier");
    }
    return await db.supplierResponsible.update({
      where: { id: responsibleId },
      data: {
        status: !existingResponsible.status
      }
    });
  },
  async bulkCreate({ supplierId, responsibles }) {
    const supplier = await db.supplier.findUnique({
      where: { id: supplierId }
    });
    if (!supplier) {
      throw new Error("Supplier not found");
    }
    const emails = responsibles.filter((r) => r.email).map((r) => r.email);
    const cpfs = responsibles.filter((r) => r.cpf).map((r) => r.cpf);
    if (new Set(emails).size !== emails.length) {
      throw new Error("Duplicate emails found in the provided data");
    }
    if (new Set(cpfs).size !== cpfs.length) {
      throw new Error("Duplicate CPFs found in the provided data");
    }
    if (emails.length > 0) {
      const existingEmails = await db.supplierResponsible.findMany({
        where: {
          supplierId,
          email: { in: emails }
        },
        select: { email: true }
      });
      if (existingEmails.length > 0) {
        throw new Error(`Emails already exist: ${existingEmails.map((e) => e.email).join(", ")}`);
      }
    }
    if (cpfs.length > 0) {
      const existingCpfs = await db.supplierResponsible.findMany({
        where: {
          supplierId,
          cpf: { in: cpfs }
        },
        select: { cpf: true }
      });
      if (existingCpfs.length > 0) {
        throw new Error(`CPFs already exist: ${existingCpfs.map((c) => c.cpf).join(", ")}`);
      }
    }
    return await db.supplierResponsible.createMany({
      data: responsibles.map((responsible) => ({
        ...responsible,
        supplierId,
        status: true
      }))
    });
  }
};

// src/features/supplier/queries/supplier-responsible.queries.ts
init_prisma();
var SupplierResponsibleQueries = {
  async getById({ supplierId, responsibleId }) {
    const responsible = await db.supplierResponsible.findFirst({
      where: {
        id: responsibleId,
        supplierId
      }
    });
    if (!responsible) {
      throw new Error("Responsible not found for this supplier");
    }
    return responsible;
  },
  async list({ supplierId, params }) {
    const { page = 1, limit = 10, search, status } = params;
    const skip = (page - 1) * limit;
    const supplier = await db.supplier.findUnique({
      where: { id: supplierId }
    });
    if (!supplier) {
      throw new Error("Supplier not found");
    }
    const where = {
      supplierId
    };
    if (status !== void 0) {
      where.status = status;
    }
    if (search) {
      where.OR = [
        { name: { contains: search, mode: "insensitive" } },
        { email: { contains: search, mode: "insensitive" } },
        { phone: { contains: search, mode: "insensitive" } },
        { cpf: { contains: search, mode: "insensitive" } }
      ];
    }
    const [responsibles, total] = await Promise.all([
      db.supplierResponsible.findMany({
        where,
        skip,
        take: limit
      }),
      db.supplierResponsible.count({ where })
    ]);
    const totalPages = Math.ceil(total / limit);
    return {
      responsibles,
      pagination: {
        page,
        limit,
        total,
        totalPages
      }
    };
  },
  async getByEmail({ supplierId, email }) {
    const responsible = await db.supplierResponsible.findFirst({
      where: {
        supplierId,
        email
      }
    });
    if (!responsible) {
      throw new Error("Responsible not found with this email for this supplier");
    }
    return responsible;
  },
  async getByCpf({ supplierId, cpf }) {
    const responsible = await db.supplierResponsible.findFirst({
      where: {
        supplierId,
        cpf
      }
    });
    if (!responsible) {
      throw new Error("Responsible not found with this CPF for this supplier");
    }
    return responsible;
  },
  async getActive({ supplierId }) {
    const supplier = await db.supplier.findUnique({
      where: { id: supplierId }
    });
    if (!supplier) {
      throw new Error("Supplier not found");
    }
    return await db.supplierResponsible.findMany({
      where: {
        supplierId,
        status: true
      },
      orderBy: { name: "asc" }
    });
  },
  async getStats({ supplierId }) {
    const supplier = await db.supplier.findUnique({
      where: { id: supplierId }
    });
    if (!supplier) {
      throw new Error("Supplier not found");
    }
    const [total, active, inactive] = await Promise.all([
      db.supplierResponsible.count({
        where: { supplierId }
      }),
      db.supplierResponsible.count({
        where: { supplierId, status: true }
      }),
      db.supplierResponsible.count({
        where: { supplierId, status: false }
      })
    ]);
    return {
      total,
      active,
      inactive
    };
  },
  async search({ supplierId, searchTerm, limit }) {
    const supplier = await db.supplier.findUnique({
      where: { id: supplierId }
    });
    if (!supplier) {
      throw new Error("Supplier not found");
    }
    return await db.supplierResponsible.findMany({
      where: {
        supplierId,
        OR: [
          { name: { contains: searchTerm, mode: "insensitive" } },
          { email: { contains: searchTerm, mode: "insensitive" } },
          { phone: { contains: searchTerm, mode: "insensitive" } },
          { cpf: { contains: searchTerm, mode: "insensitive" } }
        ]
      },
      take: limit,
      orderBy: { name: "asc" }
    });
  },
  async getBySupplier({ supplierId }) {
    const supplier = await db.supplier.findUnique({
      where: { id: supplierId }
    });
    if (!supplier) {
      throw new Error("Supplier not found");
    }
    return await db.supplierResponsible.findMany({
      where: { supplierId },
      orderBy: { name: "asc" }
    });
  },
  async getRecent({ supplierId, limit }) {
    const supplier = await db.supplier.findUnique({
      where: { id: supplierId }
    });
    if (!supplier) {
      throw new Error("Supplier not found");
    }
    return await db.supplierResponsible.findMany({
      where: { supplierId },
      take: limit
    });
  }
};

// src/features/supplier/supplier-responsible.controller.ts
var SupplierResponsibleController = {
  // === CRUD BÁSICO ===
  async create(request, reply) {
    try {
      const { supplierId } = request.params;
      const { name, email, phone, cpf } = request.body;
      const createData = { name, email, phone, cpf };
      const result = await SupplierResponsibleCommands.create({ supplierId, data: createData });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Supplier not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Email already exists for this supplier" || error.message === "CPF already exists for this supplier") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { supplierId, responsibleId } = request.params;
      const result = await SupplierResponsibleQueries.getById({ supplierId, responsibleId });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Responsible not found for this supplier") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { supplierId, responsibleId } = request.params;
      const { name, email, phone, cpf, status } = request.body;
      const updateData = {};
      if (name !== void 0) updateData.name = name;
      if (email !== void 0) updateData.email = email;
      if (phone !== void 0) updateData.phone = phone;
      if (cpf !== void 0) updateData.cpf = cpf;
      if (status !== void 0) updateData.status = status;
      const result = await SupplierResponsibleCommands.update({ supplierId, responsibleId, data: updateData });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Responsible not found for this supplier") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Email already exists for another responsible of this supplier" || error.message === "CPF already exists for another responsible of this supplier") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { supplierId, responsibleId } = request.params;
      await SupplierResponsibleCommands.delete({ supplierId, responsibleId });
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Responsible not found for this supplier") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { supplierId } = request.params;
      const { page = 1, limit = 10, search, status } = request.query;
      const result = await SupplierResponsibleQueries.list({ supplierId, params: { page, limit, search, status } });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Supplier not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (QUERIES) ===
  async getByEmail(request, reply) {
    try {
      const { supplierId, email } = request.params;
      const result = await SupplierResponsibleQueries.getByEmail({ supplierId, email });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Responsible not found with this email for this supplier") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByCpf(request, reply) {
    try {
      const { supplierId, cpf } = request.params;
      const result = await SupplierResponsibleQueries.getByCpf({ supplierId, cpf });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Responsible not found with this CPF for this supplier") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getActive(request, reply) {
    try {
      const { supplierId } = request.params;
      const result = await SupplierResponsibleQueries.getActive({ supplierId });
      return reply.send({ responsibles: result });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Supplier not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const { supplierId } = request.params;
      const result = await SupplierResponsibleQueries.getStats({ supplierId });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Supplier not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { supplierId } = request.params;
      const { q, limit = 10 } = request.query;
      const result = await SupplierResponsibleQueries.search({ supplierId, searchTerm: q, limit });
      return reply.send({ responsibles: result });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Supplier not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getRecent(request, reply) {
    try {
      const { supplierId } = request.params;
      const { limit = 5 } = request.query;
      const result = await SupplierResponsibleQueries.getRecent({ supplierId, limit });
      return reply.send({ responsibles: result });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Supplier not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (COMMANDS) ===
  async toggleStatus(request, reply) {
    try {
      const { supplierId, responsibleId } = request.params;
      const result = await SupplierResponsibleCommands.toggleStatus({ supplierId, responsibleId });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Responsible not found for this supplier") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async bulkCreate(request, reply) {
    try {
      const { supplierId } = request.params;
      const responsibles = request.body;
      const filteredResponsibles = responsibles.map((responsible) => ({
        name: responsible.name,
        email: responsible.email,
        phone: responsible.phone,
        cpf: responsible.cpf
      }));
      const result = await SupplierResponsibleCommands.bulkCreate({ supplierId, responsibles: filteredResponsibles });
      return reply.status(201).send({
        message: `${result.count} responsibles created successfully`,
        count: result.count
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Supplier not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message.includes("already exist") || error.message.includes("Duplicate")) {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/supplier/supplier-responsible.schema.ts
var createSupplierResponsibleSchema = {
  params: {
    type: "object",
    required: ["supplierId"],
    properties: {
      supplierId: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["name"],
    properties: {
      name: { type: "string", minLength: 1 },
      email: { type: "string", format: "email" },
      phone: { type: "string" },
      cpf: { type: "string", minLength: 11, maxLength: 14 }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        email: { type: "string", nullable: true },
        phone: { type: "string", nullable: true },
        cpf: { type: "string", nullable: true },
        status: { type: "boolean" },
        supplierId: { type: "string" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var updateSupplierResponsibleSchema = {
  params: {
    type: "object",
    required: ["supplierId", "responsibleId"],
    properties: {
      supplierId: { type: "string" },
      responsibleId: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      name: { type: "string", minLength: 1 },
      email: { type: "string", format: "email" },
      phone: { type: "string" },
      cpf: { type: "string", minLength: 11, maxLength: 14 },
      status: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        email: { type: "string", nullable: true },
        phone: { type: "string", nullable: true },
        cpf: { type: "string", nullable: true },
        status: { type: "boolean" },
        supplierId: { type: "string" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var getSupplierResponsibleSchema = {
  params: {
    type: "object",
    required: ["supplierId", "responsibleId"],
    properties: {
      supplierId: { type: "string" },
      responsibleId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        email: { type: "string", nullable: true },
        phone: { type: "string", nullable: true },
        cpf: { type: "string", nullable: true },
        status: { type: "boolean" },
        supplierId: { type: "string" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var deleteSupplierResponsibleSchema = {
  params: {
    type: "object",
    required: ["supplierId", "responsibleId"],
    properties: {
      supplierId: { type: "string" },
      responsibleId: { type: "string" }
    }
  },
  response: {
    204: { type: "null" }
  }
};
var listSupplierResponsiblesSchema = {
  params: {
    type: "object",
    required: ["supplierId"],
    properties: {
      supplierId: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      status: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        responsibles: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              email: { type: "string", nullable: true },
              phone: { type: "string", nullable: true },
              cpf: { type: "string", nullable: true },
              status: { type: "boolean" },
              supplierId: { type: "string" },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getSupplierResponsibleByEmailSchema = {
  params: {
    type: "object",
    required: ["supplierId", "email"],
    properties: {
      supplierId: { type: "string" },
      email: { type: "string", format: "email" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        email: { type: "string", nullable: true },
        phone: { type: "string", nullable: true },
        cpf: { type: "string", nullable: true },
        status: { type: "boolean" },
        supplierId: { type: "string" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var getSupplierResponsibleByCpfSchema = {
  params: {
    type: "object",
    required: ["supplierId", "cpf"],
    properties: {
      supplierId: { type: "string" },
      cpf: { type: "string", minLength: 11, maxLength: 14 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        email: { type: "string", nullable: true },
        phone: { type: "string", nullable: true },
        cpf: { type: "string", nullable: true },
        status: { type: "boolean" },
        supplierId: { type: "string" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var SupplierResponsibleSchemas = {
  create: createSupplierResponsibleSchema,
  update: updateSupplierResponsibleSchema,
  get: getSupplierResponsibleSchema,
  delete: deleteSupplierResponsibleSchema,
  list: listSupplierResponsiblesSchema,
  getByEmail: getSupplierResponsibleByEmailSchema,
  getByCpf: getSupplierResponsibleByCpfSchema
};

// src/features/supplier/supplier-responsible.routes.ts
init_auth_middleware();
async function SupplierResponsibleRoutes(fastify2) {
  fastify2.post("/:supplierId/responsibles", {
    schema: SupplierResponsibleSchemas.create,
    preHandler: [authMiddleware],
    handler: SupplierResponsibleController.create
  });
  fastify2.get("/:supplierId/responsibles", {
    schema: SupplierResponsibleSchemas.list,
    handler: SupplierResponsibleController.list
  });
  fastify2.get("/:supplierId/responsibles/:responsibleId", {
    schema: SupplierResponsibleSchemas.get,
    handler: SupplierResponsibleController.get
  });
  fastify2.put("/:supplierId/responsibles/:responsibleId", {
    schema: SupplierResponsibleSchemas.update,
    preHandler: [authMiddleware],
    handler: SupplierResponsibleController.update
  });
  fastify2.delete("/:supplierId/responsibles/:responsibleId", {
    schema: SupplierResponsibleSchemas.delete,
    preHandler: [authMiddleware],
    handler: SupplierResponsibleController.delete
  });
  fastify2.get("/:supplierId/responsibles/email/:email", {
    schema: SupplierResponsibleSchemas.getByEmail,
    handler: SupplierResponsibleController.getByEmail
  });
  fastify2.get("/:supplierId/responsibles/cpf/:cpf", {
    schema: SupplierResponsibleSchemas.getByCpf,
    handler: SupplierResponsibleController.getByCpf
  });
  fastify2.get("/:supplierId/responsibles/active", {
    handler: SupplierResponsibleController.getActive
  });
  fastify2.get("/:supplierId/responsibles/stats", {
    handler: SupplierResponsibleController.getStats
  });
  fastify2.get("/:supplierId/responsibles/search", {
    handler: SupplierResponsibleController.search
  });
  fastify2.get("/:supplierId/responsibles/recent", {
    handler: SupplierResponsibleController.getRecent
  });
  fastify2.patch("/:supplierId/responsibles/:responsibleId/toggle-status", {
    preHandler: [authMiddleware],
    handler: SupplierResponsibleController.toggleStatus
  });
  fastify2.post("/:supplierId/responsibles/bulk", {
    preHandler: [authMiddleware],
    handler: SupplierResponsibleController.bulkCreate
  });
}

// src/features/supplier/supplier.routes.ts
init_auth_middleware();
async function SupplierRoutes(fastify2) {
  fastify2.addHook("preHandler", authMiddleware);
  fastify2.addHook("preHandler", storeContextMiddleware);
  fastify2.post("/", {
    schema: SupplierSchemas.create,
    handler: SupplierController.create
  });
  fastify2.get("/", {
    schema: SupplierSchemas.list,
    handler: SupplierController.list
  });
  fastify2.get("/:id", {
    schema: SupplierSchemas.get,
    handler: SupplierController.get
  });
  fastify2.put("/:id", {
    schema: SupplierSchemas.update,
    handler: SupplierController.update
  });
  fastify2.delete("/:id", {
    schema: SupplierSchemas.delete,
    handler: SupplierController.delete
  });
  fastify2.get("/cnpj/:cnpj", {
    schema: SupplierSchemas.getByCnpj,
    handler: SupplierController.getByCnpj
  });
  fastify2.get("/city/:city", {
    schema: SupplierSchemas.getByCity,
    handler: SupplierController.getByCity
  });
  fastify2.get("/state/:state", {
    schema: SupplierSchemas.getByState,
    handler: SupplierController.getByState
  });
  fastify2.get("/active", {
    handler: SupplierController.getActive
  });
  fastify2.get("/stats", {
    handler: SupplierController.getStats
  });
  fastify2.get("/search", {
    schema: SupplierSchemas.search,
    handler: SupplierController.search
  });
  fastify2.get("/top", {
    handler: SupplierController.getTopSuppliers
  });
  fastify2.patch("/:id/toggle-status", {
    schema: SupplierSchemas.get,
    handler: SupplierController.toggleStatus
  });
  await fastify2.register(SupplierResponsibleRoutes);
}

// src/features/store/commands/store.commands.ts
init_prisma();
var StoreCommands = {
  async create(data) {
    const existingStore = await db.store.findUnique({
      where: { cnpj: data.cnpj }
    });
    if (existingStore) {
      throw new Error("CNPJ already exists");
    }
    const owner = await db.user.findUnique({
      where: { id: data.ownerId }
    });
    if (!owner) {
      throw new Error("Owner not found");
    }
    return await db.store.create({
      data: {
        ownerId: data.ownerId,
        name: data.name,
        cnpj: data.cnpj,
        email: data.email || null,
        phone: data.phone || null,
        cep: data.cep || null,
        city: data.city || null,
        state: data.state || null,
        address: data.address || null,
        status: data.status !== void 0 ? data.status : true
      },
      include: {
        owner: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async update(id, data) {
    const existingStore = await db.store.findUnique({
      where: { id }
    });
    if (!existingStore) {
      throw new Error("Store not found");
    }
    if (data.cnpj && data.cnpj !== existingStore.cnpj) {
      const cnpjExists = await db.store.findUnique({
        where: { cnpj: data.cnpj }
      });
      if (cnpjExists) {
        throw new Error("CNPJ already exists");
      }
    }
    return await db.store.update({
      where: { id },
      data: {
        ...data,
        email: data.email === "" ? null : data.email,
        phone: data.phone === "" ? null : data.phone,
        cep: data.cep === "" ? null : data.cep,
        city: data.city === "" ? null : data.city,
        state: data.state === "" ? null : data.state,
        address: data.address === "" ? null : data.address
      },
      include: {
        owner: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async delete(id) {
    const existingStore = await db.store.findUnique({
      where: { id }
    });
    if (!existingStore) {
      throw new Error("Store not found");
    }
    const productCount = await db.product.count({
      where: { storeId: id }
    });
    if (productCount > 0) {
      throw new Error("Cannot delete store with existing products");
    }
    return await db.store.delete({
      where: { id }
    });
  },
  async toggleStatus(id) {
    const store = await db.store.findUnique({
      where: { id }
    });
    if (!store) {
      throw new Error("Store not found");
    }
    return await db.store.update({
      where: { id },
      data: { status: !store.status },
      include: {
        owner: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async verifyCnpj(cnpj) {
    const store = await db.store.findUnique({
      where: { cnpj }
    });
    return {
      exists: !!store,
      store: store ? {
        id: store.id,
        name: store.name,
        status: store.status
      } : null
    };
  },
  // === GERENCIAMENTO DE USUÁRIOS DA LOJA ===
  async addUser(storeId, userId, role) {
    const store = await db.store.findUnique({
      where: { id: storeId }
    });
    if (!store) {
      throw new Error("Store not found");
    }
    const user = await db.user.findUnique({
      where: { id: userId, status: true }
    });
    if (!user) {
      throw new Error("User not found or inactive");
    }
    const existingStoreUser = await db.storeUser.findUnique({
      where: {
        storeId_userId: {
          storeId,
          userId
        }
      }
    });
    if (existingStoreUser) {
      throw new Error("User already exists in this store");
    }
    return await db.storeUser.create({
      data: {
        storeId,
        userId,
        role
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            status: true,
            lastLoginAt: true
          }
        },
        store: {
          select: {
            id: true,
            name: true,
            cnpj: true
          }
        }
      }
    });
  },
  async removeUser(storeId, userId) {
    const store = await db.store.findUnique({
      where: { id: storeId }
    });
    if (!store) {
      throw new Error("Store not found");
    }
    const storeUser = await db.storeUser.findUnique({
      where: {
        storeId_userId: {
          storeId,
          userId
        }
      }
    });
    if (!storeUser) {
      throw new Error("User not found in this store");
    }
    if (storeUser.role === "OWNER") {
      throw new Error("Cannot remove store owner");
    }
    return await db.storeUser.delete({
      where: {
        storeId_userId: {
          storeId,
          userId
        }
      }
    });
  },
  async updateUserRole(storeId, userId, newRole) {
    const store = await db.store.findUnique({
      where: { id: storeId }
    });
    if (!store) {
      throw new Error("Store not found");
    }
    const storeUser = await db.storeUser.findUnique({
      where: {
        storeId_userId: {
          storeId,
          userId
        }
      }
    });
    if (!storeUser) {
      throw new Error("User not found in this store");
    }
    if (storeUser.role === "OWNER") {
      throw new Error("Cannot change store owner role");
    }
    return await db.storeUser.update({
      where: {
        storeId_userId: {
          storeId,
          userId
        }
      },
      data: {
        role: newRole
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            status: true,
            lastLoginAt: true
          }
        },
        store: {
          select: {
            id: true,
            name: true,
            cnpj: true
          }
        }
      }
    });
  },
  async transferOwnership(storeId, newOwnerId) {
    const store = await db.store.findUnique({
      where: { id: storeId }
    });
    if (!store) {
      throw new Error("Store not found");
    }
    const newOwner = await db.user.findUnique({
      where: { id: newOwnerId, status: true }
    });
    if (!newOwner) {
      throw new Error("New owner not found or inactive");
    }
    const existingStoreUser = await db.storeUser.findUnique({
      where: {
        storeId_userId: {
          storeId,
          userId: newOwnerId
        }
      }
    });
    if (!existingStoreUser) {
      await db.storeUser.create({
        data: {
          storeId,
          userId: newOwnerId,
          role: "OWNER"
        }
      });
    } else {
      await db.storeUser.update({
        where: {
          storeId_userId: {
            storeId,
            userId: newOwnerId
          }
        },
        data: {
          role: "OWNER"
        }
      });
    }
    return await db.store.update({
      where: { id: storeId },
      data: {
        ownerId: newOwnerId
      },
      include: {
        owner: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  }
};

// src/features/store/queries/store.queries.ts
init_prisma();
var StoreQueries = {
  async getById(id) {
    const store = await db.store.findUnique({
      where: { id },
      include: {
        owner: {
          select: {
            id: true,
            name: true,
            email: true
          }
        },
        products: {
          select: {
            id: true,
            name: true,
            referencePrice: true,
            status: true,
            createdAt: true
          }
        },
        _count: {
          select: {
            products: true,
            users: true
          }
        }
      }
    });
    if (!store) {
      throw new Error("Store not found");
    }
    return store;
  },
  async getByCnpj(cnpj) {
    const store = await db.store.findUnique({
      where: { cnpj },
      include: {
        owner: {
          select: {
            id: true,
            name: true,
            email: true
          }
        },
        _count: {
          select: {
            products: true,
            users: true
          }
        }
      }
    });
    if (!store) {
      throw new Error("Store not found");
    }
    return store;
  },
  async list(params) {
    const where = {};
    if (params.search) {
      where.OR = [
        { name: { contains: params.search, mode: "insensitive" } },
        { cnpj: { contains: params.search } },
        { email: { contains: params.search, mode: "insensitive" } }
      ];
    }
    if (params.status !== void 0) {
      where.status = params.status;
    }
    if (params.ownerId) {
      where.ownerId = params.ownerId;
    }
    const result = await PaginationUtils.paginate(db, "store", {
      where,
      include: {
        owner: {
          select: {
            id: true,
            name: true,
            email: true
          }
        },
        _count: {
          select: {
            products: true,
            users: true
          }
        }
      },
      orderBy: { id: "desc" },
      params: {
        page: params.page,
        limit: params.limit
      },
      paginationOptions: {
        defaultPage: 1,
        defaultLimit: 10,
        maxLimit: 100
      }
    });
    return PaginationUtils.transformPaginationResult(
      result,
      "stores"
    );
  },
  async search(term, limit = 10) {
    return await db.store.findMany({
      where: {
        OR: [
          { name: { contains: term, mode: "insensitive" } },
          { cnpj: { contains: term } },
          { email: { contains: term, mode: "insensitive" } }
        ]
      },
      take: limit,
      orderBy: { name: "asc" },
      include: {
        owner: {
          select: {
            id: true,
            name: true,
            email: true
          }
        },
        _count: {
          select: {
            products: true
          }
        }
      }
    });
  },
  async getByOwner(ownerId) {
    return await db.store.findMany({
      where: { ownerId },
      orderBy: { id: "desc" },
      include: {
        _count: {
          select: {
            products: true,
            users: true
          }
        }
      }
    });
  },
  async getActive() {
    return await db.store.findMany({
      where: { status: true },
      orderBy: { name: "asc" },
      select: {
        id: true,
        name: true,
        cnpj: true,
        city: true,
        state: true,
        _count: {
          select: {
            products: true
          }
        }
      }
    });
  },
  async getStats() {
    const [total, active, inactive, withProducts, withoutProducts] = await Promise.all([
      db.store.count(),
      db.store.count({ where: { status: true } }),
      db.store.count({ where: { status: false } }),
      db.store.count({
        where: {
          products: {
            some: {}
          }
        }
      }),
      db.store.count({
        where: {
          products: {
            none: {}
          }
        }
      })
    ]);
    const storesByState = await db.store.groupBy({
      by: ["state"],
      _count: { id: true },
      where: {
        state: { not: null }
      },
      orderBy: { _count: { id: "desc" } },
      take: 10
    });
    return {
      total,
      active,
      inactive,
      withProducts,
      withoutProducts,
      storesByState
    };
  },
  async getRecent(limit = 5) {
    return await db.store.findMany({
      take: limit,
      orderBy: { id: "desc" },
      include: {
        owner: {
          select: {
            id: true,
            name: true,
            email: true
          }
        },
        _count: {
          select: {
            products: true
          }
        }
      }
    });
  },
  // === CONSULTAS PARA GERENCIAMENTO DE USUÁRIOS DA LOJA ===
  async getStoreUsers(storeId, params) {
    const store = await db.store.findUnique({
      where: { id: storeId }
    });
    if (!store) {
      throw new Error("Store not found");
    }
    const where = {
      storeId
    };
    if (params.search) {
      where.user = {
        OR: [
          { name: { contains: params.search, mode: "insensitive" } },
          { email: { contains: params.search, mode: "insensitive" } }
        ]
      };
    }
    if (params.role) {
      where.role = params.role;
    }
    const result = await PaginationUtils.paginate(db, "storeUser", {
      where,
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            status: true,
            lastLoginAt: true,
            createdAt: true
          }
        },
        store: {
          select: {
            id: true,
            name: true,
            cnpj: true
          }
        }
      },
      orderBy: { id: "desc" },
      params: {
        page: params.page,
        limit: params.limit
      },
      paginationOptions: {
        defaultPage: 1,
        defaultLimit: 10,
        maxLimit: 100
      }
    });
    return PaginationUtils.transformPaginationResult(
      result,
      "storeUsers"
    );
  },
  async getStoreUser(storeId, userId) {
    const storeUser = await db.storeUser.findUnique({
      where: {
        storeId_userId: {
          storeId,
          userId
        }
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            status: true,
            lastLoginAt: true,
            createdAt: true
          }
        },
        store: {
          select: {
            id: true,
            name: true,
            cnpj: true
          }
        }
      }
    });
    if (!storeUser) {
      throw new Error("User not found in this store");
    }
    return storeUser;
  },
  async getStoreUsersByRole(storeId, role) {
    return await db.storeUser.findMany({
      where: {
        storeId,
        role
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            status: true,
            lastLoginAt: true
          }
        }
      },
      orderBy: { id: "desc" }
    });
  },
  async getStoreOwner(storeId) {
    const storeUser = await db.storeUser.findFirst({
      where: {
        storeId,
        role: "OWNER"
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            status: true,
            lastLoginAt: true
          }
        }
      }
    });
    if (!storeUser) {
      throw new Error("Store owner not found");
    }
    return storeUser;
  },
  async getStoreAdmins(storeId) {
    return await db.storeUser.findMany({
      where: {
        storeId,
        role: "ADMIN"
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            status: true,
            lastLoginAt: true
          }
        }
      },
      orderBy: { id: "desc" }
    });
  },
  async getStoreManagers(storeId) {
    return await db.storeUser.findMany({
      where: {
        storeId,
        role: "MANAGER"
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            status: true,
            lastLoginAt: true
          }
        }
      },
      orderBy: { id: "desc" }
    });
  },
  async getStoreStaff(storeId) {
    return await db.storeUser.findMany({
      where: {
        storeId,
        role: "STAFF"
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            status: true,
            lastLoginAt: true
          }
        }
      },
      orderBy: { id: "desc" }
    });
  },
  async getStoreUserStats(storeId) {
    const [total, byRole, active, inactive] = await Promise.all([
      db.storeUser.count({
        where: { storeId }
      }),
      db.storeUser.groupBy({
        by: ["role"],
        where: { storeId },
        _count: { id: true }
      }),
      db.storeUser.count({
        where: {
          storeId,
          user: { status: true }
        }
      }),
      db.storeUser.count({
        where: {
          storeId,
          user: { status: false }
        }
      })
    ]);
    return {
      total,
      byRole,
      active,
      inactive
    };
  },
  async searchStoreUsers(storeId, searchTerm, limit = 10) {
    return await db.storeUser.findMany({
      where: {
        storeId,
        user: {
          OR: [
            { name: { contains: searchTerm, mode: "insensitive" } },
            { email: { contains: searchTerm, mode: "insensitive" } }
          ]
        }
      },
      take: limit,
      orderBy: { id: "desc" },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            status: true,
            lastLoginAt: true
          }
        }
      }
    });
  }
};

// src/features/store/store.controller.ts
var StoreController = {
  // === CRUD BÁSICO ===
  async create(request, reply) {
    try {
      const { name, cnpj, email, phone, cep, city, state, address, status } = request.body;
      const ownerId = request.user.id;
      const cleanCnpj = cnpj.replace(/\D/g, "");
      const result = await StoreCommands.create({
        ownerId,
        name,
        cnpj: cleanCnpj,
        email,
        phone,
        cep,
        city,
        state,
        address,
        status
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "CNPJ already exists") {
        return reply.status(400).send({
          error: error.message
        });
      }
      if (error.message === "Owner not found") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      const result = await StoreQueries.getById(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Store not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      if (updateData.cnpj) {
        updateData.cnpj = updateData.cnpj.replace(/\D/g, "");
      }
      const result = await StoreCommands.update(id, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Store not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "CNPJ already exists") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      await StoreCommands.delete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Store not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Cannot delete store with existing products") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { page = 1, limit = 10, search, status } = request.query;
      const userId = request.user?.id;
      if (!userId) {
        return reply.status(401).send({
          error: "User not authenticated"
        });
      }
      const result = await StoreQueries.list({
        page,
        limit,
        search,
        status,
        ownerId: userId
        // Filtrar apenas as lojas do usuário autenticado
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (QUERIES) ===
  async getByCnpj(request, reply) {
    try {
      const { cnpj } = request.params;
      const cleanCnpj = cnpj.replace(/\D/g, "");
      const result = await StoreQueries.getByCnpj(cleanCnpj);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Store not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByOwner(request, reply) {
    try {
      const { ownerId } = request.params;
      const result = await StoreQueries.getByOwner(ownerId);
      return reply.send({ stores: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getActive(request, reply) {
    try {
      const result = await StoreQueries.getActive();
      return reply.send({ stores: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const result = await StoreQueries.getStats();
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { q, limit = 10 } = request.query;
      const result = await StoreQueries.search(q, limit);
      return reply.send({ stores: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getRecent(request, reply) {
    try {
      const { limit = 5 } = request.query;
      const result = await StoreQueries.getRecent(limit);
      return reply.send({ stores: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (COMMANDS) ===
  async verifyCnpj(request, reply) {
    try {
      const { cnpj } = request.params;
      const cleanCnpj = cnpj.replace(/\D/g, "");
      const result = await StoreCommands.verifyCnpj(cleanCnpj);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async toggleStatus(request, reply) {
    try {
      const { id } = request.params;
      const result = await StoreCommands.toggleStatus(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Store not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === GERENCIAMENTO DE USUÁRIOS DA LOJA ===
  async addUser(request, reply) {
    try {
      const { id: storeId } = request.params;
      const { userId, role } = request.body;
      const result = await StoreCommands.addUser(storeId, userId, role);
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Store not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "User not found or inactive") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "User already exists in this store") {
        return reply.status(409).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async removeUser(request, reply) {
    try {
      const { id: storeId, userId } = request.params;
      await StoreCommands.removeUser(storeId, userId);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Store not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "User not found in this store") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Cannot remove store owner") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async updateUserRole(request, reply) {
    try {
      const { id: storeId, userId } = request.params;
      const { role } = request.body;
      const result = await StoreCommands.updateUserRole(storeId, userId, role);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Store not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "User not found in this store") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Cannot change store owner role") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async listUsers(request, reply) {
    try {
      const { id: storeId } = request.params;
      const { page = 1, limit = 10, search, role } = request.query;
      const result = await StoreQueries.getStoreUsers(storeId, {
        page,
        limit,
        search,
        role
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Store not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStoreUser(request, reply) {
    try {
      const { id: storeId, userId } = request.params;
      const result = await StoreQueries.getStoreUser(storeId, userId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Store not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "User not found in this store") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStoreOwner(request, reply) {
    try {
      const { id: storeId } = request.params;
      const result = await StoreQueries.getStoreOwner(storeId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Store not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Store owner not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStoreAdmins(request, reply) {
    try {
      const { id: storeId } = request.params;
      const result = await StoreQueries.getStoreAdmins(storeId);
      return reply.send({ admins: result });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Store not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStoreManagers(request, reply) {
    try {
      const { id: storeId } = request.params;
      const result = await StoreQueries.getStoreManagers(storeId);
      return reply.send({ managers: result });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Store not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStoreStaff(request, reply) {
    try {
      const { id: storeId } = request.params;
      const result = await StoreQueries.getStoreStaff(storeId);
      return reply.send({ staff: result });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Store not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStoreUserStats(request, reply) {
    try {
      const { id: storeId } = request.params;
      const result = await StoreQueries.getStoreUserStats(storeId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Store not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async searchStoreUsers(request, reply) {
    try {
      const { id: storeId } = request.params;
      const { q, limit = 10 } = request.query;
      const result = await StoreQueries.searchStoreUsers(storeId, q, limit);
      return reply.send({ storeUsers: result });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Store not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async transferOwnership(request, reply) {
    try {
      const { id: storeId } = request.params;
      const { newOwnerId } = request.body;
      const result = await StoreCommands.transferOwnership(storeId, newOwnerId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Store not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "New owner not found or inactive") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/store/store.schema.ts
var createStoreSchema = {
  body: {
    type: "object",
    required: ["name", "cnpj"],
    properties: {
      name: { type: "string", minLength: 1, maxLength: 255 },
      cnpj: { type: "string", minLength: 14, maxLength: 18 },
      email: { type: "string", format: "email" },
      phone: { type: "string" },
      cep: { type: "string" },
      city: { type: "string" },
      state: { type: "string" },
      address: { type: "string" },
      status: { type: "boolean", default: true }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        cnpj: { type: "string" },
        email: { type: "string", nullable: true },
        phone: { type: "string", nullable: true },
        cep: { type: "string", nullable: true },
        city: { type: "string", nullable: true },
        state: { type: "string", nullable: true },
        address: { type: "string", nullable: true },
        status: { type: "boolean" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        owner: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" }
          }
        }
      }
    }
  }
};
var updateStoreSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      name: { type: "string", minLength: 1, maxLength: 255 },
      cnpj: { type: "string", minLength: 14, maxLength: 18 },
      email: { type: "string", format: "email" },
      phone: { type: "string" },
      cep: { type: "string" },
      city: { type: "string" },
      state: { type: "string" },
      address: { type: "string" },
      status: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        cnpj: { type: "string" },
        email: { type: "string", nullable: true },
        phone: { type: "string", nullable: true },
        cep: { type: "string", nullable: true },
        city: { type: "string", nullable: true },
        state: { type: "string", nullable: true },
        address: { type: "string", nullable: true },
        status: { type: "boolean" },
        updatedAt: { type: "string", format: "date-time" },
        owner: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" }
          }
        }
      }
    }
  }
};
var getStoreSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        cnpj: { type: "string" },
        email: { type: "string", nullable: true },
        phone: { type: "string", nullable: true },
        cep: { type: "string", nullable: true },
        city: { type: "string", nullable: true },
        state: { type: "string", nullable: true },
        address: { type: "string", nullable: true },
        status: { type: "boolean" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        owner: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" }
          }
        },
        products: { type: "array" },
        _count: {
          type: "object",
          properties: {
            products: { type: "number" },
            users: { type: "number" }
          }
        }
      }
    }
  }
};
var deleteStoreSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" }
  }
};
var listStoresSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      status: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        stores: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              cnpj: { type: "string" },
              email: { type: "string", nullable: true },
              phone: { type: "string", nullable: true },
              cep: { type: "string", nullable: true },
              city: { type: "string", nullable: true },
              state: { type: "string", nullable: true },
              address: { type: "string", nullable: true },
              status: { type: "boolean" },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" },
              owner: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  email: { type: "string" }
                }
              },
              _count: {
                type: "object",
                properties: {
                  products: { type: "number" },
                  users: { type: "number" }
                }
              }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getStoreByCnpjSchema = {
  params: {
    type: "object",
    required: ["cnpj"],
    properties: {
      cnpj: { type: "string", minLength: 14, maxLength: 14 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        cnpj: { type: "string" },
        email: { type: "string", nullable: true },
        phone: { type: "string", nullable: true },
        cep: { type: "string", nullable: true },
        city: { type: "string", nullable: true },
        state: { type: "string", nullable: true },
        address: { type: "string", nullable: true },
        status: { type: "boolean" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        owner: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" }
          }
        },
        _count: {
          type: "object",
          properties: {
            products: { type: "number" },
            users: { type: "number" }
          }
        }
      }
    }
  }
};
var getStoresByOwnerSchema = {
  params: {
    type: "object",
    required: ["ownerId"],
    properties: {
      ownerId: { type: "string", minLength: 1 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        stores: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              cnpj: { type: "string" },
              email: { type: "string", nullable: true },
              phone: { type: "string", nullable: true },
              cep: { type: "string", nullable: true },
              city: { type: "string", nullable: true },
              state: { type: "string", nullable: true },
              address: { type: "string", nullable: true },
              status: { type: "boolean" },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" },
              owner: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  email: { type: "string" }
                }
              },
              _count: {
                type: "object",
                properties: {
                  products: { type: "number" },
                  users: { type: "number" }
                }
              }
            }
          }
        }
      }
    }
  }
};
var verifyCnpjSchema = {
  params: {
    type: "object",
    required: ["cnpj"],
    properties: {
      cnpj: { type: "string", minLength: 14, maxLength: 14 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        available: { type: "boolean" },
        message: { type: "string" }
      }
    }
  }
};
var toggleStatusSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        status: { type: "boolean" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var addUserToStoreSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["userId", "role"],
    properties: {
      userId: { type: "string", minLength: 1 },
      role: {
        type: "string",
        enum: ["OWNER", "ADMIN", "MANAGER", "STAFF"]
      }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: "string" },
        userId: { type: "string" },
        role: { type: "string" },
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" },
            status: { type: "boolean" },
            lastLoginAt: { type: "string", format: "date-time", nullable: true }
          }
        },
        store: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            cnpj: { type: "string" }
          }
        }
      }
    }
  }
};
var removeUserFromStoreSchema = {
  params: {
    type: "object",
    required: ["id", "userId"],
    properties: {
      id: { type: "string" },
      userId: { type: "string" }
    }
  },
  response: {
    204: { type: "null" }
  }
};
var updateUserRoleSchema = {
  params: {
    type: "object",
    required: ["id", "userId"],
    properties: {
      id: { type: "string" },
      userId: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["role"],
    properties: {
      role: {
        type: "string",
        enum: ["OWNER", "ADMIN", "MANAGER", "STAFF"]
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: "string" },
        userId: { type: "string" },
        role: { type: "string" },
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" },
            status: { type: "boolean" },
            lastLoginAt: { type: "string", format: "date-time", nullable: true }
          }
        },
        store: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            cnpj: { type: "string" }
          }
        }
      }
    }
  }
};
var listStoreUsersSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      role: {
        type: "string",
        enum: ["OWNER", "ADMIN", "MANAGER", "STAFF"]
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        storeUsers: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              storeId: { type: "string" },
              userId: { type: "string" },
              role: { type: "string" },
              user: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  email: { type: "string" },
                  status: { type: "boolean" },
                  lastLoginAt: { type: "string", format: "date-time", nullable: true },
                  createdAt: { type: "string", format: "date-time" }
                }
              },
              store: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  cnpj: { type: "string" }
                }
              }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getStoreUserSchema = {
  params: {
    type: "object",
    required: ["id", "userId"],
    properties: {
      id: { type: "string" },
      userId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: "string" },
        userId: { type: "string" },
        role: { type: "string" },
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" },
            status: { type: "boolean" },
            lastLoginAt: { type: "string", format: "date-time", nullable: true },
            createdAt: { type: "string", format: "date-time" }
          }
        },
        store: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            cnpj: { type: "string" }
          }
        }
      }
    }
  }
};
var getStoreOwnerSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: "string" },
        userId: { type: "string" },
        role: { type: "string" },
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" },
            status: { type: "boolean" },
            lastLoginAt: { type: "string", format: "date-time", nullable: true }
          }
        }
      }
    }
  }
};
var getStoreAdminsSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        admins: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              storeId: { type: "string" },
              userId: { type: "string" },
              role: { type: "string" },
              user: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  email: { type: "string" },
                  status: { type: "boolean" },
                  lastLoginAt: { type: "string", format: "date-time", nullable: true }
                }
              }
            }
          }
        }
      }
    }
  }
};
var getStoreManagersSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        managers: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              storeId: { type: "string" },
              userId: { type: "string" },
              role: { type: "string" },
              user: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  email: { type: "string" },
                  status: { type: "boolean" },
                  lastLoginAt: { type: "string", format: "date-time", nullable: true }
                }
              }
            }
          }
        }
      }
    }
  }
};
var getStoreStaffSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        staff: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              storeId: { type: "string" },
              userId: { type: "string" },
              role: { type: "string" },
              user: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  email: { type: "string" },
                  status: { type: "boolean" },
                  lastLoginAt: { type: "string", format: "date-time", nullable: true }
                }
              }
            }
          }
        }
      }
    }
  }
};
var getStoreUserStatsSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        total: { type: "number" },
        byRole: {
          type: "array",
          items: {
            type: "object",
            properties: {
              role: { type: "string" },
              _count: {
                type: "object",
                properties: {
                  id: { type: "number" }
                }
              }
            }
          }
        },
        active: { type: "number" },
        inactive: { type: "number" }
      }
    }
  }
};
var searchStoreUsersSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    required: ["q"],
    properties: {
      q: { type: "string", minLength: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        storeUsers: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              storeId: { type: "string" },
              userId: { type: "string" },
              role: { type: "string" },
              user: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  email: { type: "string" },
                  status: { type: "boolean" },
                  lastLoginAt: { type: "string", format: "date-time", nullable: true }
                }
              }
            }
          }
        }
      }
    }
  }
};
var transferOwnershipSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["newOwnerId"],
    properties: {
      newOwnerId: { type: "string", minLength: 1 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        cnpj: { type: "string" },
        ownerId: { type: "string" },
        owner: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" }
          }
        }
      }
    }
  }
};
var StoreSchemas = {
  create: createStoreSchema,
  update: updateStoreSchema,
  get: getStoreSchema,
  delete: deleteStoreSchema,
  list: listStoresSchema,
  getByCnpj: getStoreByCnpjSchema,
  getByOwner: getStoresByOwnerSchema,
  verifyCnpj: verifyCnpjSchema,
  toggleStatus: toggleStatusSchema,
  // Gerenciamento de usuários
  addUser: addUserToStoreSchema,
  removeUser: removeUserFromStoreSchema,
  updateUserRole: updateUserRoleSchema,
  listUsers: listStoreUsersSchema,
  getStoreUser: getStoreUserSchema,
  getStoreOwner: getStoreOwnerSchema,
  getStoreAdmins: getStoreAdminsSchema,
  getStoreManagers: getStoreManagersSchema,
  getStoreStaff: getStoreStaffSchema,
  getStoreUserStats: getStoreUserStatsSchema,
  searchStoreUsers: searchStoreUsersSchema,
  transferOwnership: transferOwnershipSchema
};

// src/middlewares/index.ts
init_auth_middleware();

// src/middlewares/authorization.middleware.ts
var StoreRole = /* @__PURE__ */ ((StoreRole2) => {
  StoreRole2["OWNER"] = "OWNER";
  StoreRole2["ADMIN"] = "ADMIN";
  StoreRole2["MANAGER"] = "MANAGER";
  StoreRole2["STAFF"] = "STAFF";
  return StoreRole2;
})(StoreRole || {});
var Action = /* @__PURE__ */ ((Action3) => {
  Action3["CREATE_USER"] = "create_user";
  Action3["READ_USER"] = "read_user";
  Action3["UPDATE_USER"] = "update_user";
  Action3["DELETE_USER"] = "delete_user";
  Action3["LIST_USERS"] = "list_users";
  Action3["CREATE_STORE"] = "create_store";
  Action3["READ_STORE"] = "read_store";
  Action3["UPDATE_STORE"] = "update_store";
  Action3["DELETE_STORE"] = "delete_store";
  Action3["LIST_STORES"] = "list_stores";
  Action3["MANAGE_STORE_USERS"] = "manage_store_users";
  Action3["CREATE_PRODUCT"] = "create_product";
  Action3["READ_PRODUCT"] = "read_product";
  Action3["UPDATE_PRODUCT"] = "update_product";
  Action3["DELETE_PRODUCT"] = "delete_product";
  Action3["LIST_PRODUCTS"] = "list_products";
  Action3["CREATE_CATEGORY"] = "create_category";
  Action3["READ_CATEGORY"] = "read_category";
  Action3["UPDATE_CATEGORY"] = "update_category";
  Action3["DELETE_CATEGORY"] = "delete_category";
  Action3["LIST_CATEGORIES"] = "list_categories";
  Action3["CREATE_SUPPLIER"] = "create_supplier";
  Action3["READ_SUPPLIER"] = "read_supplier";
  Action3["UPDATE_SUPPLIER"] = "update_supplier";
  Action3["DELETE_SUPPLIER"] = "delete_supplier";
  Action3["LIST_SUPPLIERS"] = "list_suppliers";
  Action3["CREATE_MOVEMENT"] = "create_movement";
  Action3["READ_MOVEMENT"] = "read_movement";
  Action3["UPDATE_MOVEMENT"] = "update_movement";
  Action3["DELETE_MOVEMENT"] = "delete_movement";
  Action3["LIST_MOVEMENTS"] = "list_movements";
  Action3["VIEW_AUDIT_LOGS"] = "view_audit_logs";
  Action3["MANAGE_SYSTEM_SETTINGS"] = "manage_system_settings";
  return Action3;
})(Action || {});
var PERMISSIONS = {
  ["super_admin" /* SUPER_ADMIN */]: Object.values(Action),
  // Can do everything
  ["admin" /* ADMIN */]: [
    // User management
    "create_user" /* CREATE_USER */,
    "read_user" /* READ_USER */,
    "update_user" /* UPDATE_USER */,
    "delete_user" /* DELETE_USER */,
    "list_users" /* LIST_USERS */,
    // Store management
    "create_store" /* CREATE_STORE */,
    "read_store" /* READ_STORE */,
    "update_store" /* UPDATE_STORE */,
    "delete_store" /* DELETE_STORE */,
    "list_stores" /* LIST_STORES */,
    "manage_store_users" /* MANAGE_STORE_USERS */,
    // Product management
    "create_product" /* CREATE_PRODUCT */,
    "read_product" /* READ_PRODUCT */,
    "update_product" /* UPDATE_PRODUCT */,
    "delete_product" /* DELETE_PRODUCT */,
    "list_products" /* LIST_PRODUCTS */,
    // Category management
    "create_category" /* CREATE_CATEGORY */,
    "read_category" /* READ_CATEGORY */,
    "update_category" /* UPDATE_CATEGORY */,
    "delete_category" /* DELETE_CATEGORY */,
    "list_categories" /* LIST_CATEGORIES */,
    // Supplier management
    "create_supplier" /* CREATE_SUPPLIER */,
    "read_supplier" /* READ_SUPPLIER */,
    "update_supplier" /* UPDATE_SUPPLIER */,
    "delete_supplier" /* DELETE_SUPPLIER */,
    "list_suppliers" /* LIST_SUPPLIERS */,
    // Movement management
    "create_movement" /* CREATE_MOVEMENT */,
    "read_movement" /* READ_MOVEMENT */,
    "update_movement" /* UPDATE_MOVEMENT */,
    "delete_movement" /* DELETE_MOVEMENT */,
    "list_movements" /* LIST_MOVEMENTS */,
    // System
    "view_audit_logs" /* VIEW_AUDIT_LOGS */
  ],
  ["manager" /* MANAGER */]: [
    // Store management (limited)
    "read_store" /* READ_STORE */,
    "list_stores" /* LIST_STORES */,
    "manage_store_users" /* MANAGE_STORE_USERS */,
    // Product management
    "create_product" /* CREATE_PRODUCT */,
    "read_product" /* READ_PRODUCT */,
    "update_product" /* UPDATE_PRODUCT */,
    "delete_product" /* DELETE_PRODUCT */,
    "list_products" /* LIST_PRODUCTS */,
    // Category management
    "create_category" /* CREATE_CATEGORY */,
    "read_category" /* READ_CATEGORY */,
    "update_category" /* UPDATE_CATEGORY */,
    "delete_category" /* DELETE_CATEGORY */,
    "list_categories" /* LIST_CATEGORIES */,
    // Supplier management
    "create_supplier" /* CREATE_SUPPLIER */,
    "read_supplier" /* READ_SUPPLIER */,
    "update_supplier" /* UPDATE_SUPPLIER */,
    "delete_supplier" /* DELETE_SUPPLIER */,
    "list_suppliers" /* LIST_SUPPLIERS */,
    // Movement management
    "create_movement" /* CREATE_MOVEMENT */,
    "read_movement" /* READ_MOVEMENT */,
    "update_movement" /* UPDATE_MOVEMENT */,
    "delete_movement" /* DELETE_MOVEMENT */,
    "list_movements" /* LIST_MOVEMENTS */
  ],
  ["user" /* USER */]: [
    // Read-only access
    "read_store" /* READ_STORE */,
    "list_stores" /* LIST_STORES */,
    "read_product" /* READ_PRODUCT */,
    "list_products" /* LIST_PRODUCTS */,
    "read_category" /* READ_CATEGORY */,
    "list_categories" /* LIST_CATEGORIES */,
    "read_supplier" /* READ_SUPPLIER */,
    "list_suppliers" /* LIST_SUPPLIERS */,
    "read_movement" /* READ_MOVEMENT */,
    "list_movements" /* LIST_MOVEMENTS */
  ]
};
var hasPermission = (userRoles, action) => {
  for (const role of userRoles) {
    const userRole = role;
    if (PERMISSIONS[userRole]?.includes(action)) {
      return true;
    }
  }
  return false;
};
var requirePermission = (action) => {
  return async (request, reply) => {
    try {
      if (!request.user) {
        return reply.status(401).send({
          error: "Authentication required"
        });
      }
      const userRoles = request.user.roles;
      if (!hasPermission(userRoles, action)) {
        return reply.status(403).send({
          error: "Insufficient permissions",
          required: action,
          current: userRoles
        });
      }
      return;
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  };
};

// src/middlewares/granular-permissions.middleware.ts
var BASE_ROLE_PERMISSIONS = {
  ["super_admin" /* SUPER_ADMIN */]: Object.values(Action),
  // Pode fazer tudo
  ["admin" /* ADMIN */]: [
    // Gestão de usuários
    "create_user" /* CREATE_USER */,
    "read_user" /* READ_USER */,
    "update_user" /* UPDATE_USER */,
    "delete_user" /* DELETE_USER */,
    "list_users" /* LIST_USERS */,
    // Gestão de lojas
    "create_store" /* CREATE_STORE */,
    "read_store" /* READ_STORE */,
    "update_store" /* UPDATE_STORE */,
    "delete_store" /* DELETE_STORE */,
    "list_stores" /* LIST_STORES */,
    "manage_store_users" /* MANAGE_STORE_USERS */,
    // Gestão de produtos
    "create_product" /* CREATE_PRODUCT */,
    "read_product" /* READ_PRODUCT */,
    "update_product" /* UPDATE_PRODUCT */,
    "delete_product" /* DELETE_PRODUCT */,
    "list_products" /* LIST_PRODUCTS */,
    // Gestão de categorias
    "create_category" /* CREATE_CATEGORY */,
    "read_category" /* READ_CATEGORY */,
    "update_category" /* UPDATE_CATEGORY */,
    "delete_category" /* DELETE_CATEGORY */,
    "list_categories" /* LIST_CATEGORIES */,
    // Gestão de fornecedores
    "create_supplier" /* CREATE_SUPPLIER */,
    "read_supplier" /* READ_SUPPLIER */,
    "update_supplier" /* UPDATE_SUPPLIER */,
    "delete_supplier" /* DELETE_SUPPLIER */,
    "list_suppliers" /* LIST_SUPPLIERS */,
    // Gestão de movimentações
    "create_movement" /* CREATE_MOVEMENT */,
    "read_movement" /* READ_MOVEMENT */,
    "update_movement" /* UPDATE_MOVEMENT */,
    "delete_movement" /* DELETE_MOVEMENT */,
    "list_movements" /* LIST_MOVEMENTS */,
    // Sistema
    "view_audit_logs" /* VIEW_AUDIT_LOGS */
  ],
  ["manager" /* MANAGER */]: [
    // Gestão de lojas (limitada)
    "read_store" /* READ_STORE */,
    "list_stores" /* LIST_STORES */,
    "manage_store_users" /* MANAGE_STORE_USERS */,
    // Gestão de produtos
    "create_product" /* CREATE_PRODUCT */,
    "read_product" /* READ_PRODUCT */,
    "update_product" /* UPDATE_PRODUCT */,
    "delete_product" /* DELETE_PRODUCT */,
    "list_products" /* LIST_PRODUCTS */,
    // Gestão de categorias
    "create_category" /* CREATE_CATEGORY */,
    "read_category" /* READ_CATEGORY */,
    "update_category" /* UPDATE_CATEGORY */,
    "delete_category" /* DELETE_CATEGORY */,
    "list_categories" /* LIST_CATEGORIES */,
    // Gestão de fornecedores
    "create_supplier" /* CREATE_SUPPLIER */,
    "read_supplier" /* READ_SUPPLIER */,
    "update_supplier" /* UPDATE_SUPPLIER */,
    "delete_supplier" /* DELETE_SUPPLIER */,
    "list_suppliers" /* LIST_SUPPLIERS */,
    // Gestão de movimentações
    "create_movement" /* CREATE_MOVEMENT */,
    "read_movement" /* READ_MOVEMENT */,
    "update_movement" /* UPDATE_MOVEMENT */,
    "delete_movement" /* DELETE_MOVEMENT */,
    "list_movements" /* LIST_MOVEMENTS */
  ],
  ["user" /* USER */]: [
    // Acesso somente leitura
    "read_store" /* READ_STORE */,
    "list_stores" /* LIST_STORES */,
    "read_product" /* READ_PRODUCT */,
    "list_products" /* LIST_PRODUCTS */,
    "read_category" /* READ_CATEGORY */,
    "list_categories" /* LIST_CATEGORIES */,
    "read_supplier" /* READ_SUPPLIER */,
    "list_suppliers" /* LIST_SUPPLIERS */,
    "read_movement" /* READ_MOVEMENT */,
    "list_movements" /* LIST_MOVEMENTS */
  ]
};
var BASE_STORE_ROLE_PERMISSIONS = {
  ["OWNER" /* OWNER */]: [
    // Pode fazer tudo na loja
    "read_store" /* READ_STORE */,
    "update_store" /* UPDATE_STORE */,
    "manage_store_users" /* MANAGE_STORE_USERS */,
    "create_product" /* CREATE_PRODUCT */,
    "read_product" /* READ_PRODUCT */,
    "update_product" /* UPDATE_PRODUCT */,
    "delete_product" /* DELETE_PRODUCT */,
    "list_products" /* LIST_PRODUCTS */,
    "create_category" /* CREATE_CATEGORY */,
    "read_category" /* READ_CATEGORY */,
    "update_category" /* UPDATE_CATEGORY */,
    "delete_category" /* DELETE_CATEGORY */,
    "list_categories" /* LIST_CATEGORIES */,
    "create_supplier" /* CREATE_SUPPLIER */,
    "read_supplier" /* READ_SUPPLIER */,
    "update_supplier" /* UPDATE_SUPPLIER */,
    "delete_supplier" /* DELETE_SUPPLIER */,
    "list_suppliers" /* LIST_SUPPLIERS */,
    "create_movement" /* CREATE_MOVEMENT */,
    "read_movement" /* READ_MOVEMENT */,
    "update_movement" /* UPDATE_MOVEMENT */,
    "delete_movement" /* DELETE_MOVEMENT */,
    "list_movements" /* LIST_MOVEMENTS */
  ],
  ["ADMIN" /* ADMIN */]: [
    // Gestão completa da loja (exceto transferir propriedade)
    "read_store" /* READ_STORE */,
    "update_store" /* UPDATE_STORE */,
    "manage_store_users" /* MANAGE_STORE_USERS */,
    "create_product" /* CREATE_PRODUCT */,
    "read_product" /* READ_PRODUCT */,
    "update_product" /* UPDATE_PRODUCT */,
    "delete_product" /* DELETE_PRODUCT */,
    "list_products" /* LIST_PRODUCTS */,
    "create_category" /* CREATE_CATEGORY */,
    "read_category" /* READ_CATEGORY */,
    "update_category" /* UPDATE_CATEGORY */,
    "delete_category" /* DELETE_CATEGORY */,
    "list_categories" /* LIST_CATEGORIES */,
    "create_supplier" /* CREATE_SUPPLIER */,
    "read_supplier" /* READ_SUPPLIER */,
    "update_supplier" /* UPDATE_SUPPLIER */,
    "delete_supplier" /* DELETE_SUPPLIER */,
    "list_suppliers" /* LIST_SUPPLIERS */,
    "create_movement" /* CREATE_MOVEMENT */,
    "read_movement" /* READ_MOVEMENT */,
    "update_movement" /* UPDATE_MOVEMENT */,
    "delete_movement" /* DELETE_MOVEMENT */,
    "list_movements" /* LIST_MOVEMENTS */
  ],
  ["MANAGER" /* MANAGER */]: [
    // Gestão operacional
    "read_store" /* READ_STORE */,
    "list_stores" /* LIST_STORES */,
    "create_product" /* CREATE_PRODUCT */,
    "read_product" /* READ_PRODUCT */,
    "update_product" /* UPDATE_PRODUCT */,
    "delete_product" /* DELETE_PRODUCT */,
    "list_products" /* LIST_PRODUCTS */,
    "create_category" /* CREATE_CATEGORY */,
    "read_category" /* READ_CATEGORY */,
    "update_category" /* UPDATE_CATEGORY */,
    "delete_category" /* DELETE_CATEGORY */,
    "list_categories" /* LIST_CATEGORIES */,
    "create_supplier" /* CREATE_SUPPLIER */,
    "read_supplier" /* READ_SUPPLIER */,
    "update_supplier" /* UPDATE_SUPPLIER */,
    "delete_supplier" /* DELETE_SUPPLIER */,
    "list_suppliers" /* LIST_SUPPLIERS */,
    "create_movement" /* CREATE_MOVEMENT */,
    "read_movement" /* READ_MOVEMENT */,
    "update_movement" /* UPDATE_MOVEMENT */,
    "delete_movement" /* DELETE_MOVEMENT */,
    "list_movements" /* LIST_MOVEMENTS */
  ],
  ["STAFF" /* STAFF */]: [
    // Operações básicas
    "read_store" /* READ_STORE */,
    "list_stores" /* LIST_STORES */,
    "read_product" /* READ_PRODUCT */,
    "list_products" /* LIST_PRODUCTS */,
    "read_category" /* READ_CATEGORY */,
    "list_categories" /* LIST_CATEGORIES */,
    "read_supplier" /* READ_SUPPLIER */,
    "list_suppliers" /* LIST_SUPPLIERS */,
    "read_movement" /* READ_MOVEMENT */,
    "list_movements" /* LIST_MOVEMENTS */
  ]
};
var GranularPermissionService = class {
  // Verifica se usuário tem permissão considerando todas as camadas
  static async hasPermission(context, action, resource) {
    try {
      if (context.userRoles.includes("super_admin" /* SUPER_ADMIN */)) {
        return { allowed: true, source: "super_admin" };
      }
      if (context.customPermissions) {
        const customResult = this.checkCustomPermissions(context, action, resource);
        if (customResult !== null) {
          return customResult;
        }
      }
      if (context.storeId && context.storeRole) {
        const storeResult = this.checkStorePermissions(context, action);
        if (storeResult.allowed) {
          return { ...storeResult, source: "store_role" };
        }
      }
      const globalResult = this.checkGlobalRolePermissions(context, action);
      if (globalResult.allowed) {
        return { ...globalResult, source: "global_role" };
      }
      return { allowed: false, reason: "No permission found" };
    } catch (error) {
      console.error("Error checking granular permission:", error);
      return { allowed: false, reason: "Permission check error" };
    }
  }
  // Verifica permissões customizadas do usuário
  static checkCustomPermissions(context, action, resource) {
    if (!context.customPermissions) return null;
    const now = context.requestTime || /* @__PURE__ */ new Date();
    const applicablePermissions = context.customPermissions.filter((permission) => {
      if (permission.action !== action) return false;
      if (permission.resource && resource) {
        if (permission.resource !== "*" && permission.resource !== resource) return false;
      }
      if (permission.storeId && context.storeId && permission.storeId !== context.storeId) return false;
      if (permission.expiresAt && permission.expiresAt < now) return false;
      if (!this.checkConditions(permission.conditions, context)) return false;
      return true;
    });
    if (applicablePermissions.length === 0) return null;
    const denyPermission = applicablePermissions.find((p) => !p.grant);
    if (denyPermission) {
      return {
        allowed: false,
        reason: `Permission denied by custom rule: ${denyPermission.reason || "No reason provided"}`,
        source: "custom_deny"
      };
    }
    const grantPermission = applicablePermissions.find((p) => p.grant);
    if (grantPermission) {
      return {
        allowed: true,
        reason: `Permission granted by custom rule: ${grantPermission.reason || "No reason provided"}`,
        source: "custom_grant"
      };
    }
    return null;
  }
  // Verifica permissões da loja
  static checkStorePermissions(context, action) {
    if (!context.storeRole) {
      return { allowed: false, reason: "No store role defined" };
    }
    const storePermissions = BASE_STORE_ROLE_PERMISSIONS[context.storeRole] || [];
    if (storePermissions.includes(action)) {
      return { allowed: true, reason: `Allowed by store role: ${context.storeRole}` };
    }
    return { allowed: false, reason: `Store role ${context.storeRole} does not have permission for ${action}` };
  }
  // Verifica permissões do role global
  static checkGlobalRolePermissions(context, action) {
    for (const role of context.userRoles) {
      const userRole = role;
      const rolePermissions = BASE_ROLE_PERMISSIONS[userRole] || [];
      if (rolePermissions.includes(action)) {
        return { allowed: true, reason: `Allowed by global role: ${userRole}` };
      }
    }
    return { allowed: false, reason: "No global role has this permission" };
  }
  // Verifica condições de permissão
  static checkConditions(conditions, context) {
    if (!conditions) return true;
    const now = context.requestTime || /* @__PURE__ */ new Date();
    const requestData = context.requestData || {};
    if (conditions.timeRange) {
      const [start, end] = conditions.timeRange.split("-").map(Number);
      const currentHour = now.getHours();
      if (currentHour < start || currentHour > end) {
        return false;
      }
    }
    if (conditions.dayOfWeek) {
      const [start, end] = conditions.dayOfWeek.split("-").map(Number);
      const currentDay = now.getDay();
      if (currentDay < start || currentDay > end) {
        return false;
      }
    }
    if (conditions.dateRange) {
      const { start, end } = conditions.dateRange;
      if (now < new Date(start) || now > new Date(end)) {
        return false;
      }
    }
    if (conditions.amountLimit && requestData.body?.amount) {
      if (requestData.body.amount > conditions.amountLimit) {
        return false;
      }
    }
    if (conditions.ipWhitelist && requestData.ip) {
      if (!conditions.ipWhitelist.includes(requestData.ip)) {
        return false;
      }
    }
    if (conditions.userAgent && requestData.userAgent) {
      if (!requestData.userAgent.includes(conditions.userAgent)) {
        return false;
      }
    }
    if (conditions.custom) {
      try {
        const result = this.evaluateCustomCondition(conditions.custom, requestData);
        return result;
      } catch (error) {
        console.error("Error evaluating custom condition:", error);
        return false;
      }
    }
    return true;
  }
  // Avalia condição customizada de forma segura (substitui eval)
  static evaluateCustomCondition(expression, requestData) {
    try {
      const comparisonRegex = /(\w+(?:\.\w+)*)\s*(<|>|<=|>=|==|!=)\s*([\w\d.-]+)/;
      const match = expression.match(comparisonRegex);
      if (!match) {
        console.warn("Invalid custom condition expression:", expression);
        return false;
      }
      const [, leftSide, operator, rightSide] = match;
      const leftValue = this.resolveValue(leftSide, requestData);
      let rightValue;
      if (!isNaN(Number(rightSide))) {
        rightValue = Number(rightSide);
      } else {
        rightValue = this.resolveValue(rightSide, requestData);
      }
      switch (operator) {
        case "<":
          return leftValue < rightValue;
        case ">":
          return leftValue > rightValue;
        case "<=":
          return leftValue <= rightValue;
        case ">=":
          return leftValue >= rightValue;
        case "==":
          return leftValue == rightValue;
        case "!=":
          return leftValue != rightValue;
        default:
          console.warn("Unsupported operator:", operator);
          return false;
      }
    } catch (error) {
      console.error("Error in evaluateCustomCondition:", error);
      return false;
    }
  }
  // Resolve valor de propriedades aninhadas (ex: requestData.body.amount)
  static resolveValue(path3, requestData) {
    const parts = path3.split(".");
    let value = requestData;
    for (const part of parts) {
      if (value === void 0 || value === null) {
        return void 0;
      }
      value = value[part];
    }
    return value;
  }
  // Verifica se usuário tem qualquer uma das permissões
  static async hasAnyPermission(context, actions, resource) {
    for (const action of actions) {
      const result = await this.hasPermission(context, action, resource);
      if (result.allowed) {
        return result;
      }
    }
    return { allowed: false, reason: "None of the required permissions found" };
  }
  // Verifica se usuário tem todas as permissões
  static async hasAllPermissions(context, actions, resource) {
    for (const action of actions) {
      const result = await this.hasPermission(context, action, resource);
      if (!result.allowed) {
        return { allowed: false, reason: `Missing permission: ${action} - ${result.reason}` };
      }
    }
    return { allowed: true, reason: "All permissions granted" };
  }
  // Obtém todas as permissões efetivas do usuário
  static async getUserEffectivePermissions(context) {
    const effectivePermissions = /* @__PURE__ */ new Set();
    for (const role of context.userRoles) {
      const userRole = role;
      const rolePermissions = BASE_ROLE_PERMISSIONS[userRole] || [];
      rolePermissions.forEach((permission) => effectivePermissions.add(permission));
    }
    if (context.storeRole) {
      const storePermissions = BASE_STORE_ROLE_PERMISSIONS[context.storeRole] || [];
      storePermissions.forEach((permission) => effectivePermissions.add(permission));
    }
    if (context.customPermissions) {
      const now = context.requestTime || /* @__PURE__ */ new Date();
      context.customPermissions.forEach((permission) => {
        if (permission.expiresAt && permission.expiresAt < now) return;
        if (!this.checkConditions(permission.conditions, context)) return;
        if (permission.grant) {
          effectivePermissions.add(permission.action);
        } else {
          effectivePermissions.delete(permission.action);
        }
      });
    }
    return Array.from(effectivePermissions);
  }
};

// src/features/store/store.routes.ts
async function StoreRoutes(fastify2) {
  fastify2.post("/", {
    schema: StoreSchemas.create,
    preHandler: [authMiddleware],
    handler: StoreController.create
  });
  fastify2.get("/", {
    schema: StoreSchemas.list,
    preHandler: [authMiddleware],
    handler: StoreController.list
  });
  fastify2.get("/:id", {
    schema: StoreSchemas.get,
    preHandler: [authMiddleware],
    handler: StoreController.get
  });
  fastify2.put("/:id", {
    schema: StoreSchemas.update,
    preHandler: [authMiddleware],
    handler: StoreController.update
  });
  fastify2.delete("/:id", {
    schema: StoreSchemas.delete,
    preHandler: [authMiddleware],
    handler: StoreController.delete
  });
  fastify2.get("/cnpj/:cnpj", {
    schema: StoreSchemas.getByCnpj,
    handler: StoreController.getByCnpj
  });
  fastify2.get("/owner/:ownerId", {
    schema: StoreSchemas.getByOwner,
    handler: StoreController.getByOwner
  });
  fastify2.get("/active", {
    handler: StoreController.getActive
  });
  fastify2.get("/stats", {
    handler: StoreController.getStats
  });
  fastify2.get("/search", {
    schema: {
      querystring: {
        type: "object",
        properties: {
          q: { type: "string" },
          limit: { type: "number" }
        },
        required: ["q"]
      }
    },
    handler: StoreController.search
  });
  fastify2.get("/recent", {
    schema: {
      querystring: {
        type: "object",
        properties: {
          limit: { type: "number" }
        }
      }
    },
    handler: StoreController.getRecent
  });
  fastify2.get("/verify-cnpj/:cnpj", {
    schema: StoreSchemas.verifyCnpj,
    preHandler: [authMiddleware],
    handler: StoreController.verifyCnpj
  });
  fastify2.patch("/:id/toggle-status", {
    schema: StoreSchemas.toggleStatus,
    preHandler: [authMiddleware],
    handler: StoreController.toggleStatus
  });
}

// src/features/category/commands/category.commands.ts
init_prisma();
var CategoryCommands = {
  async create(data) {
    return await db.category.create({
      data: {
        ...data,
        status: data.status ?? true
      },
      include: {
        parent: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true
          }
        },
        children: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true,
            status: true,
            color: true,
            icon: true
          }
        },
        products: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                status: true
              }
            }
          },
          take: 5
        },
        _count: {
          select: {
            children: true,
            products: true
          }
        }
      }
    });
  },
  async update(id, data) {
    return await db.category.update({
      where: { id },
      data,
      include: {
        parent: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true
          }
        },
        children: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true,
            status: true,
            color: true,
            icon: true
          }
        },
        products: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                status: true
              }
            }
          },
          take: 5
        },
        _count: {
          select: {
            children: true,
            products: true
          }
        }
      }
    });
  },
  async delete(id) {
    return await db.category.delete({
      where: { id }
    });
  },
  async updateStatus(id, status) {
    return await db.category.update({
      where: { id },
      data: { status },
      include: {
        parent: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true
          }
        },
        children: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true,
            status: true,
            color: true,
            icon: true
          }
        },
        products: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                status: true
              }
            }
          },
          take: 5
        },
        _count: {
          select: {
            children: true,
            products: true
          }
        }
      }
    });
  },
  async moveToParent(id, parentId) {
    return await db.category.update({
      where: { id },
      data: { parentId },
      include: {
        parent: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true
          }
        },
        children: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true,
            status: true,
            color: true,
            icon: true
          }
        },
        _count: {
          select: {
            children: true,
            products: true
          }
        }
      }
    });
  }
};

// src/features/category/queries/category.queries.ts
init_prisma();
var CategoryQueries = {
  async getById(id) {
    return await db.category.findUnique({
      where: { id },
      include: {
        parent: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true
          }
        },
        children: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true,
            status: true,
            color: true,
            icon: true
          }
        },
        products: {
          select: {
            id: true,
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                status: true
              }
            }
          }
        },
        _count: {
          select: {
            children: true,
            products: true
          }
        }
      }
    });
  },
  async list(params) {
    const { page = 1, limit = 10, search, status, parentId, storeId } = params;
    const skip = (page - 1) * limit;
    const where = {};
    if (status !== void 0) {
      where.status = status;
    }
    if (parentId !== void 0) {
      if (parentId === null) {
        where.parentId = null;
      } else {
        where.parentId = parentId;
      }
    }
    if (storeId) {
      where.storeId = storeId;
    }
    if (search) {
      where.OR = [
        { name: { contains: search, mode: "insensitive" } },
        { description: { contains: search, mode: "insensitive" } },
        { code: { contains: search, mode: "insensitive" } }
      ];
    }
    const [items, total] = await Promise.all([
      db.category.findMany({
        where,
        skip,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          parent: {
            select: {
              id: true,
              name: true,
              description: true,
              code: true
            }
          },
          children: {
            select: {
              id: true,
              name: true,
              description: true,
              code: true,
              status: true,
              color: true,
              icon: true
            }
          },
          products: {
            select: {
              id: true,
              product: {
                select: {
                  id: true,
                  name: true,
                  description: true,
                  status: true
                }
              }
            },
            take: 5
          },
          _count: {
            select: {
              children: true,
              products: true
            }
          }
        }
      }),
      db.category.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async search(term, storeId, params = {}) {
    const { page = 1, limit = 10 } = params;
    const skip = (page - 1) * limit;
    const where = {
      storeId,
      OR: [
        { name: { contains: term, mode: "insensitive" } },
        { description: { contains: term, mode: "insensitive" } },
        { code: { contains: term, mode: "insensitive" } }
      ]
    };
    const [items, total] = await Promise.all([
      db.category.findMany({
        where,
        skip,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          parent: {
            select: {
              id: true,
              name: true,
              description: true,
              code: true
            }
          },
          children: {
            select: {
              id: true,
              name: true,
              description: true,
              code: true,
              status: true,
              color: true,
              icon: true
            }
          },
          _count: {
            select: {
              children: true,
              products: true
            }
          }
        }
      }),
      db.category.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getActive(storeId) {
    return await db.category.findMany({
      where: {
        status: true,
        storeId
      },
      orderBy: { createdAt: "desc" },
      include: {
        parent: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true
          }
        },
        children: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true,
            status: true,
            color: true,
            icon: true
          }
        },
        _count: {
          select: {
            children: true,
            products: true
          }
        }
      }
    });
  },
  async getStats(storeId) {
    const [total, active, inactive, withChildren, withoutChildren] = await Promise.all([
      db.category.count({ where: { storeId } }),
      db.category.count({ where: { status: true, storeId } }),
      db.category.count({ where: { status: false, storeId } }),
      db.category.count({
        where: {
          storeId,
          children: { some: {} }
        }
      }),
      db.category.count({
        where: {
          storeId,
          children: { none: {} }
        }
      })
    ]);
    return {
      total,
      active,
      inactive,
      withChildren,
      withoutChildren
    };
  },
  async getRootCategories(storeId, status) {
    const where = {
      parentId: null,
      storeId
    };
    if (status !== void 0) {
      where.status = status;
    }
    return await db.category.findMany({
      where,
      orderBy: { createdAt: "desc" },
      include: {
        children: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true,
            status: true,
            color: true,
            icon: true
          }
        },
        _count: {
          select: {
            children: true,
            products: true
          }
        }
      }
    });
  },
  async getChildren(parentId, storeId) {
    return await db.category.findMany({
      where: {
        parentId,
        storeId
      },
      orderBy: { createdAt: "desc" },
      include: {
        children: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true,
            status: true,
            color: true,
            icon: true
          }
        },
        products: {
          select: {
            id: true,
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                status: true
              }
            }
          },
          take: 5
        },
        _count: {
          select: {
            children: true,
            products: true
          }
        }
      }
    });
  },
  async getHierarchy(storeId) {
    const rootCategories = await CategoryQueries.getRootCategories(storeId);
    const buildHierarchy = async (categories) => {
      for (const category of categories) {
        category.children = await CategoryQueries.getChildren(category.id, storeId);
        if (category.children.length > 0) {
          await buildHierarchy(category.children);
        }
      }
    };
    await buildHierarchy(rootCategories);
    return rootCategories;
  },
  async getByCode(code, storeId) {
    return await db.category.findUnique({
      where: {
        code_storeId: {
          code,
          storeId
        }
      },
      include: {
        parent: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true
          }
        },
        children: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true,
            status: true,
            color: true,
            icon: true
          }
        },
        products: {
          select: {
            id: true,
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                status: true
              }
            }
          },
          take: 5
        },
        _count: {
          select: {
            children: true,
            products: true
          }
        }
      }
    });
  },
  async getTopCategoriesByProducts(storeId, params) {
    const { limit = 10, status, includeInactive = false } = params;
    const where = {
      storeId
    };
    if (!includeInactive) {
      where.status = status !== void 0 ? status : true;
    } else if (status !== void 0) {
      where.status = status;
    }
    where.products = {
      some: {}
    };
    return await db.category.findMany({
      where,
      take: limit,
      orderBy: {
        products: {
          _count: "desc"
        }
      },
      select: {
        id: true,
        name: true,
        description: true,
        code: true,
        status: true,
        color: true,
        icon: true,
        parentId: true,
        createdAt: true,
        updatedAt: true,
        parent: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true
          }
        },
        _count: {
          select: {
            products: true,
            children: true
          }
        }
      }
    });
  },
  async getTopCategoriesByProductsWithDetails(storeId, params) {
    const { limit = 10, status, includeInactive = false, includeProductDetails = false } = params;
    const where = {
      storeId
    };
    if (!includeInactive) {
      where.status = status !== void 0 ? status : true;
    } else if (status !== void 0) {
      where.status = status;
    }
    where.products = {
      some: {}
    };
    const include = {
      parent: {
        select: {
          id: true,
          name: true,
          description: true,
          code: true
        }
      },
      _count: {
        select: {
          products: true,
          children: true
        }
      }
    };
    if (includeProductDetails) {
      include.products = {
        select: {
          id: true,
          product: {
            select: {
              id: true,
              name: true,
              description: true,
              status: true,
              sku: true,
              price: true,
              stock: true
            }
          }
        },
        take: 5
        // Limitar a 5 produtos por categoria para não sobrecarregar
      };
    }
    return await db.category.findMany({
      where,
      take: limit,
      orderBy: {
        products: {
          _count: "desc"
        }
      },
      select: {
        id: true,
        name: true,
        description: true,
        code: true,
        status: true,
        color: true,
        icon: true,
        parentId: true,
        createdAt: true,
        updatedAt: true,
        ...include
      }
    });
  },
  async getCategoryCreationEvolution(storeId, params) {
    const {
      period = "month",
      startDate,
      endDate,
      status,
      includeInactive = false
    } = params;
    const where = {
      storeId
    };
    if (!includeInactive) {
      where.status = status !== void 0 ? status : true;
    } else if (status !== void 0) {
      where.status = status;
    }
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) {
        where.createdAt.gte = startDate;
      }
      if (endDate) {
        where.createdAt.lte = endDate;
      }
    }
    const categories = await db.category.findMany({
      where,
      select: {
        id: true,
        name: true,
        status: true,
        createdAt: true
      },
      orderBy: {
        createdAt: "asc"
      }
    });
    const groupedData = this.groupByPeriod(categories, period);
    const totalCategories = categories.length;
    const activeCategories = categories.filter((cat) => cat.status).length;
    const inactiveCategories = totalCategories - activeCategories;
    const periods = Object.keys(groupedData).sort();
    const growthRate = this.calculateGrowthRate(groupedData, periods);
    return {
      data: groupedData,
      metadata: {
        totalCategories,
        activeCategories,
        inactiveCategories,
        period,
        startDate: startDate || null,
        endDate: endDate || null,
        growthRate,
        description: `Evolu\xE7\xE3o de cria\xE7\xE3o de categorias por ${period}`,
        chartType: "line"
      }
    };
  },
  async getCategoryCreationEvolutionDetailed(storeId, params) {
    const {
      period = "month",
      startDate,
      endDate,
      status,
      includeInactive = false,
      includeDetails = false
    } = params;
    const where = {
      storeId
    };
    if (!includeInactive) {
      where.status = status !== void 0 ? status : true;
    } else if (status !== void 0) {
      where.status = status;
    }
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) {
        where.createdAt.gte = startDate;
      }
      if (endDate) {
        where.createdAt.lte = endDate;
      }
    }
    const selectFields = {
      id: true,
      name: true,
      status: true,
      createdAt: true
    };
    if (includeDetails) {
      selectFields.parent = {
        select: {
          id: true,
          name: true
        }
      };
      selectFields._count = {
        select: {
          children: true,
          products: true
        }
      };
    }
    const categories = await db.category.findMany({
      where,
      select: selectFields,
      orderBy: {
        createdAt: "asc"
      }
    });
    const groupedData = this.groupByPeriod(categories, period);
    const totalCategories = categories.length;
    const activeCategories = categories.filter((cat) => cat.status).length;
    const inactiveCategories = totalCategories - activeCategories;
    const periods = Object.keys(groupedData).sort();
    const growthRate = this.calculateGrowthRate(groupedData, periods);
    const periodStats = this.calculatePeriodStats(groupedData, periods);
    return {
      data: groupedData,
      periodStats,
      metadata: {
        totalCategories,
        activeCategories,
        inactiveCategories,
        period,
        startDate: startDate || null,
        endDate: endDate || null,
        growthRate,
        description: `Evolu\xE7\xE3o detalhada de cria\xE7\xE3o de categorias por ${period}`,
        chartType: "line"
      }
    };
  },
  // Métodos auxiliares privados
  groupByPeriod(categories, period) {
    const grouped = {};
    categories.forEach((category) => {
      const date = new Date(category.createdAt);
      let key;
      switch (period) {
        case "day":
          key = date.toISOString().split("T")[0];
          break;
        case "week":
          const weekStart = new Date(date);
          weekStart.setDate(date.getDate() - date.getDay());
          key = weekStart.toISOString().split("T")[0];
          break;
        case "month":
          key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, "0")}`;
          break;
        case "year":
          key = String(date.getFullYear());
          break;
        default:
          key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, "0")}`;
      }
      if (!grouped[key]) {
        grouped[key] = [];
      }
      grouped[key].push(category);
    });
    const chartData = {};
    Object.keys(grouped).forEach((key) => {
      chartData[key] = {
        count: grouped[key].length,
        categories: grouped[key]
      };
    });
    return chartData;
  },
  calculateGrowthRate(groupedData, periods) {
    if (periods.length < 2) return 0;
    const firstPeriod = periods[0];
    const lastPeriod = periods[periods.length - 1];
    const firstCount = groupedData[firstPeriod]?.count || 0;
    const lastCount = groupedData[lastPeriod]?.count || 0;
    if (firstCount === 0) return lastCount > 0 ? 100 : 0;
    return (lastCount - firstCount) / firstCount * 100;
  },
  calculatePeriodStats(groupedData, periods) {
    const stats = {
      averagePerPeriod: 0,
      maxPerPeriod: 0,
      minPerPeriod: Infinity,
      totalPeriods: periods.length,
      periodsWithGrowth: 0,
      periodsWithDecline: 0,
      periodsStable: 0
    };
    if (periods.length === 0) return stats;
    let totalCount = 0;
    let previousCount = 0;
    periods.forEach((period, index) => {
      const count = groupedData[period]?.count || 0;
      totalCount += count;
      stats.maxPerPeriod = Math.max(stats.maxPerPeriod, count);
      stats.minPerPeriod = Math.min(stats.minPerPeriod, count);
      if (index > 0) {
        if (count > previousCount) {
          stats.periodsWithGrowth++;
        } else if (count < previousCount) {
          stats.periodsWithDecline++;
        } else {
          stats.periodsStable++;
        }
      }
      previousCount = count;
    });
    stats.averagePerPeriod = totalCount / periods.length;
    stats.minPerPeriod = stats.minPerPeriod === Infinity ? 0 : stats.minPerPeriod;
    return stats;
  },
  async getActiveInactiveRatio(storeId, params) {
    const { includeDetails = false, includeHierarchy = false } = params;
    const [activeCount, inactiveCount, totalCount] = await Promise.all([
      db.category.count({ where: { status: true, storeId } }),
      db.category.count({ where: { status: false, storeId } }),
      db.category.count({ where: { storeId } })
    ]);
    const activePercentage = totalCount > 0 ? activeCount / totalCount * 100 : 0;
    const inactivePercentage = totalCount > 0 ? inactiveCount / totalCount * 100 : 0;
    const hygieneScore = activePercentage;
    const result = {
      active: {
        count: activeCount,
        percentage: Math.round(activePercentage * 100) / 100
      },
      inactive: {
        count: inactiveCount,
        percentage: Math.round(inactivePercentage * 100) / 100
      },
      total: totalCount,
      hygieneScore: Math.round(hygieneScore * 100) / 100,
      metadata: {
        description: "Taxa de categorias ativas vs inativas",
        chartType: "donut",
        lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
      }
    };
    if (includeDetails) {
      const [activeCategories, inactiveCategories] = await Promise.all([
        db.category.findMany({
          where: { status: true, storeId },
          select: {
            id: true,
            name: true,
            code: true,
            createdAt: true,
            updatedAt: true,
            _count: {
              select: {
                children: true,
                products: true
              }
            }
          },
          orderBy: { createdAt: "desc" },
          take: 10
          // Limitar para não sobrecarregar
        }),
        db.category.findMany({
          where: { status: false, storeId },
          select: {
            id: true,
            name: true,
            code: true,
            createdAt: true,
            updatedAt: true,
            _count: {
              select: {
                children: true,
                products: true
              }
            }
          },
          orderBy: { updatedAt: "desc" },
          take: 10
          // Limitar para não sobrecarregar
        })
      ]);
      result.active.recentCategories = activeCategories;
      result.inactive.recentCategories = inactiveCategories;
    }
    if (includeHierarchy) {
      const [activeWithChildren, inactiveWithChildren, activeWithoutChildren, inactiveWithoutChildren] = await Promise.all([
        db.category.count({
          where: {
            storeId,
            status: true,
            children: { some: {} }
          }
        }),
        db.category.count({
          where: {
            storeId,
            status: false,
            children: { some: {} }
          }
        }),
        db.category.count({
          where: {
            storeId,
            status: true,
            children: { none: {} }
          }
        }),
        db.category.count({
          where: {
            storeId,
            status: false,
            children: { none: {} }
          }
        })
      ]);
      result.hierarchy = {
        activeWithChildren,
        inactiveWithChildren,
        activeWithoutChildren,
        inactiveWithoutChildren,
        totalWithChildren: activeWithChildren + inactiveWithChildren,
        totalWithoutChildren: activeWithoutChildren + inactiveWithoutChildren
      };
    }
    return result;
  },
  async getActiveInactiveTrend(storeId, params) {
    const { period = "month", startDate, endDate } = params;
    const where = {
      storeId
    };
    if (startDate || endDate) {
      where.updatedAt = {};
      if (startDate) {
        where.updatedAt.gte = startDate;
      }
      if (endDate) {
        where.updatedAt.lte = endDate;
      }
    }
    const categories = await db.category.findMany({
      where,
      select: {
        id: true,
        name: true,
        status: true,
        createdAt: true,
        updatedAt: true
      },
      orderBy: {
        updatedAt: "asc"
      }
    });
    const groupedData = this.groupByPeriod(categories, period);
    const trendData = {};
    Object.keys(groupedData).forEach((periodKey) => {
      const periodCategories = groupedData[periodKey].categories;
      const active = periodCategories.filter((cat) => cat.status).length;
      const inactive = periodCategories.filter((cat) => !cat.status).length;
      trendData[periodKey] = {
        active,
        inactive,
        total: active + inactive
      };
    });
    return {
      trendData,
      metadata: {
        period,
        startDate: startDate || null,
        endDate: endDate || null,
        description: `Tend\xEAncia de categorias ativas vs inativas por ${period}`,
        chartType: "line"
      }
    };
  }
};

// src/features/category/category.controller.ts
var CategoryController = {
  // === CRUD BÁSICO ===
  async create(request, reply) {
    try {
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CategoryCommands.create({
        ...request.body,
        storeId
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.code === "P2002") {
        return reply.status(400).send({
          error: "Category with this name or code already exists"
        });
      }
      if (error.code === "P2003") {
        return reply.status(400).send({
          error: "Invalid parent category reference"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      const result = await CategoryQueries.getById(id);
      if (!result) {
        return reply.status(404).send({
          error: "Category not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Category not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = request.body;
      const result = await CategoryCommands.update(id, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.code === "P2025") {
        return reply.status(404).send({
          error: "Category not found"
        });
      }
      if (error.code === "P2002") {
        return reply.status(400).send({
          error: "Category with this name or code already exists"
        });
      }
      if (error.code === "P2003") {
        return reply.status(400).send({
          error: "Invalid parent category reference"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      await CategoryCommands.delete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.code === "P2025") {
        return reply.status(404).send({
          error: "Category not found"
        });
      }
      if (error.code === "P2003") {
        return reply.status(400).send({
          error: "Cannot delete category with children or products"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { page = 1, limit = 10, search, status, parentId } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CategoryQueries.list({
        page,
        limit,
        search,
        status,
        parentId,
        storeId
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (QUERIES) ===
  async getActive(request, reply) {
    try {
      const result = await CategoryQueries.getActive(request.store?.id);
      if (!result) {
        return reply.status(404).send({
          error: "Categories not found"
        });
      }
      return reply.send({ categories: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const result = await CategoryQueries.getStats(request.store?.id);
      if (!result) {
        return reply.status(404).send({
          error: "Categories not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { q, page = 1, limit = 10 } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CategoryQueries.search(q, storeId, { page, limit });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getRootCategories(request, reply) {
    try {
      const { status } = request.query;
      const result = await CategoryQueries.getRootCategories(status);
      return reply.send({ categories: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getChildren(request, reply) {
    try {
      const { id } = request.params;
      const result = await CategoryQueries.getChildren(id, request.store?.id);
      return reply.send({ categories: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getHierarchy(request, reply) {
    try {
      const result = await CategoryQueries.getHierarchy(request.store?.id);
      return reply.send({ categories: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByCode(request, reply) {
    try {
      const { code } = request.params;
      const result = await CategoryQueries.getByCode(code, request.store?.id);
      if (!result) {
        return reply.status(404).send({
          error: "Category not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (COMMANDS) ===
  async updateStatus(request, reply) {
    try {
      const { id } = request.params;
      const { status } = request.body;
      const result = await CategoryCommands.updateStatus(id, status);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.code === "P2025") {
        return reply.status(404).send({
          error: "Category not found"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async moveToParent(request, reply) {
    try {
      const { id } = request.params;
      const { parentId } = request.body;
      const result = await CategoryCommands.moveToParent(id, parentId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.code === "P2025") {
        return reply.status(404).send({
          error: "Category not found"
        });
      }
      if (error.code === "P2003") {
        return reply.status(400).send({
          error: "Invalid parent category reference"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === RELATÓRIOS ===
  async getTopCategoriesByProducts(request, reply) {
    try {
      const { limit = 10, status, includeInactive = false, includeProductDetails = false } = request.query;
      const result = await CategoryQueries.getTopCategoriesByProductsWithDetails(request.store?.id, {
        limit: parseInt(limit),
        status,
        includeInactive: includeInactive === "true",
        includeProductDetails: includeProductDetails === "true"
      });
      return reply.send({
        categories: result,
        metadata: {
          total: result.length,
          limit: parseInt(limit),
          description: "Top categorias com mais produtos",
          chartType: "horizontalBar",
          recommendedLimit: Math.min(parseInt(limit), 10)
        }
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getCategoryCreationEvolution(request, reply) {
    try {
      const {
        period = "month",
        startDate,
        endDate,
        status,
        includeInactive = false,
        includeDetails = false
      } = request.query;
      const startDateObj = startDate ? new Date(startDate) : void 0;
      const endDateObj = endDate ? new Date(endDate) : void 0;
      if (startDateObj && isNaN(startDateObj.getTime())) {
        return reply.status(400).send({
          error: "Data de in\xEDcio inv\xE1lida"
        });
      }
      if (endDateObj && isNaN(endDateObj.getTime())) {
        return reply.status(400).send({
          error: "Data de fim inv\xE1lida"
        });
      }
      if (startDateObj && endDateObj && startDateObj > endDateObj) {
        return reply.status(400).send({
          error: "Data de in\xEDcio deve ser anterior \xE0 data de fim"
        });
      }
      const result = await CategoryQueries.getCategoryCreationEvolutionDetailed(request.store?.id, {
        period,
        startDate: startDateObj,
        endDate: endDateObj,
        status,
        includeInactive: includeInactive === "true",
        includeDetails: includeDetails === "true"
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getActiveInactiveRatio(request, reply) {
    try {
      const { includeDetails = false, includeHierarchy = false } = request.query;
      const result = await CategoryQueries.getActiveInactiveRatio(request.store?.id, {
        includeDetails: includeDetails === "true",
        includeHierarchy: includeHierarchy === "true"
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getActiveInactiveTrend(request, reply) {
    try {
      const {
        period = "month",
        startDate,
        endDate
      } = request.query;
      const startDateObj = startDate ? new Date(startDate) : void 0;
      const endDateObj = endDate ? new Date(endDate) : void 0;
      if (startDateObj && isNaN(startDateObj.getTime())) {
        return reply.status(400).send({
          error: "Data de in\xEDcio inv\xE1lida"
        });
      }
      if (endDateObj && isNaN(endDateObj.getTime())) {
        return reply.status(400).send({
          error: "Data de fim inv\xE1lida"
        });
      }
      if (startDateObj && endDateObj && startDateObj > endDateObj) {
        return reply.status(400).send({
          error: "Data de in\xEDcio deve ser anterior \xE0 data de fim"
        });
      }
      const result = await CategoryQueries.getActiveInactiveTrend(request.store?.id, {
        period,
        startDate: startDateObj,
        endDate: endDateObj
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/category/category.schema.ts
var createCategorySchema = {
  body: {
    type: "object",
    required: ["name"],
    properties: {
      name: { type: "string", minLength: 1, maxLength: 255 },
      description: { type: "string" },
      code: { type: "string" },
      status: { type: "boolean", default: true },
      color: { type: "string" },
      icon: { type: "string" },
      parentId: { type: "string" }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        description: { type: "string", nullable: true },
        code: { type: "string", nullable: true },
        status: { type: "boolean" },
        color: { type: "string", nullable: true },
        icon: { type: "string", nullable: true },
        parentId: { type: "string", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        parent: { type: "object", nullable: true },
        children: { type: "array" },
        products: { type: "array" },
        _count: {
          type: "object",
          properties: {
            children: { type: "number" },
            products: { type: "number" }
          }
        }
      }
    }
  }
};
var updateCategorySchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      name: { type: "string", minLength: 1, maxLength: 255 },
      description: { type: "string" },
      code: { type: "string" },
      status: { type: "boolean" },
      color: { type: "string" },
      icon: { type: "string" },
      parentId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        description: { type: "string", nullable: true },
        code: { type: "string", nullable: true },
        status: { type: "boolean" },
        color: { type: "string", nullable: true },
        icon: { type: "string", nullable: true },
        parentId: { type: "string", nullable: true },
        updatedAt: { type: "string", format: "date-time" },
        parent: { type: "object", nullable: true },
        children: { type: "array" },
        products: { type: "array" },
        _count: {
          type: "object",
          properties: {
            children: { type: "number" },
            products: { type: "number" }
          }
        }
      }
    }
  }
};
var getCategorySchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        description: { type: "string", nullable: true },
        code: { type: "string", nullable: true },
        status: { type: "boolean" },
        color: { type: "string", nullable: true },
        icon: { type: "string", nullable: true },
        parentId: { type: "string", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        parent: { type: "object", nullable: true },
        children: { type: "array" },
        products: { type: "array" },
        _count: {
          type: "object",
          properties: {
            children: { type: "number" },
            products: { type: "number" }
          }
        }
      }
    }
  }
};
var listCategoriesSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      status: { type: "boolean" },
      parentId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              code: { type: "string", nullable: true },
              status: { type: "boolean" },
              color: { type: "string", nullable: true },
              icon: { type: "string", nullable: true },
              parentId: { type: "string", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" },
              parent: { type: "object", nullable: true },
              children: { type: "array" },
              products: { type: "array" },
              _count: {
                type: "object",
                properties: {
                  children: { type: "number" },
                  products: { type: "number" }
                }
              }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var deleteCategorySchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" }
  }
};
var updateStatusSchema2 = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["status"],
    properties: {
      status: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        status: { type: "boolean" },
        parent: { type: "object", nullable: true },
        children: { type: "array" },
        products: { type: "array" },
        _count: {
          type: "object",
          properties: {
            children: { type: "number" },
            products: { type: "number" }
          }
        }
      }
    }
  }
};
var getChildrenSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        categories: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              code: { type: "string", nullable: true },
              status: { type: "boolean" },
              color: { type: "string", nullable: true },
              icon: { type: "string", nullable: true },
              parentId: { type: "string", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" },
              parent: { type: "object", nullable: true },
              children: { type: "array" },
              products: { type: "array" },
              _count: {
                type: "object",
                properties: {
                  children: { type: "number" },
                  products: { type: "number" }
                }
              }
            }
          }
        }
      }
    }
  }
};
var getRootCategoriesSchema = {
  querystring: {
    type: "object",
    properties: {
      status: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        categories: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              code: { type: "string", nullable: true },
              status: { type: "boolean" },
              color: { type: "string", nullable: true },
              icon: { type: "string", nullable: true },
              parentId: { type: "string", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" },
              parent: { type: "object", nullable: true },
              children: { type: "array" },
              products: { type: "array" },
              _count: {
                type: "object",
                properties: {
                  children: { type: "number" },
                  products: { type: "number" }
                }
              }
            }
          }
        }
      }
    }
  }
};
var getTopCategoriesByProductsSchema = {
  querystring: {
    type: "object",
    properties: {
      limit: {
        type: "number",
        minimum: 1,
        maximum: 50,
        default: 10,
        description: "N\xFAmero m\xE1ximo de categorias a retornar (recomendado: 5-10 para gr\xE1ficos)"
      },
      status: {
        type: "boolean",
        description: "Filtrar por status da categoria (true = ativa, false = inativa)"
      },
      includeInactive: {
        type: "boolean",
        default: false,
        description: "Incluir categorias inativas no resultado"
      },
      includeProductDetails: {
        type: "boolean",
        default: false,
        description: "Incluir detalhes dos produtos em cada categoria"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        categories: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              code: { type: "string", nullable: true },
              status: { type: "boolean" },
              color: { type: "string", nullable: true },
              icon: { type: "string", nullable: true },
              parentId: { type: "string", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" },
              parent: {
                type: "object",
                nullable: true,
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  description: { type: "string", nullable: true },
                  code: { type: "string", nullable: true }
                }
              },
              products: {
                type: "array",
                nullable: true,
                items: {
                  type: "object",
                  properties: {
                    id: { type: "string" },
                    product: {
                      type: "object",
                      properties: {
                        id: { type: "string" },
                        name: { type: "string" },
                        description: { type: "string", nullable: true },
                        status: { type: "boolean" },
                        sku: { type: "string", nullable: true },
                        price: { type: "number", nullable: true },
                        stock: { type: "number", nullable: true }
                      }
                    }
                  }
                }
              },
              _count: {
                type: "object",
                properties: {
                  products: { type: "number" },
                  children: { type: "number" }
                }
              }
            }
          }
        },
        metadata: {
          type: "object",
          properties: {
            total: { type: "number" },
            limit: { type: "number" },
            description: { type: "string" },
            chartType: { type: "string" },
            recommendedLimit: { type: "number" }
          }
        }
      }
    }
  }
};
var getCategoryCreationEvolutionSchema = {
  querystring: {
    type: "object",
    properties: {
      period: {
        type: "string",
        enum: ["day", "week", "month", "year"],
        default: "month",
        description: "Per\xEDodo de agrupamento dos dados"
      },
      startDate: {
        type: "string",
        format: "date",
        description: "Data de in\xEDcio do per\xEDodo (YYYY-MM-DD)"
      },
      endDate: {
        type: "string",
        format: "date",
        description: "Data de fim do per\xEDodo (YYYY-MM-DD)"
      },
      status: {
        type: "boolean",
        description: "Filtrar por status da categoria (true = ativa, false = inativa)"
      },
      includeInactive: {
        type: "boolean",
        default: false,
        description: "Incluir categorias inativas no resultado"
      },
      includeDetails: {
        type: "boolean",
        default: false,
        description: "Incluir detalhes adicionais das categorias"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        data: {
          type: "object",
          additionalProperties: {
            type: "object",
            properties: {
              count: { type: "number" },
              categories: {
                type: "array",
                items: {
                  type: "object",
                  properties: {
                    id: { type: "string" },
                    name: { type: "string" },
                    status: { type: "boolean" },
                    createdAt: { type: "string", format: "date-time" },
                    parent: {
                      type: "object",
                      nullable: true,
                      properties: {
                        id: { type: "string" },
                        name: { type: "string" }
                      }
                    },
                    _count: {
                      type: "object",
                      nullable: true,
                      properties: {
                        children: { type: "number" },
                        products: { type: "number" }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        periodStats: {
          type: "object",
          properties: {
            averagePerPeriod: { type: "number" },
            maxPerPeriod: { type: "number" },
            minPerPeriod: { type: "number" },
            totalPeriods: { type: "number" },
            periodsWithGrowth: { type: "number" },
            periodsWithDecline: { type: "number" },
            periodsStable: { type: "number" }
          }
        },
        metadata: {
          type: "object",
          properties: {
            totalCategories: { type: "number" },
            activeCategories: { type: "number" },
            inactiveCategories: { type: "number" },
            period: { type: "string" },
            startDate: { type: "string", nullable: true },
            endDate: { type: "string", nullable: true },
            growthRate: { type: "number" },
            description: { type: "string" },
            chartType: { type: "string" }
          }
        }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getActiveInactiveRatioSchema = {
  querystring: {
    type: "object",
    properties: {
      includeDetails: {
        type: "boolean",
        default: false,
        description: "Incluir detalhes das categorias recentes"
      },
      includeHierarchy: {
        type: "boolean",
        default: false,
        description: "Incluir an\xE1lise hier\xE1rquica das categorias"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        active: {
          type: "object",
          properties: {
            count: { type: "number" },
            percentage: { type: "number" },
            recentCategories: {
              type: "array",
              nullable: true,
              items: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  code: { type: "string", nullable: true },
                  createdAt: { type: "string", format: "date-time" },
                  updatedAt: { type: "string", format: "date-time" },
                  _count: {
                    type: "object",
                    properties: {
                      children: { type: "number" },
                      products: { type: "number" }
                    }
                  }
                }
              }
            }
          }
        },
        inactive: {
          type: "object",
          properties: {
            count: { type: "number" },
            percentage: { type: "number" },
            recentCategories: {
              type: "array",
              nullable: true,
              items: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  code: { type: "string", nullable: true },
                  createdAt: { type: "string", format: "date-time" },
                  updatedAt: { type: "string", format: "date-time" },
                  _count: {
                    type: "object",
                    properties: {
                      children: { type: "number" },
                      products: { type: "number" }
                    }
                  }
                }
              }
            }
          }
        },
        total: { type: "number" },
        hygieneScore: { type: "number" },
        hierarchy: {
          type: "object",
          nullable: true,
          properties: {
            activeWithChildren: { type: "number" },
            inactiveWithChildren: { type: "number" },
            activeWithoutChildren: { type: "number" },
            inactiveWithoutChildren: { type: "number" },
            totalWithChildren: { type: "number" },
            totalWithoutChildren: { type: "number" }
          }
        },
        metadata: {
          type: "object",
          properties: {
            description: { type: "string" },
            chartType: { type: "string" },
            lastUpdated: { type: "string", format: "date-time" }
          }
        }
      }
    }
  }
};
var getActiveInactiveTrendSchema = {
  querystring: {
    type: "object",
    properties: {
      period: {
        type: "string",
        enum: ["day", "week", "month", "year"],
        default: "month",
        description: "Per\xEDodo de agrupamento dos dados"
      },
      startDate: {
        type: "string",
        format: "date",
        description: "Data de in\xEDcio do per\xEDodo (YYYY-MM-DD)"
      },
      endDate: {
        type: "string",
        format: "date",
        description: "Data de fim do per\xEDodo (YYYY-MM-DD)"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        trendData: {
          type: "object",
          additionalProperties: {
            type: "object",
            properties: {
              active: { type: "number" },
              inactive: { type: "number" },
              total: { type: "number" }
            }
          }
        },
        metadata: {
          type: "object",
          properties: {
            period: { type: "string" },
            startDate: { type: "string", nullable: true },
            endDate: { type: "string", nullable: true },
            description: { type: "string" },
            chartType: { type: "string" }
          }
        }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var CategorySchemas = {
  create: createCategorySchema,
  update: updateCategorySchema,
  get: getCategorySchema,
  delete: deleteCategorySchema,
  list: listCategoriesSchema,
  updateStatus: updateStatusSchema2,
  getChildren: getChildrenSchema,
  getRoot: getRootCategoriesSchema,
  getTopCategoriesByProducts: getTopCategoriesByProductsSchema,
  getCategoryCreationEvolution: getCategoryCreationEvolutionSchema,
  getActiveInactiveRatio: getActiveInactiveRatioSchema,
  getActiveInactiveTrend: getActiveInactiveTrendSchema
};

// src/features/category/category.routes.ts
init_auth_middleware();
async function CategoryRoutes(fastify2) {
  fastify2.addHook("preHandler", authMiddleware);
  fastify2.addHook("preHandler", storeContextMiddleware);
  fastify2.post("/", {
    schema: CategorySchemas.create,
    handler: CategoryController.create
  });
  fastify2.get("/", {
    schema: CategorySchemas.list,
    handler: CategoryController.list
  });
  fastify2.get("/:id", {
    schema: CategorySchemas.get,
    handler: CategoryController.get
  });
  fastify2.put("/:id", {
    schema: CategorySchemas.update,
    handler: CategoryController.update
  });
  fastify2.delete("/:id", {
    schema: CategorySchemas.delete,
    handler: CategoryController.delete
  });
  fastify2.get("/active", {
    handler: CategoryController.getActive
  });
  fastify2.get("/stats", {
    handler: CategoryController.getStats
  });
  fastify2.get("/search", {
    schema: {
      querystring: {
        type: "object",
        properties: {
          q: { type: "string" },
          limit: { type: "number" }
        },
        required: ["q"]
      }
    },
    handler: CategoryController.search
  });
  fastify2.get("/root", {
    schema: CategorySchemas.getRoot,
    handler: CategoryController.getRootCategories
  });
  fastify2.get("/:id/children", {
    schema: CategorySchemas.getChildren,
    handler: CategoryController.getChildren
  });
  fastify2.get("/hierarchy", {
    handler: CategoryController.getHierarchy
  });
  fastify2.get("/code/:code", {
    schema: {
      params: {
        type: "object",
        properties: {
          code: { type: "string" }
        },
        required: ["code"]
      }
    },
    handler: CategoryController.getByCode
  });
  fastify2.patch("/:id/status", {
    schema: CategorySchemas.updateStatus,
    handler: CategoryController.updateStatus
  });
  fastify2.patch("/:id/move", {
    schema: {
      params: {
        type: "object",
        properties: {
          id: { type: "string" }
        },
        required: ["id"]
      },
      body: {
        type: "object",
        properties: {
          parentId: { type: "string", nullable: true }
        }
      }
    },
    handler: CategoryController.moveToParent
  });
  fastify2.get("/reports/top-by-products", {
    schema: CategorySchemas.getTopCategoriesByProducts,
    handler: CategoryController.getTopCategoriesByProducts
  });
  fastify2.get("/reports/creation-evolution", {
    schema: CategorySchemas.getCategoryCreationEvolution,
    handler: CategoryController.getCategoryCreationEvolution
  });
  fastify2.get("/reports/active-inactive-ratio", {
    schema: CategorySchemas.getActiveInactiveRatio,
    handler: CategoryController.getActiveInactiveRatio
  });
  fastify2.get("/reports/active-inactive-trend", {
    schema: CategorySchemas.getActiveInactiveTrend,
    handler: CategoryController.getActiveInactiveTrend
  });
}

// src/features/movement/commands/movement.commands.ts
init_prisma();
var MovementCommands = {
  async create(data) {
    console.log("MovementCommands.create called with:", data);
    const storeId = data.storeId;
    console.log("Using storeId:", storeId);
    const product = await db.product.findFirst({
      where: {
        id: data.productId,
        storeId,
        status: true
      }
    });
    console.log("Product found:", product);
    if (!product) {
      throw new Error("Product not found in this store");
    }
    if (data.supplierId) {
      const supplier = await db.supplier.findUnique({
        where: {
          id: data.supplierId,
          status: true
        }
      });
      if (!supplier) {
        throw new Error("Supplier not found or inactive");
      }
    }
    console.log("Calculating current stock for product:", data.productId, "store:", storeId);
    const currentStock = await MovementCommands.getCurrentStock(data.productId, storeId);
    console.log("Current stock:", currentStock);
    let balanceAfter = currentStock;
    if (data.type === "ENTRADA") {
      balanceAfter = currentStock + data.quantity;
    } else if (data.type === "SAIDA" || data.type === "PERDA") {
      if (currentStock < data.quantity) {
        throw new Error("Insufficient stock for this movement");
      }
      balanceAfter = currentStock - data.quantity;
    }
    console.log("Balance after movement:", balanceAfter);
    console.log("Creating movement in database...");
    const movement = await db.movement.create({
      data: {
        type: data.type,
        quantity: data.quantity,
        storeId,
        productId: data.productId,
        supplierId: data.supplierId,
        batch: data.batch,
        expiration: data.expiration ? new Date(data.expiration) : null,
        price: data.price,
        note: data.note,
        userId: data.userId,
        balanceAfter,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      },
      include: {
        store: {
          select: {
            id: true,
            name: true
          }
        },
        product: {
          select: {
            id: true,
            name: true,
            unitOfMeasure: true
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    console.log("Movement created successfully:", movement);
    return movement;
  },
  async update(id, data) {
    const existingMovement = await db.movement.findUnique({
      where: { id },
      include: {
        product: true
      }
    });
    if (!existingMovement) {
      throw new Error("Movement not found");
    }
    if (data.quantity !== void 0 || data.type !== void 0) {
      const currentStock = await MovementCommands.getCurrentStock(existingMovement.productId, existingMovement.storeId);
      let revertedStock = currentStock;
      if (existingMovement.type === "ENTRADA") {
        revertedStock = currentStock - existingMovement.quantity;
      } else if (existingMovement.type === "SAIDA" || existingMovement.type === "PERDA") {
        revertedStock = currentStock + existingMovement.quantity;
      }
      const newQuantity = data.quantity ?? existingMovement.quantity;
      const newType = data.type ?? existingMovement.type;
      let newBalanceAfter = revertedStock;
      if (newType === "ENTRADA") {
        newBalanceAfter = revertedStock + newQuantity;
      } else if (newType === "SAIDA" || newType === "PERDA") {
        if (revertedStock < newQuantity) {
          throw new Error("Insufficient stock for this movement");
        }
        newBalanceAfter = revertedStock - newQuantity;
      }
      data.balanceAfter = newBalanceAfter;
    }
    const updateData = {
      ...data,
      expiration: data.expiration ? new Date(data.expiration) : void 0,
      updatedAt: /* @__PURE__ */ new Date()
    };
    return await db.movement.update({
      where: { id },
      data: updateData,
      include: {
        store: {
          select: {
            id: true,
            name: true
          }
        },
        product: {
          select: {
            id: true,
            name: true,
            unitOfMeasure: true
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async delete(id) {
    const movement = await db.movement.findUnique({
      where: { id }
    });
    if (!movement) {
      throw new Error("Movement not found");
    }
    const currentStock = await MovementCommands.getCurrentStock(movement.productId, movement.storeId);
    if (movement.type === "SAIDA" || movement.type === "PERDA") {
      if (currentStock < movement.quantity) {
        throw new Error("Cannot delete movement: insufficient stock to revert");
      }
    }
    await db.movement.delete({
      where: { id }
    });
    return { success: true };
  },
  async getCurrentStock(productId, storeId) {
    const movements = await db.movement.findMany({
      where: {
        productId,
        storeId
      },
      orderBy: {
        createdAt: "desc"
      }
    });
    let stock = 0;
    for (const movement of movements) {
      if (movement.type === "ENTRADA") {
        stock += movement.quantity;
      } else if (movement.type === "SAIDA" || movement.type === "PERDA") {
        stock -= movement.quantity;
      }
    }
    return Math.max(0, stock);
  },
  async recalculateStock(productId, storeId) {
    const movements = await db.movement.findMany({
      where: {
        productId,
        storeId
      },
      orderBy: {
        createdAt: "asc"
      }
    });
    let currentStock = 0;
    const updatedMovements = [];
    for (const movement of movements) {
      if (movement.type === "ENTRADA") {
        currentStock += movement.quantity;
      } else if (movement.type === "SAIDA" || movement.type === "PERDA") {
        currentStock -= movement.quantity;
      }
      if (movement.balanceAfter !== currentStock) {
        updatedMovements.push({
          id: movement.id,
          balanceAfter: currentStock
        });
      }
    }
    if (updatedMovements.length > 0) {
      await db.$transaction(
        updatedMovements.map(
          (movement) => db.movement.update({
            where: { id: movement.id },
            data: { balanceAfter: movement.balanceAfter }
          })
        )
      );
    }
    return currentStock;
  },
  // === FUNÇÕES ADICIONAIS DE MOVIMENTAÇÃO ===
  async createBulk(movements, userId) {
    const results = [];
    let successCount = 0;
    let failedCount = 0;
    for (let i = 0; i < movements.length; i++) {
      try {
        const movement = await MovementCommands.create({
          ...movements[i],
          userId
        });
        results.push({
          index: i,
          success: true,
          movement
        });
        successCount++;
      } catch (error) {
        results.push({
          index: i,
          success: false,
          error: error.message
        });
        failedCount++;
      }
    }
    return {
      success: successCount,
      failed: failedCount,
      results
    };
  },
  async verify(id, verified, note, userId) {
    const movement = await db.movement.findUnique({
      where: { id }
    });
    if (!movement) {
      throw new Error("Movement not found");
    }
    return await db.movement.update({
      where: { id },
      data: {
        verified,
        verifiedAt: verified ? /* @__PURE__ */ new Date() : null,
        verifiedBy: verified ? userId : null,
        verificationNote: note,
        updatedAt: /* @__PURE__ */ new Date()
      },
      include: {
        store: {
          select: {
            id: true,
            name: true
          }
        },
        product: {
          select: {
            id: true,
            name: true,
            unitOfMeasure: true
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async cancel(id, reason, userId) {
    const movement = await db.movement.findUnique({
      where: { id }
    });
    if (!movement) {
      throw new Error("Movement not found");
    }
    if (movement.cancelled) {
      throw new Error("Movement already cancelled");
    }
    const currentStock = await MovementCommands.getCurrentStock(movement.productId, movement.storeId);
    if (movement.type === "SAIDA" || movement.type === "PERDA") {
      if (currentStock < movement.quantity) {
        throw new Error("Cannot cancel movement: insufficient stock to revert");
      }
    }
    return await db.movement.update({
      where: { id },
      data: {
        cancelled: true,
        cancelledAt: /* @__PURE__ */ new Date(),
        cancelledBy: userId,
        cancellationReason: reason,
        updatedAt: /* @__PURE__ */ new Date()
      },
      include: {
        store: {
          select: {
            id: true,
            name: true
          }
        },
        product: {
          select: {
            id: true,
            name: true,
            unitOfMeasure: true
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async getMovementReport(params) {
    const {
      storeId,
      productId,
      supplierId,
      type,
      startDate,
      endDate,
      groupBy = "day"
    } = params;
    const where = {};
    if (storeId) where.storeId = storeId;
    if (productId) where.productId = productId;
    if (supplierId) where.supplierId = supplierId;
    if (type) where.type = type;
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) where.createdAt.gte = new Date(startDate);
      if (endDate) where.createdAt.lte = new Date(endDate);
    }
    const movements = await db.movement.findMany({
      where,
      include: {
        store: {
          select: {
            id: true,
            name: true
          }
        },
        product: {
          select: {
            id: true,
            name: true
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true
          }
        }
      },
      orderBy: { createdAt: "asc" }
    });
    const groupedData = /* @__PURE__ */ new Map();
    movements.forEach((movement) => {
      let dateKey;
      const date = new Date(movement.createdAt);
      switch (groupBy) {
        case "day":
          dateKey = date.toISOString().split("T")[0];
          break;
        case "week":
          const weekStart = new Date(date);
          weekStart.setDate(date.getDate() - date.getDay());
          dateKey = weekStart.toISOString().split("T")[0];
          break;
        case "month":
          dateKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, "0")}`;
          break;
        case "year":
          dateKey = String(date.getFullYear());
          break;
        default:
          dateKey = date.toISOString().split("T")[0];
      }
      if (!groupedData.has(dateKey)) {
        groupedData.set(dateKey, {
          movements: 0,
          value: 0,
          entrada: 0,
          saida: 0,
          perda: 0
        });
      }
      const data2 = groupedData.get(dateKey);
      data2.movements++;
      data2.value += Number(movement.price) || 0;
      if (movement.type === "ENTRADA") {
        data2.entrada += movement.quantity;
      } else if (movement.type === "SAIDA") {
        data2.saida += movement.quantity;
      } else if (movement.type === "PERDA") {
        data2.perda += movement.quantity;
      }
    });
    const data = Array.from(groupedData.entries()).map(([date, stats]) => ({
      date,
      ...stats
    }));
    const byType = {
      ENTRADA: { count: 0, value: 0, quantity: 0 },
      SAIDA: { count: 0, value: 0, quantity: 0 },
      PERDA: { count: 0, value: 0, quantity: 0 }
    };
    movements.forEach((movement) => {
      const typeData = byType[movement.type];
      typeData.count++;
      typeData.value += Number(movement.price) || 0;
      typeData.quantity += movement.quantity;
    });
    const storeMap = /* @__PURE__ */ new Map();
    movements.forEach((movement) => {
      const storeId2 = movement.storeId;
      if (!storeMap.has(storeId2)) {
        storeMap.set(storeId2, { movements: 0, value: 0 });
      }
      const storeData = storeMap.get(storeId2);
      storeData.movements++;
      storeData.value += Number(movement.price) || 0;
    });
    const byStore = Array.from(storeMap.entries()).map(([storeId2, stats]) => {
      const store = movements.find((m) => m.storeId === storeId2)?.store;
      return {
        storeId: storeId2,
        storeName: store?.name || "Unknown",
        ...stats
      };
    });
    const productMap = /* @__PURE__ */ new Map();
    movements.forEach((movement) => {
      const productId2 = movement.productId;
      if (!productMap.has(productId2)) {
        productMap.set(productId2, { movements: 0, quantity: 0 });
      }
      const productData = productMap.get(productId2);
      productData.movements++;
      productData.quantity += movement.quantity;
    });
    const byProduct = Array.from(productMap.entries()).map(([productId2, stats]) => {
      const product = movements.find((m) => m.productId === productId2)?.product;
      return {
        productId: productId2,
        productName: product?.name || "Unknown",
        ...stats
      };
    });
    const supplierMap = /* @__PURE__ */ new Map();
    movements.forEach((movement) => {
      if (movement.supplierId) {
        const supplierId2 = movement.supplierId;
        if (!supplierMap.has(supplierId2)) {
          supplierMap.set(supplierId2, { movements: 0, value: 0 });
        }
        const supplierData = supplierMap.get(supplierId2);
        supplierData.movements++;
        supplierData.value += Number(movement.price) || 0;
      }
    });
    const bySupplier = Array.from(supplierMap.entries()).map(([supplierId2, stats]) => {
      const supplier = movements.find((m) => m.supplierId === supplierId2)?.supplier;
      return {
        supplierId: supplierId2,
        supplierName: supplier?.corporateName || "Unknown",
        ...stats
      };
    });
    return {
      summary: {
        totalMovements: movements.length,
        totalValue: movements.reduce((sum, m) => sum + (Number(m.price) || 0), 0),
        period: {
          startDate: startDate || new Date(Math.min(...movements.map((m) => m.createdAt.getTime()))).toISOString().split("T")[0],
          endDate: endDate || new Date(Math.max(...movements.map((m) => m.createdAt.getTime()))).toISOString().split("T")[0]
        }
      },
      data,
      byType,
      byStore,
      byProduct,
      bySupplier
    };
  }
};

// src/features/movement/queries/movement.queries.ts
init_prisma();

// src/services/llm/index.ts
var import_ollama = require("@langchain/ollama");
var import_messages = require("@langchain/core/messages");
var defaultModel = new import_ollama.ChatOllama({
  model: "mistral",
  temperature: 0.2
});
var LLMService = {
  async executePrompt(prompt) {
    try {
      const response = await defaultModel.invoke([new import_messages.HumanMessage(prompt)]);
      return response.content;
    } catch (error) {
      console.error("Erro em executePrompt:", error);
      throw new Error("Falha ao executar prompt no LLM");
    }
  },
  async executeWithStreaming(prompt, onToken) {
    try {
      if (!defaultModel.stream) {
        throw new Error("Streaming n\xE3o suportado nesta vers\xE3o do ChatOllama");
      }
      const stream = await defaultModel.stream([new import_messages.HumanMessage(prompt)]);
      let fullResponse = "";
      for await (const chunk of stream) {
        const token = chunk.content;
        if (token) {
          fullResponse += token;
          onToken(token);
        }
      }
      return fullResponse;
    } catch (error) {
      console.error("Erro em executeWithStreaming:", error);
      throw new Error("Falha ao executar prompt com streaming");
    }
  },
  async executeBatch(prompts) {
    try {
      const results = await Promise.all(prompts.map((p) => this.executePrompt(p)));
      return results;
    } catch (error) {
      console.error("Erro em executeBatch:", error);
      throw new Error("Falha ao executar batch de prompts no LLM");
    }
  },
  async executeWithTemplate(template, variables) {
    try {
      const prompt = await template.format(variables);
      return await this.executePrompt(prompt);
    } catch (error) {
      console.error("Erro em executeWithTemplate:", error);
      throw new Error("Falha ao executar prompt com template");
    }
  },
  async executeWithOptions(prompt, options) {
    try {
      const useDefault = (options.temperature ?? 0.2) === 0.2 && (options.numPredict ?? 1e3) === 1e3 && (options.repeatPenalty ?? 1.1) === 1.1;
      if (useDefault) {
        return await this.executePrompt(prompt);
      }
      const tempModel = new import_ollama.ChatOllama({
        model: "mistral",
        temperature: options.temperature ?? 0.2,
        numPredict: options.numPredict ?? 1e3,
        repeatPenalty: options.repeatPenalty ?? 1.1
      });
      const response = await tempModel.invoke([new import_messages.HumanMessage(prompt)]);
      return response.content;
    } catch (error) {
      console.error("Erro em executeWithOptions:", error);
      throw new Error("Falha ao executar prompt com op\xE7\xF5es customizadas");
    }
  }
};

// src/features/movement/queries/movement.queries.ts
var MovementQueries = {
  async getById(id) {
    console.log("MovementQueries.getById: Searching for movement with id:", id);
    const movement = await db.movement.findUnique({
      where: { id },
      include: {
        store: {
          select: {
            id: true,
            name: true
          }
        },
        product: {
          select: {
            id: true,
            name: true,
            unitOfMeasure: true
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    if (!movement) {
      console.log("MovementQueries.getById: Movement not found");
      return null;
    }
    console.log("MovementQueries.getById: Found movement with relations:", {
      id: movement.id,
      storeId: movement.storeId,
      productId: movement.productId,
      supplierId: movement.supplierId,
      userId: movement.userId,
      store: movement.store,
      product: movement.product,
      supplier: movement.supplier,
      user: movement.user
    });
    const result = {
      ...movement,
      store: movement.store || null,
      product: movement.product || null,
      supplier: movement.supplier || null,
      user: movement.user || null
    };
    console.log("MovementQueries.getById: Final result:", JSON.stringify(result, null, 2));
    return result;
  },
  async list(params) {
    const {
      page = 1,
      limit = 10,
      search,
      type,
      storeId,
      productId,
      supplierId,
      startDate,
      endDate
    } = params;
    const skip = (page - 1) * limit;
    const where = {};
    if (type) {
      where.type = type;
    }
    if (storeId) {
      where.storeId = storeId;
    }
    if (productId) {
      where.productId = productId;
    }
    if (supplierId) {
      where.supplierId = supplierId;
    }
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) {
        where.createdAt.gte = new Date(startDate);
      }
      if (endDate) {
        where.createdAt.lte = new Date(endDate);
      }
    }
    if (search) {
      where.OR = [
        {
          product: {
            name: {
              contains: search,
              mode: "insensitive"
            }
          }
        },
        {
          store: {
            name: {
              contains: search,
              mode: "insensitive"
            }
          }
        },
        {
          supplier: {
            corporateName: {
              contains: search,
              mode: "insensitive"
            }
          }
        },
        {
          batch: {
            contains: search,
            mode: "insensitive"
          }
        },
        {
          note: {
            contains: search,
            mode: "insensitive"
          }
        }
      ];
    }
    const [items, total] = await Promise.all([
      db.movement.findMany({
        where,
        skip,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          store: {
            select: {
              id: true,
              name: true
            }
          },
          product: {
            select: {
              id: true,
              name: true,
              unitOfMeasure: true
            }
          },
          supplier: {
            select: {
              id: true,
              corporateName: true
            }
          },
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      }),
      db.movement.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async search(term, limit = 10) {
    return await db.movement.findMany({
      where: {
        OR: [
          {
            product: {
              name: {
                contains: term,
                mode: "insensitive"
              }
            }
          },
          {
            store: {
              name: {
                contains: term,
                mode: "insensitive"
              }
            }
          },
          {
            supplier: {
              corporateName: {
                contains: term,
                mode: "insensitive"
              }
            }
          },
          {
            batch: {
              contains: term,
              mode: "insensitive"
            }
          }
        ]
      },
      take: limit,
      orderBy: { createdAt: "desc" },
      include: {
        store: {
          select: {
            id: true,
            name: true
          }
        },
        product: {
          select: {
            id: true,
            name: true,
            unitOfMeasure: true
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true
          }
        }
      }
    });
  },
  async getByStore(storeId, params) {
    const { page = 1, limit = 10, type, startDate, endDate } = params;
    const skip = (page - 1) * limit;
    const where = { storeId };
    if (type) {
      where.type = type;
    }
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) {
        where.createdAt.gte = new Date(startDate);
      }
      if (endDate) {
        where.createdAt.lte = new Date(endDate);
      }
    }
    const [items, total] = await Promise.all([
      db.movement.findMany({
        where,
        skip,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          store: {
            select: {
              id: true,
              name: true
            }
          },
          product: {
            select: {
              id: true,
              name: true,
              unitOfMeasure: true
            }
          },
          supplier: {
            select: {
              id: true,
              corporateName: true
            }
          },
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      }),
      db.movement.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getByProduct(productId, params) {
    const { page = 1, limit = 10, type, startDate, endDate, storeId } = params;
    const skip = (page - 1) * limit;
    const where = { productId };
    if (storeId) {
      where.storeId = storeId;
    }
    if (type) {
      where.type = type;
    }
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) {
        where.createdAt.gte = new Date(startDate);
      }
      if (endDate) {
        where.createdAt.lte = new Date(endDate);
      }
    }
    const [items, total] = await Promise.all([
      db.movement.findMany({
        where,
        skip,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          store: {
            select: {
              id: true,
              name: true
            }
          },
          supplier: {
            select: {
              id: true,
              corporateName: true
            }
          },
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      }),
      db.movement.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getBySupplier(supplierId, params) {
    const { page = 1, limit = 10, type, startDate, endDate } = params;
    const skip = (page - 1) * limit;
    const where = { supplierId };
    if (type) {
      where.type = type;
    }
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) {
        where.createdAt.gte = new Date(startDate);
      }
      if (endDate) {
        where.createdAt.lte = new Date(endDate);
      }
    }
    const [items, total] = await Promise.all([
      db.movement.findMany({
        where,
        skip,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          store: {
            select: {
              id: true,
              name: true
            }
          },
          product: {
            select: {
              id: true,
              name: true,
              unitOfMeasure: true
            }
          },
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      }),
      db.movement.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getStockHistory(productId, storeId, params) {
    const { startDate, endDate } = params;
    const where = { productId, storeId };
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) {
        where.createdAt.gte = new Date(startDate);
      }
      if (endDate) {
        where.createdAt.lte = new Date(endDate);
      }
    }
    return await db.movement.findMany({
      where,
      orderBy: { createdAt: "asc" },
      select: {
        id: true,
        type: true,
        quantity: true,
        balanceAfter: true,
        createdAt: true,
        batch: true,
        price: true,
        note: true,
        user: {
          select: {
            id: true,
            name: true
          }
        }
      }
    });
  },
  async getCurrentStock(productId, storeId) {
    const movements = await db.movement.findMany({
      where: {
        productId,
        storeId
      },
      orderBy: {
        createdAt: "desc"
      }
    });
    let stock = 0;
    for (const movement of movements) {
      if (movement.type === "ENTRADA") {
        stock += movement.quantity;
      } else if (movement.type === "SAIDA" || movement.type === "PERDA") {
        stock -= movement.quantity;
      }
    }
    return Math.max(0, stock);
  },
  async getStats() {
    const [
      total,
      entrada,
      saida,
      perda,
      totalValue,
      averageValue,
      _byType,
      byStore,
      byProduct,
      bySupplier
    ] = await Promise.all([
      db.movement.count(),
      db.movement.count({ where: { type: "ENTRADA" } }),
      db.movement.count({ where: { type: "SAIDA" } }),
      db.movement.count({ where: { type: "PERDA" } }),
      db.movement.aggregate({
        _sum: {
          price: true
        }
      }),
      db.movement.aggregate({
        _avg: {
          price: true
        }
      }),
      db.movement.groupBy({
        by: ["type"],
        _count: {
          id: true
        }
      }),
      db.movement.groupBy({
        by: ["storeId"],
        _count: {
          id: true
        },
        _sum: {
          price: true
        }
      }),
      db.movement.groupBy({
        by: ["productId"],
        _count: {
          id: true
        },
        _sum: {
          quantity: true
        }
      }),
      db.movement.groupBy({
        by: ["supplierId"],
        _count: {
          id: true
        },
        _sum: {
          price: true
        },
        where: {
          supplierId: {
            not: null
          }
        }
      })
    ]);
    const storeIds = byStore.map((item) => item.storeId);
    const productIds = byProduct.map((item) => item.productId);
    const supplierIds = bySupplier.map((item) => item.supplierId).filter(Boolean);
    const [stores, products, suppliers] = await Promise.all([
      storeIds.length > 0 ? db.store.findMany({
        where: { id: { in: storeIds } },
        select: { id: true, name: true }
      }) : [],
      productIds.length > 0 ? db.product.findMany({
        where: { id: { in: productIds } },
        select: { id: true, name: true }
      }) : [],
      supplierIds.length > 0 ? db.supplier.findMany({
        where: { id: { in: supplierIds } },
        select: { id: true, corporateName: true }
      }) : []
    ]);
    const storeMap = new Map(stores.map((store) => [store.id, store.name]));
    const productMap = new Map(products.map((product) => [product.id, product.name]));
    const supplierMap = new Map(suppliers.map((supplier) => [supplier.id, supplier.corporateName]));
    return {
      total,
      entrada,
      saida,
      perda,
      totalValue: totalValue._sum.price || 0,
      averageValue: averageValue._avg.price || 0,
      byType: {
        ENTRADA: entrada,
        SAIDA: saida,
        PERDA: perda
      },
      byStore: byStore.map((item) => ({
        storeId: item.storeId,
        storeName: storeMap.get(item.storeId) || "Unknown",
        count: item._count.id,
        totalValue: item._sum.price || 0
      })),
      byProduct: byProduct.map((item) => ({
        productId: item.productId,
        productName: productMap.get(item.productId) || "Unknown",
        count: item._count.id,
        totalQuantity: item._sum.quantity || 0
      })),
      bySupplier: bySupplier.map((item) => ({
        supplierId: item.supplierId,
        supplierName: supplierMap.get(item.supplierId) || "Unknown",
        count: item._count.id,
        totalValue: item._sum.price || 0
      }))
    };
  },
  async getLowStockProducts(storeId) {
    const where = {};
    if (storeId) {
      where.storeId = storeId;
    }
    const products = await db.product.findMany({
      where: {
        ...where,
        status: true
      },
      include: {
        movements: {
          where: {
            storeId: storeId || void 0
          },
          orderBy: {
            createdAt: "desc"
          }
        },
        store: {
          select: {
            id: true,
            name: true
          }
        }
      }
    });
    const lowStockProducts = [];
    for (const product of products) {
      const currentStock = await MovementQueries.getCurrentStock(product.id, product.storeId);
      const alertThreshold = Math.floor(product.stockMin * product.alertPercentage / 100);
      if (currentStock <= alertThreshold) {
        lowStockProducts.push({
          product: {
            id: product.id,
            name: product.name,
            unitOfMeasure: product.unitOfMeasure
          },
          store: product.store,
          currentStock,
          stockMin: product.stockMin,
          stockMax: product.stockMax,
          alertThreshold,
          status: currentStock === 0 ? "OUT_OF_STOCK" : "LOW_STOCK"
        });
      }
    }
    return lowStockProducts.sort((a, b) => a.currentStock - b.currentStock);
  },
  // === FUNÇÕES ADICIONAIS DE MOVIMENTAÇÃO ===
  async getMovementReport(params) {
    const { storeId, productId, supplierId, type, startDate, endDate } = params;
    const where = {};
    if (storeId) where.storeId = storeId;
    if (productId) where.productId = productId;
    if (supplierId) where.supplierId = supplierId;
    if (type) where.type = type;
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) where.createdAt.gte = new Date(startDate);
      if (endDate) where.createdAt.lte = new Date(endDate);
    }
    const movements = await db.movement.findMany({
      where,
      orderBy: { createdAt: "desc" },
      include: {
        store: { select: { id: true, name: true } },
        product: { select: { id: true, name: true, unitOfMeasure: true } },
        supplier: { select: { id: true, corporateName: true } },
        user: { select: { id: true, name: true, email: true } }
      }
    });
    return {
      movements,
      summary: {
        total: movements.length,
        totalValue: movements.reduce((sum, m) => sum + (Number(m.price) || 0), 0),
        byType: movements.reduce((acc, m) => {
          acc[m.type] = (acc[m.type] || 0) + 1;
          return acc;
        }, {})
      }
    };
  },
  async getVerifiedMovements(params) {
    const { page = 1, limit = 10, storeId, verified, startDate, endDate } = params;
    const skip = (page - 1) * limit;
    const where = {};
    if (storeId) where.storeId = storeId;
    if (verified !== void 0) where.verified = verified;
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) where.createdAt.gte = new Date(startDate);
      if (endDate) where.createdAt.lte = new Date(endDate);
    }
    const [items, total] = await Promise.all([
      db.movement.findMany({
        where,
        skip,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          store: {
            select: {
              id: true,
              name: true
            }
          },
          product: {
            select: {
              id: true,
              name: true,
              unitOfMeasure: true
            }
          },
          supplier: {
            select: {
              id: true,
              corporateName: true
            }
          },
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      }),
      db.movement.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getCancelledMovements(params) {
    const { page = 1, limit = 10, storeId, startDate, endDate } = params;
    const skip = (page - 1) * limit;
    const where = { cancelled: true };
    if (storeId) where.storeId = storeId;
    if (startDate || endDate) {
      where.cancelledAt = {};
      if (startDate) where.cancelledAt.gte = new Date(startDate);
      if (endDate) where.cancelledAt.lte = new Date(endDate);
    }
    const [items, total] = await Promise.all([
      db.movement.findMany({
        where,
        skip,
        take: limit,
        orderBy: { cancelledAt: "desc" },
        include: {
          store: {
            select: {
              id: true,
              name: true
            }
          },
          product: {
            select: {
              id: true,
              name: true,
              unitOfMeasure: true
            }
          },
          supplier: {
            select: {
              id: true,
              corporateName: true
            }
          },
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      }),
      db.movement.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getMovementAnalytics(params) {
    const { storeId, productId, supplierId, startDate, endDate } = params;
    const where = {};
    if (storeId) where.storeId = storeId;
    if (productId) where.productId = productId;
    if (supplierId) where.supplierId = supplierId;
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) where.createdAt.gte = new Date(startDate);
      if (endDate) where.createdAt.lte = new Date(endDate);
    }
    const [
      totalMovements,
      totalValue,
      averageValue,
      byType,
      byMonth,
      byStore,
      byProduct,
      bySupplier,
      verifiedCount,
      cancelledCount
    ] = await Promise.all([
      db.movement.count({ where }),
      db.movement.aggregate({
        where,
        _sum: { price: true }
      }),
      db.movement.aggregate({
        where,
        _avg: { price: true }
      }),
      db.movement.groupBy({
        by: ["type"],
        where,
        _count: { id: true },
        _sum: { quantity: true, price: true }
      }),
      db.movement.groupBy({
        by: ["createdAt"],
        where,
        _count: { id: true },
        _sum: { price: true },
        orderBy: { createdAt: "asc" }
      }),
      db.movement.groupBy({
        by: ["storeId"],
        where,
        _count: { id: true },
        _sum: { price: true }
      }),
      db.movement.groupBy({
        by: ["productId"],
        where,
        _count: { id: true },
        _sum: { quantity: true, price: true }
      }),
      db.movement.groupBy({
        by: ["supplierId"],
        where: { ...where, supplierId: { not: null } },
        _count: { id: true },
        _sum: { price: true }
      }),
      db.movement.count({ where: { ...where, verified: true } }),
      db.movement.count({ where: { ...where, cancelled: true } })
    ]);
    const storeIds = byStore.map((item) => item.storeId);
    const productIds = byProduct.map((item) => item.productId);
    const supplierIds = bySupplier.map((item) => item.supplierId).filter(Boolean);
    const [stores, products, suppliers] = await Promise.all([
      storeIds.length > 0 ? db.store.findMany({
        where: { id: { in: storeIds } },
        select: { id: true, name: true }
      }) : [],
      productIds.length > 0 ? db.product.findMany({
        where: { id: { in: productIds } },
        select: { id: true, name: true }
      }) : [],
      supplierIds.length > 0 ? db.supplier.findMany({
        where: { id: { in: supplierIds } },
        select: { id: true, corporateName: true }
      }) : []
    ]);
    const storeMap = new Map(stores.map((store) => [store.id, store.name]));
    const productMap = new Map(products.map((product) => [product.id, product.name]));
    const supplierMap = new Map(suppliers.map((supplier) => [supplier.id, supplier.corporateName]));
    return {
      summary: {
        totalMovements,
        totalValue: totalValue._sum.price || 0,
        averageValue: averageValue._avg.price || 0,
        verifiedCount,
        cancelledCount,
        verificationRate: totalMovements > 0 ? verifiedCount / totalMovements * 100 : 0,
        cancellationRate: totalMovements > 0 ? cancelledCount / totalMovements * 100 : 0
      },
      byType: byType.map((item) => ({
        type: item.type,
        count: item._count.id,
        quantity: item._sum.quantity || 0,
        value: item._sum.price || 0
      })),
      byMonth: byMonth.map((item) => ({
        month: item.createdAt.toISOString().substring(0, 7),
        count: item._count.id,
        value: item._sum.price || 0
      })),
      byStore: byStore.map((item) => ({
        storeId: item.storeId,
        storeName: storeMap.get(item.storeId) || "Unknown",
        count: item._count.id,
        value: item._sum.price || 0
      })),
      byProduct: byProduct.map((item) => ({
        productId: item.productId,
        productName: productMap.get(item.productId) || "Unknown",
        count: item._count.id,
        quantity: item._sum.quantity || 0,
        value: item._sum.price || 0
      })),
      bySupplier: bySupplier.map((item) => ({
        supplierId: item.supplierId,
        supplierName: supplierMap.get(item.supplierId) || "Unknown",
        count: item._count.id,
        value: item._sum.price || 0
      }))
    };
  },
  async summarize() {
    const movements = await db.movement.findMany();
    const summary = movements.map(
      (m) => `Produto: ${m.productId}, Tipo: ${m.type}, Quantidade: ${m.quantity}`
    ).join("\n");
    const prompt = `
    Ol\xE1! Sou o gerente do estoque e preciso de uma an\xE1lise amig\xE1vel sobre as movimenta\xE7\xF5es de hoje.
      
      Analise os dados abaixo e me conte como est\xE1 nosso estoque de forma conversacional e humanizada.
      Quero entender o que est\xE1 acontecendo sem muito jarg\xE3o t\xE9cnico. Me fale sobre:
      - O que mais est\xE1 entrando e saindo
      - Se temos algum problema com perdas
      - Como est\xE1 a demanda geral
      - Alguma observa\xE7\xE3o importante que devo saber
 
    ${summary}`;
    const result = LLMService.executePrompt(prompt);
    return result;
  },
  /*
    Resumo gerado pelo LLM:
    Olá, eu analisei os dados do seu estoque de hoje e aqui está uma resumida:
  
  - Entradas mais comuns: Notebook Dell Inspiron 15 3000 (25 unidades), SSD NVMe 
  1TB Kingston (30 unidades) e Smartphone Samsung Galaxy A54 (40 unidades). Esses 
  itens estão entrando em grande quantidade, indicando uma alta demanda.
  
  - Saídas mais comuns: Monitor Samsung 24" Full HD (12 unidades), Memória RAM 
  DDR4 16GB Corsair (18 unidades) e Fone Bluetooth JBL Tune 500BT (22 unidades). 
  Esses itens estão sendo vendidos em grande quantidade, indicando uma alta demanda.
  
  - Perdas: Cabo HDMI Premium 2m (3 unidades), Carregador USB-C 65W Universal (1 
  unidade) e Webcam Logitech C920 HD Pro (2 unidades). Esses itens estão sendo 
  perdidos, o que pode ser causado por erros de inventário ou falhas no produto.
  
  - Observação importante: O estoque de Memória RAM DDR4 16GB Corsair está 
  sendo vendido em grande quantidade e também está entrando em pequena quantidade. 
  Isso indica que a demanda pode estar ultrapassando a oferta, o que pode causar 
  problemas no futuro se não for feito alguma ação para aumentar a quantidade 
  disponível.
  
  - Demanda geral: A demanda geral parece ser alta, com muitos itens entrando e 
  saídas em grande quantidade. Isso é um bom sinal para o negócio, mas precisa 
  ser monitorado de forma regular para evitar problemas no futuro.
  
  Espero que essa análise ajude a entender melhor o que está acontecendo com seu 
  estoque hoje!
    */
  async getProductSummary(productId, params) {
    const { startDate, endDate, storeId } = params;
    const product = await db.product.findUnique({
      where: { id: productId },
      select: {
        id: true,
        name: true,
        unitOfMeasure: true,
        stockMin: true,
        stockMax: true,
        alertPercentage: true
      }
    });
    if (!product) {
      throw new Error("Product not found");
    }
    const where = { productId };
    if (storeId) {
      where.storeId = storeId;
    }
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) where.createdAt.gte = new Date(startDate);
      if (endDate) where.createdAt.lte = new Date(endDate);
    }
    const movements = await db.movement.findMany({
      where,
      orderBy: { createdAt: "desc" },
      include: {
        store: {
          select: {
            id: true,
            name: true
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true
          }
        },
        user: {
          select: {
            id: true,
            name: true
          }
        }
      }
    });
    const totalMovements = movements.length;
    const entradaMovements = movements.filter((m) => m.type === "ENTRADA");
    const saidaMovements = movements.filter((m) => m.type === "SAIDA");
    const perdaMovements = movements.filter((m) => m.type === "PERDA");
    const totalEntrada = entradaMovements.reduce((sum, m) => sum + m.quantity, 0);
    const totalSaida = saidaMovements.reduce((sum, m) => sum + m.quantity, 0);
    const totalPerda = perdaMovements.reduce((sum, m) => sum + m.quantity, 0);
    const totalValue = movements.reduce((sum, m) => sum + (Number(m.price) || 0), 0);
    const averageValue = totalMovements > 0 ? totalValue / totalMovements : 0;
    const stores = [...new Set(movements.map((m) => m.storeId))];
    const currentStockByStore = await Promise.all(
      stores.map(async (storeId2) => {
        const currentStock = await MovementQueries.getCurrentStock(productId, storeId2);
        const store = movements.find((m) => m.storeId === storeId2)?.store;
        return {
          storeId: storeId2,
          storeName: store?.name || "Unknown",
          currentStock
        };
      })
    );
    const movementsSummary = movements.slice(0, 20).map(
      (m) => `Data: ${m.createdAt.toISOString().split("T")[0]}, Tipo: ${m.type}, Quantidade: ${m.quantity} ${product.unitOfMeasure}, Loja: ${m.store.name}, Pre\xE7o: R$ ${Number(m.price || 0).toFixed(2)}, Lote: ${m.batch || "N/A"}`
    ).join("\n");
    const prompt = `
      Voc\xEA \xE9 um especialista em an\xE1lise de estoque. Analise as movimenta\xE7\xF5es do produto "${product.name}" e gere um resumo executivo em portugu\xEAs.

      INFORMA\xC7\xD5ES DO PRODUTO:
      - Nome: ${product.name}
      - Unidade: ${product.unitOfMeasure}
      - Estoque M\xEDnimo: ${product.stockMin}
      - Estoque M\xE1ximo: ${product.stockMax}
      - Percentual de Alerta: ${product.alertPercentage}%

      ESTAT\xCDSTICAS GERAIS:
      - Total de Movimenta\xE7\xF5es: ${totalMovements}
      - Entradas: ${entradaMovements.length} (${totalEntrada} ${product.unitOfMeasure})
      - Sa\xEDdas: ${saidaMovements.length} (${totalSaida} ${product.unitOfMeasure})
      - Perdas: ${perdaMovements.length} (${totalPerda} ${product.unitOfMeasure})
      - Valor Total: R$ ${totalValue.toFixed(2)}
      - Valor M\xE9dio por Movimenta\xE7\xE3o: R$ ${averageValue.toFixed(2)}

      ESTOQUE ATUAL POR LOJA:
      ${currentStockByStore.map((s) => `- ${s.storeName}: ${s.currentStock} ${product.unitOfMeasure}`).join("\n")}

      MOVIMENTA\xC7\xD5ES RECENTES:
      ${movementsSummary}

      Gere um resumo executivo destacando:
      1. Situa\xE7\xE3o atual do estoque
      2. Tend\xEAncias de movimenta\xE7\xE3o
      3. Alertas importantes (estoque baixo, perdas, etc.)
      4. Recomenda\xE7\xF5es de a\xE7\xE3o
    `;
    const llmSummary = await LLMService.executePrompt(prompt);
    return {
      product: {
        id: product.id,
        name: product.name,
        unitOfMeasure: product.unitOfMeasure,
        stockMin: product.stockMin,
        stockMax: product.stockMax,
        alertPercentage: product.alertPercentage
      },
      period: {
        startDate: startDate || null,
        endDate: endDate || null,
        storeId: storeId || null
      },
      statistics: {
        totalMovements,
        entrada: {
          count: entradaMovements.length,
          quantity: totalEntrada
        },
        saida: {
          count: saidaMovements.length,
          quantity: totalSaida
        },
        perda: {
          count: perdaMovements.length,
          quantity: totalPerda
        },
        totalValue,
        averageValue
      },
      currentStockByStore,
      recentMovements: movements.slice(0, 10).map((m) => ({
        id: m.id,
        type: m.type,
        quantity: m.quantity,
        price: m.price,
        batch: m.batch,
        createdAt: m.createdAt,
        store: m.store,
        supplier: m.supplier,
        user: m.user
      })),
      summary: llmSummary
    };
  }
};

// src/features/movement/movement.controller.ts
init_prisma();

// src/services/stock-monitoring/stock-alert.service.ts
init_prisma();

// src/features/notification/commands/notification.commands.ts
init_prisma();
var NotificationCommands = {
  async create(data) {
    return await db.notification.create({
      data: {
        userId: data.userId,
        title: data.title,
        message: data.message,
        type: data.type || "INFO",
        priority: data.priority || "MEDIUM",
        data: data.data,
        actionUrl: data.actionUrl,
        expiresAt: data.expiresAt
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async update(id, data) {
    return await db.notification.update({
      where: { id },
      data,
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async delete(id) {
    return await db.notification.delete({
      where: { id }
    });
  },
  async markAsRead(id) {
    return await db.notification.update({
      where: { id },
      data: {
        isRead: true,
        readAt: /* @__PURE__ */ new Date()
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async markAsUnread(id) {
    return await db.notification.update({
      where: { id },
      data: {
        isRead: false,
        readAt: null
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async markAllAsRead(userId) {
    return await db.notification.updateMany({
      where: {
        userId,
        isRead: false
      },
      data: {
        isRead: true,
        readAt: /* @__PURE__ */ new Date()
      }
    });
  },
  async deleteExpired() {
    return await db.notification.deleteMany({
      where: {
        expiresAt: {
          lt: /* @__PURE__ */ new Date()
        }
      }
    });
  },
  async deleteByUser(userId) {
    return await db.notification.deleteMany({
      where: { userId }
    });
  },
  async markStockAlertsAsRead(userId, storeId) {
    const whereCondition = {
      userId,
      isRead: false,
      type: "STOCK_ALERT"
    };
    if (storeId) {
      whereCondition.data = {
        path: ["storeId"],
        equals: storeId
      };
    }
    return await db.notification.updateMany({
      where: whereCondition,
      data: {
        isRead: true,
        readAt: /* @__PURE__ */ new Date()
      }
    });
  }
};

// src/services/stock-monitoring/stock-alert.service.ts
var StockAlertService = class {
  /**
   * Verifica se uma movimentação deve gerar alertas de estoque
   */
  static async checkStockAlerts(productId, storeId, movementType, movementQuantity, movementId) {
    try {
      const product = await db.product.findFirst({
        where: {
          id: productId,
          storeId,
          status: true
        },
        include: {
          store: {
            select: {
              id: true,
              name: true,
              ownerId: true,
              users: {
                select: {
                  userId: true,
                  user: {
                    select: {
                      id: true,
                      name: true,
                      email: true
                    }
                  }
                }
              }
            }
          }
        }
      });
      if (!product) {
        throw new Error("Product not found");
      }
      const movements = await db.movement.findMany({
        where: {
          productId,
          cancelled: false
        },
        select: {
          type: true,
          quantity: true
        }
      });
      let currentStock = 0;
      movements.forEach((movement) => {
        if (movement.type === "ENTRADA") {
          currentStock += movement.quantity;
        } else {
          currentStock -= movement.quantity;
        }
      });
      const previousStock = movementType === "ENTRADA" ? currentStock - movementQuantity : currentStock + movementQuantity;
      const alertType = this.determineAlertType(
        currentStock,
        previousStock,
        product.stockMin,
        product.stockMax,
        product.alertPercentage
      );
      if (!alertType) {
        return {
          alertTriggered: false,
          alertType: null
        };
      }
      const alertData = {
        productId: product.id,
        productName: product.name,
        storeId: product.store.id,
        storeName: product.store.name,
        currentStock,
        stockMin: product.stockMin,
        stockMax: product.stockMax,
        alertPercentage: product.alertPercentage,
        previousStock,
        movementType,
        movementQuantity,
        movementId
      };
      const notifications = await this.createStockAlertNotifications(alertData, alertType, product.store);
      return {
        alertTriggered: true,
        alertType,
        notification: notifications[0],
        // Retorna a primeira notificação como exemplo
        message: this.generateAlertMessage(alertData, alertType)
      };
    } catch (error) {
      console.error("Error checking stock alerts:", error);
      return {
        alertTriggered: false,
        alertType: null
      };
    }
  }
  /**
   * Determina o tipo de alerta baseado no estoque atual e anterior
   */
  static determineAlertType(currentStock, previousStock, stockMin, stockMax, alertPercentage) {
    const alertThreshold = Math.round(stockMin * (alertPercentage / 100));
    if (currentStock <= 0) {
      return "CRITICAL_STOCK";
    }
    if (currentStock <= alertThreshold && currentStock > 0) {
      return "LOW_STOCK";
    }
    if (currentStock > alertThreshold && previousStock <= alertThreshold) {
      return "STOCK_RECOVERED";
    }
    if (currentStock > stockMax && previousStock <= stockMax) {
      return "OVERSTOCK";
    }
    return null;
  }
  /**
   * Cria notificações para usuários da loja
   */
  static async createStockAlertNotifications(alertData, alertType, store) {
    const notifications = [];
    const { priority, notificationType } = this.getNotificationConfig(alertType);
    const ownerNotification = await NotificationCommands.create({
      userId: store.ownerId,
      title: this.getAlertTitle(alertType),
      message: this.generateAlertMessage(alertData, alertType),
      type: notificationType,
      priority,
      data: {
        productId: alertData.productId,
        productName: alertData.productName,
        storeId: alertData.storeId,
        storeName: alertData.storeName,
        currentStock: alertData.currentStock,
        stockMin: alertData.stockMin,
        stockMax: alertData.stockMax,
        movementType: alertData.movementType,
        movementQuantity: alertData.movementQuantity,
        movementId: alertData.movementId,
        alertType
      },
      actionUrl: `/products/${alertData.productId}`,
      expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1e3)
      // 7 dias
    });
    notifications.push(ownerNotification);
    const storeUsers = store.users.filter((su) => su.userId !== store.ownerId);
    for (const storeUser of storeUsers) {
      const userNotification = await NotificationCommands.create({
        userId: storeUser.userId,
        title: this.getAlertTitle(alertType),
        message: this.generateAlertMessage(alertData, alertType),
        type: notificationType,
        priority,
        data: {
          productId: alertData.productId,
          productName: alertData.productName,
          storeId: alertData.storeId,
          storeName: alertData.storeName,
          currentStock: alertData.currentStock,
          stockMin: alertData.stockMin,
          stockMax: alertData.stockMax,
          movementType: alertData.movementType,
          movementQuantity: alertData.movementQuantity,
          movementId: alertData.movementId,
          alertType
        },
        actionUrl: `/products/${alertData.productId}`,
        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1e3)
        // 7 dias
      });
      notifications.push(userNotification);
    }
    return notifications;
  }
  /**
   * Obtém configuração de notificação baseada no tipo de alerta
   */
  static getNotificationConfig(alertType) {
    switch (alertType) {
      case "CRITICAL_STOCK":
        return { priority: "URGENT", notificationType: "ERROR" };
      case "LOW_STOCK":
        return { priority: "HIGH", notificationType: "WARNING" };
      case "OVERSTOCK":
        return { priority: "MEDIUM", notificationType: "WARNING" };
      case "STOCK_RECOVERED":
        return { priority: "LOW", notificationType: "STOCK_ALERT" };
      default:
        return { priority: "MEDIUM", notificationType: "STOCK_ALERT" };
    }
  }
  /**
   * Gera título do alerta
   */
  static getAlertTitle(alertType) {
    switch (alertType) {
      case "CRITICAL_STOCK":
        return "\u{1F6A8} Estoque Cr\xEDtico";
      case "LOW_STOCK":
        return "\u26A0\uFE0F Estoque Baixo";
      case "OVERSTOCK":
        return "\u{1F4E6} Estoque Excessivo";
      case "STOCK_RECOVERED":
        return "\u2705 Estoque Recuperado";
      default:
        return "\u{1F4CA} Alerta de Estoque";
    }
  }
  /**
   * Gera mensagem do alerta
   */
  static generateAlertMessage(alertData, alertType) {
    const { productName, currentStock, stockMin, stockMax, movementType, movementQuantity } = alertData;
    switch (alertType) {
      case "CRITICAL_STOCK":
        return `Produto "${productName}" est\xE1 com estoque cr\xEDtico (${currentStock} unidades). Movimenta\xE7\xE3o de ${movementType.toLowerCase()} de ${movementQuantity} unidades realizada.`;
      case "LOW_STOCK":
        return `Produto "${productName}" est\xE1 com estoque baixo (${currentStock} unidades). Estoque m\xEDnimo: ${stockMin} unidades. Movimenta\xE7\xE3o de ${movementType.toLowerCase()} de ${movementQuantity} unidades realizada.`;
      case "OVERSTOCK":
        return `Produto "${productName}" est\xE1 com estoque excessivo (${currentStock} unidades). Estoque m\xE1ximo: ${stockMax} unidades. Movimenta\xE7\xE3o de ${movementType.toLowerCase()} de ${movementQuantity} unidades realizada.`;
      case "STOCK_RECOVERED":
        return `Produto "${productName}" recuperou o estoque (${currentStock} unidades). Estoque m\xEDnimo: ${stockMin} unidades. Movimenta\xE7\xE3o de ${movementType.toLowerCase()} de ${movementQuantity} unidades realizada.`;
      default:
        return `Alerta de estoque para o produto "${productName}" (${currentStock} unidades).`;
    }
  }
  /**
   * Verifica produtos com estoque baixo em uma loja
   */
  static async checkLowStockProducts(storeId) {
    try {
      const products = await db.product.findMany({
        where: {
          storeId,
          status: true
        },
        include: {
          store: {
            select: {
              id: true,
              name: true
            }
          }
        }
      });
      const lowStockProducts = [];
      for (const product of products) {
        const movements = await db.movement.findMany({
          where: {
            productId: product.id,
            cancelled: false
          },
          select: {
            type: true,
            quantity: true
          }
        });
        let currentStock = 0;
        movements.forEach((movement) => {
          if (movement.type === "ENTRADA") {
            currentStock += movement.quantity;
          } else {
            currentStock -= movement.quantity;
          }
        });
        const alertThreshold = Math.round(product.stockMin * (product.alertPercentage / 100));
        if (currentStock <= alertThreshold) {
          lowStockProducts.push({
            productId: product.id,
            productName: product.name,
            currentStock,
            stockMin: product.stockMin,
            stockMax: product.stockMax,
            alertPercentage: product.alertPercentage,
            alertThreshold,
            storeId: product.store.id,
            storeName: product.store.name
          });
        }
      }
      return lowStockProducts;
    } catch (error) {
      console.error("Error checking low stock products:", error);
      return [];
    }
  }
  /**
   * Cria notificação de resumo de estoque baixo
   */
  static async createLowStockSummaryNotification(storeId) {
    try {
      const lowStockProducts = await this.checkLowStockProducts(storeId);
      if (lowStockProducts.length === 0) {
        return null;
      }
      const store = await db.store.findUnique({
        where: { id: storeId },
        select: {
          id: true,
          name: true,
          ownerId: true,
          users: {
            select: {
              userId: true
            }
          }
        }
      });
      if (!store) {
        throw new Error("Store not found");
      }
      const criticalProducts = lowStockProducts.filter((p) => p.currentStock <= 0);
      const lowProducts = lowStockProducts.filter((p) => p.currentStock > 0);
      const title = `\u{1F4CA} Resumo de Estoque - ${store.name}`;
      const message = `Encontrados ${lowStockProducts.length} produtos com estoque baixo:
\u2022 ${criticalProducts.length} produtos cr\xEDticos (estoque zero)
\u2022 ${lowProducts.length} produtos com estoque baixo

Produtos cr\xEDticos: ${criticalProducts.map((p) => p.productName).join(", ")}`;
      return await NotificationCommands.create({
        userId: store.ownerId,
        title,
        message,
        type: "STOCK_ALERT",
        priority: criticalProducts.length > 0 ? "URGENT" : "HIGH",
        data: {
          storeId,
          storeName: store.name,
          lowStockProducts,
          criticalCount: criticalProducts.length,
          lowCount: lowProducts.length
        },
        actionUrl: `/reports/low-stock?storeId=${storeId}`,
        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1e3)
        // 24 horas
      });
    } catch (error) {
      console.error("Error creating low stock summary notification:", error);
      return null;
    }
  }
};

// src/features/movement/movement.controller.ts
var MovementController = {
  // === CRUD BÁSICO ===
  async create(request, reply) {
    try {
      const { type, quantity, storeId, productId, supplierId, batch, expiration, price, note } = request.body;
      const userId = request.user?.id;
      console.log("Creating movement with data:", {
        type,
        quantity,
        storeId,
        productId,
        supplierId,
        batch,
        price,
        note,
        userId
      });
      const result = await MovementCommands.create({
        type,
        quantity,
        storeId,
        // Agora vem do middleware
        productId,
        supplierId,
        batch,
        expiration,
        price,
        note,
        userId
      });
      console.log("Movement created successfully:", result);
      try {
        const stockAlert = await StockAlertService.checkStockAlerts(
          productId,
          storeId,
          type,
          quantity,
          result.id
        );
        if (stockAlert.alertTriggered) {
          console.log("Stock alert triggered:", stockAlert);
          const resultWithAlert = {
            ...result,
            stockAlert: {
              triggered: true,
              type: stockAlert.alertType,
              message: stockAlert.message
            }
          };
          return reply.status(201).send(resultWithAlert);
        }
      } catch (alertError) {
        console.error("Error checking stock alerts:", alertError);
      }
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found in this store") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Insufficient stock for this movement") {
        return reply.status(400).send({
          error: error.message
        });
      }
      if (error.message === "Supplier not found or inactive") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message.includes("Store ID is required")) {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      console.log("MovementController.get: Getting movement with id:", id);
      const result = await MovementQueries.getById(id);
      if (!result) {
        console.log("MovementController.get: Movement not found");
        return reply.status(404).send({
          error: "Movement not found"
        });
      }
      console.log("MovementController.get: Returning movement:", {
        id: result.id,
        store: result.store,
        product: result.product,
        supplier: result.supplier,
        user: result.user
      });
      console.log("MovementController.get: Full result JSON:", JSON.stringify(result, null, 2));
      const serializedResult = {
        ...result,
        store: result.store ? {
          id: result.store.id,
          name: result.store.name
        } : null,
        product: result.product ? {
          id: result.product.id,
          name: result.product.name,
          unitOfMeasure: result.product.unitOfMeasure
        } : null,
        supplier: result.supplier ? {
          id: result.supplier.id,
          corporateName: result.supplier.corporateName
        } : null,
        user: result.user ? {
          id: result.user.id,
          name: result.user.name,
          email: result.user.email
        } : null
      };
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Movement not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      const result = await MovementCommands.update(id, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Movement not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Insufficient stock for this movement") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      await MovementCommands.delete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Movement not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Cannot delete movement: insufficient stock to revert") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { page = 1, limit = 10, search, type, productId, supplierId, startDate, endDate } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await MovementQueries.list({
        page,
        limit,
        search,
        type,
        storeId,
        productId,
        supplierId,
        startDate,
        endDate
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === NOVOS ENDPOINTS ESPECÍFICOS ===
  async listByStore(request, reply) {
    try {
      const { page = 1, limit = 10, search, type, productId, supplierId, startDate, endDate } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store ID is required. User must be associated with a store."
        });
      }
      console.log("Listing movements for store:", storeId);
      const result = await MovementQueries.getByStore(storeId, {
        page,
        limit,
        type,
        startDate,
        endDate
      });
      if (search || productId || supplierId) {
        const filteredResult = await MovementQueries.list({
          page,
          limit,
          search,
          type,
          storeId,
          productId,
          supplierId,
          startDate,
          endDate
        });
        return reply.send(filteredResult);
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async listByProduct(request, reply) {
    try {
      const { productId } = request.params;
      const { page = 1, limit = 10, type, startDate, endDate } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store ID is required. User must be associated with a store."
        });
      }
      console.log("Listing movements for product:", productId, "in store:", storeId);
      const product = await db.product.findFirst({
        where: {
          id: productId,
          storeId,
          status: true
        }
      });
      if (!product) {
        return reply.status(404).send({
          error: "Product not found in this store"
        });
      }
      const result = await MovementQueries.getByProduct(productId, {
        page,
        limit,
        type,
        startDate,
        endDate
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (QUERIES) ===
  async getByStore(request, reply) {
    try {
      const { storeId } = request.params;
      const { page = 1, limit = 10, type, startDate, endDate } = request.query;
      const result = await MovementQueries.getByStore(storeId, {
        page,
        limit,
        type,
        startDate,
        endDate
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByProduct(request, reply) {
    try {
      const { productId } = request.params;
      const { page = 1, limit = 10, type, startDate, endDate } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store ID is required. User must be associated with a store."
        });
      }
      console.log("Getting movements for product:", productId, "in store:", storeId);
      const product = await ProductQueries.getById(productId, storeId);
      console.log("Product:", product);
      if (!product) {
        return reply.status(404).send({
          error: "Product not found in this store"
        });
      }
      const result = await MovementQueries.getByProduct(productId, {
        page,
        limit,
        type,
        startDate,
        endDate,
        storeId
      });
      console.log("Result:", result);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getBySupplier(request, reply) {
    try {
      const { supplierId } = request.params;
      const { page = 1, limit = 10, type, startDate, endDate } = request.query;
      const result = await MovementQueries.getBySupplier(supplierId, {
        page,
        limit,
        type,
        startDate,
        endDate
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStockHistory(request, reply) {
    try {
      const { productId, storeId } = request.params;
      const { startDate, endDate } = request.query;
      const result = await MovementQueries.getStockHistory(productId, storeId, {
        startDate,
        endDate
      });
      return reply.send({ movements: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getCurrentStock(request, reply) {
    try {
      const { productId, storeId } = request.params;
      const result = await MovementQueries.getCurrentStock(productId, storeId);
      return reply.send({ currentStock: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const result = await MovementQueries.getStats();
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { q, limit = 10 } = request.query;
      const result = await MovementQueries.search(q, limit);
      return reply.send({ movements: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getLowStockProducts(request, reply) {
    try {
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await MovementQueries.getLowStockProducts(storeId);
      return reply.send({ products: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (COMMANDS) ===
  async recalculateStock(request, reply) {
    try {
      const { productId, storeId } = request.params;
      const result = await MovementCommands.recalculateStock(productId, storeId);
      return reply.send({ currentStock: result });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS DE MOVIMENTAÇÃO ===
  async getReport(request, reply) {
    try {
      const { productId, supplierId, type, startDate, endDate, groupBy, format } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await MovementQueries.getMovementReport({
        storeId,
        productId,
        supplierId,
        type,
        startDate,
        endDate,
        groupBy
      });
      if (format === "csv") {
        return reply.type("text/csv").send("CSV generation not implemented yet");
      }
      if (format === "pdf") {
        return reply.type("application/pdf").send("PDF generation not implemented yet");
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async createBulk(request, reply) {
    try {
      const { movements } = request.body;
      const userId = request.user?.id;
      const result = await MovementCommands.createBulk(movements, userId);
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async verify(request, reply) {
    try {
      const { id } = request.params;
      const { verified, note } = request.body;
      const userId = request.user?.id;
      const result = await MovementCommands.verify(id, verified, note, userId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Movement not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async cancel(request, reply) {
    try {
      const { id } = request.params;
      const { reason } = request.body;
      const userId = request.user?.id;
      const result = await MovementCommands.cancel(id, reason, userId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Movement not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Movement already cancelled") {
        return reply.status(400).send({
          error: error.message
        });
      }
      if (error.message === "Cannot cancel movement: insufficient stock to revert") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getVerifiedMovements(request, reply) {
    try {
      const { page = 1, limit = 10, verified, startDate, endDate } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await MovementQueries.getVerifiedMovements({
        page,
        limit,
        storeId,
        verified,
        startDate,
        endDate
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getCancelledMovements(request, reply) {
    try {
      const { page = 1, limit = 10, startDate, endDate } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await MovementQueries.getCancelledMovements({
        page,
        limit,
        storeId,
        startDate,
        endDate
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getAnalytics(request, reply) {
    try {
      const { productId, supplierId, startDate, endDate } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await MovementQueries.getMovementAnalytics({
        storeId,
        productId,
        supplierId,
        startDate,
        endDate
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async summarize(request, reply) {
    try {
      const result = await MovementQueries.summarize();
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async summarizeProduct(request, reply) {
    try {
      const { productId } = request.params;
      const { startDate, endDate } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await MovementQueries.getProductSummary(productId, {
        startDate,
        endDate,
        storeId
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === ENDPOINTS PARA ALERTAS DE ESTOQUE ===
  async checkStockAlerts(request, reply) {
    try {
      const finalStoreId = request.store?.id;
      if (!finalStoreId) {
        return reply.status(400).send({
          error: "Store ID is required"
        });
      }
      const lowStockProducts = await StockAlertService.checkLowStockProducts(finalStoreId);
      return reply.send({
        storeId: finalStoreId,
        lowStockCount: lowStockProducts.length,
        products: lowStockProducts
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async createLowStockSummaryNotification(request, reply) {
    try {
      const finalStoreId = request.store?.id;
      if (!finalStoreId) {
        return reply.status(400).send({
          error: "Store ID is required"
        });
      }
      const notification = await StockAlertService.createLowStockSummaryNotification(finalStoreId);
      if (!notification) {
        return reply.send({
          message: "No low stock products found",
          notification: null
        });
      }
      return reply.status(201).send({
        message: "Low stock summary notification created",
        notification
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/movement/movement.schema.ts
var createMovementSchema = {
  body: {
    type: "object",
    required: ["type", "quantity", "productId"],
    properties: {
      type: {
        type: "string",
        enum: ["ENTRADA", "SAIDA", "PERDA"]
      },
      quantity: { type: "number", minimum: 1 },
      storeId: { type: "string", minLength: 1 },
      // Obrigatório, vem do middleware
      productId: { type: "string", minLength: 1 },
      supplierId: { type: "string" },
      batch: { type: "string" },
      expiration: { type: "string", format: "date-time" },
      price: { type: "number", minimum: 0.01 },
      note: { type: "string", maxLength: 500 },
      userId: { type: "string" }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        type: { type: "string" },
        quantity: { type: "number" },
        storeId: { type: "string" },
        productId: { type: "string" },
        supplierId: { type: "string", nullable: true },
        batch: { type: "string", nullable: true },
        expiration: { type: "string", format: "date-time", nullable: true },
        price: { type: "number", nullable: true },
        note: { type: "string", nullable: true },
        userId: { type: "string", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        store: { type: "object" },
        product: { type: "object" },
        supplier: { type: "object", nullable: true },
        user: { type: "object", nullable: true }
      }
    }
  }
};
var updateMovementSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      type: {
        type: "string",
        enum: ["ENTRADA", "SAIDA", "PERDA"]
      },
      quantity: { type: "number", minimum: 1 },
      supplierId: { type: "string" },
      batch: { type: "string" },
      expiration: { type: "string", format: "date-time" },
      price: { type: "number", minimum: 0.01 },
      note: { type: "string", maxLength: 500 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        type: { type: "string" },
        quantity: { type: "number" },
        storeId: { type: "string" },
        productId: { type: "string" },
        supplierId: { type: "string", nullable: true },
        batch: { type: "string", nullable: true },
        expiration: { type: "string", format: "date-time", nullable: true },
        price: { type: "number", nullable: true },
        note: { type: "string", nullable: true },
        userId: { type: "string", nullable: true },
        updatedAt: { type: "string", format: "date-time" },
        store: { type: "object" },
        product: { type: "object" },
        supplier: { type: "object", nullable: true },
        user: { type: "object", nullable: true }
      }
    }
  }
};
var getMovementSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        type: { type: "string" },
        quantity: { type: "number" },
        storeId: { type: "string" },
        productId: { type: "string" },
        supplierId: { type: "string", nullable: true },
        batch: { type: "string", nullable: true },
        expiration: { type: "string", format: "date-time", nullable: true },
        price: { type: "number", nullable: true },
        note: { type: "string", nullable: true },
        userId: { type: "string", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        store: { type: "object" },
        product: { type: "object" },
        supplier: { type: "object", nullable: true },
        user: { type: "object", nullable: true }
      }
    }
  }
};
var listMovementsSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      type: {
        type: "string",
        enum: ["ENTRADA", "SAIDA", "PERDA"]
      },
      storeId: { type: "string" },
      productId: { type: "string" },
      supplierId: { type: "string" },
      startDate: { type: "string", format: "date-time" },
      endDate: { type: "string", format: "date-time" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              type: { type: "string" },
              quantity: { type: "number" },
              storeId: { type: "string" },
              productId: { type: "string" },
              supplierId: { type: "string", nullable: true },
              batch: { type: "string", nullable: true },
              expiration: { type: "string", format: "date-time", nullable: true },
              price: { type: "number", nullable: true },
              note: { type: "string", nullable: true },
              userId: { type: "string", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" },
              store: { type: "object" },
              product: { type: "object" },
              supplier: { type: "object", nullable: true },
              user: { type: "object", nullable: true }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var deleteMovementSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" }
  }
};
var getByStoreSchema = {
  params: {
    type: "object",
    required: ["storeId"],
    properties: {
      storeId: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      type: {
        type: "string",
        enum: ["ENTRADA", "SAIDA", "PERDA"]
      },
      startDate: { type: "string", format: "date-time" },
      endDate: { type: "string", format: "date-time" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        movements: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              type: { type: "string" },
              quantity: { type: "number" },
              storeId: { type: "string" },
              productId: { type: "string" },
              supplierId: { type: "string", nullable: true },
              batch: { type: "string", nullable: true },
              expiration: { type: "string", format: "date-time", nullable: true },
              price: { type: "number", nullable: true },
              note: { type: "string", nullable: true },
              userId: { type: "string", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              store: { type: "object" },
              product: { type: "object" },
              supplier: { type: "object", nullable: true },
              user: { type: "object", nullable: true }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getByProductSchema = {
  params: {
    type: "object",
    required: ["productId"],
    properties: {
      productId: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      type: {
        type: "string",
        enum: ["ENTRADA", "SAIDA", "PERDA"]
      },
      startDate: { type: "string", format: "date-time" },
      endDate: { type: "string", format: "date-time" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        movements: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              type: { type: "string" },
              quantity: { type: "number" },
              storeId: { type: "string" },
              productId: { type: "string" },
              supplierId: { type: "string", nullable: true },
              batch: { type: "string", nullable: true },
              expiration: { type: "string", format: "date-time", nullable: true },
              price: { type: "number", nullable: true },
              note: { type: "string", nullable: true },
              userId: { type: "string", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              store: { type: "object" },
              product: { type: "object" },
              supplier: { type: "object", nullable: true },
              user: { type: "object", nullable: true }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getBySupplierSchema = {
  params: {
    type: "object",
    required: ["supplierId"],
    properties: {
      supplierId: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      type: {
        type: "string",
        enum: ["ENTRADA", "SAIDA", "PERDA"]
      },
      startDate: { type: "string", format: "date-time" },
      endDate: { type: "string", format: "date-time" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        movements: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              type: { type: "string" },
              quantity: { type: "number" },
              storeId: { type: "string" },
              productId: { type: "string" },
              supplierId: { type: "string", nullable: true },
              batch: { type: "string", nullable: true },
              expiration: { type: "string", format: "date-time", nullable: true },
              price: { type: "number", nullable: true },
              note: { type: "string", nullable: true },
              userId: { type: "string", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              store: { type: "object" },
              product: { type: "object" },
              supplier: { type: "object", nullable: true },
              user: { type: "object", nullable: true }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getStockHistorySchema = {
  params: {
    type: "object",
    required: ["productId", "storeId"],
    properties: {
      productId: { type: "string" },
      storeId: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      startDate: { type: "string", format: "date-time" },
      endDate: { type: "string", format: "date-time" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        product: { type: "object" },
        store: { type: "object" },
        currentStock: { type: "number" },
        history: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              type: { type: "string" },
              quantity: { type: "number" },
              batch: { type: "string", nullable: true },
              expiration: { type: "string", format: "date-time", nullable: true },
              price: { type: "number", nullable: true },
              note: { type: "string", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              supplier: { type: "object", nullable: true },
              user: { type: "object", nullable: true }
            }
          }
        },
        summary: {
          type: "object",
          properties: {
            totalEntries: { type: "number" },
            totalExits: { type: "number" },
            totalLosses: { type: "number" },
            netMovement: { type: "number" }
          }
        }
      }
    }
  }
};
var getMovementReportSchema = {
  querystring: {
    type: "object",
    properties: {
      storeId: { type: "string" },
      productId: { type: "string" },
      supplierId: { type: "string" },
      type: {
        type: "string",
        enum: ["ENTRADA", "SAIDA", "PERDA"]
      },
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" },
      groupBy: {
        type: "string",
        enum: ["day", "week", "month", "year"],
        default: "day"
      },
      format: {
        type: "string",
        enum: ["json", "csv", "pdf"],
        default: "json"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        summary: {
          type: "object",
          properties: {
            totalMovements: { type: "number" },
            totalValue: { type: "number" },
            period: {
              type: "object",
              properties: {
                startDate: { type: "string" },
                endDate: { type: "string" }
              }
            }
          }
        },
        data: {
          type: "array",
          items: {
            type: "object",
            properties: {
              date: { type: "string" },
              movements: { type: "number" },
              value: { type: "number" },
              entrada: { type: "number" },
              saida: { type: "number" },
              perda: { type: "number" }
            }
          }
        },
        byType: {
          type: "object",
          properties: {
            ENTRADA: {
              type: "object",
              properties: {
                count: { type: "number" },
                value: { type: "number" },
                quantity: { type: "number" }
              }
            },
            SAIDA: {
              type: "object",
              properties: {
                count: { type: "number" },
                value: { type: "number" },
                quantity: { type: "number" }
              }
            },
            PERDA: {
              type: "object",
              properties: {
                count: { type: "number" },
                value: { type: "number" },
                quantity: { type: "number" }
              }
            }
          }
        },
        byStore: {
          type: "array",
          items: {
            type: "object",
            properties: {
              storeId: { type: "string" },
              storeName: { type: "string" },
              movements: { type: "number" },
              value: { type: "number" }
            }
          }
        },
        byProduct: {
          type: "array",
          items: {
            type: "object",
            properties: {
              productId: { type: "string" },
              productName: { type: "string" },
              movements: { type: "number" },
              quantity: { type: "number" }
            }
          }
        },
        bySupplier: {
          type: "array",
          items: {
            type: "object",
            properties: {
              supplierId: { type: "string" },
              supplierName: { type: "string" },
              movements: { type: "number" },
              value: { type: "number" }
            }
          }
        }
      }
    }
  }
};
var createBulkMovementSchema = {
  body: {
    type: "object",
    required: ["movements"],
    properties: {
      movements: {
        type: "array",
        minItems: 1,
        maxItems: 100,
        items: {
          type: "object",
          required: ["type", "quantity", "storeId", "productId"],
          properties: {
            type: {
              type: "string",
              enum: ["ENTRADA", "SAIDA", "PERDA"]
            },
            quantity: { type: "number", minimum: 1 },
            storeId: { type: "string", minLength: 1 },
            productId: { type: "string", minLength: 1 },
            supplierId: { type: "string" },
            batch: { type: "string" },
            expiration: { type: "string", format: "date" },
            price: { type: "number", minimum: 0 },
            note: { type: "string", maxLength: 500 }
          }
        }
      }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        success: { type: "number" },
        failed: { type: "number" },
        results: {
          type: "array",
          items: {
            type: "object",
            properties: {
              index: { type: "number" },
              success: { type: "boolean" },
              movement: { type: "object", nullable: true },
              error: { type: "string", nullable: true }
            }
          }
        }
      }
    }
  }
};
var verifyMovementSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["verified"],
    properties: {
      verified: { type: "boolean" },
      note: { type: "string", maxLength: 500 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        verified: { type: "boolean" },
        verifiedAt: { type: "string", format: "date-time", nullable: true },
        verifiedBy: { type: "string", nullable: true },
        verificationNote: { type: "string", nullable: true },
        updatedAt: { type: "string", format: "date-time" },
        store: { type: "object" },
        product: { type: "object" },
        supplier: { type: "object", nullable: true },
        user: { type: "object", nullable: true }
      }
    }
  }
};
var cancelMovementSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["reason"],
    properties: {
      reason: { type: "string", minLength: 1, maxLength: 500 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        cancelled: { type: "boolean" },
        cancelledAt: { type: "string", format: "date-time" },
        cancelledBy: { type: "string", nullable: true },
        cancellationReason: { type: "string" },
        updatedAt: { type: "string", format: "date-time" },
        store: { type: "object" },
        product: { type: "object" },
        supplier: { type: "object", nullable: true },
        user: { type: "object", nullable: true }
      }
    }
  }
};
var getVerifiedMovementsSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      storeId: { type: "string" },
      verified: { type: "boolean" },
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              type: { type: "string" },
              quantity: { type: "number" },
              verified: { type: "boolean" },
              verifiedAt: { type: "string", format: "date-time", nullable: true },
              verifiedBy: { type: "string", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              store: { type: "object" },
              product: { type: "object" },
              supplier: { type: "object", nullable: true },
              user: { type: "object", nullable: true }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getCancelledMovementsSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      storeId: { type: "string" },
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              type: { type: "string" },
              quantity: { type: "number" },
              cancelled: { type: "boolean" },
              cancelledAt: { type: "string", format: "date-time" },
              cancelledBy: { type: "string", nullable: true },
              cancellationReason: { type: "string" },
              createdAt: { type: "string", format: "date-time" },
              store: { type: "object" },
              product: { type: "object" },
              supplier: { type: "object", nullable: true },
              user: { type: "object", nullable: true }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getMovementAnalyticsSchema = {
  querystring: {
    type: "object",
    properties: {
      storeId: { type: "string" },
      productId: { type: "string" },
      supplierId: { type: "string" },
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        summary: {
          type: "object",
          properties: {
            totalMovements: { type: "number" },
            totalValue: { type: "number" },
            averageValue: { type: "number" },
            verifiedCount: { type: "number" },
            cancelledCount: { type: "number" },
            verificationRate: { type: "number" },
            cancellationRate: { type: "number" }
          }
        },
        byType: {
          type: "array",
          items: {
            type: "object",
            properties: {
              type: { type: "string" },
              count: { type: "number" },
              quantity: { type: "number" },
              value: { type: "number" }
            }
          }
        },
        byMonth: {
          type: "array",
          items: {
            type: "object",
            properties: {
              month: { type: "string" },
              count: { type: "number" },
              value: { type: "number" }
            }
          }
        },
        byStore: {
          type: "array",
          items: {
            type: "object",
            properties: {
              storeId: { type: "string" },
              storeName: { type: "string" },
              count: { type: "number" },
              value: { type: "number" }
            }
          }
        },
        byProduct: {
          type: "array",
          items: {
            type: "object",
            properties: {
              productId: { type: "string" },
              productName: { type: "string" },
              count: { type: "number" },
              quantity: { type: "number" },
              value: { type: "number" }
            }
          }
        },
        bySupplier: {
          type: "array",
          items: {
            type: "object",
            properties: {
              supplierId: { type: "string" },
              supplierName: { type: "string" },
              count: { type: "number" },
              value: { type: "number" }
            }
          }
        }
      }
    }
  }
};
var MovementSchemas = {
  create: createMovementSchema,
  update: updateMovementSchema,
  get: getMovementSchema,
  delete: deleteMovementSchema,
  list: listMovementsSchema,
  getByStore: getByStoreSchema,
  getByProduct: getByProductSchema,
  getBySupplier: getBySupplierSchema,
  getStockHistory: getStockHistorySchema,
  // Funções adicionais
  getReport: getMovementReportSchema,
  createBulk: createBulkMovementSchema,
  verify: verifyMovementSchema,
  cancel: cancelMovementSchema,
  getVerifiedMovements: getVerifiedMovementsSchema,
  getCancelledMovements: getCancelledMovementsSchema,
  getAnalytics: getMovementAnalyticsSchema
};

// src/features/movement/movement.routes.ts
async function MovementRoutes(fastify2) {
  fastify2.addHook("preHandler", authMiddleware);
  fastify2.addHook("preHandler", storeContextMiddleware);
  fastify2.post("/", {
    schema: MovementSchemas.create,
    handler: MovementController.create
  });
  fastify2.get("/", {
    schema: MovementSchemas.list,
    handler: MovementController.list
  });
  fastify2.get("/my-store", {
    schema: {
      querystring: {
        type: "object",
        properties: {
          page: { type: "number", minimum: 1 },
          limit: { type: "number", minimum: 1, maximum: 100 },
          search: { type: "string" },
          type: { type: "string", enum: ["ENTRADA", "SAIDA", "PERDA"] },
          productId: { type: "string" },
          supplierId: { type: "string" },
          startDate: { type: "string", format: "date-time" },
          endDate: { type: "string", format: "date-time" }
        }
      }
    },
    handler: MovementController.listByStore
  });
  fastify2.get("/my-store/product/:productId", {
    schema: {
      params: {
        type: "object",
        required: ["productId"],
        properties: {
          productId: { type: "string", minLength: 1 }
        }
      },
      querystring: {
        type: "object",
        properties: {
          page: { type: "number", minimum: 1 },
          limit: { type: "number", minimum: 1, maximum: 100 },
          type: { type: "string", enum: ["ENTRADA", "SAIDA", "PERDA"] },
          startDate: { type: "string", format: "date-time" },
          endDate: { type: "string", format: "date-time" }
        }
      }
    },
    handler: MovementController.listByProduct
  });
  fastify2.get("/:id", {
    schema: MovementSchemas.get,
    handler: MovementController.get
  });
  fastify2.put("/:id", {
    schema: MovementSchemas.update,
    handler: MovementController.update
  });
  fastify2.delete("/:id", {
    schema: MovementSchemas.delete,
    handler: MovementController.delete
  });
  fastify2.get("/store/:storeId", {
    schema: MovementSchemas.getByStore,
    handler: MovementController.getByStore
  });
  fastify2.get("/product/:productId", {
    schema: MovementSchemas.getByProduct,
    handler: MovementController.getByProduct
  });
  fastify2.get("/product/:productId/summary", {
    handler: MovementController.summarizeProduct
  });
  fastify2.get("/supplier/:supplierId", {
    schema: MovementSchemas.getBySupplier,
    handler: MovementController.getBySupplier
  });
  fastify2.get("/stock-history/:productId/:storeId", {
    schema: MovementSchemas.getStockHistory,
    handler: MovementController.getStockHistory
  });
  fastify2.get("/current-stock/:productId/:storeId", {
    handler: MovementController.getCurrentStock
  });
  fastify2.get("/stats", {
    handler: MovementController.getStats
  });
  fastify2.get("/search", {
    handler: MovementController.search
  });
  fastify2.get("/low-stock", {
    handler: MovementController.getLowStockProducts
  });
  fastify2.post("/recalculate-stock/:productId/:storeId", {
    handler: MovementController.recalculateStock
  });
  fastify2.get("/summarize", {
    handler: MovementController.summarize
  });
  fastify2.get("/stock-alerts", {
    schema: {
      querystring: {
        type: "object",
        properties: {
          storeId: { type: "string" }
        }
      }
    },
    handler: MovementController.checkStockAlerts
  });
  fastify2.post("/stock-alerts/summary", {
    schema: {
      querystring: {
        type: "object",
        properties: {
          storeId: { type: "string" }
        }
      }
    },
    handler: MovementController.createLowStockSummaryNotification
  });
}

// src/features/permission/commands/permission.commands.ts
var createUserPermission = async (prisma2, data) => {
  return await prisma2.userPermission.create({
    data: {
      userId: data.userId,
      action: data.action,
      resource: data.resource,
      storeId: data.storeId,
      grant: data.grant,
      conditions: data.conditions ? JSON.stringify(data.conditions) : null,
      expiresAt: data.expiresAt ? new Date(data.expiresAt) : null,
      reason: data.reason,
      createdBy: data.createdBy
    }
  });
};
var updateUserPermission = async (prisma2, id, data) => {
  return await prisma2.userPermission.update({
    where: { id },
    data: {
      ...data,
      conditions: data.conditions ? JSON.stringify(data.conditions) : void 0,
      expiresAt: data.expiresAt ? new Date(data.expiresAt) : void 0
    }
  });
};
var deleteUserPermission = async (prisma2, id) => {
  return await prisma2.userPermission.delete({
    where: { id }
  });
};
var setStoreUserPermissions = async (prisma2, data) => {
  return await prisma2.storePermission.upsert({
    where: {
      userId_storeId: {
        userId: data.userId,
        storeId: data.storeId
      }
    },
    update: {
      storeRole: data.storeRole,
      permissions: JSON.stringify(data.permissions),
      conditions: data.conditions ? JSON.stringify(data.conditions) : null,
      expiresAt: data.expiresAt ? new Date(data.expiresAt) : null,
      createdBy: data.createdBy
    },
    create: {
      userId: data.userId,
      storeId: data.storeId,
      storeRole: data.storeRole,
      permissions: JSON.stringify(data.permissions),
      conditions: data.conditions ? JSON.stringify(data.conditions) : null,
      expiresAt: data.expiresAt ? new Date(data.expiresAt) : null,
      createdBy: data.createdBy
    }
  });
};

// src/features/permission/queries/permission.queries.ts
var getUserPermissions = async (prisma2, filters) => {
  const { userId, storeId, action, active, page = 1, limit = 10 } = filters;
  const where = { userId };
  if (storeId) where.storeId = storeId;
  if (action) where.action = action;
  if (active !== void 0) {
    if (active) {
      where.OR = [
        { expiresAt: null },
        { expiresAt: { gt: /* @__PURE__ */ new Date() } }
      ];
    } else {
      where.expiresAt = { lte: /* @__PURE__ */ new Date() };
    }
  }
  const [permissions, total] = await Promise.all([
    prisma2.userPermission.findMany({
      where,
      skip: (page - 1) * limit,
      take: limit,
      orderBy: { createdAt: "desc" },
      include: {
        user: {
          select: { id: true, name: true, email: true }
        },
        creator: {
          select: { id: true, name: true, email: true }
        }
      }
    }),
    prisma2.userPermission.count({ where })
  ]);
  return {
    permissions: permissions.map((p) => ({
      ...p,
      conditions: p.conditions ? JSON.parse(p.conditions) : null
    })),
    pagination: {
      page,
      limit,
      total,
      pages: Math.ceil(total / limit)
    }
  };
};
var getStoreUserPermissions = async (prisma2, filters) => {
  const { storeId, page = 1, limit = 10 } = filters;
  const [permissions, total] = await Promise.all([
    prisma2.storePermission.findMany({
      where: { storeId },
      skip: (page - 1) * limit,
      take: limit,
      orderBy: { createdAt: "desc" },
      include: {
        user: {
          select: { id: true, name: true, email: true }
        },
        store: {
          select: { id: true, name: true }
        },
        creator: {
          select: { id: true, name: true, email: true }
        }
      }
    }),
    prisma2.storePermission.count({ where: { storeId } })
  ]);
  return {
    permissions: permissions.map((p) => ({
      ...p,
      permissions: JSON.parse(p.permissions),
      conditions: p.conditions ? JSON.parse(p.conditions) : null
    })),
    pagination: {
      page,
      limit,
      total,
      pages: Math.ceil(total / limit)
    }
  };
};
var getUserEffectivePermissions = async (prisma2, context) => {
  const { userId, storeId } = context;
  const user = await prisma2.user.findUnique({
    where: { id: userId },
    select: { id: true, roles: true }
  });
  if (!user) {
    throw new Error("User not found");
  }
  const customPermissions = await prisma2.userPermission.findMany({
    where: {
      userId,
      ...storeId ? { storeId } : {}
    }
  });
  let storePermissions = [];
  if (storeId) {
    storePermissions = await prisma2.storePermission.findMany({
      where: { userId, storeId }
    });
  }
  const permissionContext = {
    userId,
    userRoles: user.roles,
    storeId,
    storeRole: storePermissions[0]?.storeRole,
    customPermissions: customPermissions.map((p) => ({
      ...p,
      conditions: p.conditions ? JSON.parse(p.conditions) : null
    })),
    storePermissions: storePermissions.map((p) => ({
      ...p,
      permissions: JSON.parse(p.permissions),
      conditions: p.conditions ? JSON.parse(p.conditions) : null
    }))
  };
  const effectivePermissions = await GranularPermissionService.getUserEffectivePermissions(permissionContext);
  return {
    userId,
    userRoles: user.roles,
    storeId,
    effectivePermissions,
    customPermissions: permissionContext.customPermissions,
    storePermissions: permissionContext.storePermissions
  };
};
var testPermission = async (prisma2, context) => {
  const { userId, action, resource, storeId, testContext } = context;
  const user = await prisma2.user.findUnique({
    where: { id: userId },
    select: { id: true, roles: true }
  });
  if (!user) {
    throw new Error("User not found");
  }
  const customPermissions = await prisma2.userPermission.findMany({
    where: { userId }
  });
  let storePermissions = [];
  if (storeId) {
    storePermissions = await prisma2.storePermission.findMany({
      where: { userId, storeId }
    });
  }
  const permissionContext = {
    userId,
    userRoles: user.roles,
    storeId,
    storeRole: storePermissions[0]?.storeRole,
    customPermissions: customPermissions.map((p) => ({
      ...p,
      conditions: p.conditions ? JSON.parse(p.conditions) : null
    })),
    storePermissions: storePermissions.map((p) => ({
      ...p,
      permissions: JSON.parse(p.permissions),
      conditions: p.conditions ? JSON.parse(p.conditions) : null
    })),
    requestTime: /* @__PURE__ */ new Date(),
    requestData: testContext || {}
  };
  const result = await GranularPermissionService.hasPermission(permissionContext, action, resource);
  return {
    userId,
    action,
    resource,
    storeId,
    result,
    context: permissionContext
  };
};
var getPermissionStats = async (prisma2) => {
  const [
    totalUserPermissions,
    activeUserPermissions,
    expiredUserPermissions,
    totalStorePermissions,
    permissionsByAction,
    permissionsByRole
  ] = await Promise.all([
    prisma2.userPermission.count(),
    prisma2.userPermission.count({
      where: {
        OR: [
          { expiresAt: null },
          { expiresAt: { gt: /* @__PURE__ */ new Date() } }
        ]
      }
    }),
    prisma2.userPermission.count({
      where: {
        expiresAt: { lte: /* @__PURE__ */ new Date() }
      }
    }),
    prisma2.storePermission.count(),
    prisma2.userPermission.groupBy({
      by: ["action"],
      _count: { action: true }
    }),
    prisma2.storePermission.groupBy({
      by: ["storeRole"],
      _count: { storeRole: true }
    })
  ]);
  return {
    userPermissions: {
      total: totalUserPermissions,
      active: activeUserPermissions,
      expired: expiredUserPermissions
    },
    storePermissions: {
      total: totalStorePermissions
    },
    permissionsByAction: permissionsByAction.map((p) => ({
      action: p.action,
      count: p._count.action
    })),
    permissionsByRole: permissionsByRole.map((p) => ({
      role: p.storeRole,
      count: p._count.storeRole
    }))
  };
};

// src/features/permission/permission.controller.ts
var PermissionController = {
  // ================================
  // GESTÃO DE PERMISSÕES CUSTOMIZADAS
  // ================================
  // Criar permissão customizada para usuário
  async createUserPermission(request, reply) {
    try {
      const { userId, action, resource, storeId, grant, conditions, expiresAt, reason } = request.body;
      const prisma2 = request.server.prisma;
      if (!request.user?.roles.includes("super_admin" /* SUPER_ADMIN */) && !request.user?.roles.includes("admin" /* ADMIN */)) {
        return reply.status(403).send({
          error: "Insufficient permissions to create user permissions"
        });
      }
      const userPermission = await createUserPermission(prisma2, {
        userId,
        action,
        resource,
        storeId,
        grant,
        conditions,
        expiresAt,
        reason,
        createdBy: request.user.id
      });
      return reply.status(201).send({
        message: "User permission created successfully",
        permission: userPermission
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // Listar permissões customizadas de um usuário
  async getUserPermissions(request, reply) {
    try {
      const { userId } = request.params;
      const { storeId, action, active, page = 1, limit = 10 } = request.query;
      const prisma2 = request.server.prisma;
      if (!request.user?.roles.includes("super_admin" /* SUPER_ADMIN */) && !request.user?.roles.includes("admin" /* ADMIN */) && request.user?.id !== userId) {
        return reply.status(403).send({
          error: "Insufficient permissions to view user permissions"
        });
      }
      const result = await getUserPermissions(prisma2, {
        userId,
        storeId,
        action,
        active,
        page,
        limit
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // Atualizar permissão customizada
  async updateUserPermission(request, reply) {
    try {
      const { id } = request.params;
      const updateData = request.body;
      const prisma2 = request.server.prisma;
      if (!request.user?.roles.includes("super_admin" /* SUPER_ADMIN */) && !request.user?.roles.includes("admin" /* ADMIN */)) {
        return reply.status(403).send({
          error: "Insufficient permissions to update user permissions"
        });
      }
      const permission = await updateUserPermission(prisma2, id, updateData);
      return reply.send({
        message: "User permission updated successfully",
        permission: {
          ...permission,
          conditions: permission.conditions ? JSON.parse(permission.conditions) : null
        }
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // Deletar permissão customizada
  async deleteUserPermission(request, reply) {
    try {
      const { id } = request.params;
      const prisma2 = request.server.prisma;
      if (!request.user?.roles.includes("super_admin" /* SUPER_ADMIN */) && !request.user?.roles.includes("admin" /* ADMIN */)) {
        return reply.status(403).send({
          error: "Insufficient permissions to delete user permissions"
        });
      }
      await deleteUserPermission(prisma2, id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // ================================
  // GESTÃO DE PERMISSÕES POR LOJA
  // ================================
  // Definir permissões de usuário em uma loja
  async setStoreUserPermissions(request, reply) {
    try {
      const { userId, storeId, storeRole, permissions, conditions, expiresAt } = request.body;
      const prisma2 = request.server.prisma;
      if (!request.user?.roles.includes("super_admin" /* SUPER_ADMIN */) && !request.user?.roles.includes("admin" /* ADMIN */) && !request.storeRole?.includes("OWNER" /* OWNER */) && !request.storeRole?.includes("ADMIN" /* ADMIN */)) {
        return reply.status(403).send({
          error: "Insufficient permissions to manage store user permissions"
        });
      }
      if (request.store?.id !== storeId) {
        return reply.status(403).send({
          error: "Access denied to this store"
        });
      }
      const storePermission = await setStoreUserPermissions(prisma2, {
        userId,
        storeId,
        storeRole,
        permissions,
        conditions,
        expiresAt,
        createdBy: request.user.id
      });
      return reply.send({
        message: "Store user permissions set successfully",
        permission: {
          ...storePermission,
          permissions: JSON.parse(storePermission.permissions),
          conditions: storePermission.conditions ? JSON.parse(storePermission.conditions) : null
        }
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // Listar permissões de usuários em uma loja
  async getStoreUserPermissions(request, reply) {
    try {
      const { storeId } = request.params;
      const { page = 1, limit = 10 } = request.query;
      const prisma2 = request.server.prisma;
      if (!request.user?.roles.includes("super_admin" /* SUPER_ADMIN */) && !request.user?.roles.includes("admin" /* ADMIN */) && !request.storeRole?.includes("OWNER" /* OWNER */) && !request.storeRole?.includes("ADMIN" /* ADMIN */)) {
        return reply.status(403).send({
          error: "Insufficient permissions to view store user permissions"
        });
      }
      if (request.store?.id !== storeId) {
        return reply.status(403).send({
          error: "Access denied to this store"
        });
      }
      const result = await getStoreUserPermissions(prisma2, {
        storeId,
        page,
        limit
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // ================================
  // CONSULTAS E RELATÓRIOS
  // ================================
  // Obter permissões efetivas de um usuário
  async getUserEffectivePermissions(request, reply) {
    try {
      const { userId } = request.params;
      const { storeId } = request.query;
      if (!request.user?.roles.includes("super_admin" /* SUPER_ADMIN */) && !request.user?.roles.includes("admin" /* ADMIN */) && request.user?.id !== userId) {
        return reply.status(403).send({
          error: "Insufficient permissions to view user permissions"
        });
      }
      const prisma2 = request.server.prisma;
      const result = await getUserEffectivePermissions(prisma2, {
        userId,
        storeId
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // Testar permissão específica
  async testPermission(request, reply) {
    try {
      const { userId, action, resource, storeId, context: testContext } = request.body;
      if (!request.user?.roles.includes("super_admin" /* SUPER_ADMIN */) && !request.user?.roles.includes("admin" /* ADMIN */)) {
        return reply.status(403).send({
          error: "Insufficient permissions to test permissions"
        });
      }
      const prisma2 = request.server.prisma;
      const result = await testPermission(prisma2, {
        userId,
        action,
        resource,
        storeId,
        testContext
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // Obter estatísticas de permissões
  async getPermissionStats(request, reply) {
    try {
      const prisma2 = request.server.prisma;
      if (!request.user?.roles.includes("super_admin" /* SUPER_ADMIN */) && !request.user?.roles.includes("admin" /* ADMIN */)) {
        return reply.status(403).send({
          error: "Insufficient permissions to view permission statistics"
        });
      }
      const result = await getPermissionStats(prisma2);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/permission/permission.schema.ts
var PermissionSchemas = {
  // Criar permissão customizada
  createUserPermission: {
    body: {
      type: "object",
      required: ["userId", "action", "grant"],
      properties: {
        userId: { type: "string", minLength: 1 },
        action: { type: "string", enum: Object.values(Action) },
        resource: { type: "string", maxLength: 100 },
        storeId: { type: "string", minLength: 1 },
        grant: { type: "boolean" },
        conditions: {
          type: "object",
          properties: {
            timeRange: { type: "string", pattern: "^\\d{1,2}-\\d{1,2}$" },
            dayOfWeek: { type: "string", pattern: "^\\d-\\d$" },
            dateRange: {
              type: "object",
              properties: {
                start: { type: "string", format: "date" },
                end: { type: "string", format: "date" }
              },
              required: ["start", "end"]
            },
            amountLimit: { type: "number", minimum: 0 },
            custom: { type: "string", maxLength: 500 },
            ipWhitelist: {
              type: "array",
              items: { type: "string", format: "ipv4" }
            },
            userAgent: { type: "string", maxLength: 200 }
          }
        },
        expiresAt: { type: "string", format: "date-time" },
        reason: { type: "string", maxLength: 500 }
      }
    }
  },
  // Listar permissões de usuário
  getUserPermissions: {
    params: {
      type: "object",
      required: ["userId"],
      properties: {
        userId: { type: "string", minLength: 1 }
      }
    },
    querystring: {
      type: "object",
      properties: {
        storeId: { type: "string", minLength: 1 },
        action: { type: "string", enum: Object.values(Action) },
        active: { type: "boolean" },
        page: { type: "integer", minimum: 1, default: 1 },
        limit: { type: "integer", minimum: 1, maximum: 100, default: 10 }
      }
    }
  },
  // Atualizar permissão customizada
  updateUserPermission: {
    params: {
      type: "object",
      required: ["id"],
      properties: {
        id: { type: "string", minLength: 1 }
      }
    },
    body: {
      type: "object",
      properties: {
        action: { type: "string", enum: Object.values(Action) },
        resource: { type: "string", maxLength: 100 },
        storeId: { type: "string", minLength: 1 },
        grant: { type: "boolean" },
        conditions: {
          type: "object",
          properties: {
            timeRange: { type: "string", pattern: "^\\d{1,2}-\\d{1,2}$" },
            dayOfWeek: { type: "string", pattern: "^\\d-\\d$" },
            dateRange: {
              type: "object",
              properties: {
                start: { type: "string", format: "date" },
                end: { type: "string", format: "date" }
              },
              required: ["start", "end"]
            },
            amountLimit: { type: "number", minimum: 0 },
            custom: { type: "string", maxLength: 500 },
            ipWhitelist: {
              type: "array",
              items: { type: "string", format: "ipv4" }
            },
            userAgent: { type: "string", maxLength: 200 }
          }
        },
        expiresAt: { type: "string", format: "date-time" },
        reason: { type: "string", maxLength: 500 }
      }
    }
  },
  // Deletar permissão customizada
  deleteUserPermission: {
    params: {
      type: "object",
      required: ["id"],
      properties: {
        id: { type: "string", minLength: 1 }
      }
    }
  },
  // ================================
  // SCHEMAS PARA PERMISSÕES DE LOJA
  // ================================
  // Definir permissões de usuário em loja
  setStoreUserPermissions: {
    body: {
      type: "object",
      required: ["userId", "storeId", "storeRole", "permissions"],
      properties: {
        userId: { type: "string", minLength: 1 },
        storeId: { type: "string", minLength: 1 },
        storeRole: { type: "string", enum: Object.values(StoreRole) },
        permissions: {
          type: "array",
          items: { type: "string", enum: Object.values(Action) },
          minItems: 1
        },
        conditions: {
          type: "object",
          properties: {
            timeRange: { type: "string", pattern: "^\\d{1,2}-\\d{1,2}$" },
            dayOfWeek: { type: "string", pattern: "^\\d-\\d$" },
            dateRange: {
              type: "object",
              properties: {
                start: { type: "string", format: "date" },
                end: { type: "string", format: "date" }
              },
              required: ["start", "end"]
            },
            amountLimit: { type: "number", minimum: 0 },
            custom: { type: "string", maxLength: 500 },
            ipWhitelist: {
              type: "array",
              items: { type: "string", format: "ipv4" }
            },
            userAgent: { type: "string", maxLength: 200 }
          }
        },
        expiresAt: { type: "string", format: "date-time" }
      }
    }
  },
  // Listar permissões de loja
  getStoreUserPermissions: {
    params: {
      type: "object",
      required: ["storeId"],
      properties: {
        storeId: { type: "string", minLength: 1 }
      }
    },
    querystring: {
      type: "object",
      properties: {
        page: { type: "integer", minimum: 1, default: 1 },
        limit: { type: "integer", minimum: 1, maximum: 100, default: 10 }
      }
    }
  },
  // ================================
  // SCHEMAS PARA CONSULTAS
  // ================================
  // Obter permissões efetivas
  getUserEffectivePermissions: {
    params: {
      type: "object",
      required: ["userId"],
      properties: {
        userId: { type: "string", minLength: 1 }
      }
    },
    querystring: {
      type: "object",
      properties: {
        storeId: { type: "string", minLength: 1 }
      }
    }
  },
  // Testar permissão
  testPermission: {
    body: {
      type: "object",
      required: ["userId", "action"],
      properties: {
        userId: { type: "string", minLength: 1 },
        action: { type: "string", enum: Object.values(Action) },
        resource: { type: "string", maxLength: 100 },
        storeId: { type: "string", minLength: 1 },
        context: { type: "object" }
      }
    }
  },
  // Obter estatísticas
  getPermissionStats: {
    querystring: {
      type: "object",
      properties: {
        storeId: { type: "string", minLength: 1 },
        dateFrom: { type: "string", format: "date" },
        dateTo: { type: "string", format: "date" }
      }
    }
  },
  // ================================
  // SCHEMAS PARA BULK OPERATIONS
  // ================================
  // Criar múltiplas permissões
  bulkCreateUserPermissions: {
    body: {
      type: "object",
      required: ["permissions"],
      properties: {
        permissions: {
          type: "array",
          items: {
            type: "object",
            required: ["userId", "action", "grant"],
            properties: {
              userId: { type: "string", minLength: 1 },
              action: { type: "string", enum: Object.values(Action) },
              resource: { type: "string", maxLength: 100 },
              storeId: { type: "string", minLength: 1 },
              grant: { type: "boolean" },
              conditions: {
                type: "object",
                properties: {
                  timeRange: { type: "string", pattern: "^\\d{1,2}-\\d{1,2}$" },
                  dayOfWeek: { type: "string", pattern: "^\\d-\\d$" },
                  dateRange: {
                    type: "object",
                    properties: {
                      start: { type: "string", format: "date" },
                      end: { type: "string", format: "date" }
                    },
                    required: ["start", "end"]
                  },
                  amountLimit: { type: "number", minimum: 0 },
                  custom: { type: "string", maxLength: 500 },
                  ipWhitelist: {
                    type: "array",
                    items: { type: "string", format: "ipv4" }
                  },
                  userAgent: { type: "string", maxLength: 200 }
                }
              },
              expiresAt: { type: "string", format: "date-time" },
              reason: { type: "string", maxLength: 500 }
            }
          },
          minItems: 1,
          maxItems: 100
        }
      }
    }
  },
  // Atualizar múltiplas permissões
  bulkUpdateUserPermissions: {
    body: {
      type: "object",
      required: ["updates"],
      properties: {
        updates: {
          type: "array",
          items: {
            type: "object",
            required: ["id"],
            properties: {
              id: { type: "string", minLength: 1 },
              action: { type: "string", enum: Object.values(Action) },
              resource: { type: "string", maxLength: 100 },
              storeId: { type: "string", minLength: 1 },
              grant: { type: "boolean" },
              conditions: {
                type: "object",
                properties: {
                  timeRange: { type: "string", pattern: "^\\d{1,2}-\\d{1,2}$" },
                  dayOfWeek: { type: "string", pattern: "^\\d-\\d$" },
                  dateRange: {
                    type: "object",
                    properties: {
                      start: { type: "string", format: "date" },
                      end: { type: "string", format: "date" }
                    },
                    required: ["start", "end"]
                  },
                  amountLimit: { type: "number", minimum: 0 },
                  custom: { type: "string", maxLength: 500 },
                  ipWhitelist: {
                    type: "array",
                    items: { type: "string", format: "ipv4" }
                  },
                  userAgent: { type: "string", maxLength: 200 }
                }
              },
              expiresAt: { type: "string", format: "date-time" },
              reason: { type: "string", maxLength: 500 }
            }
          },
          minItems: 1,
          maxItems: 100
        }
      }
    }
  },
  // Deletar múltiplas permissões
  bulkDeleteUserPermissions: {
    body: {
      type: "object",
      required: ["ids"],
      properties: {
        ids: {
          type: "array",
          items: { type: "string", minLength: 1 },
          minItems: 1,
          maxItems: 100
        }
      }
    }
  },
  // ================================
  // SCHEMAS PARA TEMPLATES
  // ================================
  // Criar template de permissão
  createPermissionTemplate: {
    body: {
      type: "object",
      required: ["name", "description", "permissions"],
      properties: {
        name: { type: "string", minLength: 3, maxLength: 100 },
        description: { type: "string", maxLength: 500 },
        permissions: {
          type: "array",
          items: { type: "string", enum: Object.values(Action) },
          minItems: 1
        },
        conditions: {
          type: "object",
          properties: {
            timeRange: { type: "string", pattern: "^\\d{1,2}-\\d{1,2}$" },
            dayOfWeek: { type: "string", pattern: "^\\d-\\d$" },
            dateRange: {
              type: "object",
              properties: {
                start: { type: "string", format: "date" },
                end: { type: "string", format: "date" }
              },
              required: ["start", "end"]
            },
            amountLimit: { type: "number", minimum: 0 },
            custom: { type: "string", maxLength: 500 },
            ipWhitelist: {
              type: "array",
              items: { type: "string", format: "ipv4" }
            },
            userAgent: { type: "string", maxLength: 200 }
          }
        }
      }
    }
  },
  // Aplicar template de permissão
  applyPermissionTemplate: {
    body: {
      type: "object",
      required: ["userId", "templateId"],
      properties: {
        userId: { type: "string", minLength: 1 },
        templateId: { type: "string", minLength: 1 },
        storeId: { type: "string", minLength: 1 },
        expiresAt: { type: "string", format: "date-time" }
      }
    }
  },
  // ================================
  // SCHEMAS PARA AUDITORIA
  // ================================
  // Obter log de auditoria
  getPermissionAuditLog: {
    params: {
      type: "object",
      required: ["permissionId"],
      properties: {
        permissionId: { type: "string", minLength: 1 }
      }
    },
    querystring: {
      type: "object",
      properties: {
        page: { type: "integer", minimum: 1, default: 1 },
        limit: { type: "integer", minimum: 1, maximum: 100, default: 10 },
        action: { type: "string", enum: ["created", "updated", "deleted", "expired"] },
        dateFrom: { type: "string", format: "date" },
        dateTo: { type: "string", format: "date" }
      }
    }
  }
};

// src/features/permission/permission.routes.ts
async function PermissionRoutes(fastify2) {
  fastify2.post("/user", {
    schema: PermissionSchemas.createUserPermission,
    preHandler: [
      authMiddleware,
      requirePermission("create_user" /* CREATE_USER */)
    ],
    handler: PermissionController.createUserPermission
  });
  fastify2.get("/user/:userId", {
    schema: PermissionSchemas.getUserPermissions,
    preHandler: [
      authMiddleware,
      requirePermission("read_user" /* READ_USER */)
    ],
    handler: PermissionController.getUserPermissions
  });
  fastify2.put("/user/:id", {
    schema: PermissionSchemas.updateUserPermission,
    preHandler: [
      authMiddleware,
      requirePermission("update_user" /* UPDATE_USER */)
    ],
    handler: PermissionController.updateUserPermission
  });
  fastify2.delete("/user/:id", {
    schema: PermissionSchemas.deleteUserPermission,
    preHandler: [
      authMiddleware,
      requirePermission("delete_user" /* DELETE_USER */)
    ],
    handler: PermissionController.deleteUserPermission
  });
  fastify2.post("/store", {
    schema: PermissionSchemas.setStoreUserPermissions,
    preHandler: [
      authMiddleware,
      requirePermission("manage_store_users" /* MANAGE_STORE_USERS */)
    ],
    handler: PermissionController.setStoreUserPermissions
  });
  fastify2.get("/store/:storeId", {
    schema: PermissionSchemas.getStoreUserPermissions,
    preHandler: [
      authMiddleware,
      requirePermission("read_store" /* READ_STORE */)
    ],
    handler: PermissionController.getStoreUserPermissions
  });
  fastify2.get("/effective/:userId", {
    schema: PermissionSchemas.getUserEffectivePermissions,
    preHandler: [
      authMiddleware,
      requirePermission("read_user" /* READ_USER */)
    ],
    handler: PermissionController.getUserEffectivePermissions
  });
  fastify2.post("/test", {
    schema: PermissionSchemas.testPermission,
    preHandler: [
      authMiddleware,
      requirePermission("read_user" /* READ_USER */)
    ],
    handler: PermissionController.testPermission
  });
  fastify2.get("/stats", {
    schema: PermissionSchemas.getPermissionStats,
    preHandler: [
      authMiddleware,
      requirePermission("view_audit_logs" /* VIEW_AUDIT_LOGS */)
    ],
    handler: PermissionController.getPermissionStats
  });
}

// src/features/report/queries/report.queries.ts
init_prisma();
var ReportQueries = {
  // ================================
  // DASHBOARD STATS
  // ================================
  async getDashboardStats(filters) {
    const { storeId, startDate, endDate } = filters;
    const dateFilter = ReportQueries.buildDateFilter(startDate, endDate);
    const [
      totalProducts,
      totalCategories,
      totalSuppliers,
      totalStores,
      totalUsers
    ] = await Promise.all([
      db.product.count({
        where: storeId ? { storeId } : {}
      }),
      db.category.count(),
      db.supplier.count(),
      db.store.count(),
      db.user.count()
    ]);
    const inventoryStats = await ReportQueries.getInventoryStats(storeId);
    const movementStats = await ReportQueries.getMovementStats(storeId, dateFilter);
    const recentActivity = await ReportQueries.getRecentActivity(storeId, dateFilter);
    const charts = await ReportQueries.getChartData(storeId, dateFilter);
    return {
      overview: {
        totalProducts,
        totalCategories,
        totalSuppliers,
        totalStores,
        totalUsers
      },
      inventory: inventoryStats,
      movements: movementStats,
      recentActivity,
      charts
    };
  },
  // ================================
  // INVENTORY REPORT
  // ================================
  async getInventoryReport(filters, pagination, sort) {
    const { storeId, categoryId, supplierId, status, lowStock } = filters;
    const { page, limit } = pagination;
    const { field, order } = sort;
    const where = {};
    if (storeId) where.storeId = storeId;
    if (categoryId) where.categoryId = categoryId;
    if (supplierId) where.supplierId = supplierId;
    if (status && status !== "all") where.status = status === "active";
    if (lowStock) {
      where.AND = [
        { stockMin: { gt: 0 } },
        {
          OR: [
            { stockMin: { gt: 0 } },
            { currentStock: { lte: 0 } }
          ]
        }
      ];
    }
    const orderBy = {};
    switch (field) {
      case "name":
        orderBy.name = order;
        break;
      case "stock":
        orderBy.currentStock = order;
        break;
      case "value":
        orderBy.totalValue = order;
        break;
      case "category":
        orderBy.category = { name: order };
        break;
      default:
        orderBy.name = "asc";
    }
    const [products, total] = await Promise.all([
      db.product.findMany({
        where,
        orderBy,
        skip: (page - 1) * limit,
        take: limit,
        include: {
          categories: {
            select: {
              category: {
                select: { id: true, name: true }
              }
            }
          },
          supplier: {
            select: { id: true, corporateName: true }
          },
          movements: {
            orderBy: { createdAt: "desc" },
            take: 1,
            select: { createdAt: true }
          }
        }
      }),
      db.product.count({ where })
    ]);
    const productsWithStats = products.map((product) => {
      const currentStock = ReportQueries.calculateCurrentStock(product.movements || []);
      const totalValue = Number(product.referencePrice) * currentStock;
      let alertLevel = "normal";
      if (currentStock <= 0) alertLevel = "out";
      else if (currentStock <= product.stockMin) alertLevel = "low";
      else if (currentStock >= product.stockMax) alertLevel = "high";
      return {
        id: product.id,
        name: product.name,
        description: product.description,
        category: product.categories[0]?.category,
        supplier: product.supplier,
        currentStock,
        stockMin: product.stockMin,
        stockMax: product.stockMax,
        unitPrice: Number(product.referencePrice),
        totalValue,
        status: product.status,
        alertLevel,
        lastMovement: product.movements?.[0]?.createdAt?.toISOString()
      };
    });
    const summary = await ReportQueries.calculateInventorySummary(where);
    return {
      products: productsWithStats,
      summary,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  // ================================
  // MOVEMENT REPORT
  // ================================
  async getMovementReport(filters, pagination) {
    const { storeId, productId, supplierId, type, startDate, endDate } = filters;
    const { page, limit } = pagination;
    const where = {};
    if (storeId) where.storeId = storeId;
    if (productId) where.productId = productId;
    if (supplierId) where.supplierId = supplierId;
    if (type) where.type = type;
    if (startDate || endDate) {
      where.createdAt = ReportQueries.buildDateFilter(startDate, endDate);
    }
    const [movements, total] = await Promise.all([
      db.movement.findMany({
        where,
        orderBy: { createdAt: "desc" },
        skip: (page - 1) * limit,
        take: limit,
        include: {
          product: {
            select: { id: true, name: true, unitOfMeasure: true }
          },
          supplier: {
            select: { id: true, corporateName: true }
          },
          user: {
            select: { id: true, name: true }
          }
        }
      }),
      db.movement.count({ where })
    ]);
    const summary = await ReportQueries.calculateMovementSummary(where);
    return {
      movements: movements.map((movement) => ({
        id: movement.id,
        type: movement.type,
        quantity: movement.quantity,
        price: movement.price ? Number(movement.price) : void 0,
        totalValue: movement.price ? Number(movement.price) * movement.quantity : void 0,
        batch: movement.batch,
        expiration: movement.expiration?.toISOString(),
        note: movement.note,
        balanceAfter: movement.balanceAfter,
        product: movement.product,
        supplier: movement.supplier,
        user: movement.user,
        createdAt: movement.createdAt.toISOString()
      })),
      summary,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  // ================================
  // FINANCIAL REPORT
  // ================================
  async getFinancialReport(filters) {
    const { storeId, startDate, endDate, groupBy = "month" } = filters;
    const dateFilter = ReportQueries.buildDateFilter(startDate, endDate);
    const where = { ...dateFilter };
    if (storeId) where.storeId = storeId;
    const movements = await db.movement.findMany({
      where: {
        ...where,
        price: { not: null }
      },
      include: {
        product: {
          select: { id: true, name: true, categories: true }
        },
        supplier: {
          select: { id: true, corporateName: true }
        }
      }
    });
    const financialData = ReportQueries.calculateFinancialData(movements, groupBy);
    const breakdown = await ReportQueries.calculateFinancialBreakdown(movements);
    return {
      period: {
        startDate: startDate || new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3).toISOString().split("T")[0],
        endDate: endDate || (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
        groupBy
      },
      summary: financialData.summary,
      data: financialData.timeSeries,
      breakdown
    };
  },
  // ================================
  // CATEGORY REPORT
  // ================================
  async getCategoryReport(filters) {
    const { storeId, includeSubcategories = true } = filters;
    const where = {};
    if (storeId) where.storeId = storeId;
    const categories = await db.category.findMany({
      include: {
        products: {
          where,
          include: {
            product: {
              include: {
                movements: {
                  orderBy: { createdAt: "desc" },
                  take: 1,
                  select: { createdAt: true }
                }
              }
            }
          }
        },
        children: includeSubcategories ? {
          include: {
            products: {
              where,
              include: {
                product: {
                  include: {
                    movements: {
                      orderBy: { createdAt: "desc" },
                      take: 1,
                      select: { createdAt: true }
                    }
                  }
                }
              }
            }
          }
        } : false,
        parent: true
      }
    });
    const categoriesWithStats = categories.map((category) => {
      const allProducts = includeSubcategories && category.children ? [...category.products, ...category.children.flatMap((child) => child.products || [])] : category.products;
      const totalValue2 = allProducts.reduce((sum, productCategory) => {
        const product = productCategory.product;
        const currentStock = ReportQueries.calculateCurrentStock(product.movements || []);
        return sum + Number(product.referencePrice) * currentStock;
      }, 0);
      const totalMovements = allProducts.reduce((sum, productCategory) => {
        return sum + (productCategory.product.movements?.length || 0);
      }, 0);
      const lastMovement = allProducts.flatMap((productCategory) => productCategory.product.movements || []).sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime())[0];
      return {
        id: category.id,
        name: category.name,
        description: category.description,
        code: category.code,
        color: category.color,
        icon: category.icon,
        parentId: category.parentId,
        parent: category.parent,
        children: category.children?.map((child) => ({
          id: child.id,
          name: child.name
        })),
        stats: {
          totalProducts: allProducts.length,
          totalValue: totalValue2,
          averagePrice: allProducts.length > 0 ? totalValue2 / allProducts.length : 0,
          movements: totalMovements,
          lastMovement: lastMovement?.createdAt.toISOString()
        }
      };
    });
    const totalProducts = categoriesWithStats.reduce((sum, cat) => sum + cat.stats.totalProducts, 0);
    const totalValue = categoriesWithStats.reduce((sum, cat) => sum + cat.stats.totalValue, 0);
    return {
      categories: categoriesWithStats,
      summary: {
        totalCategories: categories.length,
        totalProducts,
        totalValue,
        averageProductsPerCategory: categories.length > 0 ? totalProducts / categories.length : 0
      }
    };
  },
  // ================================
  // SUPPLIER REPORT
  // ================================
  async getSupplierReport(filters) {
    const { storeId, status } = filters;
    const where = {};
    if (status && status !== "all") where.status = status === "active";
    const suppliers = await db.supplier.findMany({
      where,
      include: {
        products: {
          where: storeId ? { storeId } : {},
          include: {
            movements: {
              orderBy: { createdAt: "desc" },
              take: 1,
              select: { createdAt: true }
            }
          }
        },
        movements: {
          where: storeId ? { storeId } : {},
          orderBy: { createdAt: "desc" },
          take: 1,
          select: { createdAt: true }
        },
        responsibles: true
      }
    });
    const suppliersWithStats = suppliers.map((supplier) => {
      const totalValue2 = supplier.products.reduce((sum, product) => {
        const currentStock = ReportQueries.calculateCurrentStock(product.movements || []);
        return sum + Number(product.referencePrice) * currentStock;
      }, 0);
      const totalMovements = supplier.movements.length;
      const lastMovement = supplier.movements[0];
      return {
        id: supplier.id,
        corporateName: supplier.corporateName,
        tradeName: supplier.tradeName,
        cnpj: supplier.cnpj,
        status: supplier.status,
        address: {
          cep: supplier.cep,
          city: supplier.city,
          state: supplier.state,
          address: supplier.address
        },
        stats: {
          totalProducts: supplier.products.length,
          totalValue: totalValue2,
          totalMovements,
          lastMovement: lastMovement?.createdAt.toISOString(),
          averageOrderValue: totalMovements > 0 ? totalValue2 / totalMovements : 0
        },
        responsibles: supplier.responsibles.map((resp) => ({
          id: resp.id,
          name: resp.name,
          phone: resp.phone,
          email: resp.email
        }))
      };
    });
    const totalProducts = suppliersWithStats.reduce((sum, sup) => sum + sup.stats.totalProducts, 0);
    const totalValue = suppliersWithStats.reduce((sum, sup) => sum + sup.stats.totalValue, 0);
    const activeSuppliers = suppliersWithStats.filter((sup) => sup.status).length;
    return {
      suppliers: suppliersWithStats,
      summary: {
        totalSuppliers: suppliers.length,
        activeSuppliers,
        totalProducts,
        totalValue,
        averageProductsPerSupplier: suppliers.length > 0 ? totalProducts / suppliers.length : 0
      }
    };
  },
  // ================================
  // USER ACTIVITY REPORT
  // ================================
  async getUserActivityReport(filters, pagination) {
    const { storeId, userId, startDate, endDate, action } = filters;
    const { page, limit } = pagination;
    const where = {};
    if (userId) where.userId = userId;
    if (action) where.action = action;
    if (startDate || endDate) {
      where.createdAt = ReportQueries.buildDateFilter(startDate, endDate);
    }
    const [activities, total] = await Promise.all([
      db.auditLog.findMany({
        where,
        orderBy: { createdAt: "desc" },
        skip: (page - 1) * limit,
        take: limit,
        include: {
          user: {
            select: { id: true, name: true, email: true }
          }
        }
      }),
      db.auditLog.count({ where })
    ]);
    const summary = await ReportQueries.calculateUserActivitySummary(where);
    return {
      activities: activities.map((activity) => ({
        id: activity.id,
        entity: activity.entity,
        entityId: activity.entityId,
        action: activity.action,
        before: activity.before,
        after: activity.after,
        user: activity.user,
        createdAt: activity.createdAt.toISOString()
      })),
      summary,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  // ================================
  // STOCK ALERT REPORT
  // ================================
  async getStockAlertReport(filters, pagination) {
    const { storeId, alertType = "all" } = filters;
    const { page, limit } = pagination;
    const where = {};
    if (storeId) where.storeId = storeId;
    const products = await db.product.findMany({
      where,
      include: {
        categories: {
          select: {
            category: {
              select: { id: true, name: true }
            }
          }
        },
        supplier: {
          select: { id: true, corporateName: true }
        },
        movements: {
          orderBy: { createdAt: "desc" },
          take: 1,
          select: { createdAt: true }
        }
      }
    });
    const alerts = products.map((product) => {
      const currentStock = ReportQueries.calculateCurrentStock(product.movements || []);
      const unitPrice = Number(product.referencePrice);
      const totalValue = unitPrice * currentStock;
      let alertType2 = null;
      let severity = "low";
      if (currentStock <= 0) {
        alertType2 = "out";
        severity = "critical";
      } else if (currentStock <= product.stockMin) {
        alertType2 = "low";
        severity = currentStock === 0 ? "critical" : "high";
      } else if (currentStock >= product.stockMax) {
        alertType2 = "high";
        severity = "medium";
      }
      return {
        id: product.id,
        productId: product.id,
        productName: product.name,
        currentStock,
        stockMin: product.stockMin,
        stockMax: product.stockMax,
        alertType: alertType2,
        severity,
        unitPrice,
        totalValue,
        lastMovement: product.movements?.[0]?.createdAt.toISOString(),
        category: product.categories[0]?.category,
        supplier: product.supplier
      };
    }).filter((alert) => {
      if (alertType === "all") return alert.alertType !== null;
      return alert.alertType === alertType;
    }).sort((a, b) => {
      const severityOrder = { critical: 4, high: 3, medium: 2, low: 1 };
      return severityOrder[b.severity] - severityOrder[a.severity];
    });
    const paginatedAlerts = alerts.slice((page - 1) * limit, page * limit);
    const summary = {
      totalAlerts: alerts.length,
      lowStockAlerts: alerts.filter((a) => a.alertType === "low").length,
      highStockAlerts: alerts.filter((a) => a.alertType === "high").length,
      expiredAlerts: alerts.filter((a) => a.alertType === "expired").length,
      outOfStockAlerts: alerts.filter((a) => a.alertType === "out").length,
      totalValue: alerts.reduce((sum, alert) => sum + alert.totalValue, 0)
    };
    return {
      alerts: paginatedAlerts,
      summary,
      pagination: {
        page,
        limit,
        total: alerts.length,
        totalPages: Math.ceil(alerts.length / limit)
      }
    };
  },
  // ================================
  // HELPER METHODS
  // ================================
  buildDateFilter(startDate, endDate) {
    const filter = {};
    if (startDate) {
      filter.gte = new Date(startDate);
    }
    if (endDate) {
      filter.lte = new Date(endDate);
    }
    return Object.keys(filter).length > 0 ? filter : void 0;
  },
  calculateCurrentStock(movements) {
    return movements.reduce((stock, movement) => {
      switch (movement.type) {
        case "ENTRADA":
          return stock + movement.quantity;
        case "SAIDA":
        case "PERDA":
          return stock - movement.quantity;
        default:
          return stock;
      }
    }, 0);
  },
  async getInventoryStats(storeId) {
    const where = storeId ? { storeId } : {};
    const [totalValue, lowStockCount, outOfStockCount] = await Promise.all([
      db.product.aggregate({
        where,
        _sum: { referencePrice: true }
      }),
      db.product.count({
        where: {
          ...where,
          AND: [
            { stockMin: { gt: 0 } },
            { stockMin: { gt: 0 } }
          ]
        }
      }),
      db.product.count({
        where: {
          ...where,
          stockMin: { gt: 0 }
        }
      })
    ]);
    return {
      totalValue: Number(totalValue._sum.referencePrice || 0),
      lowStockItems: lowStockCount,
      outOfStockItems: outOfStockCount,
      averageStockValue: 0
      // Will be calculated based on actual stock
    };
  },
  async getMovementStats(storeId, dateFilter) {
    const where = { ...dateFilter };
    if (storeId) where.storeId = storeId;
    const [totalMovements, entries, exits, losses, totalValue] = await Promise.all([
      db.movement.count({ where }),
      db.movement.count({ where: { ...where, type: "ENTRADA" } }),
      db.movement.count({ where: { ...where, type: "SAIDA" } }),
      db.movement.count({ where: { ...where, type: "PERDA" } }),
      db.movement.aggregate({
        where: { ...where, price: { not: null } },
        _sum: { price: true }
      })
    ]);
    return {
      totalMovements,
      entries,
      exits,
      losses,
      totalValue: Number(totalValue._sum.price || 0)
    };
  },
  async getRecentActivity(storeId, dateFilter) {
    const where = { ...dateFilter };
    if (storeId) where.storeId = storeId;
    const [lastMovements, recentProducts] = await Promise.all([
      db.movement.findMany({
        where,
        orderBy: { createdAt: "desc" },
        take: 5,
        include: {
          product: {
            select: { name: true }
          }
        }
      }),
      db.product.findMany({
        where: storeId ? { storeId } : {},
        orderBy: { createdAt: "desc" },
        take: 5,
        select: { id: true, name: true, createdAt: true }
      })
    ]);
    return {
      lastMovements: lastMovements.map((movement) => ({
        id: movement.id,
        type: movement.type,
        productName: movement.product.name,
        quantity: movement.quantity,
        createdAt: movement.createdAt.toISOString()
      })),
      recentProducts: recentProducts.map((product) => ({
        id: product.id,
        name: product.name,
        createdAt: product.createdAt.toISOString()
      }))
    };
  },
  async getChartData(storeId, dateFilter) {
    const where = { ...dateFilter };
    if (storeId) where.storeId = storeId;
    const movementsByType = await db.movement.groupBy({
      by: ["type"],
      where,
      _count: { type: true },
      _sum: { price: true }
    });
    const topProducts = await db.movement.groupBy({
      by: ["productId"],
      where,
      _count: { productId: true },
      _sum: { price: true },
      orderBy: { _count: { productId: "desc" } },
      take: 5
    });
    const productIds = topProducts.map((p) => p.productId);
    const products = await db.product.findMany({
      where: { id: { in: productIds } },
      select: { id: true, name: true }
    });
    const productMap = new Map(products.map((p) => [p.id, p.name]));
    return {
      movementsByType: movementsByType.map((m) => ({
        type: m.type,
        count: m._count.type,
        value: Number(m._sum.price || 0)
      })),
      topProducts: topProducts.map((p) => ({
        productId: p.productId,
        productName: productMap.get(p.productId) || "Unknown",
        movements: p._count.productId,
        value: Number(p._sum.price || 0)
      })),
      movementsByDay: []
      // Will be implemented with proper date grouping
    };
  },
  async calculateInventorySummary(where) {
    const [totalProducts, totalValue, lowStockCount, outOfStockCount] = await Promise.all([
      db.product.count({ where }),
      db.product.aggregate({
        where,
        _sum: { referencePrice: true }
      }),
      db.product.count({
        where: {
          ...where,
          AND: [
            { stockMin: { gt: 0 } },
            { stockMin: { gt: 0 } }
          ]
        }
      }),
      db.product.count({
        where: {
          ...where,
          stockMin: { gt: 0 }
        }
      })
    ]);
    return {
      totalProducts,
      totalValue: Number(totalValue._sum.referencePrice || 0),
      lowStockCount,
      outOfStockCount,
      averageStockValue: totalProducts > 0 ? Number(totalValue._sum.referencePrice || 0) / totalProducts : 0
    };
  },
  async calculateMovementSummary(where) {
    const [totalMovements, totalEntries, totalExits, totalLosses, totalValue] = await Promise.all([
      db.movement.count({ where }),
      db.movement.count({ where: { ...where, type: "ENTRADA" } }),
      db.movement.count({ where: { ...where, type: "SAIDA" } }),
      db.movement.count({ where: { ...where, type: "PERDA" } }),
      db.movement.aggregate({
        where: { ...where, price: { not: null } },
        _sum: { price: true }
      })
    ]);
    return {
      totalMovements,
      totalEntries,
      totalExits,
      totalLosses,
      totalValue: Number(totalValue._sum.price || 0),
      averageValue: totalMovements > 0 ? Number(totalValue._sum.price || 0) / totalMovements : 0
    };
  },
  calculateFinancialData(movements, groupBy) {
    const totalRevenue = movements.filter((m) => m.type === "ENTRADA" && m.price).reduce((sum, m) => sum + Number(m.price) * m.quantity, 0);
    const totalCosts = movements.filter((m) => m.type === "SAIDA" && m.price).reduce((sum, m) => sum + Number(m.price) * m.quantity, 0);
    const grossProfit = totalRevenue - totalCosts;
    const profitMargin = totalRevenue > 0 ? grossProfit / totalRevenue * 100 : 0;
    return {
      summary: {
        totalRevenue,
        totalCosts,
        grossProfit,
        profitMargin,
        totalMovements: movements.length
      },
      timeSeries: []
      // Would be implemented with proper date grouping
    };
  },
  async calculateFinancialBreakdown(movements) {
    const byProduct = /* @__PURE__ */ new Map();
    const byCategory = /* @__PURE__ */ new Map();
    const bySupplier = /* @__PURE__ */ new Map();
    movements.forEach((movement) => {
      const value = Number(movement.price || 0) * movement.quantity;
      const isRevenue = movement.type === "ENTRADA";
      const isCost = movement.type === "SAIDA";
      if (!byProduct.has(movement.product.id)) {
        byProduct.set(movement.product.id, {
          productId: movement.product.id,
          productName: movement.product.name,
          revenue: 0,
          costs: 0,
          profit: 0,
          movements: 0
        });
      }
      const productData = byProduct.get(movement.product.id);
      productData.movements++;
      if (isRevenue) productData.revenue += value;
      if (isCost) productData.costs += value;
      productData.profit = productData.revenue - productData.costs;
    });
    return {
      byProduct: Array.from(byProduct.values()),
      byCategory: Array.from(byCategory.values()),
      bySupplier: Array.from(bySupplier.values())
    };
  },
  async calculateUserActivitySummary(where) {
    const [totalActivities, uniqueUsers, activitiesByType] = await Promise.all([
      db.auditLog.count({ where }),
      db.auditLog.groupBy({
        by: ["userId"],
        where,
        _count: { userId: true }
      }),
      db.auditLog.groupBy({
        by: ["action"],
        where,
        _count: { action: true }
      })
    ]);
    const mostActiveUser = uniqueUsers.length > 0 ? uniqueUsers.reduce((max, user) => user._count.userId > max._count.userId ? user : max) : null;
    return {
      totalActivities,
      uniqueUsers: uniqueUsers.length,
      mostActiveUser: mostActiveUser ? {
        id: mostActiveUser.userId,
        name: "Unknown",
        // Would need to join with user table
        activities: mostActiveUser._count.userId
      } : null,
      activitiesByType: activitiesByType.map((activity) => ({
        action: activity.action,
        count: activity._count.action
      }))
    };
  }
};

// src/features/report/commands/report.commands.ts
init_prisma();
var ReportCommands = {
  // ================================
  // EXPORT REPORTS
  // ================================
  async exportReport(reportType, format, filters) {
    try {
      const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
      const filename = `${reportType}-report-${timestamp}.${format}`;
      const exportRecord = await db.auditLog.create({
        data: {
          entity: "REPORT",
          entityId: `export-${Date.now()}`,
          action: "CREATE",
          before: null,
          after: {
            reportType,
            format,
            filters,
            filename,
            generatedAt: (/* @__PURE__ */ new Date()).toISOString()
          }
        }
      });
      const downloadUrl = `/api/reports/download/${exportRecord.id}`;
      const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1e3);
      return {
        success: true,
        downloadUrl,
        filename,
        format,
        generatedAt: (/* @__PURE__ */ new Date()).toISOString(),
        expiresAt: expiresAt.toISOString()
      };
    } catch (error) {
      throw new Error(`Failed to export report: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  },
  // ================================
  // GENERATE CSV REPORT
  // ================================
  async generateCsvReport(reportType, data, columns) {
    try {
      const header = columns.join(",");
      const rows = data.map((item) => {
        return columns.map((column) => {
          const value = ReportCommands.getNestedValue(item, column);
          if (typeof value === "string" && (value.includes(",") || value.includes('"') || value.includes("\n"))) {
            return `"${value.replace(/"/g, '""')}"`;
          }
          return value || "";
        }).join(",");
      });
      return [header, ...rows].join("\n");
    } catch (error) {
      throw new Error(`Failed to generate CSV report: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  },
  // ================================
  // GENERATE EXCEL REPORT
  // ================================
  async generateExcelReport(reportType, data, columns) {
    try {
      const workbook = {
        SheetNames: [reportType],
        Sheets: {
          [reportType]: {
            "!ref": "A1",
            A1: { v: "Report Generated", t: "s" },
            A2: { v: (/* @__PURE__ */ new Date()).toISOString(), t: "s" }
          }
        }
      };
      return Buffer.from(JSON.stringify(workbook));
    } catch (error) {
      throw new Error(`Failed to generate Excel report: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  },
  // ================================
  // GENERATE PDF REPORT
  // ================================
  async generatePdfReport(reportType, data, columns) {
    try {
      const pdfContent = {
        title: `${reportType} Report`,
        generatedAt: (/* @__PURE__ */ new Date()).toISOString(),
        totalRecords: data.length,
        columns: columns.map((col) => col.label),
        data: data.slice(0, 10)
        // Limit for demo
      };
      return Buffer.from(JSON.stringify(pdfContent));
    } catch (error) {
      throw new Error(`Failed to generate PDF report: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  },
  // ================================
  // SCHEDULE REPORT
  // ================================
  async scheduleReport(reportType, schedule, filters, emailRecipients) {
    try {
      const scheduledReport = await db.auditLog.create({
        data: {
          entity: "REPORT",
          entityId: `schedule-${Date.now()}`,
          action: "CREATE",
          before: null,
          after: {
            reportType,
            schedule,
            filters,
            emailRecipients,
            isActive: true,
            createdAt: (/* @__PURE__ */ new Date()).toISOString()
          }
        }
      });
      return {
        success: true,
        scheduleId: scheduledReport.id
      };
    } catch (error) {
      throw new Error(`Failed to schedule report: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  },
  // ================================
  // CANCEL SCHEDULED REPORT
  // ================================
  async cancelScheduledReport(scheduleId) {
    try {
      await db.auditLog.update({
        where: { id: scheduleId },
        data: {
          after: {
            ...(await db.auditLog.findUnique({
              where: { id: scheduleId },
              select: { after: true }
            }))?.after,
            isActive: false,
            cancelledAt: (/* @__PURE__ */ new Date()).toISOString()
          }
        }
      });
      return { success: true };
    } catch (error) {
      throw new Error(`Failed to cancel scheduled report: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  },
  // ================================
  // SEND REPORT VIA EMAIL
  // ================================
  async sendReportViaEmail(reportType, format, data, emailRecipients, subject, message) {
    try {
      let reportContent;
      let filename;
      switch (format) {
        case "csv":
          const columns = ReportCommands.getDefaultColumns(reportType);
          reportContent = await ReportCommands.generateCsvReport(reportType, data, columns);
          filename = `${reportType}-report-${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.csv`;
          break;
        case "xlsx":
          const excelColumns = ReportCommands.getDefaultExcelColumns(reportType);
          reportContent = await ReportCommands.generateExcelReport(reportType, data, excelColumns);
          filename = `${reportType}-report-${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.xlsx`;
          break;
        case "pdf":
          const pdfColumns = ReportCommands.getDefaultPdfColumns(reportType);
          reportContent = await ReportCommands.generatePdfReport(reportType, data, pdfColumns);
          filename = `${reportType}-report-${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.pdf`;
          break;
        default:
          throw new Error(`Unsupported format: ${format}`);
      }
      const emailLog = await db.auditLog.create({
        data: {
          entity: "REPORT",
          entityId: `email-${Date.now()}`,
          action: "CREATE",
          before: null,
          after: {
            reportType,
            format,
            recipients: emailRecipients,
            subject: subject || `${reportType} Report`,
            message: message || "Please find the attached report.",
            filename,
            sentAt: (/* @__PURE__ */ new Date()).toISOString()
          }
        }
      });
      return {
        success: true,
        messageId: emailLog.id
      };
    } catch (error) {
      throw new Error(`Failed to send report via email: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  },
  // ================================
  // GENERATE REPORT SUMMARY
  // ================================
  async generateReportSummary(reportType, data, filters) {
    try {
      const summary = {};
      switch (reportType) {
        case "inventory":
          summary.totalValue = data.reduce((sum, item) => sum + (item.totalValue || 0), 0);
          summary.lowStockItems = data.filter((item) => item.alertLevel === "low").length;
          summary.outOfStockItems = data.filter((item) => item.alertLevel === "out").length;
          break;
        case "movement":
          summary.totalMovements = data.length;
          summary.totalValue = data.reduce((sum, item) => sum + (item.totalValue || 0), 0);
          summary.entries = data.filter((item) => item.type === "ENTRADA").length;
          summary.exits = data.filter((item) => item.type === "SAIDA").length;
          summary.losses = data.filter((item) => item.type === "PERDA").length;
          break;
        case "financial":
          summary.totalRevenue = data.reduce((sum, item) => sum + (item.revenue || 0), 0);
          summary.totalCosts = data.reduce((sum, item) => sum + (item.costs || 0), 0);
          summary.grossProfit = summary.totalRevenue - summary.totalCosts;
          summary.profitMargin = summary.totalRevenue > 0 ? summary.grossProfit / summary.totalRevenue * 100 : 0;
          break;
        default:
          summary.totalRecords = data.length;
      }
      return {
        totalRecords: data.length,
        dateRange: {
          start: filters.startDate || new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3).toISOString().split("T")[0],
          end: filters.endDate || (/* @__PURE__ */ new Date()).toISOString().split("T")[0]
        },
        filters,
        generatedAt: (/* @__PURE__ */ new Date()).toISOString(),
        summary
      };
    } catch (error) {
      throw new Error(`Failed to generate report summary: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  },
  // ================================
  // HELPER METHODS
  // ================================
  getNestedValue(obj, path3) {
    return path3.split(".").reduce((current, key) => current?.[key], obj);
  },
  getDefaultColumns(reportType) {
    const columnMap = {
      inventory: ["id", "name", "description", "category.name", "supplier.corporateName", "currentStock", "stockMin", "stockMax", "unitPrice", "totalValue", "status", "alertLevel"],
      movement: ["id", "type", "quantity", "price", "totalValue", "batch", "expiration", "note", "product.name", "supplier.corporateName", "user.name", "createdAt"],
      financial: ["period", "revenue", "costs", "profit", "movements"],
      category: ["id", "name", "description", "code", "stats.totalProducts", "stats.totalValue", "stats.averagePrice", "stats.movements"],
      supplier: ["id", "corporateName", "tradeName", "cnpj", "status", "stats.totalProducts", "stats.totalValue", "stats.totalMovements", "stats.averageOrderValue"],
      "user-activity": ["id", "entity", "entityId", "action", "user.name", "user.email", "createdAt"],
      "stock-alert": ["id", "productName", "currentStock", "stockMin", "stockMax", "alertType", "severity", "unitPrice", "totalValue", "category.name", "supplier.corporateName"]
    };
    return columnMap[reportType] || ["id", "name", "createdAt"];
  },
  getDefaultExcelColumns(reportType) {
    const columnMap = {
      inventory: [
        { key: "id", label: "ID", type: "string" },
        { key: "name", label: "Nome", type: "string" },
        { key: "description", label: "Descri\xE7\xE3o", type: "string" },
        { key: "category.name", label: "Categoria", type: "string" },
        { key: "supplier.corporateName", label: "Fornecedor", type: "string" },
        { key: "currentStock", label: "Estoque Atual", type: "number" },
        { key: "stockMin", label: "Estoque M\xEDnimo", type: "number" },
        { key: "stockMax", label: "Estoque M\xE1ximo", type: "number" },
        { key: "unitPrice", label: "Pre\xE7o Unit\xE1rio", type: "number" },
        { key: "totalValue", label: "Valor Total", type: "number" },
        { key: "status", label: "Status", type: "string" },
        { key: "alertLevel", label: "N\xEDvel de Alerta", type: "string" }
      ],
      movement: [
        { key: "id", label: "ID", type: "string" },
        { key: "type", label: "Tipo", type: "string" },
        { key: "quantity", label: "Quantidade", type: "number" },
        { key: "price", label: "Pre\xE7o", type: "number" },
        { key: "totalValue", label: "Valor Total", type: "number" },
        { key: "batch", label: "Lote", type: "string" },
        { key: "expiration", label: "Validade", type: "date" },
        { key: "note", label: "Observa\xE7\xE3o", type: "string" },
        { key: "product.name", label: "Produto", type: "string" },
        { key: "supplier.corporateName", label: "Fornecedor", type: "string" },
        { key: "user.name", label: "Usu\xE1rio", type: "string" },
        { key: "createdAt", label: "Data", type: "date" }
      ]
    };
    return columnMap[reportType] || [
      { key: "id", label: "ID", type: "string" },
      { key: "name", label: "Nome", type: "string" },
      { key: "createdAt", label: "Data de Cria\xE7\xE3o", type: "date" }
    ];
  },
  getDefaultPdfColumns(reportType) {
    const columnMap = {
      inventory: [
        { key: "name", label: "Produto", width: 30 },
        { key: "category.name", label: "Categoria", width: 20 },
        { key: "currentStock", label: "Estoque", width: 15 },
        { key: "unitPrice", label: "Pre\xE7o", width: 15 },
        { key: "totalValue", label: "Valor Total", width: 20 }
      ],
      movement: [
        { key: "product.name", label: "Produto", width: 25 },
        { key: "type", label: "Tipo", width: 15 },
        { key: "quantity", label: "Quantidade", width: 15 },
        { key: "totalValue", label: "Valor", width: 15 },
        { key: "user.name", label: "Usu\xE1rio", width: 15 },
        { key: "createdAt", label: "Data", width: 15 }
      ]
    };
    return columnMap[reportType] || [
      { key: "name", label: "Nome", width: 50 },
      { key: "createdAt", label: "Data", width: 50 }
    ];
  },
  // ================================
  // VALIDATION METHODS
  // ================================
  validateReportFilters(filters) {
    const errors = [];
    if (filters.startDate && filters.endDate) {
      const startDate = new Date(filters.startDate);
      const endDate = new Date(filters.endDate);
      if (startDate > endDate) {
        errors.push("Start date cannot be after end date");
      }
    }
    if (filters.storeId && typeof filters.storeId !== "string") {
      errors.push("Store ID must be a string");
    }
    return {
      valid: errors.length === 0,
      errors
    };
  },
  getAvailableReportTypes() {
    return [
      "inventory",
      "movement",
      "financial",
      "category",
      "supplier",
      "user-activity",
      "stock-alert"
    ];
  },
  getReportStatistics() {
    return {
      totalReports: 0,
      // This would be calculated from actual data
      availableTypes: ReportCommands.getAvailableReportTypes()
    };
  }
};

// src/features/report/report.controller.ts
var ReportController = {
  // ================================
  // DASHBOARD STATS
  // ================================
  async getDashboardStats(request, reply) {
    try {
      const { storeId, period, startDate, endDate } = request.query;
      const filters = {
        storeId,
        startDate,
        endDate,
        period
      };
      const result = await ReportQueries.getDashboardStats(filters);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("Failed to get dashboard stats")) {
        return reply.status(500).send({
          error: "Erro ao obter estat\xEDsticas do dashboard"
        });
      }
      return reply.status(500).send({
        error: "Erro interno do servidor"
      });
    }
  },
  // ================================
  // INVENTORY REPORT
  // ================================
  async getInventoryReport(request, reply) {
    try {
      const {
        storeId,
        categoryId,
        supplierId,
        status,
        lowStock,
        sortBy,
        sortOrder,
        page = 1,
        limit = 20
      } = request.query;
      const filters = {
        storeId,
        categoryId,
        supplierId,
        status,
        lowStock
      };
      const pagination = { page, limit };
      const sort = { field: sortBy || "name", order: sortOrder || "asc" };
      const result = await ReportQueries.getInventoryReport(filters, pagination, sort);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("Failed to get inventory report")) {
        return reply.status(500).send({
          error: "Erro ao obter relat\xF3rio de invent\xE1rio"
        });
      }
      return reply.status(500).send({
        error: "Erro interno do servidor"
      });
    }
  },
  // ================================
  // MOVEMENT REPORT
  // ================================
  async getMovementReport(request, reply) {
    try {
      const {
        storeId,
        productId,
        supplierId,
        type,
        startDate,
        endDate,
        page = 1,
        limit = 20
      } = request.query;
      const filters = {
        storeId,
        productId,
        supplierId,
        type,
        startDate,
        endDate
      };
      const pagination = { page, limit };
      const result = await ReportQueries.getMovementReport(filters, pagination);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("Failed to get movement report")) {
        return reply.status(500).send({
          error: "Erro ao obter relat\xF3rio de movimenta\xE7\xF5es"
        });
      }
      return reply.status(500).send({
        error: "Erro interno do servidor"
      });
    }
  },
  // ================================
  // FINANCIAL REPORT
  // ================================
  async getFinancialReport(request, reply) {
    try {
      const { storeId, startDate, endDate, groupBy } = request.query;
      const filters = {
        storeId,
        startDate,
        endDate,
        groupBy
      };
      const result = await ReportQueries.getFinancialReport(filters);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("Failed to get financial report")) {
        return reply.status(500).send({
          error: "Erro ao obter relat\xF3rio financeiro"
        });
      }
      return reply.status(500).send({
        error: "Erro interno do servidor"
      });
    }
  },
  // ================================
  // CATEGORY REPORT
  // ================================
  async getCategoryReport(request, reply) {
    try {
      const { storeId, startDate, endDate, includeSubcategories } = request.query;
      const filters = {
        storeId,
        startDate,
        endDate,
        includeSubcategories
      };
      const result = await ReportQueries.getCategoryReport(filters);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("Failed to get category report")) {
        return reply.status(500).send({
          error: "Erro ao obter relat\xF3rio de categorias"
        });
      }
      return reply.status(500).send({
        error: "Erro interno do servidor"
      });
    }
  },
  // ================================
  // SUPPLIER REPORT
  // ================================
  async getSupplierReport(request, reply) {
    try {
      const { storeId, startDate, endDate, status } = request.query;
      const filters = {
        storeId,
        startDate,
        endDate,
        status
      };
      const result = await ReportQueries.getSupplierReport(filters);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("Failed to get supplier report")) {
        return reply.status(500).send({
          error: "Erro ao obter relat\xF3rio de fornecedores"
        });
      }
      return reply.status(500).send({
        error: "Erro interno do servidor"
      });
    }
  },
  // ================================
  // USER ACTIVITY REPORT
  // ================================
  async getUserActivityReport(request, reply) {
    try {
      const {
        storeId,
        userId,
        startDate,
        endDate,
        action,
        page = 1,
        limit = 20
      } = request.query;
      const filters = {
        storeId,
        userId,
        startDate,
        endDate,
        action
      };
      const pagination = { page, limit };
      const result = await ReportQueries.getUserActivityReport(filters, pagination);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("Failed to get user activity report")) {
        return reply.status(500).send({
          error: "Erro ao obter relat\xF3rio de atividade de usu\xE1rios"
        });
      }
      return reply.status(500).send({
        error: "Erro interno do servidor"
      });
    }
  },
  // ================================
  // STOCK ALERT REPORT
  // ================================
  async getStockAlertReport(request, reply) {
    try {
      const { storeId, alertType, page = 1, limit = 20 } = request.query;
      const filters = {
        storeId,
        alertType
      };
      const pagination = { page, limit };
      const result = await ReportQueries.getStockAlertReport(filters, pagination);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("Failed to get stock alert report")) {
        return reply.status(500).send({
          error: "Erro ao obter relat\xF3rio de alertas de estoque"
        });
      }
      return reply.status(500).send({
        error: "Erro interno do servidor"
      });
    }
  },
  // ================================
  // EXPORT REPORTS
  // ================================
  async exportReport(request, reply) {
    try {
      const { reportType, format, storeId, startDate, endDate, filters } = request.query;
      const reportFilters = {
        storeId,
        startDate,
        endDate,
        ...filters ? JSON.parse(filters) : {}
      };
      const result = await ReportCommands.exportReport(reportType, format, reportFilters);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("Failed to export report")) {
        return reply.status(500).send({
          error: "Erro ao exportar relat\xF3rio"
        });
      }
      if (error.message.includes("Unsupported report type")) {
        return reply.status(400).send({
          error: "Tipo de relat\xF3rio n\xE3o suportado"
        });
      }
      return reply.status(500).send({
        error: "Erro interno do servidor"
      });
    }
  },
  // ================================
  // SCHEDULE REPORTS
  // ================================
  async scheduleReport(request, reply) {
    try {
      const { reportType, schedule, filters, emailRecipients } = request.body;
      const result = await ReportCommands.scheduleReport(reportType, schedule, filters, emailRecipients);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("Failed to schedule report")) {
        return reply.status(500).send({
          error: "Erro ao agendar relat\xF3rio"
        });
      }
      return reply.status(500).send({
        error: "Erro interno do servidor"
      });
    }
  },
  async cancelScheduledReport(request, reply) {
    try {
      const { scheduleId } = request.params;
      const result = await ReportCommands.cancelScheduledReport(scheduleId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("Failed to cancel scheduled report")) {
        return reply.status(500).send({
          error: "Erro ao cancelar relat\xF3rio agendado"
        });
      }
      return reply.status(500).send({
        error: "Erro interno do servidor"
      });
    }
  },
  // ================================
  // EMAIL REPORTS
  // ================================
  async sendReportViaEmail(request, reply) {
    try {
      const { reportType, format, data, emailRecipients, subject, message } = request.body;
      const result = await ReportCommands.sendReportViaEmail(
        reportType,
        format,
        data,
        emailRecipients,
        subject,
        message
      );
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("Failed to send report via email")) {
        return reply.status(500).send({
          error: "Erro ao enviar relat\xF3rio por email"
        });
      }
      return reply.status(500).send({
        error: "Erro interno do servidor"
      });
    }
  },
  // ================================
  // UTILITY ENDPOINTS
  // ================================
  async getAvailableReportTypes(request, reply) {
    try {
      const result = ReportCommands.getAvailableReportTypes();
      return reply.send({ reportTypes: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Erro interno do servidor"
      });
    }
  },
  async getReportStatistics(request, reply) {
    try {
      const result = ReportCommands.getReportStatistics();
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Erro interno do servidor"
      });
    }
  },
  // ================================
  // VALIDATION ENDPOINT
  // ================================
  async validateFilters(request, reply) {
    try {
      const { filters } = request.body;
      const result = ReportCommands.validateReportFilters(filters);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Erro interno do servidor"
      });
    }
  }
};

// src/features/report/report.schema.ts
var getDashboardStatsSchema = {
  querystring: {
    type: "object",
    properties: {
      storeId: { type: "string" },
      period: {
        type: "string",
        enum: ["day", "week", "month", "year"],
        default: "month"
      },
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        overview: {
          type: "object",
          properties: {
            totalProducts: { type: "number" },
            totalCategories: { type: "number" },
            totalSuppliers: { type: "number" },
            totalStores: { type: "number" },
            totalUsers: { type: "number" }
          }
        },
        inventory: {
          type: "object",
          properties: {
            totalValue: { type: "number" },
            lowStockItems: { type: "number" },
            outOfStockItems: { type: "number" },
            averageStockValue: { type: "number" }
          }
        },
        movements: {
          type: "object",
          properties: {
            totalMovements: { type: "number" },
            entries: { type: "number" },
            exits: { type: "number" },
            losses: { type: "number" },
            totalValue: { type: "number" }
          }
        },
        recentActivity: {
          type: "object",
          properties: {
            lastMovements: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  type: { type: "string" },
                  productName: { type: "string" },
                  quantity: { type: "number" },
                  createdAt: { type: "string" }
                }
              }
            },
            recentProducts: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  createdAt: { type: "string" }
                }
              }
            }
          }
        },
        charts: {
          type: "object",
          properties: {
            movementsByType: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  type: { type: "string" },
                  count: { type: "number" },
                  value: { type: "number" }
                }
              }
            },
            topProducts: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  productId: { type: "string" },
                  productName: { type: "string" },
                  movements: { type: "number" },
                  value: { type: "number" }
                }
              }
            },
            movementsByDay: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  date: { type: "string" },
                  entries: { type: "number" },
                  exits: { type: "number" },
                  losses: { type: "number" }
                }
              }
            }
          }
        }
      }
    }
  }
};
var getInventoryReportSchema = {
  querystring: {
    type: "object",
    properties: {
      storeId: { type: "string" },
      categoryId: { type: "string" },
      supplierId: { type: "string" },
      status: {
        type: "string",
        enum: ["all", "active", "inactive"],
        default: "all"
      },
      lowStock: { type: "boolean" },
      sortBy: {
        type: "string",
        enum: ["name", "stock", "value", "category"],
        default: "name"
      },
      sortOrder: {
        type: "string",
        enum: ["asc", "desc"],
        default: "asc"
      },
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 20 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        products: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string" },
              category: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" }
                }
              },
              supplier: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  corporateName: { type: "string" }
                }
              },
              currentStock: { type: "number" },
              stockMin: { type: "number" },
              stockMax: { type: "number" },
              unitPrice: { type: "number" },
              totalValue: { type: "number" },
              status: { type: "boolean" },
              alertLevel: {
                type: "string",
                enum: ["normal", "low", "high", "out"]
              },
              lastMovement: { type: "string" }
            }
          }
        },
        summary: {
          type: "object",
          properties: {
            totalProducts: { type: "number" },
            totalValue: { type: "number" },
            lowStockCount: { type: "number" },
            outOfStockCount: { type: "number" },
            averageStockValue: { type: "number" }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getMovementReportSchema2 = {
  querystring: {
    type: "object",
    properties: {
      storeId: { type: "string" },
      productId: { type: "string" },
      supplierId: { type: "string" },
      type: {
        type: "string",
        enum: ["ENTRADA", "SAIDA", "PERDA"]
      },
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" },
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 20 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        movements: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              type: { type: "string" },
              quantity: { type: "number" },
              price: { type: "number" },
              totalValue: { type: "number" },
              batch: { type: "string" },
              expiration: { type: "string" },
              note: { type: "string" },
              balanceAfter: { type: "number" },
              product: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  unitOfMeasure: { type: "string" }
                }
              },
              supplier: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  corporateName: { type: "string" }
                }
              },
              user: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" }
                }
              },
              createdAt: { type: "string" }
            }
          }
        },
        summary: {
          type: "object",
          properties: {
            totalMovements: { type: "number" },
            totalEntries: { type: "number" },
            totalExits: { type: "number" },
            totalLosses: { type: "number" },
            totalValue: { type: "number" },
            averageValue: { type: "number" }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getFinancialReportSchema = {
  querystring: {
    type: "object",
    properties: {
      storeId: { type: "string" },
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" },
      groupBy: {
        type: "string",
        enum: ["day", "week", "month", "year"],
        default: "month"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        period: {
          type: "object",
          properties: {
            startDate: { type: "string" },
            endDate: { type: "string" },
            groupBy: { type: "string" }
          }
        },
        summary: {
          type: "object",
          properties: {
            totalRevenue: { type: "number" },
            totalCosts: { type: "number" },
            grossProfit: { type: "number" },
            profitMargin: { type: "number" },
            totalMovements: { type: "number" }
          }
        },
        data: {
          type: "array",
          items: {
            type: "object",
            properties: {
              period: { type: "string" },
              revenue: { type: "number" },
              costs: { type: "number" },
              profit: { type: "number" },
              movements: { type: "number" }
            }
          }
        },
        breakdown: {
          type: "object",
          properties: {
            byProduct: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  productId: { type: "string" },
                  productName: { type: "string" },
                  revenue: { type: "number" },
                  costs: { type: "number" },
                  profit: { type: "number" },
                  movements: { type: "number" }
                }
              }
            },
            byCategory: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  categoryId: { type: "string" },
                  categoryName: { type: "string" },
                  revenue: { type: "number" },
                  costs: { type: "number" },
                  profit: { type: "number" },
                  movements: { type: "number" }
                }
              }
            },
            bySupplier: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  supplierId: { type: "string" },
                  supplierName: { type: "string" },
                  revenue: { type: "number" },
                  costs: { type: "number" },
                  profit: { type: "number" },
                  movements: { type: "number" }
                }
              }
            }
          }
        }
      }
    }
  }
};
var getCategoryReportSchema = {
  querystring: {
    type: "object",
    properties: {
      storeId: { type: "string" },
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" },
      includeSubcategories: { type: "boolean", default: true }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        categories: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string" },
              code: { type: "string" },
              color: { type: "string" },
              icon: { type: "string" },
              parentId: { type: "string" },
              parent: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" }
                }
              },
              children: {
                type: "array",
                items: {
                  type: "object",
                  properties: {
                    id: { type: "string" },
                    name: { type: "string" }
                  }
                }
              },
              stats: {
                type: "object",
                properties: {
                  totalProducts: { type: "number" },
                  totalValue: { type: "number" },
                  averagePrice: { type: "number" },
                  movements: { type: "number" },
                  lastMovement: { type: "string" }
                }
              }
            }
          }
        },
        summary: {
          type: "object",
          properties: {
            totalCategories: { type: "number" },
            totalProducts: { type: "number" },
            totalValue: { type: "number" },
            averageProductsPerCategory: { type: "number" }
          }
        }
      }
    }
  }
};
var getSupplierReportSchema = {
  querystring: {
    type: "object",
    properties: {
      storeId: { type: "string" },
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" },
      status: {
        type: "string",
        enum: ["all", "active", "inactive"],
        default: "all"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        suppliers: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              corporateName: { type: "string" },
              tradeName: { type: "string" },
              cnpj: { type: "string" },
              status: { type: "boolean" },
              address: {
                type: "object",
                properties: {
                  cep: { type: "string" },
                  city: { type: "string" },
                  state: { type: "string" },
                  address: { type: "string" }
                }
              },
              stats: {
                type: "object",
                properties: {
                  totalProducts: { type: "number" },
                  totalValue: { type: "number" },
                  totalMovements: { type: "number" },
                  lastMovement: { type: "string" },
                  averageOrderValue: { type: "number" }
                }
              },
              responsibles: {
                type: "array",
                items: {
                  type: "object",
                  properties: {
                    id: { type: "string" },
                    name: { type: "string" },
                    phone: { type: "string" },
                    email: { type: "string" }
                  }
                }
              }
            }
          }
        },
        summary: {
          type: "object",
          properties: {
            totalSuppliers: { type: "number" },
            activeSuppliers: { type: "number" },
            totalProducts: { type: "number" },
            totalValue: { type: "number" },
            averageProductsPerSupplier: { type: "number" }
          }
        }
      }
    }
  }
};
var getUserActivityReportSchema = {
  querystring: {
    type: "object",
    properties: {
      storeId: { type: "string" },
      userId: { type: "string" },
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" },
      action: {
        type: "string",
        enum: ["CREATE", "UPDATE", "DELETE"]
      },
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 20 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        activities: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              entity: { type: "string" },
              entityId: { type: "string" },
              action: { type: "string" },
              before: { type: "object" },
              after: { type: "object" },
              user: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  email: { type: "string" }
                }
              },
              createdAt: { type: "string" }
            }
          }
        },
        summary: {
          type: "object",
          properties: {
            totalActivities: { type: "number" },
            uniqueUsers: { type: "number" },
            mostActiveUser: {
              type: "object",
              properties: {
                id: { type: "string" },
                name: { type: "string" },
                activities: { type: "number" }
              }
            },
            activitiesByType: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  action: { type: "string" },
                  count: { type: "number" }
                }
              }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getStockAlertReportSchema = {
  querystring: {
    type: "object",
    properties: {
      storeId: { type: "string" },
      alertType: {
        type: "string",
        enum: ["low", "high", "expired", "all"],
        default: "all"
      },
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 20 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        alerts: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              productId: { type: "string" },
              productName: { type: "string" },
              currentStock: { type: "number" },
              stockMin: { type: "number" },
              stockMax: { type: "number" },
              alertType: {
                type: "string",
                enum: ["low", "high", "expired", "out"]
              },
              severity: {
                type: "string",
                enum: ["low", "medium", "high", "critical"]
              },
              unitPrice: { type: "number" },
              totalValue: { type: "number" },
              lastMovement: { type: "string" },
              category: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" }
                }
              },
              supplier: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  corporateName: { type: "string" }
                }
              }
            }
          }
        },
        summary: {
          type: "object",
          properties: {
            totalAlerts: { type: "number" },
            lowStockAlerts: { type: "number" },
            highStockAlerts: { type: "number" },
            expiredAlerts: { type: "number" },
            outOfStockAlerts: { type: "number" },
            totalValue: { type: "number" }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var exportReportSchema = {
  querystring: {
    type: "object",
    required: ["reportType", "format"],
    properties: {
      reportType: {
        type: "string",
        enum: ["inventory", "movement", "financial", "category", "supplier", "user-activity", "stock-alert"]
      },
      format: {
        type: "string",
        enum: ["csv", "xlsx", "pdf"]
      },
      storeId: { type: "string" },
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" },
      filters: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        success: { type: "boolean" },
        downloadUrl: { type: "string" },
        filename: { type: "string" },
        format: { type: "string" },
        generatedAt: { type: "string" },
        expiresAt: { type: "string" }
      }
    }
  }
};

// src/features/report/report.routes.ts
async function ReportRoutes(fastify2) {
  fastify2.get("/dashboard/stats", {
    schema: getDashboardStatsSchema,
    handler: ReportController.getDashboardStats
  });
  fastify2.get("/inventory", {
    schema: getInventoryReportSchema,
    handler: ReportController.getInventoryReport
  });
  fastify2.get("/movements", {
    schema: getMovementReportSchema2,
    handler: ReportController.getMovementReport
  });
  fastify2.get("/financial", {
    schema: getFinancialReportSchema,
    handler: ReportController.getFinancialReport
  });
  fastify2.get("/categories", {
    schema: getCategoryReportSchema,
    handler: ReportController.getCategoryReport
  });
  fastify2.get("/suppliers", {
    schema: getSupplierReportSchema,
    handler: ReportController.getSupplierReport
  });
  fastify2.get("/user-activity", {
    schema: getUserActivityReportSchema,
    handler: ReportController.getUserActivityReport
  });
  fastify2.get("/stock-alerts", {
    schema: getStockAlertReportSchema,
    handler: ReportController.getStockAlertReport
  });
  fastify2.get("/export", {
    schema: exportReportSchema,
    handler: ReportController.exportReport
  });
  fastify2.post("/schedule", {
    schema: {
      description: "Agendar relat\xF3rio para gera\xE7\xE3o autom\xE1tica",
      tags: ["Reports"],
      body: {
        type: "object",
        required: ["reportType", "schedule", "filters", "emailRecipients"],
        properties: {
          reportType: {
            type: "string",
            enum: ["inventory", "movement", "financial", "category", "supplier", "user-activity", "stock-alert"]
          },
          schedule: {
            type: "object",
            required: ["frequency", "time"],
            properties: {
              frequency: {
                type: "string",
                enum: ["daily", "weekly", "monthly"]
              },
              time: {
                type: "string",
                pattern: "^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$",
                description: "Time in HH:MM format"
              },
              dayOfWeek: {
                type: "number",
                minimum: 0,
                maximum: 6,
                description: "Day of week (0-6) for weekly frequency"
              },
              dayOfMonth: {
                type: "number",
                minimum: 1,
                maximum: 31,
                description: "Day of month (1-31) for monthly frequency"
              }
            }
          },
          filters: {
            type: "object",
            properties: {
              storeId: { type: "string" },
              startDate: { type: "string", format: "date" },
              endDate: { type: "string", format: "date" },
              categoryId: { type: "string" },
              supplierId: { type: "string" },
              productId: { type: "string" },
              userId: { type: "string" },
              status: { type: "string" },
              type: { type: "string" }
            }
          },
          emailRecipients: {
            type: "array",
            items: { type: "string", format: "email" },
            minItems: 1
          }
        }
      },
      response: {
        200: {
          type: "object",
          properties: {
            success: { type: "boolean" },
            scheduleId: { type: "string" }
          }
        }
      }
    },
    handler: ReportController.scheduleReport
  });
  fastify2.delete("/schedule/:scheduleId", {
    schema: {
      description: "Cancelar relat\xF3rio agendado",
      tags: ["Reports"],
      params: {
        type: "object",
        properties: {
          scheduleId: { type: "string" }
        },
        required: ["scheduleId"]
      },
      response: {
        200: {
          type: "object",
          properties: {
            success: { type: "boolean" }
          }
        }
      }
    },
    handler: ReportController.cancelScheduledReport
  });
  fastify2.post("/send-email", {
    schema: {
      description: "Enviar relat\xF3rio por email",
      tags: ["Reports"],
      body: {
        type: "object",
        required: ["reportType", "format", "data", "emailRecipients"],
        properties: {
          reportType: {
            type: "string",
            enum: ["inventory", "movement", "financial", "category", "supplier", "user-activity", "stock-alert"]
          },
          format: {
            type: "string",
            enum: ["csv", "xlsx", "pdf"]
          },
          data: {
            type: "array",
            items: { type: "object" }
          },
          emailRecipients: {
            type: "array",
            items: { type: "string", format: "email" },
            minItems: 1
          },
          subject: {
            type: "string",
            description: "Email subject (optional)"
          },
          message: {
            type: "string",
            description: "Email message (optional)"
          }
        }
      },
      response: {
        200: {
          type: "object",
          properties: {
            success: { type: "boolean" },
            messageId: { type: "string" }
          }
        }
      }
    },
    handler: ReportController.sendReportViaEmail
  });
  fastify2.get("/types", {
    schema: {
      description: "Obter tipos de relat\xF3rios dispon\xEDveis",
      tags: ["Reports"],
      response: {
        200: {
          type: "object",
          properties: {
            reportTypes: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  type: { type: "string" },
                  name: { type: "string" },
                  description: { type: "string" },
                  supportedFormats: {
                    type: "array",
                    items: { type: "string" }
                  }
                }
              }
            }
          }
        }
      }
    },
    handler: ReportController.getAvailableReportTypes
  });
  fastify2.get("/statistics", {
    schema: {
      description: "Obter estat\xEDsticas de relat\xF3rios",
      tags: ["Reports"],
      response: {
        200: {
          type: "object",
          properties: {
            totalReports: { type: "number" },
            reportsByType: { type: "object" },
            reportsByFormat: { type: "object" },
            lastGenerated: { type: "string", nullable: true }
          }
        }
      }
    },
    handler: ReportController.getReportStatistics
  });
  fastify2.post("/validate-filters", {
    schema: {
      description: "Validar filtros de relat\xF3rio",
      tags: ["Reports"],
      body: {
        type: "object",
        required: ["filters"],
        properties: {
          filters: {
            type: "object",
            properties: {
              storeId: { type: "string" },
              startDate: { type: "string", format: "date" },
              endDate: { type: "string", format: "date" },
              categoryId: { type: "string" },
              supplierId: { type: "string" },
              productId: { type: "string" },
              userId: { type: "string" },
              status: { type: "string" },
              type: { type: "string" },
              page: { type: "number", minimum: 1 },
              limit: { type: "number", minimum: 1, maximum: 1e3 }
            }
          }
        }
      },
      response: {
        200: {
          type: "object",
          properties: {
            isValid: { type: "boolean" },
            errors: {
              type: "array",
              items: { type: "string" }
            }
          }
        }
      }
    },
    handler: ReportController.validateFilters
  });
  fastify2.get("/download/:exportId", {
    schema: {
      description: "Download de relat\xF3rio exportado",
      tags: ["Reports"],
      params: {
        type: "object",
        properties: {
          exportId: { type: "string" }
        },
        required: ["exportId"]
      },
      response: {
        200: {
          type: "string",
          description: "File content"
        },
        500: {
          type: "object",
          properties: {
            error: { type: "string" }
          }
        }
      }
    },
    handler: async (request, reply) => {
      try {
        const { exportId } = request.params;
        reply.type("application/json");
        return reply.send({
          message: "Download endpoint - implementation needed",
          exportId,
          note: "This would return the actual file content"
        });
      } catch (error) {
        request.log.error(error);
        return reply.status(500).send({
          error: "Erro ao fazer download do relat\xF3rio"
        });
      }
    }
  });
}

// src/features/notification/queries/notification.queries.ts
init_prisma();
var NotificationQueries = {
  async getById(id) {
    return await db.notification.findUnique({
      where: { id },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async list(params) {
    const { page = 1, limit = 10, search, type, priority, isRead, userId } = params;
    const skip = (page - 1) * limit;
    const where = {};
    if (userId) {
      where.userId = userId;
    }
    if (type) {
      where.type = type;
    }
    if (priority) {
      where.priority = priority;
    }
    if (isRead !== void 0) {
      where.isRead = isRead;
    }
    if (search) {
      where.OR = [
        { title: { contains: search, mode: "insensitive" } },
        { message: { contains: search, mode: "insensitive" } }
      ];
    }
    where.OR = [
      { expiresAt: null },
      { expiresAt: { gt: /* @__PURE__ */ new Date() } }
    ];
    const [items, total] = await Promise.all([
      db.notification.findMany({
        where,
        skip,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      }),
      db.notification.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getByUser(userId, params) {
    return await NotificationQueries.list({
      userId,
      ...params
    });
  },
  async getUnread(userId, limit) {
    return await db.notification.findMany({
      where: {
        userId,
        isRead: false,
        OR: [
          { expiresAt: null },
          { expiresAt: { gt: /* @__PURE__ */ new Date() } }
        ]
      },
      take: limit || 10,
      orderBy: [
        { priority: "desc" },
        { createdAt: "desc" }
      ],
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async getByType(type, limit) {
    return await db.notification.findMany({
      where: {
        type,
        OR: [
          { expiresAt: null },
          { expiresAt: { gt: /* @__PURE__ */ new Date() } }
        ]
      },
      take: limit || 10,
      orderBy: { createdAt: "desc" },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async getByPriority(priority, limit) {
    return await db.notification.findMany({
      where: {
        priority,
        OR: [
          { expiresAt: null },
          { expiresAt: { gt: /* @__PURE__ */ new Date() } }
        ]
      },
      take: limit || 10,
      orderBy: { createdAt: "desc" },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async search(term, limit = 10) {
    return await db.notification.findMany({
      where: {
        AND: [
          {
            OR: [
              { title: { contains: term, mode: "insensitive" } },
              { message: { contains: term, mode: "insensitive" } }
            ]
          },
          {
            OR: [
              { expiresAt: null },
              { expiresAt: { gt: /* @__PURE__ */ new Date() } }
            ]
          }
        ]
      },
      take: limit,
      orderBy: { createdAt: "desc" },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async getStats(userId) {
    const where = userId ? { userId } : {};
    const [total, unread, byType, byPriority] = await Promise.all([
      db.notification.count({ where }),
      db.notification.count({
        where: {
          ...where,
          isRead: false,
          OR: [
            { expiresAt: null },
            { expiresAt: { gt: /* @__PURE__ */ new Date() } }
          ]
        }
      }),
      db.notification.groupBy({
        by: ["type"],
        where,
        _count: true
      }),
      db.notification.groupBy({
        by: ["priority"],
        where,
        _count: true
      })
    ]);
    return {
      total,
      unread,
      read: total - unread,
      byType: byType.reduce((acc, item) => {
        acc[item.type] = item._count;
        return acc;
      }, {}),
      byPriority: byPriority.reduce((acc, item) => {
        acc[item.priority] = item._count;
        return acc;
      }, {})
    };
  },
  async getRecent(userId, days = 7, limit = 20) {
    const startDate = /* @__PURE__ */ new Date();
    startDate.setDate(startDate.getDate() - days);
    return await db.notification.findMany({
      where: {
        userId,
        createdAt: {
          gte: startDate
        },
        OR: [
          { expiresAt: null },
          { expiresAt: { gt: /* @__PURE__ */ new Date() } }
        ]
      },
      take: limit,
      orderBy: { createdAt: "desc" },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  // === QUERIES ESPECÍFICAS PARA ALERTAS DE ESTOQUE ===
  async getStockAlerts(params) {
    const { userId, storeId, isRead, limit = 20 } = params;
    const where = {
      type: "STOCK_ALERT",
      OR: [
        { expiresAt: null },
        { expiresAt: { gt: /* @__PURE__ */ new Date() } }
      ]
    };
    if (userId) {
      where.userId = userId;
    }
    if (isRead !== void 0) {
      where.isRead = isRead;
    }
    if (storeId) {
      where.data = {
        path: ["storeId"],
        equals: storeId
      };
    }
    return await db.notification.findMany({
      where,
      take: limit,
      orderBy: [
        { priority: "desc" },
        { createdAt: "desc" }
      ],
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async getUnreadStockAlerts(userId, limit = 10) {
    return await db.notification.findMany({
      where: {
        userId,
        type: "STOCK_ALERT",
        isRead: false,
        OR: [
          { expiresAt: null },
          { expiresAt: { gt: /* @__PURE__ */ new Date() } }
        ]
      },
      take: limit,
      orderBy: [
        { priority: "desc" },
        { createdAt: "desc" }
      ],
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  }
};

// src/features/notification/notification.controller.ts
var NotificationController = {
  // === CRUD BÁSICO ===
  async create(request, reply) {
    try {
      const { userId, title, message, type, priority, data, actionUrl, expiresAt } = request.body;
      const result = await NotificationCommands.create({
        userId,
        title,
        message,
        type,
        priority,
        data,
        actionUrl,
        expiresAt: expiresAt ? new Date(expiresAt) : void 0
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      const result = await NotificationQueries.getById(id);
      if (!result) {
        return reply.status(404).send({
          error: "Notification not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Notification not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      if (updateData.expiresAt) {
        updateData.expiresAt = new Date(updateData.expiresAt);
      }
      const result = await NotificationCommands.update(id, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Notification not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Validation error") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      await NotificationCommands.delete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Notification not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { page = 1, limit = 10, search, type, priority, isRead, userId } = request.query;
      const result = await NotificationQueries.list({
        page,
        limit,
        search,
        type,
        priority,
        isRead,
        userId
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (QUERIES) ===
  async getByUser(request, reply) {
    try {
      const { userId } = request.params;
      const { page = 1, limit = 10, isRead, type } = request.query;
      const result = await NotificationQueries.getByUser(userId, {
        page,
        limit,
        isRead,
        type
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getUnread(request, reply) {
    try {
      const { userId } = request.params;
      const { limit = 10 } = request.query;
      const result = await NotificationQueries.getUnread(userId, limit);
      return reply.send({ notifications: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByType(request, reply) {
    try {
      const { type } = request.params;
      const { limit = 10 } = request.query;
      const result = await NotificationQueries.getByType(type, limit);
      return reply.send({ notifications: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByPriority(request, reply) {
    try {
      const { priority } = request.params;
      const { limit = 10 } = request.query;
      const result = await NotificationQueries.getByPriority(priority, limit);
      return reply.send({ notifications: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getRecent(request, reply) {
    try {
      const { userId } = request.params;
      const { days = 7, limit = 20 } = request.query;
      const result = await NotificationQueries.getRecent(userId, days, limit);
      return reply.send({ notifications: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const { userId } = request.query;
      const result = await NotificationQueries.getStats(userId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { q, limit = 10 } = request.query;
      const result = await NotificationQueries.search(q, limit);
      return reply.send({ notifications: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (COMMANDS) ===
  async markAsRead(request, reply) {
    try {
      const { id } = request.params;
      const result = await NotificationCommands.markAsRead(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Notification not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async markAsUnread(request, reply) {
    try {
      const { id } = request.params;
      const result = await NotificationCommands.markAsUnread(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Notification not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async markAllAsRead(request, reply) {
    try {
      const { userId } = request.body;
      const result = await NotificationCommands.markAllAsRead(userId);
      return reply.send({
        success: true,
        count: result.count
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async deleteExpired(request, reply) {
    try {
      const result = await NotificationCommands.deleteExpired();
      return reply.send({
        success: true,
        count: result.count
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async deleteByUser(request, reply) {
    try {
      const { userId } = request.params;
      const result = await NotificationCommands.deleteByUser(userId);
      return reply.send({
        success: true,
        count: result.count
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === ENDPOINTS ESPECÍFICOS PARA ALERTAS DE ESTOQUE ===
  async getStockAlerts(request, reply) {
    try {
      const { userId, storeId, isRead, limit = 20 } = request.query;
      const result = await NotificationQueries.getStockAlerts({
        userId,
        storeId,
        isRead,
        limit
      });
      return reply.send({ notifications: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getUnreadStockAlerts(request, reply) {
    try {
      const { userId } = request.params;
      const { limit = 10 } = request.query;
      const result = await NotificationQueries.getUnreadStockAlerts(userId, limit);
      return reply.send({ notifications: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async markStockAlertsAsRead(request, reply) {
    try {
      const { userId, storeId } = request.body;
      const result = await NotificationCommands.markStockAlertsAsRead(userId, storeId);
      return reply.send({
        success: true,
        count: result.count
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/notification/notification.schema.ts
var notificationTypeEnum = ["INFO", "SUCCESS", "WARNING", "ERROR", "STOCK_ALERT", "MOVEMENT", "PERMISSION", "SYSTEM"];
var notificationPriorityEnum = ["LOW", "MEDIUM", "HIGH", "URGENT"];
var notificationResponseSchema = {
  type: "object",
  properties: {
    id: { type: "string" },
    userId: { type: "string" },
    title: { type: "string" },
    message: { type: "string" },
    type: { type: "string", enum: notificationTypeEnum },
    priority: { type: "string", enum: notificationPriorityEnum },
    isRead: { type: "boolean" },
    readAt: { type: ["string", "null"], format: "date-time" },
    data: { type: "object" },
    actionUrl: { type: ["string", "null"] },
    expiresAt: { type: ["string", "null"], format: "date-time" },
    createdAt: { type: "string", format: "date-time" },
    updatedAt: { type: "string", format: "date-time" },
    user: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: ["string", "null"] },
        email: { type: "string" }
      }
    }
  }
};
var createNotificationSchema = {
  body: {
    type: "object",
    required: ["userId", "title", "message"],
    properties: {
      userId: { type: "string" },
      title: { type: "string", minLength: 1, maxLength: 255 },
      message: { type: "string", minLength: 1, maxLength: 1e3 },
      type: { type: "string", enum: notificationTypeEnum, default: "INFO" },
      priority: { type: "string", enum: notificationPriorityEnum, default: "MEDIUM" },
      data: { type: "object" },
      actionUrl: { type: "string", format: "uri" },
      expiresAt: { type: "string", format: "date-time" }
    }
  },
  response: {
    201: notificationResponseSchema,
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var updateNotificationSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      title: { type: "string", minLength: 1, maxLength: 255 },
      message: { type: "string", minLength: 1, maxLength: 1e3 },
      type: { type: "string", enum: notificationTypeEnum },
      priority: { type: "string", enum: notificationPriorityEnum },
      data: { type: "object" },
      actionUrl: { type: "string", format: "uri" },
      expiresAt: { type: "string", format: "date-time" }
    }
  },
  response: {
    200: notificationResponseSchema,
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getNotificationSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: notificationResponseSchema,
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var listNotificationsSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      type: { type: "string", enum: notificationTypeEnum },
      priority: { type: "string", enum: notificationPriorityEnum },
      isRead: { type: "boolean" },
      userId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: notificationResponseSchema
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var deleteNotificationSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var markAsReadSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: notificationResponseSchema,
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var markAllAsReadSchema = {
  body: {
    type: "object",
    required: ["userId"],
    properties: {
      userId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        success: { type: "boolean" },
        count: { type: "number" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getByUserSchema = {
  params: {
    type: "object",
    required: ["userId"],
    properties: {
      userId: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      isRead: { type: "boolean" },
      type: { type: "string", enum: notificationTypeEnum }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: notificationResponseSchema
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getUnreadSchema = {
  params: {
    type: "object",
    required: ["userId"],
    properties: {
      userId: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        notifications: {
          type: "array",
          items: notificationResponseSchema
        }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getByTypeSchema = {
  params: {
    type: "object",
    required: ["type"],
    properties: {
      type: { type: "string", enum: notificationTypeEnum }
    }
  },
  querystring: {
    type: "object",
    properties: {
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        notifications: {
          type: "array",
          items: notificationResponseSchema
        }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getByPrioritySchema = {
  params: {
    type: "object",
    required: ["priority"],
    properties: {
      priority: { type: "string", enum: notificationPriorityEnum }
    }
  },
  querystring: {
    type: "object",
    properties: {
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        notifications: {
          type: "array",
          items: notificationResponseSchema
        }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getRecentSchema = {
  params: {
    type: "object",
    required: ["userId"],
    properties: {
      userId: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      days: { type: "number", minimum: 1, maximum: 365, default: 7 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 20 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        notifications: {
          type: "array",
          items: notificationResponseSchema
        }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getStatsSchema = {
  querystring: {
    type: "object",
    properties: {
      userId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        total: { type: "number" },
        unread: { type: "number" },
        read: { type: "number" },
        byType: { type: "object" },
        byPriority: { type: "object" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var searchSchema = {
  querystring: {
    type: "object",
    required: ["q"],
    properties: {
      q: { type: "string", minLength: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        notifications: {
          type: "array",
          items: notificationResponseSchema
        }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var NotificationSchemas = {
  create: createNotificationSchema,
  update: updateNotificationSchema,
  get: getNotificationSchema,
  delete: deleteNotificationSchema,
  list: listNotificationsSchema,
  markAsRead: markAsReadSchema,
  markAllAsRead: markAllAsReadSchema,
  getByUser: getByUserSchema,
  getUnread: getUnreadSchema,
  getByType: getByTypeSchema,
  getByPriority: getByPrioritySchema,
  getRecent: getRecentSchema,
  getStats: getStatsSchema,
  search: searchSchema
};

// src/features/notification/notification.routes.ts
init_auth_middleware();
async function NotificationRoutes(fastify2) {
  fastify2.post("/", {
    schema: NotificationSchemas.create,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.create
  });
  fastify2.get("/", {
    schema: NotificationSchemas.list,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.list
  });
  fastify2.get("/:id", {
    schema: NotificationSchemas.get,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.get
  });
  fastify2.put("/:id", {
    schema: NotificationSchemas.update,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.update
  });
  fastify2.delete("/:id", {
    schema: NotificationSchemas.delete,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.delete
  });
  fastify2.get("/user/:userId", {
    schema: NotificationSchemas.getByUser,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.getByUser
  });
  fastify2.get("/user/:userId/unread", {
    schema: NotificationSchemas.getUnread,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.getUnread
  });
  fastify2.get("/user/:userId/recent", {
    schema: NotificationSchemas.getRecent,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.getRecent
  });
  fastify2.get("/type/:type", {
    schema: NotificationSchemas.getByType,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.getByType
  });
  fastify2.get("/priority/:priority", {
    schema: NotificationSchemas.getByPriority,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.getByPriority
  });
  fastify2.get("/stats", {
    schema: NotificationSchemas.getStats,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.getStats
  });
  fastify2.get("/search", {
    schema: NotificationSchemas.search,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.search
  });
  fastify2.patch("/:id/read", {
    schema: NotificationSchemas.markAsRead,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.markAsRead
  });
  fastify2.patch("/:id/unread", {
    schema: NotificationSchemas.markAsRead,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.markAsUnread
  });
  fastify2.patch("/mark-all-read", {
    schema: NotificationSchemas.markAllAsRead,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.markAllAsRead
  });
  fastify2.delete("/expired", {
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.deleteExpired
  });
  fastify2.delete("/user/:userId", {
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.deleteByUser
  });
  fastify2.get("/stock-alerts", {
    schema: {
      querystring: {
        type: "object",
        properties: {
          userId: { type: "string" },
          storeId: { type: "string" },
          isRead: { type: "boolean" },
          limit: { type: "number", minimum: 1, maximum: 100 }
        }
      }
    },
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.getStockAlerts
  });
  fastify2.get("/user/:userId/stock-alerts/unread", {
    schema: {
      params: {
        type: "object",
        required: ["userId"],
        properties: {
          userId: { type: "string" }
        }
      },
      querystring: {
        type: "object",
        properties: {
          limit: { type: "number", minimum: 1, maximum: 100 }
        }
      }
    },
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.getUnreadStockAlerts
  });
  fastify2.patch("/stock-alerts/mark-read", {
    schema: {
      body: {
        type: "object",
        required: ["userId"],
        properties: {
          userId: { type: "string" },
          storeId: { type: "string" }
        }
      }
    },
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: NotificationController.markStockAlertsAsRead
  });
}

// src/features/chat/queries/chat.query.ts
init_prisma();
var ChatToolbox = class {
  constructor(prisma2) {
    this.prisma = prisma2;
  }
  // === SERVIÇOS DE PRODUTOS ===
  async getProducts(params) {
    return await ProductQueries.list(params);
  }
  async getProductById(id, storeId) {
    if (!storeId) {
      throw new Error("Store ID is required for product queries");
    }
    return await ProductQueries.getById(id, storeId);
  }
  async searchProducts(term, params = {}) {
    return await ProductQueries.search(term, params);
  }
  async getActiveProducts(storeId) {
    if (!storeId) {
      throw new Error("Store ID is required for product queries");
    }
    return await ProductQueries.getActive(storeId);
  }
  async getProductStats(storeId) {
    if (!storeId) {
      throw new Error("Store ID is required for product queries");
    }
    return await ProductQueries.getStats(storeId);
  }
  async getLowStockProducts(storeId) {
    return await ProductQueries.getLowStockProducts(storeId);
  }
  // === SERVIÇOS DE LOJAS ===
  async getStores(params) {
    return await StoreQueries.list(params);
  }
  async getStoreById(id) {
    return await StoreQueries.getById(id);
  }
  async searchStores(term, limit = 10) {
    return await StoreQueries.search(term, limit);
  }
  async getActiveStores() {
    return await StoreQueries.getActive();
  }
  async getStoreStats() {
    return await StoreQueries.getStats();
  }
  // === SERVIÇOS DE CATEGORIAS ===
  async getCategories(params) {
    return await CategoryQueries.list(params);
  }
  async getCategoryById(id) {
    return await CategoryQueries.getById(id);
  }
  async searchCategories(term, limit = 10, storeId) {
    if (!storeId) {
      throw new Error("Store ID is required for category queries");
    }
    return await CategoryQueries.search(term, storeId, limit);
  }
  async getActiveCategories(storeId) {
    if (!storeId) {
      throw new Error("Store ID is required for category queries");
    }
    return await CategoryQueries.getActive(storeId);
  }
  async getCategoryStats(storeId) {
    if (!storeId) {
      throw new Error("Store ID is required for category queries");
    }
    return await CategoryQueries.getStats(storeId);
  }
  async getCategoryHierarchy(storeId) {
    if (!storeId) {
      throw new Error("Store ID is required for category queries");
    }
    return await CategoryQueries.getHierarchy(storeId);
  }
  // === SERVIÇOS DE FORNECEDORES ===
  async getSuppliers(params) {
    return await SupplierQueries.list(params);
  }
  async getSupplierById(id) {
    return await SupplierQueries.getById(id);
  }
  async searchSuppliers(term, limit = 10) {
    return await SupplierQueries.search(term, limit);
  }
  async getActiveSuppliers() {
    return await SupplierQueries.getActive();
  }
  async getSupplierStats() {
    return await SupplierQueries.getStats();
  }
  // === SERVIÇOS DE MOVIMENTAÇÕES ===
  async getMovements(params) {
    return await MovementQueries.list(params);
  }
  async getMovementById(id) {
    return await MovementQueries.getById(id);
  }
  async getMovementStats() {
    return await MovementQueries.getStats();
  }
  async getRecentMovements(limit = 10) {
    return;
  }
  // === SERVIÇOS DE RELATÓRIOS ===
  async getReports(params) {
    return;
  }
  async getReportById(id) {
    return;
  }
  async getReportStats() {
    return;
  }
  // === MÉTODO PARA EXECUTAR COMANDOS DINÂMICOS ===
  async executeCommand(command, params = {}) {
    const [service, method] = command.split(".");
    switch (service) {
      case "products":
        return await this.executeProductCommand(method, params);
      case "stores":
        return await this.executeStoreCommand(method, params);
      case "categories":
        return await this.executeCategoryCommand(method, params);
      case "suppliers":
        return await this.executeSupplierCommand(method, params);
      case "movements":
        return await this.executeMovementCommand(method, params);
      case "reports":
        return await this.executeReportCommand(method, params);
      default:
        throw new Error(`Unknown service: ${service}`);
    }
  }
  async executeProductCommand(method, params) {
    switch (method) {
      case "list":
        return await this.getProducts(params);
      case "getById":
        return await this.getProductById(params.id, params.storeId);
      case "search":
        return await this.searchProducts(params.term, params.limit);
      case "getActive":
        return await this.getActiveProducts();
      case "getStats":
        return await this.getProductStats();
      case "getLowStock":
        return await this.getLowStockProducts(params.storeId);
      default:
        throw new Error(`Unknown product method: ${method}`);
    }
  }
  async executeStoreCommand(method, params) {
    switch (method) {
      case "list":
        return await this.getStores(params);
      case "getById":
        return await this.getStoreById(params.id);
      case "search":
        return await this.searchStores(params.term, params.limit);
      case "getActive":
        return await this.getActiveStores();
      case "getStats":
        return await this.getStoreStats();
      default:
        throw new Error(`Unknown store method: ${method}`);
    }
  }
  async executeCategoryCommand(method, params) {
    switch (method) {
      case "list":
        return await this.getCategories(params);
      case "getById":
        return await this.getCategoryById(params.id);
      case "search":
        return await this.searchCategories(params.term, params.limit);
      case "getActive":
        return await this.getActiveCategories();
      case "getStats":
        return await this.getCategoryStats();
      case "getHierarchy":
        return await this.getCategoryHierarchy();
      default:
        throw new Error(`Unknown category method: ${method}`);
    }
  }
  async executeSupplierCommand(method, params) {
    switch (method) {
      case "list":
        return await this.getSuppliers(params);
      case "getById":
        return await this.getSupplierById(params.id);
      case "search":
        return await this.searchSuppliers(params.term, params.limit);
      case "getActive":
        return await this.getActiveSuppliers();
      case "getStats":
        return await this.getSupplierStats();
      default:
        throw new Error(`Unknown supplier method: ${method}`);
    }
  }
  async executeMovementCommand(method, params) {
    switch (method) {
      case "list":
        return await this.getMovements(params);
      case "getById":
        return await this.getMovementById(params.id);
      case "getStats":
        return await this.getMovementStats();
      case "getRecent":
        return await this.getRecentMovements(params.limit);
      default:
        throw new Error(`Unknown movement method: ${method}`);
    }
  }
  async executeReportCommand(method, params) {
    switch (method) {
      case "list":
        return await this.getReports(params);
      case "getById":
        return await this.getReportById(params.id);
      case "getStats":
        return await this.getReportStats();
      default:
        throw new Error(`Unknown report method: ${method}`);
    }
  }
};
var ChatQueries = {
  async getById(id) {
    const chatMessage = await db.chatMessage.findUnique({
      where: { id },
      include: {
        session: {
          select: {
            id: true,
            userId: true,
            storeId: true,
            title: true
          }
        }
      }
    });
    if (!chatMessage) {
      throw new Error("Chat message not found");
    }
    return chatMessage;
  },
  async list(params) {
    const { page = 1, limit = 10, sessionId, userId, storeId } = params;
    const skip = (page - 1) * Number(limit);
    const takeLimit = Number(limit);
    const where = {};
    if (sessionId) {
      where.sessionId = sessionId;
    }
    if (userId) {
      where.session = {
        userId
      };
    }
    if (storeId) {
      where.session = {
        ...where.session,
        storeId
      };
    }
    const [items, total] = await Promise.all([
      db.chatMessage.findMany({
        where,
        skip,
        take: takeLimit,
        orderBy: { createdAt: "desc" },
        include: {
          session: {
            select: {
              id: true,
              userId: true,
              storeId: true,
              title: true
            }
          }
        }
      }),
      db.chatMessage.count({ where })
    ]);
    const formattedItems = items.map((item) => ({
      id: item.id,
      interaction: {
        user: {
          message: item.content,
          timestamp: item.createdAt
        },
        ai: {
          response: item.content,
          timestamp: item.createdAt
        }
      },
      context: item.context,
      options: item.options,
      createdAt: item.createdAt,
      updatedAt: item.updatedAt,
      session: item.session
    }));
    return {
      items: formattedItems,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  // === FORMATO TRADICIONAL (compatibilidade) ===
  async listTraditional(params) {
    const { page = 1, limit = 10, sessionId, userId, storeId } = params;
    const skip = (page - 1) * Number(limit);
    const takeLimit = Number(limit);
    const where = {};
    if (sessionId) {
      where.sessionId = sessionId;
    }
    if (userId) {
      where.session = {
        userId
      };
    }
    if (storeId) {
      where.session = {
        ...where.session,
        storeId
      };
    }
    const [items, total] = await Promise.all([
      db.chatMessage.findMany({
        where,
        skip,
        take: takeLimit,
        orderBy: { createdAt: "desc" },
        include: {
          session: {
            select: {
              id: true,
              userId: true,
              storeId: true,
              title: true
            }
          }
        }
      }),
      db.chatMessage.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getSessionById(sessionId, params) {
    const { page = 1, limit = 20 } = params || {};
    const skip = (page - 1) * Number(limit);
    const takeLimit = Number(limit);
    const session = await db.chatSession.findUnique({
      where: { id: sessionId },
      include: {
        messages: {
          select: {
            id: true,
            content: true,
            isFromUser: true,
            createdAt: true,
            updatedAt: true
          },
          orderBy: { createdAt: "asc" },
          skip,
          take: takeLimit
        }
      }
    });
    if (!session) {
      throw new Error("Chat session not found");
    }
    const totalMessages = await db.chatMessage.count({
      where: { sessionId }
    });
    const formattedMessages = [];
    session.messages.forEach((message) => {
      formattedMessages.push({
        id: `${message.id}_user`,
        content: message.content,
        isUser: true,
        createdAt: message.createdAt,
        updatedAt: message.updatedAt
      });
      formattedMessages.push({
        id: `${message.id}_ai`,
        content: message.content,
        isUser: false,
        createdAt: message.createdAt,
        updatedAt: message.updatedAt
      });
    });
    return {
      id: session.id,
      userId: session.userId,
      storeId: session.storeId,
      title: session.title,
      createdAt: session.createdAt,
      updatedAt: session.updatedAt,
      messages: formattedMessages,
      pagination: {
        page,
        limit,
        total: totalMessages,
        totalPages: Math.ceil(totalMessages / limit)
      }
    };
  },
  async getSessions(params) {
    const { page = 1, limit = 10, userId, storeId } = params;
    const skip = (page - 1) * Number(limit);
    const takeLimit = Number(limit);
    const where = {};
    if (userId) {
      where.userId = userId;
    }
    if (storeId) {
      where.storeId = storeId;
    }
    const [items, total] = await Promise.all([
      db.chatSession.findMany({
        where,
        skip,
        take: takeLimit,
        orderBy: { updatedAt: "desc" },
        include: {
          _count: {
            select: {
              messages: true
            }
          }
        }
      }),
      db.chatSession.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getToolbox() {
    return {
      availableServices: {
        products: {
          description: "Servi\xE7os para gerenciar produtos, estoque e categorias",
          methods: [
            "products.list - Listar produtos com filtros",
            "products.getById - Buscar produto por ID",
            "products.search - Buscar produtos por termo",
            "products.getActive - Listar produtos ativos",
            "products.getStats - Estat\xEDsticas de produtos",
            "products.getLowStock - Produtos com estoque baixo"
          ]
        },
        stores: {
          description: "Servi\xE7os para gerenciar lojas e usu\xE1rios",
          methods: [
            "stores.list - Listar lojas com filtros",
            "stores.getById - Buscar loja por ID",
            "stores.search - Buscar lojas por termo",
            "stores.getActive - Listar lojas ativas",
            "stores.getStats - Estat\xEDsticas de lojas"
          ]
        },
        categories: {
          description: "Servi\xE7os para gerenciar categorias de produtos",
          methods: [
            "categories.list - Listar categorias com filtros",
            "categories.getById - Buscar categoria por ID",
            "categories.search - Buscar categorias por termo",
            "categories.getActive - Listar categorias ativas",
            "categories.getStats - Estat\xEDsticas de categorias",
            "categories.getHierarchy - Hierarquia de categorias"
          ]
        },
        suppliers: {
          description: "Servi\xE7os para gerenciar fornecedores",
          methods: [
            "suppliers.list - Listar fornecedores com filtros",
            "suppliers.getById - Buscar fornecedor por ID",
            "suppliers.search - Buscar fornecedores por termo",
            "suppliers.getActive - Listar fornecedores ativos",
            "suppliers.getStats - Estat\xEDsticas de fornecedores"
          ]
        },
        movements: {
          description: "Servi\xE7os para gerenciar movimenta\xE7\xF5es de estoque",
          methods: [
            "movements.list - Listar movimenta\xE7\xF5es com filtros",
            "movements.getById - Buscar movimenta\xE7\xE3o por ID",
            "movements.getStats - Estat\xEDsticas de movimenta\xE7\xF5es",
            "movements.getRecent - Movimenta\xE7\xF5es recentes"
          ]
        },
        reports: {
          description: "Servi\xE7os para gerenciar relat\xF3rios",
          methods: [
            "reports.list - Listar relat\xF3rios com filtros",
            "reports.getById - Buscar relat\xF3rio por ID",
            "reports.getStats - Estat\xEDsticas de relat\xF3rios"
          ]
        }
      }
    };
  },
  async getAnalytics(params) {
    const { startDate, endDate, userId, storeId } = params;
    const where = {};
    if (userId) {
      where.session = {
        userId
      };
    }
    if (storeId) {
      where.session = {
        ...where.session,
        storeId
      };
    }
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) {
        where.createdAt.gte = new Date(startDate);
      }
      if (endDate) {
        where.createdAt.lte = new Date(endDate);
      }
    }
    const [totalMessages, totalSessions, messagesByDay] = await Promise.all([
      db.chatMessage.count({ where }),
      db.chatSession.count({
        where: userId ? { userId } : storeId ? { storeId } : {}
      }),
      db.chatMessage.groupBy({
        by: ["createdAt"],
        where,
        _count: { id: true },
        orderBy: { createdAt: "desc" },
        take: 30
      })
    ]);
    const averageMessagesPerSession = totalSessions > 0 ? totalMessages / totalSessions : 0;
    return {
      totalMessages,
      totalSessions,
      averageMessagesPerSession: Math.round(averageMessagesPerSession * 100) / 100,
      mostUsedServices: [],
      // Implementar análise de serviços mais usados
      messagesByDay: messagesByDay.map((item) => ({
        date: item.createdAt.toISOString().split("T")[0],
        count: item._count.id
      }))
    };
  },
  async search(term, limit = 10) {
    const messages = await db.chatMessage.findMany({
      where: {
        OR: [
          { content: { contains: term, mode: "insensitive" } }
        ]
      },
      take: Number(limit),
      orderBy: { createdAt: "desc" },
      include: {
        session: {
          select: {
            id: true,
            userId: true,
            storeId: true,
            title: true
          }
        }
      }
    });
    return messages;
  }
};

// src/features/chat/commands/chat.commands.ts
init_prisma();
var ChatCommands = {
  // === CRIAÇÃO DE SESSÃO ===
  async createSession(data) {
    const session = await db.chatSession.create({
      data: {
        userId: data.userId,
        storeId: data.storeId,
        title: data.title || "\u{1F4AC} Nova conversa"
      }
    });
    return session;
  },
  // === CRIAÇÃO DE MENSAGEM ===
  async createMessage(data) {
    const chatMessage = await db.chatMessage.create({
      data: {
        content: data.content,
        isFromUser: data.isFromUser,
        sessionId: data.sessionId,
        context: data.context || {},
        options: data.options || {}
      },
      include: {
        session: {
          select: {
            id: true,
            userId: true,
            storeId: true,
            title: true
          }
        }
      }
    });
    return chatMessage;
  },
  // === PROCESSAMENTO COMPLETO DE MENSAGEM ===
  async processMessage(data) {
    let sessionId = data.context?.sessionId;
    if (!sessionId) {
      const session = await ChatCommands.createSession({
        userId: data.context?.userId || "anonymous",
        storeId: data.context?.storeId,
        title: data.message.substring(0, 50) + (data.message.length > 50 ? "..." : "")
      });
      sessionId = session.id;
    }
    const toolbox = new ChatToolbox(db);
    let systemData = "";
    const message = data.message.toLowerCase();
    if (message.includes("produto") || message.includes("estoque") || message.includes("invent\xE1rio")) {
      try {
        const products = await toolbox.executeCommand("products.list", {
          limit: 10,
          ...data.context?.storeId && { storeId: data.context.storeId }
        });
        systemData += `
DADOS DE PRODUTOS DISPON\xCDVEIS:
${JSON.stringify(products, null, 2)}
`;
      } catch (error) {
        systemData += `
Erro ao buscar produtos: ${error.message}
`;
      }
    }
    if (message.includes("categoria") || message.includes("categorias")) {
      try {
        const categories = await toolbox.executeCommand("categories.list", { limit: 10 });
        systemData += `
DADOS DE CATEGORIAS DISPON\xCDVEIS:
${JSON.stringify(categories, null, 2)}
`;
      } catch (error) {
        systemData += `
Erro ao buscar categorias: ${error.message}
`;
      }
    }
    if (message.includes("loja") || message.includes("lojas") || message.includes("store")) {
      try {
        const stores = await toolbox.executeCommand("stores.list", { limit: 10 });
        systemData += `
DADOS DE LOJAS DISPON\xCDVEIS:
${JSON.stringify(stores, null, 2)}
`;
      } catch (error) {
        systemData += `
Erro ao buscar lojas: ${error.message}
`;
      }
    }
    if (message.includes("fornecedor") || message.includes("fornecedores") || message.includes("supplier")) {
      try {
        const suppliers = await toolbox.executeCommand("suppliers.list", { limit: 10 });
        systemData += `
DADOS DE FORNECEDORES DISPON\xCDVEIS:
${JSON.stringify(suppliers, null, 2)}
`;
      } catch (error) {
        systemData += `
Erro ao buscar fornecedores: ${error.message}
`;
      }
    }
    if (message.includes("movimenta\xE7\xE3o") || message.includes("movimenta\xE7\xF5es") || message.includes("movimento")) {
      try {
        const movements = await toolbox.executeCommand("movements.list", { limit: 10 });
        systemData += `
DADOS DE MOVIMENTA\xC7\xD5ES DISPON\xCDVEIS:
${JSON.stringify(movements, null, 2)}
`;
      } catch (error) {
        systemData += `
Erro ao buscar movimenta\xE7\xF5es: ${error.message}
`;
      }
    }
    const toolboxInfo = await ChatQueries.getToolbox();
    const systemPrompt = `
Voc\xEA \xE9 um assistente inteligente para um sistema de gest\xE3o de estoque. 
Voc\xEA tem acesso aos seguintes servi\xE7os atrav\xE9s da toolbox:

${JSON.stringify(toolboxInfo, null, 2)}

${systemData}

Para acessar os servi\xE7os, use comandos no formato: service.method
Exemplo: products.list, stores.getById, categories.search

Responda de forma \xFAtil e precisa, sempre em portugu\xEAs.
Use os dados fornecidos acima para responder \xE0s perguntas do usu\xE1rio de forma espec\xEDfica e precisa.

Mensagem do usu\xE1rio: ${data.message}
`;
    let response;
    if (data.options) {
      const llmResponse = await LLMService.executeWithOptions(systemPrompt, data.options);
      response = typeof llmResponse === "string" ? llmResponse : String(llmResponse);
    } else {
      const llmResponse = await LLMService.executePrompt(systemPrompt);
      response = typeof llmResponse === "string" ? llmResponse : String(llmResponse);
    }
    const chatMessage = await ChatCommands.createMessage({
      content: data.message,
      isFromUser: true,
      sessionId,
      context: data.context || {},
      options: data.options || {}
    });
    await ChatCommands.updateSessionTimestamp(sessionId);
    await ChatCommands.updateSessionTitleIntelligent(sessionId);
    return chatMessage;
  },
  // === GERAR TÍTULO INTELIGENTE ===
  async generateSmartTitle(messages) {
    if (messages.length === 0) return "Nova conversa";
    const recentMessages = messages.slice(-3);
    const allText = recentMessages.map((m) => `${m.message} ${m.response}`).join(" ").toLowerCase();
    if (allText.includes("produto") || allText.includes("estoque") || allText.includes("invent\xE1rio")) {
      if (allText.includes("baixo") || allText.includes("cr\xEDtico")) {
        return "\u{1F4E6} An\xE1lise de Estoque Cr\xEDtico";
      }
      if (allText.includes("relat\xF3rio") || allText.includes("relatorio")) {
        return "\u{1F4CA} Relat\xF3rio de Produtos";
      }
      if (allText.includes("categoria") || allText.includes("categorias")) {
        return "\u{1F4C2} Produtos por Categoria";
      }
      return "\u{1F4E6} Consulta de Produtos";
    }
    if (allText.includes("categoria") || allText.includes("categorias")) {
      if (allText.includes("hierarquia") || allText.includes("estrutura")) {
        return "\u{1F333} Hierarquia de Categorias";
      }
      if (allText.includes("criar") || allText.includes("nova")) {
        return "\u2795 Gest\xE3o de Categorias";
      }
      return "\u{1F4C2} Consulta de Categorias";
    }
    if (allText.includes("loja") || allText.includes("lojas") || allText.includes("store")) {
      if (allText.includes("relat\xF3rio") || allText.includes("relatorio")) {
        return "\u{1F3EA} Relat\xF3rio de Lojas";
      }
      return "\u{1F3EA} Consulta de Lojas";
    }
    if (allText.includes("fornecedor") || allText.includes("fornecedores") || allText.includes("supplier")) {
      if (allText.includes("relat\xF3rio") || allText.includes("relatorio")) {
        return "\u{1F69A} Relat\xF3rio de Fornecedores";
      }
      return "\u{1F69A} Consulta de Fornecedores";
    }
    if (allText.includes("movimenta\xE7\xE3o") || allText.includes("movimenta\xE7\xF5es") || allText.includes("movimento")) {
      if (allText.includes("entrada") || allText.includes("sa\xEDda")) {
        return "\u{1F4C8} Movimenta\xE7\xF5es de Estoque";
      }
      return "\u{1F4C8} Consulta de Movimenta\xE7\xF5es";
    }
    if (allText.includes("relat\xF3rio") || allText.includes("relatorio") || allText.includes("relat\xF3rios")) {
      return "\u{1F4CA} Gera\xE7\xE3o de Relat\xF3rios";
    }
    if (allText.includes("usu\xE1rio") || allText.includes("usuarios") || allText.includes("user")) {
      return "\u{1F465} Gest\xE3o de Usu\xE1rios";
    }
    if (allText.includes("configura\xE7\xE3o") || allText.includes("configuracao") || allText.includes("config")) {
      return "\u2699\uFE0F Configura\xE7\xF5es do Sistema";
    }
    if (allText.includes("ajuda") || allText.includes("help") || allText.includes("como")) {
      return "\u2753 Suporte e Ajuda";
    }
    const firstMessage = messages[0]?.message || "";
    if (firstMessage.length > 0) {
      const truncated = firstMessage.substring(0, 30);
      return truncated.length < firstMessage.length ? `${truncated}...` : truncated;
    }
    return "\u{1F4AC} Conversa Geral";
  },
  // === ATUALIZAR TIMESTAMP DA SESSÃO ===
  async updateSessionTimestamp(sessionId) {
    await db.chatSession.update({
      where: { id: sessionId },
      data: { updatedAt: /* @__PURE__ */ new Date() }
    });
  },
  // === ATUALIZAR TÍTULO DA SESSÃO ===
  async updateSessionTitle(sessionId, title) {
    const session = await db.chatSession.update({
      where: { id: sessionId },
      data: { title }
    });
    return session;
  },
  // === ATUALIZAR TÍTULO INTELIGENTE ===
  async updateSessionTitleIntelligent(sessionId) {
    const messages = await db.chatMessage.findMany({
      where: { sessionId },
      select: { content: true, isFromUser: true },
      orderBy: { createdAt: "asc" }
    });
    const smartTitle = await ChatCommands.generateSmartTitle(messages);
    await db.chatSession.update({
      where: { id: sessionId },
      data: { title: smartTitle }
    });
    return smartTitle;
  },
  // === EXECUÇÃO DE COMANDO DA TOOLBOX ===
  async executeToolboxCommand(command, params = {}) {
    const toolbox = new ChatToolbox(db);
    return await toolbox.executeCommand(command, params);
  },
  // === EXECUÇÃO DE COMANDO COM CONTEXTO ===
  async executeCommandWithContext(data) {
    const toolbox = new ChatToolbox(db);
    const enrichedParams = {
      ...data.params,
      ...data.context?.storeId && { storeId: data.context.storeId },
      ...data.context?.userId && { userId: data.context.userId }
    };
    return await toolbox.executeCommand(data.command, enrichedParams);
  },
  // === DELETAR SESSÃO ===
  async deleteSession(sessionId) {
    const session = await db.chatSession.findUnique({
      where: { id: sessionId }
    });
    if (!session) {
      throw new Error("Chat session not found");
    }
    await db.chatMessage.deleteMany({
      where: { sessionId }
    });
    await db.chatSession.delete({
      where: { id: sessionId }
    });
    return { success: true };
  },
  // === DELETAR MENSAGEM ===
  async deleteMessage(messageId) {
    const message = await db.chatMessage.findUnique({
      where: { id: messageId }
    });
    if (!message) {
      throw new Error("Chat message not found");
    }
    await db.chatMessage.delete({
      where: { id: messageId }
    });
    return { success: true };
  },
  // === LIMPEZA DE SESSÕES ANTIGAS ===
  async cleanupOldSessions(daysOld = 30) {
    const cutoffDate = /* @__PURE__ */ new Date();
    cutoffDate.setDate(cutoffDate.getDate() - daysOld);
    const deletedSessions = await db.chatSession.deleteMany({
      where: {
        updatedAt: {
          lt: cutoffDate
        }
      }
    });
    return {
      deletedSessions: deletedSessions.count,
      cutoffDate
    };
  },
  // === LIMPEZA DE MENSAGENS ANTIGAS ===
  async cleanupOldMessages(daysOld = 30) {
    const cutoffDate = /* @__PURE__ */ new Date();
    cutoffDate.setDate(cutoffDate.getDate() - daysOld);
    const deletedMessages = await db.chatMessage.deleteMany({
      where: {
        createdAt: {
          lt: cutoffDate
        }
      }
    });
    return {
      deletedMessages: deletedMessages.count,
      cutoffDate
    };
  },
  // === BATCH OPERATIONS ===
  async createMultipleMessages(messages) {
    const createdMessages = await db.chatMessage.createMany({
      data: messages.map((msg) => ({
        content: msg.content,
        isFromUser: msg.isFromUser,
        sessionId: msg.sessionId,
        context: msg.context || {},
        options: msg.options || {}
      }))
    });
    return createdMessages;
  },
  // === MIGRAÇÃO DE DADOS ===
  async migrateSessionData(oldSessionId, newSessionId) {
    const updatedMessages = await db.chatMessage.updateMany({
      where: { sessionId: oldSessionId },
      data: { sessionId: newSessionId }
    });
    const oldSession = await db.chatSession.findUnique({
      where: { id: oldSessionId },
      include: { messages: true }
    });
    if (oldSession && oldSession.messages.length === 0) {
      await db.chatSession.delete({
        where: { id: oldSessionId }
      });
    }
    return {
      migratedMessages: updatedMessages.count,
      oldSessionDeleted: oldSession?.messages.length === 0
    };
  }
};

// src/features/chat/chat.controller.ts
var ChatController = {
  // === ENVIO DE MENSAGENS ===
  async sendMessage(request, reply) {
    try {
      const { message, context, options } = request.body;
      const enrichedContext = {
        ...context,
        userId: request.user?.id || context?.userId,
        storeId: request.store?.id || context?.storeId
      };
      const result = await ChatCommands.processMessage({
        message,
        context: enrichedContext,
        options
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("LLM")) {
        return reply.status(503).send({
          error: "Servi\xE7o de IA temporariamente indispon\xEDvel"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === HISTÓRICO DE CHAT ===
  async getHistory(request, reply) {
    try {
      const { page = 1, limit = 10, sessionId } = request.query;
      const enrichedParams = {
        page,
        limit,
        sessionId,
        userId: request.user?.id,
        storeId: request.store?.id
      };
      const result = await ChatQueries.list(enrichedParams);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === MENSAGENS DE UMA SESSÃO ESPECÍFICA ===
  async getSessionMessages(request, reply) {
    try {
      const { sessionId } = request.params;
      const { page = 1, limit = 20 } = request.query;
      const result = await ChatQueries.getSessionById(sessionId, { page, limit });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Chat session not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === ENVIAR MENSAGEM PARA SESSÃO ESPECÍFICA ===
  async sendMessageToSession(request, reply) {
    try {
      const { sessionId } = request.params;
      const { message, options } = request.body;
      const enrichedContext = {
        sessionId,
        userId: request.user?.id,
        storeId: request.store?.id
      };
      const result = await ChatCommands.processMessage({
        message,
        context: enrichedContext,
        options
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("LLM")) {
        return reply.status(503).send({
          error: "Servi\xE7o de IA temporariamente indispon\xEDvel"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === HISTÓRICO TRADICIONAL (compatibilidade) ===
  async getHistoryTraditional(request, reply) {
    try {
      const { page = 1, limit = 10, sessionId } = request.query;
      const enrichedParams = {
        page,
        limit,
        sessionId,
        userId: request.user?.id,
        storeId: request.store?.id
      };
      const result = await ChatQueries.listTraditional(enrichedParams);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === SESSÃO DE CHAT ===
  async getSession(request, reply) {
    try {
      const { sessionId } = request.params;
      const result = await ChatQueries.getSessionById(sessionId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Chat session not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async deleteSession(request, reply) {
    try {
      const { sessionId } = request.params;
      await ChatCommands.deleteSession(sessionId);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Chat session not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === TOOLBOX ===
  async getToolbox(request, reply) {
    try {
      const result = await ChatQueries.getToolbox();
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === EXECUÇÃO DE COMANDOS DA TOOLBOX ===
  async executeCommand(request, reply) {
    try {
      const { command, params = {} } = request.body;
      const result = await ChatCommands.executeToolboxCommand(command, params);
      return reply.send({
        command,
        params,
        result
      });
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("Unknown service") || error.message.includes("Unknown")) {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === ANÁLISE E ESTATÍSTICAS ===
  async getAnalytics(request, reply) {
    try {
      const { startDate, endDate, userId, storeId } = request.query;
      const result = await ChatQueries.getAnalytics({
        startDate,
        endDate,
        userId,
        storeId
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === BUSCA ===
  async search(request, reply) {
    try {
      const { q, limit = 10 } = request.query;
      const result = await ChatQueries.search(q, limit);
      return reply.send({ messages: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === SESSÕES ===
  async getSessions(request, reply) {
    try {
      const { page = 1, limit = 10 } = request.query;
      const enrichedParams = {
        page,
        limit,
        userId: request.user?.id,
        storeId: request.store?.id
      };
      const result = await ChatQueries.getSessions(enrichedParams);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === MENSAGEM ESPECÍFICA ===
  async getMessage(request, reply) {
    try {
      const { id } = request.params;
      const result = await ChatQueries.getById(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Chat message not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === OPERAÇÕES ADICIONAIS DE SESSÃO ===
  async updateSessionTitle(request, reply) {
    try {
      const { sessionId } = request.params;
      const { title } = request.body;
      const result = await ChatCommands.updateSessionTitle(sessionId, title);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Chat session not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === ATUALIZAR TÍTULO INTELIGENTE ===
  async updateSessionTitleIntelligent(request, reply) {
    try {
      const { sessionId } = request.params;
      const result = await ChatCommands.updateSessionTitleIntelligent(sessionId);
      return reply.send({
        sessionId,
        title: result,
        message: "T\xEDtulo atualizado com sucesso"
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Chat session not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === OPERAÇÕES DE LIMPEZA ===
  async cleanupOldSessions(request, reply) {
    try {
      const { daysOld = 30 } = request.query;
      const result = await ChatCommands.cleanupOldSessions(daysOld);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async cleanupOldMessages(request, reply) {
    try {
      const { daysOld = 30 } = request.query;
      const result = await ChatCommands.cleanupOldMessages(daysOld);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/chat/chat.schema.ts
var sendMessageSchema = {
  body: {
    type: "object",
    required: ["message"],
    properties: {
      message: {
        type: "string",
        minLength: 1,
        maxLength: 2e3,
        description: "Mensagem do usu\xE1rio para o chat"
      },
      context: {
        type: "object",
        properties: {
          storeId: { type: "string" },
          userId: { type: "string" },
          sessionId: { type: "string" }
        },
        additionalProperties: true
      },
      options: {
        type: "object",
        properties: {
          temperature: {
            type: "number",
            minimum: 0,
            maximum: 2,
            default: 0.2
          },
          numPredict: {
            type: "number",
            minimum: 1,
            maximum: 4e3,
            default: 1e3
          },
          repeatPenalty: {
            type: "number",
            minimum: 0.1,
            maximum: 2,
            default: 1.1
          }
        }
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        message: { type: "string" },
        response: { type: "string" },
        context: {
          type: "object",
          properties: {
            storeId: { type: "string", nullable: true },
            userId: { type: "string", nullable: true },
            sessionId: { type: "string", nullable: true }
          }
        },
        options: {
          type: "object",
          properties: {
            temperature: { type: "number" },
            numPredict: { type: "number" },
            repeatPenalty: { type: "number" }
          }
        },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var getChatHistorySchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      sessionId: { type: "string" },
      userId: { type: "string" },
      storeId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              message: { type: "string" },
              response: { type: "string" },
              context: {
                type: "object",
                properties: {
                  storeId: { type: "string", nullable: true },
                  userId: { type: "string", nullable: true },
                  sessionId: { type: "string", nullable: true }
                }
              },
              options: {
                type: "object",
                properties: {
                  temperature: { type: "number" },
                  numPredict: { type: "number" },
                  repeatPenalty: { type: "number" }
                }
              },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getChatSessionSchema = {
  params: {
    type: "object",
    required: ["sessionId"],
    properties: {
      sessionId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        storeId: { type: "string", nullable: true },
        title: { type: "string", nullable: true },
        messages: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              message: { type: "string" },
              response: { type: "string" },
              context: {
                type: "object",
                properties: {
                  storeId: { type: "string", nullable: true },
                  userId: { type: "string", nullable: true },
                  sessionId: { type: "string", nullable: true }
                }
              },
              options: {
                type: "object",
                properties: {
                  temperature: { type: "number" },
                  numPredict: { type: "number" },
                  repeatPenalty: { type: "number" }
                }
              },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" }
            }
          }
        },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var deleteChatSessionSchema = {
  params: {
    type: "object",
    required: ["sessionId"],
    properties: {
      sessionId: { type: "string" }
    }
  },
  response: {
    204: { type: "null" }
  }
};
var getToolboxSchema = {
  response: {
    200: {
      type: "object",
      properties: {
        availableServices: {
          type: "object",
          properties: {
            products: {
              type: "object",
              properties: {
                description: { type: "string" },
                methods: {
                  type: "array",
                  items: { type: "string" }
                }
              }
            },
            stores: {
              type: "object",
              properties: {
                description: { type: "string" },
                methods: {
                  type: "array",
                  items: { type: "string" }
                }
              }
            },
            categories: {
              type: "object",
              properties: {
                description: { type: "string" },
                methods: {
                  type: "array",
                  items: { type: "string" }
                }
              }
            },
            suppliers: {
              type: "object",
              properties: {
                description: { type: "string" },
                methods: {
                  type: "array",
                  items: { type: "string" }
                }
              }
            },
            movements: {
              type: "object",
              properties: {
                description: { type: "string" },
                methods: {
                  type: "array",
                  items: { type: "string" }
                }
              }
            },
            reports: {
              type: "object",
              properties: {
                description: { type: "string" },
                methods: {
                  type: "array",
                  items: { type: "string" }
                }
              }
            }
          }
        }
      }
    }
  }
};
var getAnalyticsSchema = {
  querystring: {
    type: "object",
    properties: {
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" },
      userId: { type: "string" },
      storeId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        totalMessages: { type: "number" },
        totalSessions: { type: "number" },
        averageMessagesPerSession: { type: "number" },
        mostUsedServices: {
          type: "array",
          items: {
            type: "object",
            properties: {
              service: { type: "string" },
              usageCount: { type: "number" }
            }
          }
        },
        messagesByDay: {
          type: "array",
          items: {
            type: "object",
            properties: {
              date: { type: "string" },
              count: { type: "number" }
            }
          }
        }
      }
    }
  }
};
var ChatSchemas = {
  sendMessage: sendMessageSchema,
  getHistory: getChatHistorySchema,
  getSession: getChatSessionSchema,
  deleteSession: deleteChatSessionSchema,
  getToolbox: getToolboxSchema,
  getAnalytics: getAnalyticsSchema
};

// src/features/chat/chat.routes.ts
init_auth_middleware();
async function ChatRoutes(fastify2) {
  fastify2.post("/messages", {
    schema: ChatSchemas.sendMessage,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: ChatController.sendMessage
  });
  fastify2.post("/sessions/:sessionId/messages", {
    schema: ChatSchemas.sendMessage,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: ChatController.sendMessageToSession
  });
  fastify2.get("/messages", {
    schema: ChatSchemas.getHistory,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: ChatController.getHistory
  });
  fastify2.get("/messages/traditional", {
    schema: ChatSchemas.getHistory,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: ChatController.getHistoryTraditional
  });
  fastify2.get("/messages/:id", {
    preHandler: [authMiddleware],
    handler: ChatController.getMessage
  });
  fastify2.get("/sessions", {
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: ChatController.getSessions
  });
  fastify2.get("/sessions/:sessionId", {
    schema: ChatSchemas.getSession,
    preHandler: [authMiddleware],
    handler: ChatController.getSession
  });
  fastify2.get("/sessions/:sessionId/messages", {
    preHandler: [authMiddleware],
    handler: ChatController.getSessionMessages
  });
  fastify2.put("/sessions/:sessionId/title", {
    preHandler: [authMiddleware],
    handler: ChatController.updateSessionTitle
  });
  fastify2.patch("/sessions/:sessionId/title/intelligent", {
    preHandler: [authMiddleware],
    handler: ChatController.updateSessionTitleIntelligent
  });
  fastify2.delete("/sessions/:sessionId", {
    schema: ChatSchemas.deleteSession,
    preHandler: [authMiddleware],
    handler: ChatController.deleteSession
  });
  fastify2.get("/toolbox", {
    schema: ChatSchemas.getToolbox,
    preHandler: [authMiddleware],
    handler: ChatController.getToolbox
  });
  fastify2.post("/execute", {
    preHandler: [authMiddleware],
    handler: ChatController.executeCommand
  });
  fastify2.get("/analytics", {
    schema: ChatSchemas.getAnalytics,
    preHandler: [authMiddleware],
    handler: ChatController.getAnalytics
  });
  fastify2.get("/search", {
    preHandler: [authMiddleware],
    handler: ChatController.search
  });
  fastify2.delete("/cleanup/sessions", {
    preHandler: [authMiddleware],
    handler: ChatController.cleanupOldSessions
  });
  fastify2.delete("/cleanup/messages", {
    preHandler: [authMiddleware],
    handler: ChatController.cleanupOldMessages
  });
}

// src/services/llm/rag.ts
var import_tools = require("@langchain/core/tools");
var import_ollama2 = require("@langchain/ollama");
var import_retrieval = require("langchain/chains/retrieval");
var import_combine_documents = require("langchain/chains/combine_documents");
var import_prompts = require("@langchain/core/prompts");
var import_memory = require("langchain/vectorstores/memory");

// src/services/llm/movements.json
var movements_default = [
  {
    id: "cmgffctkq0001e8lc8lembpyv",
    type: "ENTRADA",
    quantity: 12,
    storeId: "cmg4iuzet0002e8vgr7xtjo10",
    productId: "cmg4ixgh90005e8vgqdn5k6qz",
    supplierId: null,
    batch: null,
    expiration: null,
    price: null,
    balanceAfter: 27,
    verified: false,
    verifiedAt: null,
    verifiedBy: null,
    verificationNote: null,
    cancelled: false,
    cancelledAt: null,
    cancelledBy: null,
    cancellationReason: null,
    createdAt: "2025-10-06T17:48:32.565Z",
    updatedAt: "2025-10-06T17:48:32.565Z",
    userId: "cmg4itq6j0000e8vgj7t4abbq",
    store: {},
    supplier: null,
    user: {}
  },
  {
    id: "cmgfemfu60003e8ak602dmvsz",
    type: "ENTRADA",
    quantity: 12,
    storeId: "cmg4iuzet0002e8vgr7xtjo10",
    productId: "cmg4ixgh90005e8vgqdn5k6qz",
    supplierId: null,
    batch: null,
    expiration: null,
    price: null,
    balanceAfter: 15,
    verified: false,
    verifiedAt: null,
    verifiedBy: null,
    verificationNote: null,
    cancelled: false,
    cancelledAt: null,
    cancelledBy: null,
    cancellationReason: null,
    createdAt: "2025-10-06T17:28:01.708Z",
    updatedAt: "2025-10-06T17:28:01.708Z",
    userId: "cmg4itq6j0000e8vgj7t4abbq",
    store: {},
    supplier: null,
    user: {}
  },
  {
    id: "cmgfembjm0001e8ak0e7tvwbv",
    type: "ENTRADA",
    quantity: 2,
    storeId: "cmg4iuzet0002e8vgr7xtjo10",
    productId: "cmg4ixgh90005e8vgqdn5k6qz",
    supplierId: null,
    batch: null,
    expiration: null,
    price: null,
    balanceAfter: 3,
    verified: false,
    verifiedAt: null,
    verifiedBy: null,
    verificationNote: null,
    cancelled: false,
    cancelledAt: null,
    cancelledBy: null,
    cancellationReason: null,
    createdAt: "2025-10-06T17:27:56.141Z",
    updatedAt: "2025-10-06T17:27:56.141Z",
    userId: "cmg4itq6j0000e8vgj7t4abbq",
    store: {},
    supplier: null,
    user: {}
  },
  {
    id: "cmgacsg6w0007e8j4p80rtch5",
    type: "SAIDA",
    quantity: 2,
    storeId: "cmg4iuzet0002e8vgr7xtjo10",
    productId: "cmg4ixgh90005e8vgqdn5k6qz",
    supplierId: null,
    batch: null,
    expiration: null,
    price: null,
    balanceAfter: 1,
    verified: false,
    verifiedAt: null,
    verifiedBy: null,
    verificationNote: null,
    cancelled: false,
    cancelledAt: null,
    cancelledBy: null,
    cancellationReason: null,
    createdAt: "2025-10-03T04:37:51.991Z",
    updatedAt: "2025-10-03T04:37:51.991Z",
    userId: "cmg4itq6j0000e8vgj7t4abbq",
    store: {},
    supplier: null,
    user: {}
  },
  {
    id: "cmgacrf420005e8j4n73dql7v",
    type: "SAIDA",
    quantity: 2,
    storeId: "cmg4iuzet0002e8vgr7xtjo10",
    productId: "cmg4ixgh90005e8vgqdn5k6qz",
    supplierId: null,
    batch: null,
    expiration: null,
    price: null,
    balanceAfter: 3,
    verified: false,
    verifiedAt: null,
    verifiedBy: null,
    verificationNote: null,
    cancelled: false,
    cancelledAt: null,
    cancelledBy: null,
    cancellationReason: null,
    createdAt: "2025-10-03T04:37:03.936Z",
    updatedAt: "2025-10-03T04:37:03.936Z",
    userId: "cmg4itq6j0000e8vgj7t4abbq",
    store: {},
    supplier: null,
    user: {}
  },
  {
    id: "cmgacr0400001e8j4qvyetx1w",
    type: "ENTRADA",
    quantity: 5,
    storeId: "cmg4iuzet0002e8vgr7xtjo10",
    productId: "cmg4ixgh90005e8vgqdn5k6qz",
    supplierId: null,
    batch: null,
    expiration: null,
    price: null,
    balanceAfter: 5,
    verified: false,
    verifiedAt: null,
    verifiedBy: null,
    verificationNote: null,
    cancelled: false,
    cancelledAt: null,
    cancelledBy: null,
    cancellationReason: null,
    createdAt: "2025-10-03T04:36:44.494Z",
    updatedAt: "2025-10-03T04:36:44.494Z",
    userId: "cmg4itq6j0000e8vgj7t4abbq",
    store: {},
    supplier: null,
    user: {}
  },
  {
    id: "cmgackw1d0001e8k8tpi6dl89",
    type: "SAIDA",
    quantity: 1,
    storeId: "cmg4iuzet0002e8vgr7xtjo10",
    productId: "cmg4ixgh90005e8vgqdn5k6qz",
    supplierId: null,
    batch: null,
    expiration: null,
    price: 25.5,
    balanceAfter: 0,
    verified: false,
    verifiedAt: null,
    verifiedBy: null,
    verificationNote: null,
    cancelled: false,
    cancelledAt: null,
    cancelledBy: null,
    cancellationReason: null,
    createdAt: "2025-10-03T04:31:59.276Z",
    updatedAt: "2025-10-03T04:31:59.276Z",
    userId: "cmg4itq6j0000e8vgj7t4abbq",
    store: {},
    supplier: null,
    user: {}
  },
  {
    id: "cmgacij4a0001e8fkqiqxiqis",
    type: "SAIDA",
    quantity: 1,
    storeId: "cmg4iuzet0002e8vgr7xtjo10",
    productId: "cmg4ixgh90005e8vgqdn5k6qz",
    supplierId: null,
    batch: null,
    expiration: null,
    price: 25.5,
    balanceAfter: 1,
    verified: false,
    verifiedAt: null,
    verifiedBy: null,
    verificationNote: null,
    cancelled: false,
    cancelledAt: null,
    cancelledBy: null,
    cancellationReason: null,
    createdAt: "2025-10-03T04:30:09.224Z",
    updatedAt: "2025-10-03T04:30:09.224Z",
    userId: "cmg4itq6j0000e8vgj7t4abbq",
    store: {},
    supplier: null,
    user: {}
  },
  {
    id: "cmgacb7r40005e8j8amptlfye",
    type: "SAIDA",
    quantity: 9,
    storeId: "cmg4iuzet0002e8vgr7xtjo10",
    productId: "cmg4ixgh90005e8vgqdn5k6qz",
    supplierId: null,
    batch: null,
    expiration: null,
    price: 25.5,
    balanceAfter: 2,
    verified: false,
    verifiedAt: null,
    verifiedBy: null,
    verificationNote: null,
    cancelled: false,
    cancelledAt: null,
    cancelledBy: null,
    cancellationReason: null,
    createdAt: "2025-10-03T04:24:27.902Z",
    updatedAt: "2025-10-03T04:24:27.902Z",
    userId: "cmg4itq6j0000e8vgj7t4abbq",
    store: {},
    supplier: null,
    user: {}
  },
  {
    id: "cmgac9icl0003e8j84v41e88d",
    type: "SAIDA",
    quantity: 20,
    storeId: "cmg4iuzet0002e8vgr7xtjo10",
    productId: "cmg4ixgh90005e8vgqdn5k6qz",
    supplierId: null,
    batch: null,
    expiration: null,
    price: 25.5,
    balanceAfter: 11,
    verified: false,
    verifiedAt: null,
    verifiedBy: null,
    verificationNote: null,
    cancelled: false,
    cancelledAt: null,
    cancelledBy: null,
    cancellationReason: null,
    createdAt: "2025-10-03T04:23:08.323Z",
    updatedAt: "2025-10-03T04:23:08.323Z",
    userId: "cmg4itq6j0000e8vgj7t4abbq",
    store: {},
    supplier: null,
    user: {}
  }
];

// src/services/llm/rag.ts
var model = new import_ollama2.ChatOllama({ model: "mistral" });
var getStockMovementsTool = (0, import_tools.tool)(
  async (input) => {
    const productId = input.productId;
    return movements_default;
  },
  {
    name: "get_stock_movements",
    description: "Busca entradas, sa\xEDdas e perdas de um produto pelo ID",
    schema: {
      type: "object",
      properties: {
        productId: { type: "string" }
      },
      required: ["productId"]
    }
  }
);
function generateDocuments(movements) {
  const entries = movements.filter((m) => m.type === "ENTRADA");
  entries.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
  return entries.map((m) => {
    const date = new Date(m.createdAt).toLocaleDateString("pt-BR");
    const time = new Date(m.createdAt).toLocaleTimeString("pt-BR");
    const price = m.price ? ` | Pre\xE7o: R$ ${m.price}` : "";
    const balance = m.balanceAfter ? ` | Saldo ap\xF3s: ${m.balanceAfter}` : "";
    return `Data: ${date} ${time} | Tipo: ${m.type} | Quantidade: ${m.quantity}${price}${balance}`;
  });
}
async function createRAGChain(productId) {
  const movements = await getStockMovementsTool.invoke({ productId });
  const documents = generateDocuments(movements);
  const vectorStore = await import_memory.MemoryVectorStore.fromTexts(
    documents,
    [{ id: productId }],
    new import_ollama2.OllamaEmbeddings({ model: "mistral" })
  );
  const documentChain = await (0, import_combine_documents.createStuffDocumentsChain)({
    llm: model,
    prompt: new import_prompts.PromptTemplate({
      template: "Voc\xEA \xE9 um assistente especializado em an\xE1lise de movimenta\xE7\xF5es de estoque. Responda a pergunta com base no contexto fornecido sobre as movimenta\xE7\xF5es do produto.\n\nContexto das movimenta\xE7\xF5es:\n{context}\n\nPergunta:\n{input}\n\nResponda de forma clara e precisa, utilizando as informa\xE7\xF5es do contexto.",
      inputVariables: ["context", "input"]
    })
  });
  return (0, import_retrieval.createRetrievalChain)({
    combineDocsChain: documentChain,
    retriever: vectorStore.asRetriever()
  });
}
async function queryRAG(productId, query) {
  try {
    const chain = await createRAGChain(productId);
    const result = await chain.invoke({ input: query });
    return result;
  } catch (error) {
    return {
      input: query,
      context: [],
      answer: "Erro ao processar a consulta. Verifique se o produto existe e possui movimenta\xE7\xF5es nesta loja."
    };
  }
}

// src/features/roadmap/commands/roadmap.commands.ts
init_prisma();
var RoadmapCommands = {
  async create(data) {
    return await db.roadmap.create({ data });
  },
  async update(id, data) {
    return await db.roadmap.update({
      where: { id },
      data
    });
  },
  async delete(id) {
    return await db.roadmap.delete({
      where: { id }
    });
  },
  async updateStatus(id, status) {
    return await db.roadmap.update({
      where: { id },
      data: { status }
    });
  }
};

// src/features/roadmap/queries/roadmap.queries.ts
init_prisma();
var RoadmapQueries = {
  async getById(id) {
    return await db.roadmap.findUnique({
      where: { id },
      include: {
        milestones: {
          orderBy: { order: "asc" }
        },
        store: {
          select: {
            id: true,
            name: true
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async list(params) {
    const { page = 1, limit = 10, search, status } = params;
    const skip = (page - 1) * limit;
    const where = {};
    if (status !== void 0) {
      where.status = status;
    }
    if (search) {
      where.OR = [
        { title: { contains: search, mode: "insensitive" } },
        { description: { contains: search, mode: "insensitive" } }
      ];
    }
    const [items, total] = await Promise.all([
      db.roadmap.findMany({
        where,
        skip,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          _count: {
            select: { milestones: true }
          },
          store: {
            select: {
              id: true,
              name: true
            }
          },
          user: {
            select: {
              id: true,
              name: true
            }
          }
        }
      }),
      db.roadmap.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async search(term, limit = 10) {
    return await db.roadmap.findMany({
      where: {
        OR: [
          { title: { contains: term, mode: "insensitive" } },
          { description: { contains: term, mode: "insensitive" } }
        ]
      },
      take: limit,
      orderBy: { createdAt: "desc" }
    });
  },
  async getActive() {
    return await db.roadmap.findMany({
      where: { status: "ACTIVE" },
      orderBy: { createdAt: "desc" },
      include: {
        _count: {
          select: { milestones: true }
        },
        milestones: {
          where: {
            status: {
              in: ["IN_PROGRESS", "PENDING"]
            }
          },
          orderBy: { order: "asc" },
          take: 5
        }
      }
    });
  },
  async getStats() {
    const [total, active, inactive] = await Promise.all([
      db.roadmap.count(),
      db.roadmap.count({ where: { status: "ACTIVE" } }),
      db.roadmap.count({ where: { status: "COMPLETED" } })
    ]);
    return {
      total,
      active,
      inactive
    };
  }
};

// src/features/roadmap/roadmap.controller.ts
var RoadmapController = {
  // === CRUD BÁSICO ===
  async create(request, reply) {
    try {
      const data = { ...request.body };
      if (data.startDate) {
        data.startDate = new Date(data.startDate);
      }
      if (data.endDate) {
        data.endDate = new Date(data.endDate);
      }
      const result = await RoadmapCommands.create(data);
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Specific error message") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      const result = await RoadmapQueries.getById(id);
      if (!result) {
        return reply.status(404).send({
          error: "Roadmap not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Roadmap not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      if (updateData.startDate) {
        updateData.startDate = new Date(updateData.startDate);
      }
      if (updateData.endDate) {
        updateData.endDate = new Date(updateData.endDate);
      }
      const result = await RoadmapCommands.update(id, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Roadmap not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Validation error") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      await RoadmapCommands.delete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Roadmap not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { page = 1, limit = 10, search, status } = request.query;
      const result = await RoadmapQueries.list({
        page,
        limit,
        search,
        status
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (QUERIES) ===
  async getActive(request, reply) {
    try {
      const result = await RoadmapQueries.getActive();
      return reply.send({ roadmaps: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const result = await RoadmapQueries.getStats();
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { q, limit = 10 } = request.query;
      const result = await RoadmapQueries.search(q, limit);
      return reply.send({ roadmaps: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (COMMANDS) ===
  async updateStatus(request, reply) {
    try {
      const { id } = request.params;
      const { status } = request.body;
      const result = await RoadmapCommands.updateStatus(id, status);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Roadmap not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/roadmap/commands/milestone.commands.ts
init_prisma();
var MilestoneCommands = {
  async create(data) {
    const roadmap = await db.roadmap.findUnique({
      where: { id: data.roadmapId }
    });
    if (!roadmap) {
      throw new Error("Roadmap not found");
    }
    if (data.order === void 0) {
      const lastMilestone = await db.milestone.findFirst({
        where: { roadmapId: data.roadmapId },
        orderBy: { order: "desc" }
      });
      data.order = lastMilestone ? lastMilestone.order + 1 : 0;
    }
    return await db.milestone.create({
      data: {
        roadmapId: data.roadmapId,
        title: data.title,
        description: data.description,
        status: data.status || "PENDING",
        progress: data.progress || 0,
        order: data.order,
        startDate: data.startDate,
        endDate: data.endDate
      },
      include: {
        roadmap: {
          select: {
            id: true,
            title: true
          }
        }
      }
    });
  },
  async update(id, roadmapId, data) {
    const milestone = await db.milestone.findFirst({
      where: {
        id,
        roadmapId
      }
    });
    if (!milestone) {
      throw new Error("Milestone not found");
    }
    const updateData = { ...data };
    if (data.status === "COMPLETED" && milestone.status !== "COMPLETED") {
      updateData.completedAt = /* @__PURE__ */ new Date();
      updateData.progress = 100;
    }
    return await db.milestone.update({
      where: { id },
      data: updateData,
      include: {
        roadmap: {
          select: {
            id: true,
            title: true
          }
        }
      }
    });
  },
  async delete(id, roadmapId) {
    const milestone = await db.milestone.findFirst({
      where: {
        id,
        roadmapId
      }
    });
    if (!milestone) {
      throw new Error("Milestone not found");
    }
    return await db.milestone.delete({
      where: { id }
    });
  },
  async updateProgress(id, roadmapId, progress) {
    if (progress < 0 || progress > 100) {
      throw new Error("Progress must be between 0 and 100");
    }
    const milestone = await db.milestone.findFirst({
      where: {
        id,
        roadmapId
      }
    });
    if (!milestone) {
      throw new Error("Milestone not found");
    }
    const updateData = { progress };
    if (progress === 100 && milestone.status !== "COMPLETED") {
      updateData.status = "COMPLETED";
      updateData.completedAt = /* @__PURE__ */ new Date();
    }
    if (progress < 100 && milestone.status === "COMPLETED") {
      updateData.status = "IN_PROGRESS";
      updateData.completedAt = null;
    }
    return await db.milestone.update({
      where: { id },
      data: updateData
    });
  },
  async updateStatus(id, roadmapId, status) {
    const milestone = await db.milestone.findFirst({
      where: {
        id,
        roadmapId
      }
    });
    if (!milestone) {
      throw new Error("Milestone not found");
    }
    const updateData = { status };
    if (status === "COMPLETED" && milestone.status !== "COMPLETED") {
      updateData.completedAt = /* @__PURE__ */ new Date();
      updateData.progress = 100;
    }
    if (status !== "COMPLETED" && milestone.status === "COMPLETED") {
      updateData.completedAt = null;
    }
    return await db.milestone.update({
      where: { id },
      data: updateData
    });
  },
  async reorder(roadmapId, milestoneIds) {
    const milestones = await db.milestone.findMany({
      where: {
        id: { in: milestoneIds },
        roadmapId
      }
    });
    if (milestones.length !== milestoneIds.length) {
      throw new Error("Some milestones not found or do not belong to this roadmap");
    }
    const updates = milestoneIds.map(
      (id, index) => db.milestone.update({
        where: { id },
        data: { order: index }
      })
    );
    return await db.$transaction(updates);
  }
};

// src/features/roadmap/queries/milestone.queries.ts
init_prisma();
var MilestoneQueries = {
  async getById(id, roadmapId) {
    const milestone = await db.milestone.findFirst({
      where: {
        id,
        roadmapId
      },
      include: {
        roadmap: {
          select: {
            id: true,
            title: true,
            status: true
          }
        }
      }
    });
    if (!milestone) {
      throw new Error("Milestone not found");
    }
    return milestone;
  },
  async listByRoadmap(roadmapId, params) {
    const { status, page = 1, limit = 50 } = params || {};
    const skip = (page - 1) * limit;
    const where = { roadmapId };
    if (status) {
      where.status = status;
    }
    const [items, total] = await Promise.all([
      db.milestone.findMany({
        where,
        skip,
        take: limit,
        orderBy: { order: "asc" }
      }),
      db.milestone.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getByStatus(roadmapId, status) {
    return await db.milestone.findMany({
      where: {
        roadmapId,
        status
      },
      orderBy: { order: "asc" }
    });
  },
  async getStats(roadmapId) {
    const [
      total,
      pending,
      inProgress,
      completed,
      blocked,
      avgProgress
    ] = await Promise.all([
      db.milestone.count({ where: { roadmapId } }),
      db.milestone.count({ where: { roadmapId, status: "PENDING" } }),
      db.milestone.count({ where: { roadmapId, status: "IN_PROGRESS" } }),
      db.milestone.count({ where: { roadmapId, status: "COMPLETED" } }),
      db.milestone.count({ where: { roadmapId, status: "BLOCKED" } }),
      db.milestone.aggregate({
        where: { roadmapId },
        _avg: { progress: true }
      })
    ]);
    return {
      total,
      byStatus: {
        pending,
        inProgress,
        completed,
        blocked
      },
      averageProgress: Math.round(avgProgress._avg.progress || 0),
      completionRate: total > 0 ? Math.round(completed / total * 100) : 0
    };
  },
  async getUpcoming(roadmapId, limit = 5) {
    const now = /* @__PURE__ */ new Date();
    return await db.milestone.findMany({
      where: {
        roadmapId,
        status: {
          in: ["PENDING", "IN_PROGRESS"]
        },
        startDate: {
          gte: now
        }
      },
      orderBy: { startDate: "asc" },
      take: limit
    });
  },
  async getOverdue(roadmapId) {
    const now = /* @__PURE__ */ new Date();
    return await db.milestone.findMany({
      where: {
        roadmapId,
        status: {
          notIn: ["COMPLETED"]
        },
        endDate: {
          lt: now
        }
      },
      orderBy: { endDate: "asc" }
    });
  },
  async getInProgress(roadmapId) {
    return await db.milestone.findMany({
      where: {
        roadmapId,
        status: "IN_PROGRESS"
      },
      orderBy: { order: "asc" }
    });
  },
  async search(roadmapId, term, limit = 10) {
    return await db.milestone.findMany({
      where: {
        roadmapId,
        OR: [
          { title: { contains: term, mode: "insensitive" } },
          { description: { contains: term, mode: "insensitive" } }
        ]
      },
      orderBy: { order: "asc" },
      take: limit
    });
  },
  // Query para pegar todas as milestones ordenadas (útil para drag & drop)
  async getAllOrdered(roadmapId) {
    return await db.milestone.findMany({
      where: { roadmapId },
      orderBy: { order: "asc" }
    });
  },
  // Query para verificar se há milestones bloqueadas
  async hasBlocked(roadmapId) {
    const count = await db.milestone.count({
      where: {
        roadmapId,
        status: "BLOCKED"
      }
    });
    return count > 0;
  },
  // Query para pegar timeline completa
  async getTimeline(roadmapId) {
    return await db.milestone.findMany({
      where: {
        roadmapId,
        OR: [
          { startDate: { not: null } },
          { endDate: { not: null } }
        ]
      },
      orderBy: [
        { startDate: "asc" },
        { order: "asc" }
      ]
    });
  }
};

// src/features/roadmap/milestone.controller.ts
var MilestoneController = {
  // === CRUD BÁSICO ===
  async create(request, reply) {
    try {
      const { roadmapId } = request.params;
      const { title, description, status, progress, order, startDate, endDate } = request.body;
      const result = await MilestoneCommands.create({
        roadmapId,
        title,
        description,
        status,
        progress,
        order,
        startDate: startDate ? new Date(startDate) : void 0,
        endDate: endDate ? new Date(endDate) : void 0
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Roadmap not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { roadmapId, id } = request.params;
      const result = await MilestoneQueries.getById(id, roadmapId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Milestone not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { roadmapId, id } = request.params;
      const updateData = { ...request.body };
      if (updateData.startDate) {
        updateData.startDate = new Date(updateData.startDate).toISOString();
      }
      if (updateData.endDate) {
        updateData.endDate = new Date(updateData.endDate).toISOString();
      }
      const result = await MilestoneCommands.update(id, roadmapId, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Milestone not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Validation error") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { roadmapId, id } = request.params;
      await MilestoneCommands.delete(id, roadmapId);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Milestone not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { roadmapId } = request.params;
      const { status, page = 1, limit = 50 } = request.query;
      const result = await MilestoneQueries.listByRoadmap(roadmapId, {
        status,
        page,
        limit
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (QUERIES) ===
  async getByStatus(request, reply) {
    try {
      const { roadmapId } = request.params;
      const { status } = request.query;
      const result = await MilestoneQueries.getByStatus(roadmapId, status);
      return reply.send({ milestones: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const { roadmapId } = request.params;
      const result = await MilestoneQueries.getStats(roadmapId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getUpcoming(request, reply) {
    try {
      const { roadmapId } = request.params;
      const { limit = 5 } = request.query;
      const result = await MilestoneQueries.getUpcoming(roadmapId, limit);
      return reply.send({ milestones: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getOverdue(request, reply) {
    try {
      const { roadmapId } = request.params;
      const result = await MilestoneQueries.getOverdue(roadmapId);
      return reply.send({ milestones: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getInProgress(request, reply) {
    try {
      const { roadmapId } = request.params;
      const result = await MilestoneQueries.getInProgress(roadmapId);
      return reply.send({ milestones: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getTimeline(request, reply) {
    try {
      const { roadmapId } = request.params;
      const result = await MilestoneQueries.getTimeline(roadmapId);
      return reply.send({ timeline: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { roadmapId } = request.params;
      const { q, limit = 10 } = request.query;
      const result = await MilestoneQueries.search(roadmapId, q, limit);
      return reply.send({ milestones: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (COMMANDS) ===
  async updateProgress(request, reply) {
    try {
      const { roadmapId, id } = request.params;
      const { progress } = request.body;
      const result = await MilestoneCommands.updateProgress(id, roadmapId, progress);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Milestone not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Progress must be between 0 and 100") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async updateStatus(request, reply) {
    try {
      const { roadmapId, id } = request.params;
      const { status } = request.body;
      const result = await MilestoneCommands.updateStatus(id, roadmapId, status);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Milestone not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async reorder(request, reply) {
    try {
      const { roadmapId } = request.params;
      const { milestoneIds } = request.body;
      const result = await MilestoneCommands.reorder(roadmapId, milestoneIds);
      return reply.send({ milestones: result });
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("not found")) {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/roadmap/roadmap.schema.ts
var createRoadmapSchema = {
  body: {
    type: "object",
    required: ["title"],
    properties: {
      storeId: { type: "string" },
      userId: { type: "string" },
      title: { type: "string" },
      description: { type: "string" },
      status: { type: "string", enum: ["ACTIVE", "COMPLETED", "ARCHIVED"] },
      startDate: { type: "string", format: "date-time" },
      endDate: { type: "string", format: "date-time" }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: ["string", "null"] },
        userId: { type: ["string", "null"] },
        title: { type: "string" },
        description: { type: ["string", "null"] },
        status: { type: "string" },
        startDate: { type: ["string", "null"] },
        endDate: { type: ["string", "null"] },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var updateRoadmapSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      storeId: { type: "string" },
      userId: { type: "string" },
      title: { type: "string" },
      description: { type: "string" },
      status: { type: "string", enum: ["ACTIVE", "COMPLETED", "ARCHIVED"] },
      startDate: { type: "string", format: "date-time" },
      endDate: { type: "string", format: "date-time" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: ["string", "null"] },
        userId: { type: ["string", "null"] },
        title: { type: "string" },
        description: { type: ["string", "null"] },
        status: { type: "string" },
        startDate: { type: ["string", "null"] },
        endDate: { type: ["string", "null"] },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getRoadmapSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: ["string", "null"] },
        userId: { type: ["string", "null"] },
        title: { type: "string" },
        description: { type: ["string", "null"] },
        status: { type: "string" },
        startDate: { type: ["string", "null"] },
        endDate: { type: ["string", "null"] },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var listRoadmapsSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      status: { type: "string", enum: ["ACTIVE", "COMPLETED", "ARCHIVED"] }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              storeId: { type: ["string", "null"] },
              userId: { type: ["string", "null"] },
              title: { type: "string" },
              description: { type: ["string", "null"] },
              status: { type: "string" },
              startDate: { type: ["string", "null"] },
              endDate: { type: ["string", "null"] },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var deleteRoadmapSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var RoadmapSchemas = {
  create: createRoadmapSchema,
  update: updateRoadmapSchema,
  get: getRoadmapSchema,
  delete: deleteRoadmapSchema,
  list: listRoadmapsSchema
};

// src/features/roadmap/milestone.schema.ts
var createMilestoneSchema = {
  params: {
    type: "object",
    required: ["roadmapId"],
    properties: {
      roadmapId: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["title"],
    properties: {
      title: { type: "string", minLength: 1, maxLength: 200 },
      description: { type: "string", maxLength: 1e3 },
      status: {
        type: "string",
        enum: ["PENDING", "IN_PROGRESS", "COMPLETED", "BLOCKED"],
        default: "PENDING"
      },
      progress: { type: "number", minimum: 0, maximum: 100, default: 0 },
      order: { type: "number", minimum: 0 },
      startDate: { type: "string", format: "date-time" },
      endDate: { type: "string", format: "date-time" }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        roadmapId: { type: "string" },
        title: { type: "string" },
        description: { type: ["string", "null"] },
        status: { type: "string" },
        progress: { type: "number" },
        order: { type: "number" },
        startDate: { type: ["string", "null"], format: "date-time" },
        endDate: { type: ["string", "null"], format: "date-time" },
        completedAt: { type: ["string", "null"], format: "date-time" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var updateMilestoneSchema = {
  params: {
    type: "object",
    required: ["roadmapId", "id"],
    properties: {
      roadmapId: { type: "string" },
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      title: { type: "string", minLength: 1, maxLength: 200 },
      description: { type: "string", maxLength: 1e3 },
      status: {
        type: "string",
        enum: ["PENDING", "IN_PROGRESS", "COMPLETED", "BLOCKED"]
      },
      progress: { type: "number", minimum: 0, maximum: 100 },
      order: { type: "number", minimum: 0 },
      startDate: { type: "string", format: "date-time" },
      endDate: { type: "string", format: "date-time" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        roadmapId: { type: "string" },
        title: { type: "string" },
        description: { type: ["string", "null"] },
        status: { type: "string" },
        progress: { type: "number" },
        order: { type: "number" },
        startDate: { type: ["string", "null"], format: "date-time" },
        endDate: { type: ["string", "null"], format: "date-time" },
        completedAt: { type: ["string", "null"], format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getMilestoneSchema = {
  params: {
    type: "object",
    required: ["roadmapId", "id"],
    properties: {
      roadmapId: { type: "string" },
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        roadmapId: { type: "string" },
        title: { type: "string" },
        description: { type: ["string", "null"] },
        status: { type: "string" },
        progress: { type: "number" },
        order: { type: "number" },
        startDate: { type: ["string", "null"], format: "date-time" },
        endDate: { type: ["string", "null"], format: "date-time" },
        completedAt: { type: ["string", "null"], format: "date-time" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var listMilestonesSchema = {
  params: {
    type: "object",
    required: ["roadmapId"],
    properties: {
      roadmapId: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      status: {
        type: "string",
        enum: ["PENDING", "IN_PROGRESS", "COMPLETED", "BLOCKED"]
      },
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 50 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              roadmapId: { type: "string" },
              title: { type: "string" },
              description: { type: ["string", "null"] },
              status: { type: "string" },
              progress: { type: "number" },
              order: { type: "number" },
              startDate: { type: ["string", "null"], format: "date-time" },
              endDate: { type: ["string", "null"], format: "date-time" },
              completedAt: { type: ["string", "null"], format: "date-time" },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var deleteMilestoneSchema = {
  params: {
    type: "object",
    required: ["roadmapId", "id"],
    properties: {
      roadmapId: { type: "string" },
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var updateMilestoneProgressSchema = {
  params: {
    type: "object",
    required: ["roadmapId", "id"],
    properties: {
      roadmapId: { type: "string" },
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["progress"],
    properties: {
      progress: { type: "number", minimum: 0, maximum: 100 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        progress: { type: "number" },
        status: { type: "string" },
        completedAt: { type: ["string", "null"], format: "date-time" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var updateMilestoneStatusSchema = {
  params: {
    type: "object",
    required: ["roadmapId", "id"],
    properties: {
      roadmapId: { type: "string" },
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["status"],
    properties: {
      status: {
        type: "string",
        enum: ["PENDING", "IN_PROGRESS", "COMPLETED", "BLOCKED"]
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        status: { type: "string" },
        completedAt: { type: ["string", "null"], format: "date-time" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var reorderMilestonesSchema = {
  params: {
    type: "object",
    required: ["roadmapId"],
    properties: {
      roadmapId: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["milestoneIds"],
    properties: {
      milestoneIds: {
        type: "array",
        items: { type: "string" },
        minItems: 1
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        milestones: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              order: { type: "number" }
            }
          }
        }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var MilestoneSchemas = {
  create: createMilestoneSchema,
  update: updateMilestoneSchema,
  get: getMilestoneSchema,
  delete: deleteMilestoneSchema,
  list: listMilestonesSchema,
  updateProgress: updateMilestoneProgressSchema,
  updateStatus: updateMilestoneStatusSchema,
  reorder: reorderMilestonesSchema
};

// src/features/roadmap/roadmap.routes.ts
init_auth_middleware();
async function RoadmapRoutes(fastify2) {
  fastify2.get("/active", {
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: RoadmapController.getActive
  });
  fastify2.get("/stats", {
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: RoadmapController.getStats
  });
  fastify2.get("/search", {
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: RoadmapController.search
  });
  fastify2.post("/", {
    schema: RoadmapSchemas.create,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: RoadmapController.create
  });
  fastify2.get("/", {
    schema: RoadmapSchemas.list,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: RoadmapController.list
  });
  fastify2.get("/:id", {
    schema: RoadmapSchemas.get,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: RoadmapController.get
  });
  fastify2.put("/:id", {
    schema: RoadmapSchemas.update,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: RoadmapController.update
  });
  fastify2.delete("/:id", {
    schema: RoadmapSchemas.delete,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: RoadmapController.delete
  });
  fastify2.patch("/:id/status", {
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: RoadmapController.updateStatus
  });
  fastify2.get("/:roadmapId/milestones/stats", {
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: MilestoneController.getStats
  });
  fastify2.get("/:roadmapId/milestones/upcoming", {
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: MilestoneController.getUpcoming
  });
  fastify2.get("/:roadmapId/milestones/overdue", {
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: MilestoneController.getOverdue
  });
  fastify2.get("/:roadmapId/milestones/in-progress", {
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: MilestoneController.getInProgress
  });
  fastify2.get("/:roadmapId/milestones/timeline", {
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: MilestoneController.getTimeline
  });
  fastify2.get("/:roadmapId/milestones/search", {
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: MilestoneController.search
  });
  fastify2.post("/:roadmapId/milestones", {
    schema: MilestoneSchemas.create,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: MilestoneController.create
  });
  fastify2.get("/:roadmapId/milestones", {
    schema: MilestoneSchemas.list,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: MilestoneController.list
  });
  fastify2.get("/:roadmapId/milestones/:id", {
    schema: MilestoneSchemas.get,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: MilestoneController.get
  });
  fastify2.put("/:roadmapId/milestones/:id", {
    schema: MilestoneSchemas.update,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: MilestoneController.update
  });
  fastify2.delete("/:roadmapId/milestones/:id", {
    schema: MilestoneSchemas.delete,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: MilestoneController.delete
  });
  fastify2.patch("/:roadmapId/milestones/:id/progress", {
    schema: MilestoneSchemas.updateProgress,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: MilestoneController.updateProgress
  });
  fastify2.patch("/:roadmapId/milestones/:id/status", {
    schema: MilestoneSchemas.updateStatus,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: MilestoneController.updateStatus
  });
  fastify2.post("/:roadmapId/milestones/reorder", {
    schema: MilestoneSchemas.reorder,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: MilestoneController.reorder
  });
}

// src/features/upload/upload.controller.ts
var import_path2 = __toESM(require("path"));

// src/features/upload/commands/upload.commands.ts
init_prisma();
var UploadCommands = {
  async create(data) {
    const upload = await db.media.create({
      data: {
        url: data.url,
        name: data.name,
        type: data.type,
        size: data.size
      }
    });
    return upload;
  },
  async update(id, data) {
    const upload = await db.media.update({
      where: { id },
      data: {
        ...data.url && { url: data.url },
        ...data.name && { name: data.name },
        ...data.type && { type: data.type },
        ...data.size && { size: data.size }
      }
    });
    return upload;
  },
  async delete(id) {
    await db.productMedia.deleteMany({
      where: { mediaId: id }
    });
    await db.supplierMedia.deleteMany({
      where: { mediaId: id }
    });
    await db.userMedia.deleteMany({
      where: { mediaId: id }
    });
    await db.storeMedia.deleteMany({
      where: { mediaId: id }
    });
    await db.media.delete({
      where: { id }
    });
  },
  async attachToProduct(data) {
    if (data.entityType !== "product") {
      throw new Error("Invalid entity type for product attachment");
    }
    const attachment = await db.productMedia.create({
      data: {
        productId: data.entityId,
        mediaId: data.mediaId,
        isPrimary: data.isPrimary || false
      }
    });
    if (data.isPrimary) {
      await db.productMedia.updateMany({
        where: {
          productId: data.entityId,
          id: { not: attachment.id }
        },
        data: { isPrimary: false }
      });
    }
    return attachment;
  },
  async attachToSupplier(data) {
    if (data.entityType !== "supplier") {
      throw new Error("Invalid entity type for supplier attachment");
    }
    const attachment = await db.supplierMedia.create({
      data: {
        supplierId: data.entityId,
        mediaId: data.mediaId
      }
    });
    return attachment;
  },
  async attachToUser(data) {
    if (data.entityType !== "user") {
      throw new Error("Invalid entity type for user attachment");
    }
    const attachment = await db.userMedia.create({
      data: {
        userId: data.entityId,
        mediaId: data.mediaId
      }
    });
    return attachment;
  },
  async attachToStore(data) {
    if (data.entityType !== "store") {
      throw new Error("Invalid entity type for store attachment");
    }
    const attachment = await db.storeMedia.create({
      data: {
        storeId: data.entityId,
        mediaId: data.mediaId
      }
    });
    return attachment;
  },
  async detachFromProduct(mediaId, entityId) {
    const attachment = await db.productMedia.findFirst({
      where: {
        mediaId,
        productId: entityId
      }
    });
    if (!attachment) {
      throw new Error("Media attachment not found");
    }
    await db.productMedia.delete({
      where: { id: attachment.id }
    });
    return attachment;
  },
  async detachFromSupplier(mediaId, entityId) {
    const attachment = await db.supplierMedia.findFirst({
      where: {
        mediaId,
        supplierId: entityId
      }
    });
    if (!attachment) {
      throw new Error("Media attachment not found");
    }
    await db.supplierMedia.delete({
      where: { id: attachment.id }
    });
    return attachment;
  },
  async detachFromUser(mediaId, entityId) {
    const attachment = await db.userMedia.findFirst({
      where: {
        mediaId,
        userId: entityId
      }
    });
    if (!attachment) {
      throw new Error("Media attachment not found");
    }
    await db.userMedia.delete({
      where: { id: attachment.id }
    });
    return attachment;
  },
  async detachFromStore(mediaId, entityId) {
    const attachment = await db.storeMedia.findFirst({
      where: {
        mediaId,
        storeId: entityId
      }
    });
    if (!attachment) {
      throw new Error("Media attachment not found");
    }
    await db.storeMedia.delete({
      where: { id: attachment.id }
    });
    return attachment;
  },
  async setPrimaryForProduct(mediaId, productId) {
    await db.productMedia.updateMany({
      where: {
        productId,
        mediaId: { not: mediaId }
      },
      data: { isPrimary: false }
    });
    const attachment = await db.productMedia.updateMany({
      where: {
        mediaId,
        productId
      },
      data: { isPrimary: true }
    });
    return attachment;
  },
  async bulkDelete(mediaIds) {
    await Promise.all([
      db.productMedia.deleteMany({
        where: { mediaId: { in: mediaIds } }
      }),
      db.supplierMedia.deleteMany({
        where: { mediaId: { in: mediaIds } }
      }),
      db.userMedia.deleteMany({
        where: { mediaId: { in: mediaIds } }
      }),
      db.storeMedia.deleteMany({
        where: { mediaId: { in: mediaIds } }
      })
    ]);
    await db.media.deleteMany({
      where: { id: { in: mediaIds } }
    });
    return { deletedCount: mediaIds.length };
  }
};

// src/features/upload/queries/upload.queries.ts
init_prisma();
var UploadQueries = {
  async getById(id) {
    const upload = await db.media.findUnique({
      where: { id }
    });
    if (!upload) {
      throw new Error("Media not found");
    }
    return upload;
  },
  async list(filters) {
    const { page, limit, search, type, entityType, entityId } = filters;
    const skip = (page - 1) * limit;
    const where = {};
    if (search) {
      where.OR = [
        { name: { contains: search, mode: "insensitive" } },
        { type: { contains: search, mode: "insensitive" } }
      ];
    }
    if (type) {
      where.type = { contains: type, mode: "insensitive" };
    }
    let include = {};
    if (entityType && entityId) {
      switch (entityType) {
        case "product":
          include.productMedia = {
            where: { productId: entityId }
          };
          break;
        case "supplier":
          include.supplierMedia = {
            where: { supplierId: entityId }
          };
          break;
        case "user":
          include.userMedia = {
            where: { userId: entityId }
          };
          break;
        case "store":
          include.storeMedia = {
            where: { storeId: entityId }
          };
          break;
      }
    }
    const [uploads, total] = await Promise.all([
      db.media.findMany({
        where,
        include,
        skip,
        take: limit,
        orderBy: { createdAt: "desc" }
      }),
      db.media.count({ where })
    ]);
    const filteredUploads = entityType && entityId ? uploads.filter((upload) => {
      switch (entityType) {
        case "product":
          return upload.productMedia && upload.productMedia.length > 0;
        case "supplier":
          return upload.supplierMedia && upload.supplierMedia.length > 0;
        case "user":
          return upload.userMedia && upload.userMedia.length > 0;
        case "store":
          return upload.storeMedia && upload.storeMedia.length > 0;
        default:
          return true;
      }
    }) : uploads;
    return {
      uploads: filteredUploads,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getByType(type, limit = 10) {
    const uploads = await db.media.findMany({
      where: {
        type: { contains: type, mode: "insensitive" }
      },
      take: limit,
      orderBy: { createdAt: "desc" }
    });
    return uploads;
  },
  async getRecent(limit = 20) {
    const uploads = await db.media.findMany({
      take: limit,
      orderBy: { createdAt: "desc" }
    });
    return uploads;
  },
  async getEntityMedia(entityType, entityId) {
    let media = [];
    switch (entityType) {
      case "product":
        media = await db.productMedia.findMany({
          where: { productId: entityId },
          include: {
            media: true
          },
          orderBy: [
            { isPrimary: "desc" }
          ]
        });
        break;
      case "supplier":
        media = await db.supplierMedia.findMany({
          where: { supplierId: entityId },
          include: {
            media: true
          },
          orderBy: { id: "desc" }
        });
        break;
      case "user":
        media = await db.userMedia.findMany({
          where: { userId: entityId },
          include: {
            media: true
          },
          orderBy: { id: "desc" }
        });
        break;
      case "store":
        media = await db.storeMedia.findMany({
          where: { storeId: entityId },
          include: {
            media: true
          },
          orderBy: { id: "desc" }
        });
        break;
      default:
        throw new Error("Invalid entity type");
    }
    return media.map((item) => ({
      id: item.id,
      mediaId: item.mediaId,
      entityType,
      entityId,
      isPrimary: "isPrimary" in item ? item.isPrimary : null,
      createdAt: item.createdAt,
      media: item.media
    }));
  },
  async getPrimaryMedia(entityType, entityId) {
    let media = null;
    switch (entityType) {
      case "product":
        const productMedia = await db.productMedia.findFirst({
          where: {
            productId: entityId,
            isPrimary: true
          },
          include: {
            media: true
          }
        });
        media = productMedia;
        break;
      case "supplier":
      case "user":
      case "store":
        const firstMedia = await this.getEntityMedia(entityType, entityId);
        media = firstMedia[0] || null;
        break;
      default:
        throw new Error("Invalid entity type");
    }
    return media;
  },
  async search(query, limit = 10) {
    const uploads = await db.media.findMany({
      where: {
        OR: [
          { name: { contains: query, mode: "insensitive" } },
          { type: { contains: query, mode: "insensitive" } }
        ]
      },
      take: limit,
      orderBy: { createdAt: "desc" }
    });
    return uploads;
  },
  async getStats() {
    const [total, byType, recentCount] = await Promise.all([
      db.media.count(),
      db.media.groupBy({
        by: ["type"],
        _count: { type: true },
        orderBy: { _count: { type: "desc" } }
      }),
      db.media.count({
        where: {
          createdAt: {
            gte: new Date(Date.now() - 24 * 60 * 60 * 1e3)
            // Últimas 24h
          }
        }
      })
    ]);
    return {
      total,
      byType: byType.map((item) => ({
        type: item.type || "unknown",
        count: item._count.type
      })),
      recentCount
    };
  },
  async getUnusedMedia(daysOld = 30) {
    const cutoffDate = new Date(Date.now() - daysOld * 24 * 60 * 60 * 1e3);
    const unusedMedia = await db.media.findMany({
      where: {
        createdAt: { lt: cutoffDate },
        AND: [
          { productMedia: { none: {} } },
          { supplierMedia: { none: {} } },
          { userMedia: { none: {} } },
          { storeMedia: { none: {} } }
        ]
      },
      orderBy: { createdAt: "asc" }
    });
    return unusedMedia;
  },
  async getMediaUsage(mediaId) {
    const [productUsage, supplierUsage, userUsage, storeUsage] = await Promise.all([
      db.productMedia.findMany({
        where: { mediaId },
        include: {
          product: {
            select: { id: true, name: true }
          }
        }
      }),
      db.supplierMedia.findMany({
        where: { mediaId },
        include: {
          supplier: {
            select: { id: true, corporateName: true }
          }
        }
      }),
      db.userMedia.findMany({
        where: { mediaId },
        include: {
          user: {
            select: { id: true, name: true, email: true }
          }
        }
      }),
      db.storeMedia.findMany({
        where: { mediaId },
        include: {
          store: {
            select: { id: true, name: true }
          }
        }
      })
    ]);
    return {
      products: productUsage,
      suppliers: supplierUsage,
      users: userUsage,
      stores: storeUsage,
      totalUsage: productUsage.length + supplierUsage.length + userUsage.length + storeUsage.length
    };
  },
  async getAllUsedFilePaths() {
    const media = await db.media.findMany({
      select: { url: true }
    });
    return media.map((m) => m.url);
  }
};

// src/features/upload/upload.service.ts
var import_fs = require("fs");
var import_path = __toESM(require("path"));
var import_crypto2 = require("crypto");
var UPLOAD_DIR = import_path.default.join(process.cwd(), "src", "uploads");
var MAX_FILE_SIZE = 10 * 1024 * 1024;
var ALLOWED_TYPES = [
  "image/jpeg",
  "image/png",
  "image/gif",
  "image/webp",
  "image/svg+xml",
  "application/pdf",
  "application/msword",
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
  "application/vnd.ms-excel",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
  "text/plain"
];
var UploadService = class _UploadService {
  constructor() {
    this.uploadDir = UPLOAD_DIR;
    this.ensureUploadDirectories();
  }
  static getInstance() {
    if (!_UploadService.instance) {
      _UploadService.instance = new _UploadService();
    }
    return _UploadService.instance;
  }
  // === INICIALIZAÇÃO ===
  async ensureUploadDirectories() {
    const directories = [
      UPLOAD_DIR,
      import_path.default.join(UPLOAD_DIR, "product"),
      import_path.default.join(UPLOAD_DIR, "supplier"),
      import_path.default.join(UPLOAD_DIR, "user"),
      import_path.default.join(UPLOAD_DIR, "store"),
      import_path.default.join(UPLOAD_DIR, "general")
    ];
    for (const dir of directories) {
      try {
        await import_fs.promises.access(dir);
      } catch {
        await import_fs.promises.mkdir(dir, { recursive: true });
      }
    }
  }
  // === CRIAR DIRETÓRIO DO USUÁRIO ===
  async ensureUserDirectory(userId) {
    const userDir = import_path.default.join(UPLOAD_DIR, "users", userId);
    try {
      await import_fs.promises.access(userDir);
    } catch {
      await import_fs.promises.mkdir(userDir, { recursive: true });
    }
    return userDir;
  }
  // === VALIDAÇÃO ===
  validateFile(file, config = {}) {
    const allowedTypes = config.allowedTypes || ALLOWED_TYPES;
    const maxFileSize = config.maxFileSize || MAX_FILE_SIZE;
    if (!allowedTypes.includes(file.mimetype)) {
      throw new Error(`Tipo de arquivo n\xE3o permitido: ${file.mimetype}`);
    }
    if (file.size > maxFileSize) {
      throw new Error(`Arquivo muito grande. M\xE1ximo permitido: ${maxFileSize / 1024 / 1024}MB`);
    }
  }
  // === GERAR NOME ÚNICO ===
  generateUniqueFilename(originalName) {
    const ext = import_path.default.extname(originalName);
    const name = import_path.default.basename(originalName, ext);
    const uuid = (0, import_crypto2.randomUUID)();
    return `${name}-${uuid}${ext}`;
  }
  // === UPLOAD ÚNICO ===
  async uploadSingle(file, config = {}) {
    try {
      this.validateFile(file, config);
      if (!file.path || typeof file.path !== "string") {
        throw new Error("Caminho do arquivo inv\xE1lido ou n\xE3o fornecido");
      }
      try {
        await import_fs.promises.access(file.path);
      } catch (error) {
        throw new Error(`Arquivo tempor\xE1rio n\xE3o encontrado: ${file.path}`);
      }
      const entityType = config.entityType || "general";
      let destinationDir;
      let publicUrl;
      if (config.userId) {
        const userDir = await this.ensureUserDirectory(config.userId);
        destinationDir = import_path.default.join(userDir, entityType);
        try {
          await import_fs.promises.access(destinationDir);
        } catch {
          await import_fs.promises.mkdir(destinationDir, { recursive: true });
        }
        publicUrl = `/uploads/users/${config.userId}/${entityType}`;
      } else {
        destinationDir = import_path.default.join(this.uploadDir, entityType);
        publicUrl = `/uploads/${entityType}`;
      }
      const uniqueFilename = this.generateUniqueFilename(file.originalname);
      const destination = import_path.default.join(destinationDir, uniqueFilename);
      await import_fs.promises.copyFile(file.path, destination);
      publicUrl = `${publicUrl}/${uniqueFilename}`;
      const result = {
        id: (0, import_crypto2.randomUUID)(),
        url: publicUrl,
        name: file.originalname,
        type: file.mimetype,
        size: file.size,
        path: destination
      };
      return result;
    } catch (error) {
      throw new Error(`Erro no upload: ${error.message}`);
    }
  }
  // === UPLOAD MÚLTIPLOS ===
  async uploadMultiple(files, config = {}) {
    const maxFiles = config.maxFiles || 10;
    if (files.length > maxFiles) {
      throw new Error(`M\xE1ximo de ${maxFiles} arquivos permitidos`);
    }
    const results = [];
    for (const file of files) {
      try {
        const result = await this.uploadSingle(file, config);
        results.push(result);
      } catch (error) {
        await this.cleanupFailedUploads(results);
        throw error;
      }
    }
    return results;
  }
  // === LIMPEZA DE ARQUIVOS FALHADOS ===
  async cleanupFailedUploads(uploadedFiles) {
    for (const file of uploadedFiles) {
      try {
        await import_fs.promises.unlink(file.path);
      } catch (error) {
        console.error(`Erro ao deletar arquivo ${file.path}:`, error);
      }
    }
  }
  // === DELETAR ARQUIVO ===
  async deleteFile(filePath) {
    try {
      await import_fs.promises.unlink(filePath);
    } catch (error) {
      throw new Error(`Erro ao deletar arquivo: ${error.message}`);
    }
  }
  // === DELETAR MÚLTIPLOS ARQUIVOS ===
  async deleteMultipleFiles(filePaths) {
    let deleted = 0;
    let failed = 0;
    for (const filePath of filePaths) {
      try {
        await this.deleteFile(filePath);
        deleted++;
      } catch (error) {
        failed++;
        console.error(`Erro ao deletar ${filePath}:`, error);
      }
    }
    return { deleted, failed };
  }
  // === OBTER INFORMAÇÕES DO ARQUIVO ===
  async getFileInfo(filePath) {
    try {
      const stats = await import_fs.promises.stat(filePath);
      return {
        exists: true,
        size: stats.size,
        stats
      };
    } catch (error) {
      return { exists: false };
    }
  }
  // === LISTAR ARQUIVOS DE UMA ENTIDADE ===
  async listEntityFiles(entityType) {
    try {
      const entityDir = import_path.default.join(this.uploadDir, entityType);
      const files = await import_fs.promises.readdir(entityDir);
      return files.filter((file) => {
        const filePath = import_path.default.join(entityDir, file);
        const stats = import_fs.promises.stat(filePath);
        return stats.then((s) => s.isFile()).catch(() => false);
      });
    } catch (error) {
      return [];
    }
  }
  // === LIMPEZA DE ARQUIVOS ÓRFÃOS ===
  async cleanupOrphanedFiles(usedFilePaths) {
    const allFiles = [];
    const directories = ["product", "supplier", "user", "store", "general"];
    for (const dir of directories) {
      const files = await this.listEntityFiles(dir);
      allFiles.push(...files.map((file) => import_path.default.join(this.uploadDir, dir, file)));
    }
    const orphanedFiles = allFiles.filter((file) => !usedFilePaths.includes(file));
    return await this.deleteMultipleFiles(orphanedFiles);
  }
  // === OBTER ESTATÍSTICAS ===
  async getStats() {
    const stats = {
      totalFiles: 0,
      totalSize: 0,
      byEntityType: {},
      byFileType: {}
    };
    const directories = ["product", "supplier", "user", "store", "general"];
    for (const dir of directories) {
      const files = await this.listEntityFiles(dir);
      let dirSize = 0;
      for (const file of files) {
        const filePath = import_path.default.join(this.uploadDir, dir, file);
        const fileInfo = await this.getFileInfo(filePath);
        if (fileInfo.exists && fileInfo.size) {
          dirSize += fileInfo.size;
          stats.totalSize += fileInfo.size;
          stats.totalFiles++;
          const ext = import_path.default.extname(file).toLowerCase();
          stats.byFileType[ext] = (stats.byFileType[ext] || 0) + 1;
        }
      }
      stats.byEntityType[dir] = {
        count: files.length,
        size: dirSize
      };
    }
    return stats;
  }
  // === UTILITÁRIOS ===
  // Verificar se é imagem
  isImage(mimetype) {
    return mimetype.startsWith("image/");
  }
  // Verificar se é vídeo
  isVideo(mimetype) {
    return mimetype.startsWith("video/");
  }
  // Verificar se é documento
  isDocument(mimetype) {
    const documentTypes = [
      "application/pdf",
      "application/msword",
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
      "application/vnd.ms-excel",
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
      "text/plain"
    ];
    return documentTypes.includes(mimetype);
  }
  // Formatar tamanho do arquivo
  formatFileSize(bytes) {
    const sizes = ["B", "KB", "MB", "GB"];
    const i = Math.floor(Math.log(bytes) / Math.log(1024));
    return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + " " + sizes[i];
  }
  // Obter ícone baseado no tipo
  getFileIcon(mimetype) {
    if (mimetype.startsWith("image/")) return "\u{1F5BC}\uFE0F";
    if (mimetype.startsWith("video/")) return "\u{1F3A5}";
    if (mimetype.startsWith("audio/")) return "\u{1F3B5}";
    if (mimetype === "application/pdf") return "\u{1F4D5}";
    if (mimetype.includes("word")) return "\u{1F4DD}";
    if (mimetype.includes("excel") || mimetype.includes("spreadsheet")) return "\u{1F4CA}";
    if (mimetype.includes("powerpoint") || mimetype.includes("presentation")) return "\u{1F4FD}\uFE0F";
    if (mimetype.includes("zip") || mimetype.includes("rar")) return "\u{1F4E6}";
    return "\u{1F4C4}";
  }
};
var uploadService = UploadService.getInstance();

// src/features/upload/upload.controller.ts
var UploadController = {
  // === CRUD BÁSICO ===
  async create(request, reply) {
    try {
      const { name, type, size } = request.body;
      const result = await UploadCommands.create({
        url: "",
        // Será preenchida pelo service
        name,
        type,
        size
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Validation error") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      const result = await UploadQueries.getById(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Media not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      const result = await UploadCommands.update(id, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Media not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Validation error") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      const media = await UploadQueries.getById(id);
      if (!media) {
        return reply.status(404).send({
          error: "Media not found"
        });
      }
      await UploadCommands.delete(id);
      try {
        const filePath = import_path2.default.join(process.cwd(), "src", "uploads", media.url.replace("/uploads/", ""));
        await uploadService.deleteFile(filePath);
      } catch (fileError) {
        request.log.warn(`Arquivo f\xEDsico n\xE3o encontrado: ${media.url}`);
      }
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Media not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { page = 1, limit = 10, search, type, entityType, entityId } = request.query;
      const result = await UploadQueries.list({
        page,
        limit,
        search,
        type,
        entityType,
        entityId
      });
      const protocol = request.headers["x-forwarded-proto"] || request.server.https ? "https" : "http";
      const host = request.headers["x-forwarded-host"] || request.headers.host || "localhost:3000";
      const responseData = {
        ...result,
        uploads: result.uploads?.map((upload) => ({
          ...upload,
          fullUrl: `${protocol}://${host}${upload.url}`
        })) || []
      };
      return reply.send(responseData);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (QUERIES) ===
  async getByType(request, reply) {
    try {
      const { type, limit = 10 } = request.query;
      const result = await UploadQueries.getByType(type, limit);
      const protocol = request.headers["x-forwarded-proto"] || request.server.https ? "https" : "http";
      const host = request.headers["x-forwarded-host"] || request.headers.host || "localhost:3000";
      const uploadsWithFullUrl = result.map((upload) => ({
        ...upload,
        fullUrl: `${protocol}://${host}${upload.url}`
      }));
      return reply.send({ uploads: uploadsWithFullUrl });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getRecent(request, reply) {
    try {
      const { limit = 20 } = request.query;
      const result = await UploadQueries.getRecent(limit);
      const protocol = request.headers["x-forwarded-proto"] || request.server.https ? "https" : "http";
      const host = request.headers["x-forwarded-host"] || request.headers.host || "localhost:3000";
      const uploadsWithFullUrl = result.map((upload) => ({
        ...upload,
        fullUrl: `${protocol}://${host}${upload.url}`
      }));
      return reply.send({ uploads: uploadsWithFullUrl });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getEntityMedia(request, reply) {
    try {
      const { entityType, entityId } = request.params;
      const result = await UploadQueries.getEntityMedia(entityType, entityId);
      const protocol = request.headers["x-forwarded-proto"] || request.server.https ? "https" : "http";
      const host = request.headers["x-forwarded-host"] || request.headers.host || "localhost:3000";
      const mediaWithFullUrl = result.map((media) => ({
        ...media,
        fullUrl: `${protocol}://${host}${media.url}`
      }));
      return reply.send({ media: mediaWithFullUrl });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invalid entity type") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getPrimaryMedia(request, reply) {
    try {
      const { entityType, entityId } = request.params;
      const result = await UploadQueries.getPrimaryMedia(entityType, entityId);
      if (!result) {
        return reply.status(404).send({
          error: "No media found"
        });
      }
      const protocol = request.headers["x-forwarded-proto"] || request.server.https ? "https" : "http";
      const host = request.headers["x-forwarded-host"] || request.headers.host || "localhost:3000";
      const resultWithFullUrl = {
        ...result,
        fullUrl: `${protocol}://${host}${result.url}`
      };
      return reply.send(resultWithFullUrl);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invalid entity type") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const result = await UploadQueries.getStats();
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { q, limit = 10 } = request.query;
      const result = await UploadQueries.search(q, limit);
      const protocol = request.headers["x-forwarded-proto"] || request.server.https ? "https" : "http";
      const host = request.headers["x-forwarded-host"] || request.headers.host || "localhost:3000";
      const uploadsWithFullUrl = result.map((upload) => ({
        ...upload,
        fullUrl: `${protocol}://${host}${upload.url}`
      }));
      return reply.send({ uploads: uploadsWithFullUrl });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getMediaUsage(request, reply) {
    try {
      const { id } = request.params;
      const result = await UploadQueries.getMediaUsage(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getUnusedMedia(request, reply) {
    try {
      const { daysOld = 30 } = request.query;
      const result = await UploadQueries.getUnusedMedia(daysOld);
      const protocol = request.headers["x-forwarded-proto"] || request.server.https ? "https" : "http";
      const host = request.headers["x-forwarded-host"] || request.headers.host || "localhost:3000";
      const uploadsWithFullUrl = result.map((upload) => ({
        ...upload,
        fullUrl: `${protocol}://${host}${upload.url}`
      }));
      return reply.send({ uploads: uploadsWithFullUrl });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (COMMANDS) ===
  async attachMedia(request, reply) {
    try {
      const { id } = request.params;
      const { entityType, entityId, isPrimary } = request.body;
      let result;
      switch (entityType) {
        case "product":
          result = await UploadCommands.attachToProduct({
            mediaId: id,
            entityType,
            entityId,
            isPrimary
          });
          break;
        case "supplier":
          result = await UploadCommands.attachToSupplier({
            mediaId: id,
            entityType,
            entityId
          });
          break;
        case "user":
          result = await UploadCommands.attachToUser({
            mediaId: id,
            entityType,
            entityId
          });
          break;
        case "store":
          result = await UploadCommands.attachToStore({
            mediaId: id,
            entityType,
            entityId
          });
          break;
        default:
          return reply.status(400).send({
            error: "Invalid entity type"
          });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invalid entity type for attachment") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async detachMedia(request, reply) {
    try {
      const { id } = request.params;
      const { entityType, entityId } = request.body;
      let result;
      switch (entityType) {
        case "product":
          result = await UploadCommands.detachFromProduct(id, entityId);
          break;
        case "supplier":
          result = await UploadCommands.detachFromSupplier(id, entityId);
          break;
        case "user":
          result = await UploadCommands.detachFromUser(id, entityId);
          break;
        case "store":
          result = await UploadCommands.detachFromStore(id, entityId);
          break;
        default:
          return reply.status(400).send({
            error: "Invalid entity type"
          });
      }
      return reply.send({ success: true });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Media attachment not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async setPrimaryMedia(request, reply) {
    try {
      const { id } = request.params;
      const { entityType, entityId } = request.body;
      let result;
      if (entityType === "product") {
        result = await UploadCommands.setPrimaryForProduct(id, entityId);
      } else {
        return reply.status(400).send({
          error: "Primary media is only supported for products"
        });
      }
      return reply.send({ success: true });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Media not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async bulkDelete(request, reply) {
    try {
      const { mediaIds } = request.body;
      const result = await UploadCommands.bulkDelete(mediaIds);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === UPLOAD DE ARQUIVOS FÍSICOS ===
  async uploadSingle(request, reply) {
    try {
      const data = await request.file();
      if (!data) {
        return reply.status(400).send({
          error: "Nenhum arquivo enviado"
        });
      }
      console.log("Estrutura do objeto data:", JSON.stringify({
        fieldname: data.fieldname,
        filename: data.filename,
        mimetype: data.mimetype,
        encoding: data.encoding,
        hasFile: !!data.file,
        fileKeys: data.file ? Object.keys(data.file) : "no file object",
        filePath: data.file?.path,
        fileFilename: data.file?.filename,
        // Verificar se é um stream
        isStream: data.file?.toBuffer ? "yes" : "no",
        // Verificar outras propriedades possíveis
        allKeys: Object.keys(data)
      }, null, 2));
      const { entityType = "general" } = request.body || request.query;
      const userId = request.user?.id;
      if (!userId) {
        return reply.status(401).send({
          error: "Usu\xE1rio n\xE3o autenticado"
        });
      }
      let filePath;
      let fileSize = 0;
      if (data.toBuffer) {
        console.log("Convertendo stream para buffer usando data.toBuffer...");
        const buffer = await data.toBuffer();
        fileSize = buffer.length;
        const tempPath = require("path").join(require("os").tmpdir(), `temp-${Date.now()}-${data.filename}`);
        await require("fs").promises.writeFile(tempPath, buffer);
        filePath = tempPath;
        console.log(`Arquivo tempor\xE1rio criado: ${tempPath}`);
      } else if (data.file && data.file.toBuffer) {
        console.log("Convertendo stream para buffer usando data.file.toBuffer...");
        const buffer = await data.file.toBuffer();
        fileSize = buffer.length;
        const tempPath = require("path").join(require("os").tmpdir(), `temp-${Date.now()}-${data.filename}`);
        await require("fs").promises.writeFile(tempPath, buffer);
        filePath = tempPath;
        console.log(`Arquivo tempor\xE1rio criado: ${tempPath}`);
      } else if (data.file && data.file.bytesRead) {
        filePath = data.file.path || data.file.filepath || data.file.filename;
        fileSize = data.file.bytesRead;
      } else {
        filePath = data.path || data.filepath || data.filename;
        fileSize = data.size || data.bytesRead || 0;
      }
      const fileData = {
        fieldname: data.fieldname || "file",
        filename: data.filename || "unknown",
        originalname: data.filename || "unknown",
        encoding: data.encoding || "7bit",
        mimetype: data.mimetype || "application/octet-stream",
        size: fileSize,
        destination: "",
        // Será definido pelo service
        path: filePath,
        url: ""
        // Será definido pelo service
      };
      if (!fileData.path) {
        console.error("Estrutura completa do data:", JSON.stringify(data, null, 2));
        return reply.status(400).send({
          error: "N\xE3o foi poss\xEDvel determinar o caminho do arquivo. Estrutura do objeto inesperada."
        });
      }
      const uploadResult = await uploadService.uploadSingle(fileData, {
        entityType,
        userId
      });
      const dbResult = await UploadCommands.create({
        url: uploadResult.url,
        name: uploadResult.name,
        type: uploadResult.type,
        size: uploadResult.size
      });
      if (filePath && filePath.includes("temp-")) {
        try {
          await require("fs").promises.unlink(filePath);
          console.log(`Arquivo tempor\xE1rio removido: ${filePath}`);
        } catch (cleanupError) {
          console.warn(`Erro ao remover arquivo tempor\xE1rio ${filePath}:`, cleanupError);
        }
      }
      const protocol = request.headers["x-forwarded-proto"] || request.server.https ? "https" : "http";
      const host = request.headers["x-forwarded-host"] || request.headers.host || "localhost:3000";
      const fullUrl = `${protocol}://${host}${uploadResult.url}`;
      return reply.status(201).send({
        ...dbResult,
        path: uploadResult.path,
        fullUrl
      });
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("n\xE3o permitido") || error.message.includes("muito grande")) {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async uploadMultiple(request, reply) {
    try {
      const files = request.files();
      const uploadedFiles = [];
      const { entityType = "general", maxFiles = 10 } = request.body || request.query;
      const userId = request.user?.id;
      if (!userId) {
        return reply.status(401).send({
          error: "Usu\xE1rio n\xE3o autenticado"
        });
      }
      for await (const file of files) {
        if (file.file) {
          const fileData = {
            fieldname: file.fieldname,
            filename: file.filename,
            originalname: file.filename,
            encoding: file.encoding,
            mimetype: file.mimetype,
            size: file.file.bytesRead,
            destination: "",
            // Será definido pelo service
            path: file.file.path || file.file.filename,
            // Usar filename se path não estiver disponível
            url: ""
            // Será definido pelo service
          };
          uploadedFiles.push(fileData);
        }
      }
      if (uploadedFiles.length === 0) {
        return reply.status(400).send({
          error: "Nenhum arquivo v\xE1lido enviado"
        });
      }
      const uploadResults = await uploadService.uploadMultiple(uploadedFiles, {
        entityType,
        userId,
        maxFiles
      });
      const dbResults = [];
      for (const uploadResult of uploadResults) {
        const dbResult = await UploadCommands.create({
          url: uploadResult.url,
          name: uploadResult.name,
          type: uploadResult.type,
          size: uploadResult.size
        });
        const protocol = request.headers["x-forwarded-proto"] || request.server.https ? "https" : "http";
        const host = request.headers["x-forwarded-host"] || request.headers.host || "localhost:3000";
        const fullUrl = `${protocol}://${host}${uploadResult.url}`;
        dbResults.push({
          ...dbResult,
          path: uploadResult.path,
          fullUrl
        });
      }
      return reply.status(201).send({
        uploads: dbResults,
        count: dbResults.length
      });
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("n\xE3o permitido") || error.message.includes("muito grande") || error.message.includes("M\xE1ximo")) {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === SERVIÇOS DE MANUTENÇÃO ===
  async cleanupOrphanedFiles(request, reply) {
    try {
      const usedFiles = await UploadQueries.getAllUsedFilePaths();
      const result = await uploadService.cleanupOrphanedFiles(usedFiles);
      return reply.send({
        message: "Limpeza conclu\xEDda",
        ...result
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getServiceConfig(request, reply) {
    try {
      const config = {
        maxFileSize: 10 * 1024 * 1024,
        // 10MB
        maxFiles: 10,
        allowedTypes: [
          "image/jpeg",
          "image/png",
          "image/gif",
          "image/webp",
          "image/svg+xml",
          "application/pdf",
          "application/msword",
          "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
          "application/vnd.ms-excel",
          "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
          "text/plain"
        ],
        uploadDir: uploadService["uploadDir"],
        entityTypes: ["product", "supplier", "user", "store", "general"]
      };
      return reply.send(config);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getFileSystemStats(request, reply) {
    try {
      const stats = await uploadService.getStats();
      return reply.send(stats);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/upload/upload.schema.ts
var createUploadSchema = {
  body: {
    type: "object",
    properties: {
      name: { type: "string", minLength: 1, maxLength: 255 },
      type: { type: "string", minLength: 1, maxLength: 100 },
      size: { type: "number", minimum: 0 }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        url: { type: "string" },
        name: { type: "string", nullable: true },
        type: { type: "string", nullable: true },
        size: { type: "number", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var listUploadsSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      type: { type: "string" },
      entityType: {
        type: "string",
        enum: ["product", "supplier", "user", "store"]
      },
      entityId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        uploads: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              url: { type: "string" },
              name: { type: "string", nullable: true },
              type: { type: "string", nullable: true },
              size: { type: "number", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getEntityMediaSchema = {
  params: {
    type: "object",
    required: ["entityType", "entityId"],
    properties: {
      entityType: {
        type: "string",
        enum: ["product", "supplier", "user", "store"]
      },
      entityId: { type: "string", minLength: 1 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        media: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              mediaId: { type: "string" },
              entityType: { type: "string" },
              entityId: { type: "string" },
              isPrimary: { type: "boolean", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              media: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  url: { type: "string" },
                  name: { type: "string", nullable: true },
                  type: { type: "string", nullable: true },
                  size: { type: "number", nullable: true }
                }
              }
            }
          }
        }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};

// src/features/upload/upload.route.ts
async function UploadRoutes(fastify2) {
  fastify2.addHook("preHandler", authMiddleware);
  fastify2.addHook("preHandler", storeContextMiddleware);
  await fastify2.register(require("@fastify/multipart"), {
    limits: {
      fileSize: 10 * 1024 * 1024,
      // 10MB
      files: 10
      // máximo 10 arquivos por request
    },
    attachFieldsToBody: false,
    // Manter arquivos separados do body
    sharedSchemaId: "MultipartFileType"
    // Schema para validação
  });
  fastify2.post("/", {
    schema: createUploadSchema,
    handler: UploadController.create
  });
  fastify2.get("/", {
    schema: listUploadsSchema,
    handler: UploadController.list
  });
  fastify2.get("/:id", {
    handler: UploadController.get
  });
  fastify2.put("/:id", {
    handler: UploadController.update
  });
  fastify2.delete("/:id", {
    handler: UploadController.delete
  });
  fastify2.post("/upload", {
    handler: UploadController.uploadSingle
  });
  fastify2.post("/upload-multiple", {
    handler: UploadController.uploadMultiple
  });
  fastify2.get("/type/:type", {
    handler: UploadController.getByType
  });
  fastify2.get("/recent", {
    handler: UploadController.getRecent
  });
  fastify2.get("/stats", {
    handler: UploadController.getStats
  });
  fastify2.get("/search", {
    handler: UploadController.search
  });
  fastify2.get("/:id/usage", {
    handler: UploadController.getMediaUsage
  });
  fastify2.get("/unused", {
    handler: UploadController.getUnusedMedia
  });
  fastify2.post("/:id/attach", {
    handler: UploadController.attachMedia
  });
  fastify2.post("/:id/detach", {
    handler: UploadController.detachMedia
  });
  fastify2.patch("/:id/set-primary", {
    handler: UploadController.setPrimaryMedia
  });
  fastify2.get("/entity/:entityType/:entityId", {
    schema: getEntityMediaSchema,
    handler: UploadController.getEntityMedia
  });
  fastify2.get("/entity/:entityType/:entityId/primary", {
    handler: UploadController.getPrimaryMedia
  });
  fastify2.post("/bulk-delete", {
    handler: UploadController.bulkDelete
  });
  fastify2.post("/cleanup-orphaned", {
    handler: UploadController.cleanupOrphanedFiles
  });
  fastify2.get("/service/config", {
    handler: UploadController.getServiceConfig
  });
  fastify2.get("/service/stats", {
    handler: UploadController.getFileSystemStats
  });
}

// src/features/quote/commands/quote.commands.ts
init_prisma();
var import_library = require("@prisma/client/runtime/library");
var QuoteCommands = {
  async create(data) {
    const { items, installments, ...quoteData } = data;
    const productIds = items.map((item) => item.productId);
    const existingProducts = await db.product.findMany({
      where: { id: { in: productIds } },
      select: { id: true, name: true }
    });
    if (existingProducts.length !== productIds.length) {
      const foundIds = existingProducts.map((p) => p.id);
      const notFoundIds = productIds.filter((id) => !foundIds.includes(id));
      throw new Error(`Products not found: ${notFoundIds.join(", ")}`);
    }
    let subtotal = new import_library.Decimal(0);
    const itemsWithSubtotal = items.map((item) => {
      const itemSubtotal = new import_library.Decimal(item.quantity * item.unitPrice).minus(item.discount || 0);
      subtotal = subtotal.plus(itemSubtotal);
      return {
        ...item,
        subtotal: itemSubtotal.toNumber()
      };
    });
    const total = subtotal.minus(quoteData.discount || 0).plus(quoteData.interest || 0);
    const quote = await db.quote.create({
      data: {
        ...quoteData,
        subtotal: new import_library.Decimal(subtotal),
        total: new import_library.Decimal(total),
        expiresAt: quoteData.expiresAt ? new Date(quoteData.expiresAt) : null,
        items: {
          create: itemsWithSubtotal.map((item) => ({
            productId: item.productId,
            quantity: item.quantity,
            unitPrice: item.unitPrice,
            subtotal: new import_library.Decimal(item.subtotal),
            discount: item.discount,
            note: item.note
          }))
        },
        ...installments && installments.length > 0 && {
          installments: {
            create: installments.map((installment) => ({
              number: installment.number,
              dueDate: new Date(installment.dueDate),
              amount: new import_library.Decimal(installment.amount),
              interest: installment.interest ? new import_library.Decimal(installment.interest) : null
            }))
          }
        }
      },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                unitOfMeasure: true,
                referencePrice: true
              }
            }
          }
        },
        installments: true,
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    return quote;
  },
  async update(id, data) {
    const existingQuote = await db.quote.findUnique({
      where: { id },
      include: { items: true, installments: true }
    });
    if (!existingQuote) {
      throw new Error("Quote not found");
    }
    if (existingQuote.status !== "DRAFT") {
      throw new Error("Only DRAFT quotes can be updated");
    }
    const { items, installments, ...updateData } = data;
    let subtotal = existingQuote.subtotal;
    let total = existingQuote.total;
    if (items) {
      const productIds = items.map((item) => item.productId);
      const existingProducts = await db.product.findMany({
        where: { id: { in: productIds } },
        select: { id: true }
      });
      if (existingProducts.length !== productIds.length) {
        const foundIds = existingProducts.map((p) => p.id);
        const notFoundIds = productIds.filter((id2) => !foundIds.includes(id2));
        throw new Error(`Products not found: ${notFoundIds.join(", ")}`);
      }
      subtotal = new import_library.Decimal(0);
      const itemsWithSubtotal = items.map((item) => {
        const itemSubtotal = new import_library.Decimal(item.quantity * item.unitPrice).minus(item.discount || 0);
        subtotal = subtotal.plus(itemSubtotal);
        return {
          ...item,
          subtotal: itemSubtotal.toNumber()
        };
      });
      const discount = updateData.discount || existingQuote.discount || 0;
      const interest = updateData.interest || existingQuote.interest || 0;
      total = subtotal.minus(discount).plus(interest);
    }
    const quote = await db.quote.update({
      where: { id },
      data: {
        ...updateData,
        subtotal: new import_library.Decimal(subtotal),
        total: new import_library.Decimal(total),
        expiresAt: updateData.expiresAt ? new Date(updateData.expiresAt) : void 0,
        ...items && {
          items: {
            deleteMany: {},
            create: items.map((item) => ({
              productId: item.productId,
              quantity: item.quantity,
              unitPrice: item.unitPrice,
              subtotal: new import_library.Decimal(item.quantity * item.unitPrice - (item.discount || 0)),
              discount: item.discount,
              note: item.note
            }))
          }
        },
        ...installments && {
          installments: {
            deleteMany: {},
            create: installments.map((installment) => ({
              number: installment.number,
              dueDate: new Date(installment.dueDate),
              amount: new import_library.Decimal(installment.amount),
              interest: installment.interest ? new import_library.Decimal(installment.interest) : null
            }))
          }
        }
      },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                unitOfMeasure: true,
                referencePrice: true
              }
            }
          }
        },
        installments: true,
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    return quote;
  },
  async delete(id) {
    const quote = await db.quote.findUnique({
      where: { id }
    });
    if (!quote) {
      throw new Error("Quote not found");
    }
    if (quote.status !== "DRAFT" && quote.status !== "CANCELED") {
      throw new Error("Only DRAFT or CANCELED quotes can be deleted");
    }
    return await db.quote.delete({
      where: { id }
    });
  },
  async updateStatus(id, status) {
    const quote = await db.quote.findUnique({
      where: { id }
    });
    if (!quote) {
      throw new Error("Quote not found");
    }
    return await db.quote.update({
      where: { id },
      data: { status },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                unitOfMeasure: true,
                referencePrice: true
              }
            }
          }
        },
        installments: true,
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async approve(publicId, authCode) {
    const quote = await db.quote.findFirst({
      where: {
        publicId,
        authCode,
        status: { in: ["PUBLISHED", "SENT", "VIEWED"] }
      },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                storeId: true
              }
            }
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    if (!quote) {
      throw new Error("Quote not found or not available for approval");
    }
    if (quote.expiresAt && /* @__PURE__ */ new Date() > quote.expiresAt) {
      throw new Error("Quote has expired");
    }
    const movements = await this.convertToMovements(quote.id);
    await db.quote.update({
      where: { id: quote.id },
      data: { status: "APPROVED" }
    });
    return {
      quote: {
        ...quote,
        status: "APPROVED"
      },
      movements
    };
  },
  async reject(publicId, authCode, reason) {
    const quote = await db.quote.findFirst({
      where: {
        publicId,
        authCode,
        status: { in: ["PUBLISHED", "SENT", "VIEWED"] }
      }
    });
    if (!quote) {
      throw new Error("Quote not found or not available for rejection");
    }
    const updatedQuote = await db.quote.update({
      where: { id: quote.id },
      data: {
        status: "REJECTED",
        observations: reason ? `${quote.observations || ""}
Rejection reason: ${reason}`.trim() : quote.observations
      },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                unitOfMeasure: true,
                referencePrice: true
              }
            }
          }
        },
        installments: true,
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    return updatedQuote;
  },
  async convertToMovements(quoteId) {
    const quote = await db.quote.findUnique({
      where: { id: quoteId },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                storeId: true
              }
            }
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    if (!quote) {
      throw new Error("Quote not found");
    }
    if (!["PUBLISHED", "SENT", "VIEWED", "APPROVED"].includes(quote.status)) {
      throw new Error("Quote cannot be converted to movements");
    }
    const movements = [];
    for (const item of quote.items) {
      try {
        const movement = await MovementCommands.create({
          type: "SAIDA",
          quantity: item.quantity,
          storeId: item.product.storeId,
          productId: item.productId,
          note: `Quote conversion - ${quote.title} (Item: ${item.product.name})`,
          userId: quote.userId
        });
        movements.push(movement);
      } catch (error) {
        console.error(`Error creating movement for item ${item.id}:`, error);
        throw new Error(`Failed to create movement for product ${item.product.name}`);
      }
    }
    await db.quote.update({
      where: { id: quoteId },
      data: { status: "CONVERTED" }
    });
    return movements;
  },
  async publish(id) {
    const quote = await db.quote.findUnique({
      where: { id }
    });
    if (!quote) {
      throw new Error("Quote not found");
    }
    if (quote.status !== "DRAFT") {
      throw new Error("Only DRAFT quotes can be published");
    }
    return await db.quote.update({
      where: { id },
      data: { status: "PUBLISHED" },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                unitOfMeasure: true,
                referencePrice: true
              }
            }
          }
        },
        installments: true,
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async send(id) {
    const quote = await db.quote.findUnique({
      where: { id }
    });
    if (!quote) {
      throw new Error("Quote not found");
    }
    if (quote.status !== "PUBLISHED") {
      throw new Error("Only PUBLISHED quotes can be sent");
    }
    return await db.quote.update({
      where: { id },
      data: { status: "SENT" },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                unitOfMeasure: true,
                referencePrice: true
              }
            }
          }
        },
        installments: true,
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  }
};

// src/features/quote/queries/quote.queries.ts
init_prisma();
var QuoteQueries = {
  async getById(id) {
    const quote = await db.quote.findUnique({
      where: { id },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                unitOfMeasure: true,
                referencePrice: true
              }
            }
          }
        },
        installments: true,
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    return quote;
  },
  async getByPublicId(publicId, authCode) {
    const quote = await db.quote.findFirst({
      where: {
        publicId,
        authCode
      },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                unitOfMeasure: true
              }
            }
          }
        },
        installments: true,
        user: {
          select: {
            name: true
          }
        }
      }
    });
    return quote;
  },
  async list(params) {
    const { page = 1, limit = 10, search, status, userId, startDate, endDate } = params;
    const skip = (page - 1) * limit;
    const where = {};
    if (status) {
      where.status = status;
    }
    if (userId) {
      where.userId = userId;
    }
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) {
        where.createdAt.gte = new Date(startDate);
      }
      if (endDate) {
        where.createdAt.lte = new Date(endDate);
      }
    }
    if (search) {
      where.OR = [
        { title: { contains: search, mode: "insensitive" } },
        { description: { contains: search, mode: "insensitive" } }
      ];
    }
    const [quotes, total] = await Promise.all([
      db.quote.findMany({
        where,
        skip,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          items: {
            include: {
              product: {
                select: {
                  id: true,
                  name: true,
                  description: true,
                  unitOfMeasure: true,
                  referencePrice: true
                }
              }
            }
          },
          installments: true,
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      }),
      db.quote.count({ where })
    ]);
    return {
      items: quotes,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getByUser(userId, params) {
    const { page = 1, limit = 10, status } = params;
    const skip = (page - 1) * limit;
    const where = { userId };
    if (status) {
      where.status = status;
    }
    const [quotes, total] = await Promise.all([
      db.quote.findMany({
        where,
        skip,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          items: {
            include: {
              product: {
                select: {
                  id: true,
                  name: true,
                  description: true,
                  unitOfMeasure: true,
                  referencePrice: true
                }
              }
            }
          },
          installments: true,
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      }),
      db.quote.count({ where })
    ]);
    return {
      items: quotes,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getByStatus(status, params) {
    const { page = 1, limit = 10, userId } = params;
    const skip = (page - 1) * limit;
    const where = { status };
    if (userId) {
      where.userId = userId;
    }
    const [quotes, total] = await Promise.all([
      db.quote.findMany({
        where,
        skip,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          items: {
            include: {
              product: {
                select: {
                  id: true,
                  name: true,
                  description: true,
                  unitOfMeasure: true,
                  referencePrice: true
                }
              }
            }
          },
          installments: true,
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      }),
      db.quote.count({ where })
    ]);
    return {
      items: quotes,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getStats(userId) {
    const where = userId ? { userId } : {};
    const [
      total,
      draft,
      published,
      sent,
      viewed,
      approved,
      rejected,
      expired,
      converted,
      canceled,
      totalValue,
      averageValue,
      recentCount
    ] = await Promise.all([
      db.quote.count({ where }),
      db.quote.count({ where: { ...where, status: "DRAFT" } }),
      db.quote.count({ where: { ...where, status: "PUBLISHED" } }),
      db.quote.count({ where: { ...where, status: "SENT" } }),
      db.quote.count({ where: { ...where, status: "VIEWED" } }),
      db.quote.count({ where: { ...where, status: "APPROVED" } }),
      db.quote.count({ where: { ...where, status: "REJECTED" } }),
      db.quote.count({ where: { ...where, status: "EXPIRED" } }),
      db.quote.count({ where: { ...where, status: "CONVERTED" } }),
      db.quote.count({ where: { ...where, status: "CANCELED" } }),
      db.quote.aggregate({
        where,
        _sum: { total: true }
      }),
      db.quote.aggregate({
        where,
        _avg: { total: true }
      }),
      db.quote.count({
        where: {
          ...where,
          createdAt: {
            gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3)
            // últimos 30 dias
          }
        }
      })
    ]);
    return {
      total,
      byStatus: {
        DRAFT: draft,
        PUBLISHED: published,
        SENT: sent,
        VIEWED: viewed,
        APPROVED: approved,
        REJECTED: rejected,
        EXPIRED: expired,
        CONVERTED: converted,
        CANCELED: canceled
      },
      totalValue: totalValue._sum.total || 0,
      averageValue: averageValue._avg.total || 0,
      recentCount
    };
  },
  async search(term, limit = 10, userId) {
    const where = {
      OR: [
        { title: { contains: term, mode: "insensitive" } },
        { description: { contains: term, mode: "insensitive" } },
        { observations: { contains: term, mode: "insensitive" } }
      ]
    };
    if (userId) {
      where.userId = userId;
    }
    const quotes = await db.quote.findMany({
      where,
      take: limit,
      orderBy: { createdAt: "desc" },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                unitOfMeasure: true,
                referencePrice: true
              }
            }
          }
        },
        installments: true,
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    return quotes;
  },
  async getExpiredQuotes() {
    const now = /* @__PURE__ */ new Date();
    const quotes = await db.quote.findMany({
      where: {
        expiresAt: {
          lt: now
        },
        status: {
          in: ["PUBLISHED", "SENT", "VIEWED"]
        }
      },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true
              }
            }
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    return quotes;
  },
  async markAsExpired() {
    const now = /* @__PURE__ */ new Date();
    const result = await db.quote.updateMany({
      where: {
        expiresAt: {
          lt: now
        },
        status: {
          in: ["PUBLISHED", "SENT", "VIEWED"]
        }
      },
      data: {
        status: "EXPIRED"
      }
    });
    return result.count;
  },
  async getRecentQuotes(limit = 5, userId) {
    const where = userId ? { userId } : {};
    const quotes = await db.quote.findMany({
      where,
      take: limit,
      orderBy: { createdAt: "desc" },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true
              }
            }
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    return quotes;
  },
  async getQuoteAnalytics(quoteId) {
    const quote = await db.quote.findUnique({
      where: { id: quoteId },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                unitOfMeasure: true
              }
            }
          }
        },
        installments: true,
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    if (!quote) {
      throw new Error("Quote not found");
    }
    const totalItems = quote.items.length;
    const totalQuantity = quote.items.reduce((sum, item) => sum + item.quantity, 0);
    const totalInstallments = quote.installments.length;
    const averageItemValue = quote.items.length > 0 ? quote.total / quote.items.length : 0;
    const isExpired = quote.expiresAt ? /* @__PURE__ */ new Date() > quote.expiresAt : false;
    const daysUntilExpiry = quote.expiresAt ? Math.ceil((quote.expiresAt.getTime() - (/* @__PURE__ */ new Date()).getTime()) / (1e3 * 60 * 60 * 24)) : null;
    return {
      quote,
      analytics: {
        totalItems,
        totalQuantity,
        totalInstallments,
        averageItemValue,
        isExpired,
        daysUntilExpiry,
        status: quote.status,
        createdAt: quote.createdAt,
        updatedAt: quote.updatedAt
      }
    };
  }
};

// src/features/quote/quote.controller.ts
var QuoteController = {
  // === CRUD BÁSICO ===
  async create(request, reply) {
    try {
      const { title, description, paymentType, paymentTerms, paymentDueDays, expiresAt, observations, discount, interest, items, installments } = request.body;
      const userId = request.user?.id;
      if (!userId) {
        return reply.status(401).send({
          error: "Authentication required"
        });
      }
      const result = await QuoteCommands.create({
        userId,
        title,
        description,
        paymentType,
        paymentTerms,
        paymentDueDays,
        expiresAt,
        observations,
        discount,
        interest,
        items,
        installments
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("Products not found")) {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      const result = await QuoteQueries.getById(id);
      if (!result) {
        return reply.status(404).send({
          error: "Quote not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Quote not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      const result = await QuoteCommands.update(id, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Quote not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Only DRAFT quotes can be updated") {
        return reply.status(400).send({
          error: error.message
        });
      }
      if (error.message.includes("Products not found")) {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      await QuoteCommands.delete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Quote not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Only DRAFT or CANCELED quotes can be deleted") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { page = 1, limit = 10, search, status, userId, startDate, endDate } = request.query;
      const result = await QuoteQueries.list({
        page,
        limit,
        search,
        status,
        userId,
        startDate,
        endDate
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES PÚBLICAS (sem autenticação) ===
  async getPublic(request, reply) {
    try {
      const { publicId } = request.params;
      const { authCode } = request.query;
      const result = await QuoteQueries.getByPublicId(publicId, authCode);
      if (!result) {
        return reply.status(404).send({
          error: "Quote not found or invalid authorization code"
        });
      }
      if (result.expiresAt && /* @__PURE__ */ new Date() > result.expiresAt) {
        return reply.status(410).send({
          error: "Quote has expired"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Quote not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async approvePublic(request, reply) {
    try {
      const { publicId } = request.params;
      const { authCode } = request.body;
      const result = await QuoteCommands.approve(publicId, authCode);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Quote not found or not available for approval") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Quote has expired") {
        return reply.status(410).send({
          error: error.message
        });
      }
      if (error.message.includes("Failed to create movement")) {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async rejectPublic(request, reply) {
    try {
      const { publicId } = request.params;
      const { authCode, reason } = request.body;
      const result = await QuoteCommands.reject(publicId, authCode, reason);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Quote not found or not available for rejection") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (autenticadas) ===
  async updateStatus(request, reply) {
    try {
      const { id } = request.params;
      const { status } = request.body;
      const result = await QuoteCommands.updateStatus(id, status);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Quote not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async publish(request, reply) {
    try {
      const { id } = request.params;
      const result = await QuoteCommands.publish(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Quote not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Only DRAFT quotes can be published") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async send(request, reply) {
    try {
      const { id } = request.params;
      const result = await QuoteCommands.send(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Quote not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Only PUBLISHED quotes can be sent") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async convertToMovements(request, reply) {
    try {
      const { id } = request.params;
      const movements = await QuoteCommands.convertToMovements(id);
      return reply.send({
        message: "Quote converted to movements successfully",
        movements
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Quote not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Quote cannot be converted to movements") {
        return reply.status(400).send({
          error: error.message
        });
      }
      if (error.message.includes("Failed to create movement")) {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const { userId } = request.query;
      const result = await QuoteQueries.getStats(userId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByUser(request, reply) {
    try {
      const { userId } = request.params;
      const { page = 1, limit = 10, status } = request.query;
      const result = await QuoteQueries.getByUser(userId, {
        page,
        limit,
        status
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { q, limit = 10, userId } = request.query;
      const result = await QuoteQueries.search(q, limit, userId);
      return reply.send({ quotes: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByStatus(request, reply) {
    try {
      const { status } = request.params;
      const { page = 1, limit = 10, userId } = request.query;
      const result = await QuoteQueries.getByStatus(status, {
        page,
        limit,
        userId
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getRecent(request, reply) {
    try {
      const { limit = 5, userId } = request.query;
      const result = await QuoteQueries.getRecentQuotes(limit, userId);
      return reply.send({ quotes: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getAnalytics(request, reply) {
    try {
      const { id } = request.params;
      const result = await QuoteQueries.getQuoteAnalytics(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Quote not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async markExpired(request, reply) {
    try {
      const count = await QuoteQueries.markAsExpired();
      return reply.send({
        message: `${count} quotes marked as expired`,
        expiredCount: count
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/quote/quote.schema.ts
var createQuoteSchema = {
  body: {
    type: "object",
    required: ["title", "paymentType", "items"],
    properties: {
      title: { type: "string", minLength: 1 },
      description: { type: "string" },
      paymentType: {
        type: "string",
        enum: ["UNDEFINED", "PIX", "BOLETO", "CREDIT_CARD", "CASH", "TRANSFER"]
      },
      paymentTerms: { type: "string" },
      paymentDueDays: { type: "number", minimum: 1 },
      expiresAt: { type: "string", format: "date-time" },
      observations: { type: "string" },
      discount: { type: "number", minimum: 0 },
      interest: { type: "number", minimum: 0 },
      items: {
        type: "array",
        minItems: 1,
        items: {
          type: "object",
          required: ["productId", "quantity", "unitPrice"],
          properties: {
            productId: { type: "string", minLength: 1 },
            quantity: { type: "number", minimum: 0.01 },
            unitPrice: { type: "number", minimum: 0.01 },
            discount: { type: "number", minimum: 0 },
            note: { type: "string" }
          }
        }
      },
      installments: {
        type: "array",
        items: {
          type: "object",
          required: ["number", "dueDate", "amount"],
          properties: {
            number: { type: "number", minimum: 1 },
            dueDate: { type: "string", format: "date-time" },
            amount: { type: "number", minimum: 0.01 },
            interest: { type: "number", minimum: 0 }
          }
        }
      }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        title: { type: "string" },
        description: { type: "string", nullable: true },
        publicId: { type: "string" },
        authCode: { type: "string" },
        status: { type: "string" },
        total: { type: "number" },
        subtotal: { type: "number" },
        discount: { type: "number", nullable: true },
        interest: { type: "number", nullable: true },
        paymentType: { type: "string" },
        paymentTerms: { type: "string", nullable: true },
        paymentDueDays: { type: "number", nullable: true },
        expiresAt: { type: "string", format: "date-time", nullable: true },
        observations: { type: "string", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              productId: { type: "string" },
              quantity: { type: "number" },
              unitPrice: { type: "number" },
              subtotal: { type: "number" },
              discount: { type: "number", nullable: true },
              note: { type: "string", nullable: true },
              product: { type: "object" }
            }
          }
        },
        installments: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              number: { type: "number" },
              dueDate: { type: "string", format: "date-time" },
              amount: { type: "number" },
              interest: { type: "number", nullable: true }
            }
          }
        },
        user: { type: "object" }
      }
    }
  }
};
var updateQuoteSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      title: { type: "string", minLength: 1 },
      description: { type: "string" },
      paymentType: {
        type: "string",
        enum: ["UNDEFINED", "PIX", "BOLETO", "CREDIT_CARD", "CASH", "TRANSFER"]
      },
      paymentTerms: { type: "string" },
      paymentDueDays: { type: "number", minimum: 1 },
      expiresAt: { type: "string", format: "date-time" },
      observations: { type: "string" },
      discount: { type: "number", minimum: 0 },
      interest: { type: "number", minimum: 0 },
      items: {
        type: "array",
        minItems: 1,
        items: {
          type: "object",
          required: ["productId", "quantity", "unitPrice"],
          properties: {
            id: { type: "string" },
            productId: { type: "string", minLength: 1 },
            quantity: { type: "number", minimum: 0.01 },
            unitPrice: { type: "number", minimum: 0.01 },
            discount: { type: "number", minimum: 0 },
            note: { type: "string" }
          }
        }
      },
      installments: {
        type: "array",
        items: {
          type: "object",
          required: ["number", "dueDate", "amount"],
          properties: {
            id: { type: "string" },
            number: { type: "number", minimum: 1 },
            dueDate: { type: "string", format: "date-time" },
            amount: { type: "number", minimum: 0.01 },
            interest: { type: "number", minimum: 0 }
          }
        }
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        title: { type: "string" },
        description: { type: "string", nullable: true },
        publicId: { type: "string" },
        authCode: { type: "string" },
        status: { type: "string" },
        total: { type: "number" },
        subtotal: { type: "number" },
        discount: { type: "number", nullable: true },
        interest: { type: "number", nullable: true },
        paymentType: { type: "string" },
        paymentTerms: { type: "string", nullable: true },
        paymentDueDays: { type: "number", nullable: true },
        expiresAt: { type: "string", format: "date-time", nullable: true },
        observations: { type: "string", nullable: true },
        updatedAt: { type: "string", format: "date-time" },
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              productId: { type: "string" },
              quantity: { type: "number" },
              unitPrice: { type: "number" },
              subtotal: { type: "number" },
              discount: { type: "number", nullable: true },
              note: { type: "string", nullable: true },
              product: { type: "object" }
            }
          }
        },
        installments: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              number: { type: "number" },
              dueDate: { type: "string", format: "date-time" },
              amount: { type: "number" },
              interest: { type: "number", nullable: true }
            }
          }
        },
        user: { type: "object" }
      }
    }
  }
};
var getQuoteSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        title: { type: "string" },
        description: { type: "string", nullable: true },
        publicId: { type: "string" },
        authCode: { type: "string" },
        status: { type: "string" },
        total: { type: "number" },
        subtotal: { type: "number" },
        discount: { type: "number", nullable: true },
        interest: { type: "number", nullable: true },
        paymentType: { type: "string" },
        paymentTerms: { type: "string", nullable: true },
        paymentDueDays: { type: "number", nullable: true },
        expiresAt: { type: "string", format: "date-time", nullable: true },
        observations: { type: "string", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              productId: { type: "string" },
              quantity: { type: "number" },
              unitPrice: { type: "number" },
              subtotal: { type: "number" },
              discount: { type: "number", nullable: true },
              note: { type: "string", nullable: true },
              product: { type: "object" }
            }
          }
        },
        installments: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              number: { type: "number" },
              dueDate: { type: "string", format: "date-time" },
              amount: { type: "number" },
              interest: { type: "number", nullable: true }
            }
          }
        },
        user: { type: "object" }
      }
    }
  }
};
var getPublicQuoteSchema = {
  params: {
    type: "object",
    required: ["publicId"],
    properties: {
      publicId: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    required: ["authCode"],
    properties: {
      authCode: { type: "string", minLength: 1 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        title: { type: "string" },
        description: { type: "string", nullable: true },
        status: { type: "string" },
        total: { type: "number" },
        subtotal: { type: "number" },
        discount: { type: "number", nullable: true },
        interest: { type: "number", nullable: true },
        paymentType: { type: "string" },
        paymentTerms: { type: "string", nullable: true },
        paymentDueDays: { type: "number", nullable: true },
        expiresAt: { type: "string", format: "date-time", nullable: true },
        observations: { type: "string", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              quantity: { type: "number" },
              unitPrice: { type: "number" },
              subtotal: { type: "number" },
              discount: { type: "number", nullable: true },
              note: { type: "string", nullable: true },
              product: { type: "object" }
            }
          }
        },
        installments: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              number: { type: "number" },
              dueDate: { type: "string", format: "date-time" },
              amount: { type: "number" },
              interest: { type: "number", nullable: true }
            }
          }
        },
        user: { type: "object" }
      }
    }
  }
};
var listQuotesSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      status: {
        type: "string",
        enum: ["DRAFT", "PUBLISHED", "SENT", "VIEWED", "APPROVED", "REJECTED", "EXPIRED", "CONVERTED", "CANCELED"]
      },
      userId: { type: "string" },
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              userId: { type: "string" },
              title: { type: "string" },
              description: { type: "string", nullable: true },
              publicId: { type: "string" },
              authCode: { type: "string" },
              status: { type: "string" },
              total: { type: "number" },
              subtotal: { type: "number" },
              discount: { type: "number", nullable: true },
              interest: { type: "number", nullable: true },
              paymentType: { type: "string" },
              paymentTerms: { type: "string", nullable: true },
              paymentDueDays: { type: "number", nullable: true },
              expiresAt: { type: "string", format: "date-time", nullable: true },
              observations: { type: "string", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" },
              items: { type: "array" },
              installments: { type: "array" },
              user: { type: "object" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var deleteQuoteSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" }
  }
};
var updateQuoteStatusSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["status"],
    properties: {
      status: {
        type: "string",
        enum: ["DRAFT", "PUBLISHED", "SENT", "VIEWED", "APPROVED", "REJECTED", "EXPIRED", "CONVERTED", "CANCELED"]
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        status: { type: "string" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var approveQuoteSchema = {
  params: {
    type: "object",
    required: ["publicId"],
    properties: {
      publicId: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["authCode"],
    properties: {
      authCode: { type: "string", minLength: 1 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        quote: { type: "object" },
        movements: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              type: { type: "string" },
              quantity: { type: "number" },
              productId: { type: "string" },
              storeId: { type: "string" },
              note: { type: "string" },
              createdAt: { type: "string", format: "date-time" }
            }
          }
        }
      }
    }
  }
};
var rejectQuoteSchema = {
  params: {
    type: "object",
    required: ["publicId"],
    properties: {
      publicId: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["authCode"],
    properties: {
      authCode: { type: "string", minLength: 1 },
      reason: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        status: { type: "string" },
        observations: { type: "string", nullable: true },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var convertToMovementSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        quote: { type: "object" },
        movements: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              type: { type: "string" },
              quantity: { type: "number" },
              productId: { type: "string" },
              storeId: { type: "string" },
              note: { type: "string" },
              createdAt: { type: "string", format: "date-time" }
            }
          }
        }
      }
    }
  }
};
var getQuoteStatsSchema = {
  querystring: {
    type: "object",
    properties: {
      userId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        total: { type: "number" },
        byStatus: {
          type: "object",
          properties: {
            DRAFT: { type: "number" },
            PUBLISHED: { type: "number" },
            SENT: { type: "number" },
            VIEWED: { type: "number" },
            APPROVED: { type: "number" },
            REJECTED: { type: "number" },
            EXPIRED: { type: "number" },
            CONVERTED: { type: "number" },
            CANCELED: { type: "number" }
          }
        },
        totalValue: { type: "number" },
        averageValue: { type: "number" },
        recentCount: { type: "number" }
      }
    }
  }
};
var QuoteSchemas = {
  create: createQuoteSchema,
  update: updateQuoteSchema,
  get: getQuoteSchema,
  getPublic: getPublicQuoteSchema,
  list: listQuotesSchema,
  delete: deleteQuoteSchema,
  updateStatus: updateQuoteStatusSchema,
  approve: approveQuoteSchema,
  reject: rejectQuoteSchema,
  convertToMovement: convertToMovementSchema,
  getStats: getQuoteStatsSchema
};

// src/features/quote/quote.routes.ts
init_auth_middleware();
async function QuoteRoutes(fastify2) {
  fastify2.post("/", {
    schema: QuoteSchemas.create,
    preHandler: [authMiddleware],
    handler: QuoteController.create
  });
  fastify2.get("/", {
    schema: QuoteSchemas.list,
    preHandler: [authMiddleware],
    handler: QuoteController.list
  });
  fastify2.get("/:id", {
    schema: QuoteSchemas.get,
    preHandler: [authMiddleware],
    handler: QuoteController.get
  });
  fastify2.put("/:id", {
    schema: QuoteSchemas.update,
    preHandler: [authMiddleware],
    handler: QuoteController.update
  });
  fastify2.delete("/:id", {
    schema: QuoteSchemas.delete,
    preHandler: [authMiddleware],
    handler: QuoteController.delete
  });
  fastify2.patch("/:id/status", {
    schema: QuoteSchemas.updateStatus,
    preHandler: [authMiddleware],
    handler: QuoteController.updateStatus
  });
  fastify2.patch("/:id/publish", {
    schema: {
      params: {
        type: "object",
        required: ["id"],
        properties: {
          id: { type: "string" }
        }
      }
    },
    preHandler: [authMiddleware],
    handler: QuoteController.publish
  });
  fastify2.patch("/:id/send", {
    schema: {
      params: {
        type: "object",
        required: ["id"],
        properties: {
          id: { type: "string" }
        }
      }
    },
    preHandler: [authMiddleware],
    handler: QuoteController.send
  });
  fastify2.post("/:id/convert", {
    schema: QuoteSchemas.convertToMovement,
    preHandler: [authMiddleware],
    handler: QuoteController.convertToMovements
  });
  fastify2.get("/stats", {
    schema: QuoteSchemas.getStats,
    preHandler: [authMiddleware],
    handler: QuoteController.getStats
  });
  fastify2.get("/user/:userId", {
    schema: {
      params: {
        type: "object",
        required: ["userId"],
        properties: {
          userId: { type: "string" }
        }
      },
      querystring: {
        type: "object",
        properties: {
          page: { type: "number", minimum: 1, default: 1 },
          limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
          status: {
            type: "string",
            enum: ["DRAFT", "PUBLISHED", "SENT", "VIEWED", "APPROVED", "REJECTED", "EXPIRED", "CONVERTED", "CANCELED"]
          }
        }
      }
    },
    preHandler: [authMiddleware],
    handler: QuoteController.getByUser
  });
  fastify2.get("/status/:status", {
    schema: {
      params: {
        type: "object",
        required: ["status"],
        properties: {
          status: {
            type: "string",
            enum: ["DRAFT", "PUBLISHED", "SENT", "VIEWED", "APPROVED", "REJECTED", "EXPIRED", "CONVERTED", "CANCELED"]
          }
        }
      },
      querystring: {
        type: "object",
        properties: {
          page: { type: "number", minimum: 1, default: 1 },
          limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
          userId: { type: "string" }
        }
      }
    },
    preHandler: [authMiddleware],
    handler: QuoteController.getByStatus
  });
  fastify2.get("/search", {
    schema: {
      querystring: {
        type: "object",
        required: ["q"],
        properties: {
          q: { type: "string", minLength: 1 },
          limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
          userId: { type: "string" }
        }
      }
    },
    preHandler: [authMiddleware],
    handler: QuoteController.search
  });
  fastify2.get("/recent", {
    schema: {
      querystring: {
        type: "object",
        properties: {
          limit: { type: "number", minimum: 1, maximum: 50, default: 5 },
          userId: { type: "string" }
        }
      }
    },
    preHandler: [authMiddleware],
    handler: QuoteController.getRecent
  });
  fastify2.get("/:id/analytics", {
    schema: {
      params: {
        type: "object",
        required: ["id"],
        properties: {
          id: { type: "string" }
        }
      }
    },
    preHandler: [authMiddleware],
    handler: QuoteController.getAnalytics
  });
  fastify2.post("/mark-expired", {
    preHandler: [authMiddleware],
    handler: QuoteController.markExpired
  });
  fastify2.get("/public/:publicId", {
    schema: QuoteSchemas.getPublic,
    handler: QuoteController.getPublic
  });
  fastify2.post("/public/:publicId/approve", {
    schema: QuoteSchemas.approve,
    handler: QuoteController.approvePublic
  });
  fastify2.post("/public/:publicId/reject", {
    schema: QuoteSchemas.reject,
    handler: QuoteController.rejectPublic
  });
}

// src/features/plan/commands/plan.commands.ts
init_prisma();
var PlanCommands = {
  async create(data) {
    const existingPlan = await db.plan.findFirst({
      where: { name: data.name }
    });
    if (existingPlan) {
      throw new Error("Plan with this name already exists");
    }
    return await db.plan.create({
      data: {
        ...data,
        interval: data.interval
      },
      include: {
        customers: {
          select: {
            id: true,
            status: true,
            createdAt: true
          }
        }
      }
    });
  },
  async update(id, data) {
    const existingPlan = await db.plan.findUnique({
      where: { id }
    });
    if (!existingPlan) {
      throw new Error("Plan not found");
    }
    if (data.name && data.name !== existingPlan.name) {
      const planWithSameName = await db.plan.findFirst({
        where: {
          name: data.name,
          id: { not: id }
        }
      });
      if (planWithSameName) {
        throw new Error("Plan with this name already exists");
      }
    }
    return await db.plan.update({
      where: { id },
      data: {
        ...data,
        ...data.interval && { interval: data.interval }
      },
      include: {
        customers: {
          select: {
            id: true,
            status: true,
            createdAt: true
          }
        }
      }
    });
  },
  async delete(id) {
    const plan = await db.plan.findUnique({
      where: { id },
      include: {
        customers: {
          select: { id: true }
        }
      }
    });
    if (!plan) {
      throw new Error("Plan not found");
    }
    if (plan.customers.length > 0) {
      throw new Error(`Cannot delete plan. It has ${plan.customers.length} associated customers. Please reassign or delete the customers first.`);
    }
    return await db.plan.delete({
      where: { id }
    });
  },
  async forceDelete(id) {
    const plan = await db.plan.findUnique({
      where: { id }
    });
    if (!plan) {
      throw new Error("Plan not found");
    }
    await db.customer.updateMany({
      where: { planId: id },
      data: { planId: null }
    });
    return await db.plan.delete({
      where: { id }
    });
  },
  async updateStatus(id, active) {
    const plan = await db.plan.findUnique({
      where: { id }
    });
    if (!plan) {
      throw new Error("Plan not found");
    }
    return await db.plan.update({
      where: { id },
      data: {
        // Se houvesse um campo active, seria:
        // active: active
      },
      include: {
        customers: {
          select: {
            id: true,
            status: true,
            createdAt: true
          }
        }
      }
    });
  }
};

// src/features/plan/queries/plan.queries.ts
init_prisma();
var PlanQueries = {
  async getById(id) {
    const plan = await db.plan.findUnique({
      where: { id },
      include: {
        customers: {
          select: {
            id: true,
            status: true,
            createdAt: true,
            user: {
              select: {
                id: true,
                name: true,
                email: true
              }
            }
          }
        }
      }
    });
    if (!plan) {
      return null;
    }
    return {
      ...plan,
      customersCount: plan.customers.length
    };
  },
  async list(params) {
    const { page = 1, limit = 10, search, interval } = params;
    const skip = (page - 1) * limit;
    const where = {};
    if (interval) {
      where.interval = interval;
    }
    if (search) {
      where.OR = [
        { name: { contains: search, mode: "insensitive" } },
        { description: { contains: search, mode: "insensitive" } }
      ];
    }
    const [plans, total] = await Promise.all([
      db.plan.findMany({
        where,
        skip,
        take: limit,
        orderBy: { name: "asc" },
        include: {
          customers: {
            select: {
              id: true,
              status: true
            }
          }
        }
      }),
      db.plan.count({ where })
    ]);
    const itemsWithCount = plans.map((plan) => ({
      ...plan,
      customersCount: plan.customers.length
    }));
    return {
      items: itemsWithCount,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getActive() {
    const plans = await db.plan.findMany({
      orderBy: { name: "asc" },
      include: {
        customers: {
          select: {
            id: true,
            status: true
          }
        }
      }
    });
    return plans.map((plan) => ({
      ...plan,
      customersCount: plan.customers.length
    }));
  },
  async compare(planIds) {
    if (!planIds || planIds.length === 0) {
      throw new Error("At least one plan ID is required for comparison");
    }
    const plans = await db.plan.findMany({
      where: { id: { in: planIds } },
      orderBy: { price: "asc" },
      include: {
        customers: {
          select: {
            id: true,
            status: true
          }
        }
      }
    });
    if (plans.length === 0) {
      throw new Error("No plans found for comparison");
    }
    const prices = plans.map((plan) => Number(plan.price));
    const intervals = [...new Set(plans.map((plan) => plan.interval))];
    const allFeatures = /* @__PURE__ */ new Set();
    plans.forEach((plan) => {
      if (plan.features && typeof plan.features === "object") {
        Object.keys(plan.features).forEach((key) => allFeatures.add(key));
      }
    });
    const plansWithCount = plans.map((plan) => ({
      ...plan,
      customersCount: plan.customers.length
    }));
    return {
      plans: plansWithCount,
      comparison: {
        priceRange: {
          min: Math.min(...prices),
          max: Math.max(...prices)
        },
        intervals,
        features: Array.from(allFeatures)
      }
    };
  },
  async getCustomers(planId, params) {
    const { page = 1, limit = 10, status } = params;
    const skip = (page - 1) * limit;
    const plan = await db.plan.findUnique({
      where: { id: planId }
    });
    if (!plan) {
      throw new Error("Plan not found");
    }
    const where = {
      planId
    };
    if (status) {
      where.status = status;
    }
    const [customers, total] = await Promise.all([
      db.customer.findMany({
        where,
        skip,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true,
              phone: true
            }
          },
          plan: {
            select: {
              id: true,
              name: true,
              price: true,
              interval: true
            }
          },
          invoices: {
            select: {
              id: true,
              amount: true,
              status: true,
              createdAt: true
            },
            orderBy: { createdAt: "desc" },
            take: 5
            // Últimas 5 faturas
          }
        }
      }),
      db.customer.count({ where })
    ]);
    return {
      plan: {
        id: plan.id,
        name: plan.name,
        price: plan.price,
        interval: plan.interval
      },
      customers,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getStats() {
    const [
      total,
      monthlyPlans,
      yearlyPlans,
      totalCustomers,
      revenueData
    ] = await Promise.all([
      db.plan.count(),
      db.plan.count({ where: { interval: "MONTHLY" } }),
      db.plan.count({ where: { interval: "YEARLY" } }),
      db.customer.count({
        where: { status: "ACTIVE" }
      }),
      db.invoice.aggregate({
        where: { status: "PAID" },
        _sum: { amount: true },
        _avg: { amount: true }
      })
    ]);
    const planRevenue = await db.plan.findMany({
      include: {
        customers: {
          where: { status: "ACTIVE" },
          include: {
            invoices: {
              where: { status: "PAID" },
              select: { amount: true }
            }
          }
        }
      }
    });
    let totalRevenue = 0;
    planRevenue.forEach((plan) => {
      plan.customers.forEach((customer) => {
        customer.invoices.forEach((invoice) => {
          totalRevenue += Number(invoice.amount);
        });
      });
    });
    return {
      total,
      active: total,
      // Assumindo que todos os planos são ativos
      inactive: 0,
      monthlyPlans,
      yearlyPlans,
      totalCustomers,
      totalRevenue,
      averagePrice: revenueData._avg.amount ? Number(revenueData._avg.amount) : 0
    };
  }
};

// src/features/plan/plan.controller.ts
var PlanController = {
  // === CRUD BÁSICO ===
  async create(request, reply) {
    try {
      const { name, description, price, interval, features } = request.body;
      const result = await PlanCommands.create({
        name,
        description,
        price,
        interval,
        features
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Plan with this name already exists") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      const result = await PlanQueries.getById(id);
      if (!result) {
        return reply.status(404).send({
          error: "Plan not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Plan not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      const result = await PlanCommands.update(id, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Plan not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Plan with this name already exists") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      await PlanCommands.delete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Plan not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message.includes("Cannot delete plan") && error.message.includes("associated customers")) {
        return reply.status(400).send({
          error: error.message,
          suggestion: "Use DELETE /plans/:id/force to delete the plan and remove all customer associations"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async forceDelete(request, reply) {
    try {
      const { id } = request.params;
      await PlanCommands.forceDelete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Plan not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { page = 1, limit = 10, search, interval } = request.query;
      const result = await PlanQueries.list({
        page,
        limit,
        search,
        interval
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (QUERIES) ===
  async getActive(request, reply) {
    try {
      const result = await PlanQueries.getActive();
      return reply.send({ plans: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async compare(request, reply) {
    try {
      const { planIds } = request.query;
      const result = await PlanQueries.compare(planIds);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "At least one plan ID is required for comparison") {
        return reply.status(400).send({
          error: error.message
        });
      }
      if (error.message === "No plans found for comparison") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getCustomers(request, reply) {
    try {
      const { id } = request.params;
      const { page = 1, limit = 10, status } = request.query;
      const result = await PlanQueries.getCustomers(id, {
        page,
        limit,
        status
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Plan not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const result = await PlanQueries.getStats();
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (COMMANDS) ===
  async updateStatus(request, reply) {
    try {
      const { id } = request.params;
      const { active } = request.body;
      const result = await PlanCommands.updateStatus(id, active);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Plan not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/plan/plan.schema.ts
var createPlanSchema = {
  body: {
    type: "object",
    required: ["name", "price", "interval"],
    properties: {
      name: { type: "string", minLength: 1 },
      description: { type: "string" },
      price: { type: "number", minimum: 0.01 },
      interval: {
        type: "string",
        enum: ["MONTHLY", "YEARLY"]
      },
      features: { type: "object" }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        description: { type: "string", nullable: true },
        price: { type: "number" },
        interval: { type: "string" },
        features: { type: "object", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        customers: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              status: { type: "string" },
              createdAt: { type: "string", format: "date-time" }
            }
          }
        }
      }
    }
  }
};
var updatePlanSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      name: { type: "string", minLength: 1 },
      description: { type: "string" },
      price: { type: "number", minimum: 0.01 },
      interval: {
        type: "string",
        enum: ["MONTHLY", "YEARLY"]
      },
      features: { type: "object" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        description: { type: "string", nullable: true },
        price: { type: "number" },
        interval: { type: "string" },
        features: { type: "object", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        customers: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              status: { type: "string" },
              createdAt: { type: "string", format: "date-time" }
            }
          }
        }
      }
    }
  }
};
var getPlanSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        description: { type: "string", nullable: true },
        price: { type: "number" },
        interval: { type: "string" },
        features: { type: "object", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        customersCount: { type: "number" },
        customers: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              status: { type: "string" },
              createdAt: { type: "string", format: "date-time" },
              user: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  email: { type: "string" }
                }
              }
            }
          }
        }
      }
    }
  }
};
var listPlansSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      interval: {
        type: "string",
        enum: ["MONTHLY", "YEARLY"]
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              price: { type: "number" },
              interval: { type: "string" },
              features: { type: "object", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" },
              customersCount: { type: "number" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var deletePlanSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" }
  }
};
var updatePlanStatusSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["active"],
    properties: {
      active: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        description: { type: "string", nullable: true },
        price: { type: "number" },
        interval: { type: "string" },
        features: { type: "object", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var comparePlansSchema = {
  querystring: {
    type: "object",
    required: ["planIds"],
    properties: {
      planIds: {
        type: "array",
        items: { type: "string", minLength: 1 },
        minItems: 1,
        uniqueItems: true
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        plans: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              price: { type: "number" },
              interval: { type: "string" },
              features: { type: "object", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" },
              customersCount: { type: "number" }
            }
          }
        },
        comparison: {
          type: "object",
          properties: {
            priceRange: {
              type: "object",
              properties: {
                min: { type: "number" },
                max: { type: "number" }
              }
            },
            intervals: {
              type: "array",
              items: {
                type: "string",
                enum: ["MONTHLY", "YEARLY"]
              }
            },
            features: {
              type: "array",
              items: { type: "string" }
            }
          }
        }
      }
    }
  }
};
var getPlanCustomersSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      status: {
        type: "string",
        enum: ["ACTIVE", "INACTIVE", "CANCELLED", "TRIAL"]
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        plan: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            price: { type: "number" },
            interval: { type: "string" }
          }
        },
        customers: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              status: { type: "string" },
              renewalDate: { type: "string", format: "date-time", nullable: true },
              trialEndsAt: { type: "string", format: "date-time", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              user: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  email: { type: "string" },
                  phone: { type: "string", nullable: true }
                }
              },
              plan: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  price: { type: "number" },
                  interval: { type: "string" }
                }
              },
              invoices: {
                type: "array",
                items: {
                  type: "object",
                  properties: {
                    id: { type: "string" },
                    amount: { type: "number" },
                    status: { type: "string" },
                    createdAt: { type: "string", format: "date-time" }
                  }
                }
              }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getPlanStatsSchema = {
  response: {
    200: {
      type: "object",
      properties: {
        total: { type: "number" },
        active: { type: "number" },
        inactive: { type: "number" },
        monthlyPlans: { type: "number" },
        yearlyPlans: { type: "number" },
        totalCustomers: { type: "number" },
        totalRevenue: { type: "number" },
        averagePrice: { type: "number" }
      }
    }
  }
};
var PlanSchemas = {
  create: createPlanSchema,
  update: updatePlanSchema,
  get: getPlanSchema,
  delete: deletePlanSchema,
  list: listPlansSchema,
  updateStatus: updatePlanStatusSchema,
  compare: comparePlansSchema,
  getCustomers: getPlanCustomersSchema,
  getStats: getPlanStatsSchema
};

// src/features/plan/plan.routes.ts
init_auth_middleware();
async function PlanRoutes(fastify2) {
  fastify2.post("/", {
    schema: PlanSchemas.create,
    preHandler: [authMiddleware],
    handler: PlanController.create
  });
  fastify2.get("/", {
    schema: PlanSchemas.list,
    handler: PlanController.list
  });
  fastify2.get("/:id", {
    schema: PlanSchemas.get,
    handler: PlanController.get
  });
  fastify2.put("/:id", {
    schema: PlanSchemas.update,
    preHandler: [authMiddleware],
    handler: PlanController.update
  });
  fastify2.delete("/:id", {
    schema: PlanSchemas.delete,
    preHandler: [authMiddleware],
    handler: PlanController.delete
  });
  fastify2.delete("/:id/force", {
    schema: PlanSchemas.delete,
    preHandler: [authMiddleware],
    handler: PlanController.forceDelete
  });
  fastify2.get("/active", {
    handler: PlanController.getActive
  });
  fastify2.get("/stats", {
    preHandler: [authMiddleware],
    handler: PlanController.getStats
  });
  fastify2.get("/compare", {
    schema: PlanSchemas.compare,
    handler: PlanController.compare
  });
  fastify2.get("/:id/customers", {
    schema: PlanSchemas.getCustomers,
    preHandler: [authMiddleware],
    handler: PlanController.getCustomers
  });
  fastify2.patch("/:id/status", {
    schema: PlanSchemas.updateStatus,
    preHandler: [authMiddleware],
    handler: PlanController.updateStatus
  });
}

// src/features/customer/commands/customer.commands.ts
init_prisma();
var CustomerCommands = {
  async create(data) {
    const { planId, ...createData } = data;
    const user = await db.user.findUnique({
      where: { id: data.userId }
    });
    if (!user) {
      throw new Error("User not found");
    }
    const existingCustomer = await db.customer.findUnique({
      where: { userId: data.userId }
    });
    if (existingCustomer) {
      throw new Error("User is already a customer");
    }
    if (planId) {
      const plan = await db.plan.findUnique({
        where: { id: planId }
      });
      if (!plan) {
        throw new Error("Plan not found");
      }
    }
    return await db.customer.create({
      data: {
        user: { connect: { id: data.userId } },
        status: data.status || "ACTIVE" /* ACTIVE */,
        renewalDate: data.renewalDate,
        trialEndsAt: data.trialEndsAt,
        ...planId && { plan: { connect: { id: planId } } }
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            phone: true
          }
        },
        plan: {
          select: {
            id: true,
            name: true,
            description: true,
            price: true,
            interval: true,
            features: true
          }
        }
      }
    });
  },
  async update(id, data) {
    const { planId, ...updateData } = data;
    const existingCustomer = await db.customer.findUnique({
      where: { id }
    });
    if (!existingCustomer) {
      throw new Error("Customer not found");
    }
    if (planId) {
      const plan = await db.plan.findUnique({
        where: { id: planId }
      });
      if (!plan) {
        throw new Error("Plan not found");
      }
    }
    return await db.customer.update({
      where: { id },
      data: {
        ...updateData,
        ...planId && { plan: { connect: { id: planId } } }
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            phone: true
          }
        },
        plan: {
          select: {
            id: true,
            name: true,
            description: true,
            price: true,
            interval: true,
            features: true
          }
        }
      }
    });
  },
  async delete(id) {
    const customer = await db.customer.findUnique({
      where: { id },
      include: {
        invoices: {
          select: { id: true }
        }
      }
    });
    if (!customer) {
      throw new Error("Customer not found");
    }
    if (customer.invoices.length > 0) {
      throw new Error(`Cannot delete customer. It has ${customer.invoices.length} associated invoices. Please delete the invoices first or use force delete.`);
    }
    return await db.customer.delete({
      where: { id }
    });
  },
  async forceDelete(id) {
    const customer = await db.customer.findUnique({
      where: { id }
    });
    if (!customer) {
      throw new Error("Customer not found");
    }
    await db.invoice.deleteMany({
      where: { customerId: id }
    });
    return await db.customer.delete({
      where: { id }
    });
  },
  async updatePlan(customerId, planId) {
    const customer = await db.customer.findUnique({
      where: { id: customerId }
    });
    if (!customer) {
      throw new Error("Customer not found");
    }
    const plan = await db.plan.findUnique({
      where: { id: planId }
    });
    if (!plan) {
      throw new Error("Plan not found");
    }
    return await db.customer.update({
      where: { id: customerId },
      data: {
        plan: { connect: { id: planId } },
        renewalDate: new Date(Date.now() + (plan.interval === "MONTHLY" ? 30 : 365) * 24 * 60 * 60 * 1e3)
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            phone: true
          }
        },
        plan: {
          select: {
            id: true,
            name: true,
            description: true,
            price: true,
            interval: true,
            features: true
          }
        }
      }
    });
  },
  async cancelSubscription(customerId, reason) {
    const customer = await db.customer.findUnique({
      where: { id: customerId }
    });
    if (!customer) {
      throw new Error("Customer not found");
    }
    return await db.customer.update({
      where: { id: customerId },
      data: {
        status: "CANCELLED" /* CANCELLED */,
        renewalDate: null
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            phone: true
          }
        },
        plan: {
          select: {
            id: true,
            name: true,
            description: true,
            price: true,
            interval: true,
            features: true
          }
        }
      }
    });
  },
  async renewSubscription(customerId, renewalDate) {
    const customer = await db.customer.findUnique({
      where: { id: customerId },
      include: {
        plan: true
      }
    });
    if (!customer) {
      throw new Error("Customer not found");
    }
    if (!customer.plan) {
      throw new Error("Customer has no active plan");
    }
    const newRenewalDate = renewalDate || new Date(Date.now() + (customer.plan.interval === "MONTHLY" ? 30 : 365) * 24 * 60 * 60 * 1e3);
    return await db.customer.update({
      where: { id: customerId },
      data: {
        status: "ACTIVE" /* ACTIVE */,
        renewalDate: newRenewalDate
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            phone: true
          }
        },
        plan: {
          select: {
            id: true,
            name: true,
            description: true,
            price: true,
            interval: true,
            features: true
          }
        }
      }
    });
  },
  async startTrial(customerId, trialDays) {
    const customer = await db.customer.findUnique({
      where: { id: customerId }
    });
    if (!customer) {
      throw new Error("Customer not found");
    }
    const trialEndsAt = new Date(Date.now() + trialDays * 24 * 60 * 60 * 1e3);
    return await db.customer.update({
      where: { id: customerId },
      data: {
        status: "TRIAL" /* TRIAL */,
        trialEndsAt,
        renewalDate: trialEndsAt
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            phone: true
          }
        },
        plan: {
          select: {
            id: true,
            name: true,
            description: true,
            price: true,
            interval: true,
            features: true
          }
        }
      }
    });
  },
  async updateStatus(customerId, status) {
    const customer = await db.customer.findUnique({
      where: { id: customerId }
    });
    if (!customer) {
      throw new Error("Customer not found");
    }
    return await db.customer.update({
      where: { id: customerId },
      data: { status },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            phone: true
          }
        },
        plan: {
          select: {
            id: true,
            name: true,
            description: true,
            price: true,
            interval: true,
            features: true
          }
        }
      }
    });
  }
};

// src/features/customer/queries/customer.queries.ts
init_prisma();
var CustomerQueries = {
  async getById(id) {
    const customer = await db.customer.findUnique({
      where: { id },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            phone: true
          }
        },
        plan: {
          select: {
            id: true,
            name: true,
            description: true,
            price: true,
            interval: true,
            features: true
          }
        },
        invoices: {
          select: {
            id: true,
            amount: true,
            status: true,
            createdAt: true,
            paymentDate: true
          },
          orderBy: { createdAt: "desc" },
          take: 10
          // Últimas 10 faturas
        }
      }
    });
    if (!customer) {
      return null;
    }
    return customer;
  },
  async getByUserId(userId) {
    const customer = await db.customer.findUnique({
      where: { userId },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            phone: true
          }
        },
        plan: {
          select: {
            id: true,
            name: true,
            description: true,
            price: true,
            interval: true,
            features: true
          }
        },
        invoices: {
          select: {
            id: true,
            amount: true,
            status: true,
            createdAt: true,
            paymentDate: true
          },
          orderBy: { createdAt: "desc" },
          take: 10
          // Últimas 10 faturas
        }
      }
    });
    if (!customer) {
      return null;
    }
    return customer;
  },
  async list(params) {
    const { page = 1, limit = 10, search, status, planId } = params;
    const skip = (page - 1) * limit;
    const where = {};
    if (status) {
      where.status = status;
    }
    if (planId) {
      where.planId = planId;
    }
    if (search) {
      where.OR = [
        {
          user: {
            name: { contains: search, mode: "insensitive" }
          }
        },
        {
          user: {
            email: { contains: search, mode: "insensitive" }
          }
        },
        {
          plan: {
            name: { contains: search, mode: "insensitive" }
          }
        }
      ];
    }
    const [customers, total] = await Promise.all([
      db.customer.findMany({
        where,
        skip,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true,
              phone: true
            }
          },
          plan: {
            select: {
              id: true,
              name: true,
              description: true,
              price: true,
              interval: true,
              features: true
            }
          },
          invoices: {
            select: {
              id: true,
              amount: true,
              status: true,
              createdAt: true
            },
            orderBy: { createdAt: "desc" },
            take: 3
            // Últimas 3 faturas
          }
        }
      }),
      db.customer.count({ where })
    ]);
    return {
      items: customers,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getInvoices(customerId, params) {
    const { page = 1, limit = 10, status } = params;
    const skip = (page - 1) * limit;
    const customer = await db.customer.findUnique({
      where: { id: customerId }
    });
    if (!customer) {
      throw new Error("Customer not found");
    }
    const where = {
      customerId
    };
    if (status) {
      where.status = status;
    }
    const [invoices, total] = await Promise.all([
      db.invoice.findMany({
        where,
        skip,
        take: limit,
        orderBy: { createdAt: "desc" }
      }),
      db.invoice.count({ where })
    ]);
    return {
      customer: {
        id: customer.id,
        userId: customer.userId,
        status: customer.status
      },
      invoices,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getSubscriptionStatus(customerId) {
    const customer = await db.customer.findUnique({
      where: { id: customerId },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            phone: true
          }
        },
        plan: {
          select: {
            id: true,
            name: true,
            description: true,
            price: true,
            interval: true,
            features: true
          }
        },
        invoices: {
          select: {
            id: true,
            amount: true,
            status: true,
            createdAt: true,
            paymentDate: true
          },
          orderBy: { createdAt: "desc" },
          take: 1
        }
      }
    });
    if (!customer) {
      throw new Error("Customer not found");
    }
    const isActive = customer.status === "ACTIVE";
    const isTrial = customer.status === "TRIAL";
    let daysRemaining;
    let nextBillingDate;
    if (isTrial && customer.trialEndsAt) {
      const now = /* @__PURE__ */ new Date();
      const diffTime = customer.trialEndsAt.getTime() - now.getTime();
      daysRemaining = Math.ceil(diffTime / (1e3 * 60 * 60 * 24));
      nextBillingDate = customer.trialEndsAt;
    } else if (customer.renewalDate) {
      nextBillingDate = customer.renewalDate;
    }
    const canUpgrade = isActive && customer.plan !== null;
    const canDowngrade = isActive && customer.plan !== null;
    const canCancel = isActive || isTrial;
    const nextInvoice = await db.invoice.findFirst({
      where: {
        customerId,
        status: "PENDING"
      },
      orderBy: { createdAt: "desc" }
    });
    const lastPayment = await db.invoice.findFirst({
      where: {
        customerId,
        status: "PAID"
      },
      orderBy: { paymentDate: "desc" }
    });
    return {
      customer,
      subscription: {
        isActive,
        isTrial,
        daysRemaining,
        nextBillingDate,
        canUpgrade,
        canDowngrade,
        canCancel
      },
      billing: {
        currentPlan: customer.plan,
        nextInvoice: nextInvoice ? {
          amount: Number(nextInvoice.amount),
          dueDate: nextInvoice.createdAt
        } : void 0,
        lastPayment: lastPayment ? {
          amount: Number(lastPayment.amount),
          date: lastPayment.paymentDate,
          status: lastPayment.status
        } : void 0
      }
    };
  },
  async getStats() {
    const [
      total,
      active,
      inactive,
      cancelled,
      trial
    ] = await Promise.all([
      db.customer.count(),
      db.customer.count({ where: { status: "ACTIVE" } }),
      db.customer.count({ where: { status: "INACTIVE" } }),
      db.customer.count({ where: { status: "CANCELLED" } }),
      db.customer.count({ where: { status: "TRIAL" } })
    ]);
    const revenueData = await db.invoice.aggregate({
      where: { status: "PAID" },
      _sum: { amount: true }
    });
    const totalRevenue = revenueData._sum.amount ? Number(revenueData._sum.amount) : 0;
    const averageRevenuePerCustomer = total > 0 ? totalRevenue / total : 0;
    const totalEverActive = await db.customer.count({
      where: {
        OR: [
          { status: "ACTIVE" },
          { status: "CANCELLED" }
        ]
      }
    });
    const churnRate = totalEverActive > 0 ? cancelled / totalEverActive * 100 : 0;
    const totalEverTrial = await db.customer.count({
      where: {
        OR: [
          { status: "TRIAL" },
          { status: "ACTIVE" },
          { status: "CANCELLED" }
        ]
      }
    });
    const conversionRate = totalEverTrial > 0 ? active / totalEverTrial * 100 : 0;
    return {
      total,
      active,
      inactive,
      cancelled,
      trial,
      totalRevenue,
      averageRevenuePerCustomer,
      churnRate,
      conversionRate
    };
  },
  async getActive() {
    const customers = await db.customer.findMany({
      where: { status: "ACTIVE" },
      orderBy: { createdAt: "desc" },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            phone: true
          }
        },
        plan: {
          select: {
            id: true,
            name: true,
            description: true,
            price: true,
            interval: true,
            features: true
          }
        }
      }
    });
    return customers;
  },
  async getTrial() {
    const customers = await db.customer.findMany({
      where: { status: "TRIAL" },
      orderBy: { trialEndsAt: "asc" },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            phone: true
          }
        },
        plan: {
          select: {
            id: true,
            name: true,
            description: true,
            price: true,
            interval: true,
            features: true
          }
        }
      }
    });
    return customers;
  },
  async getCancelled() {
    const customers = await db.customer.findMany({
      where: { status: "CANCELLED" },
      orderBy: { updatedAt: "desc" },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            phone: true
          }
        },
        plan: {
          select: {
            id: true,
            name: true,
            description: true,
            price: true,
            interval: true,
            features: true
          }
        }
      }
    });
    return customers;
  }
};

// src/features/customer/customer.controller.ts
var CustomerController = {
  // === CRUD BÁSICO ===
  async create(request, reply) {
    try {
      const { userId, planId, status, renewalDate, trialEndsAt } = request.body;
      const result = await CustomerCommands.create({
        userId,
        planId,
        status,
        renewalDate: renewalDate ? new Date(renewalDate) : void 0,
        trialEndsAt: trialEndsAt ? new Date(trialEndsAt) : void 0
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found") {
        return reply.status(400).send({
          error: error.message
        });
      }
      if (error.message === "User is already a customer") {
        return reply.status(400).send({
          error: error.message
        });
      }
      if (error.message === "Plan not found") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      const result = await CustomerQueries.getById(id);
      if (!result) {
        return reply.status(404).send({
          error: "Customer not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Customer not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      if (updateData.renewalDate) {
        updateData.renewalDate = new Date(updateData.renewalDate);
      }
      if (updateData.trialEndsAt) {
        updateData.trialEndsAt = new Date(updateData.trialEndsAt);
      }
      const result = await CustomerCommands.update(id, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Customer not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Plan not found") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      await CustomerCommands.delete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Customer not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message.includes("Cannot delete customer") && error.message.includes("associated invoices")) {
        return reply.status(400).send({
          error: error.message,
          suggestion: "Use DELETE /customers/:id/force to delete the customer and all associated invoices"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async forceDelete(request, reply) {
    try {
      const { id } = request.params;
      await CustomerCommands.forceDelete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Customer not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { page = 1, limit = 10, search, status, planId } = request.query;
      const result = await CustomerQueries.list({
        page,
        limit,
        search,
        status,
        planId
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (QUERIES) ===
  async getByUserId(request, reply) {
    try {
      const { userId } = request.params;
      const result = await CustomerQueries.getByUserId(userId);
      if (!result) {
        return reply.status(404).send({
          error: "Customer not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getActive(request, reply) {
    try {
      const result = await CustomerQueries.getActive();
      return reply.send({ customers: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getTrial(request, reply) {
    try {
      const result = await CustomerQueries.getTrial();
      return reply.send({ customers: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getCancelled(request, reply) {
    try {
      const result = await CustomerQueries.getCancelled();
      return reply.send({ customers: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const result = await CustomerQueries.getStats();
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getInvoices(request, reply) {
    try {
      const { id } = request.params;
      const { page = 1, limit = 10, status } = request.query;
      const result = await CustomerQueries.getInvoices(id, {
        page,
        limit,
        status
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Customer not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getSubscriptionStatus(request, reply) {
    try {
      const { id } = request.params;
      const result = await CustomerQueries.getSubscriptionStatus(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Customer not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (COMMANDS) ===
  async updatePlan(request, reply) {
    try {
      const { id } = request.params;
      const { planId } = request.body;
      const result = await CustomerCommands.updatePlan(id, planId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Customer not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Plan not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async cancel(request, reply) {
    try {
      const { id } = request.params;
      const { reason } = request.body;
      const result = await CustomerCommands.cancelSubscription(id, reason);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Customer not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async renew(request, reply) {
    try {
      const { id } = request.params;
      const { renewalDate } = request.body;
      const result = await CustomerCommands.renewSubscription(
        id,
        renewalDate ? new Date(renewalDate) : void 0
      );
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Customer not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Customer has no active plan") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async startTrial(request, reply) {
    try {
      const { id } = request.params;
      const { trialDays } = request.body;
      const result = await CustomerCommands.startTrial(id, trialDays);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Customer not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async updateStatus(request, reply) {
    try {
      const { id } = request.params;
      const { status } = request.body;
      const result = await CustomerCommands.updateStatus(id, status);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Customer not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/customer/customer.schema.ts
var createCustomerSchema = {
  body: {
    type: "object",
    required: ["userId"],
    properties: {
      userId: { type: "string", minLength: 1 },
      planId: { type: "string" },
      status: {
        type: "string",
        enum: ["ACTIVE", "INACTIVE", "CANCELLED", "TRIAL"],
        default: "ACTIVE"
      },
      renewalDate: { type: "string", format: "date-time" },
      trialEndsAt: { type: "string", format: "date-time" }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        planId: { type: "string", nullable: true },
        status: { type: "string" },
        renewalDate: { type: "string", format: "date-time", nullable: true },
        trialEndsAt: { type: "string", format: "date-time", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" },
            phone: { type: "string", nullable: true }
          }
        },
        plan: {
          type: "object",
          nullable: true,
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            description: { type: "string", nullable: true },
            price: { type: "number" },
            interval: { type: "string" },
            features: { type: "object", nullable: true }
          }
        }
      }
    }
  }
};
var updateCustomerSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      planId: { type: "string" },
      status: {
        type: "string",
        enum: ["ACTIVE", "INACTIVE", "CANCELLED", "TRIAL"]
      },
      renewalDate: { type: "string", format: "date-time" },
      trialEndsAt: { type: "string", format: "date-time" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        planId: { type: "string", nullable: true },
        status: { type: "string" },
        renewalDate: { type: "string", format: "date-time", nullable: true },
        trialEndsAt: { type: "string", format: "date-time", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" },
            phone: { type: "string", nullable: true }
          }
        },
        plan: {
          type: "object",
          nullable: true,
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            description: { type: "string", nullable: true },
            price: { type: "number" },
            interval: { type: "string" },
            features: { type: "object", nullable: true }
          }
        }
      }
    }
  }
};
var getCustomerSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        planId: { type: "string", nullable: true },
        status: { type: "string" },
        renewalDate: { type: "string", format: "date-time", nullable: true },
        trialEndsAt: { type: "string", format: "date-time", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" },
            phone: { type: "string", nullable: true }
          }
        },
        plan: {
          type: "object",
          nullable: true,
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            description: { type: "string", nullable: true },
            price: { type: "number" },
            interval: { type: "string" },
            features: { type: "object", nullable: true }
          }
        },
        invoices: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              amount: { type: "number" },
              status: { type: "string" },
              createdAt: { type: "string", format: "date-time" },
              paymentDate: { type: "string", format: "date-time", nullable: true }
            }
          }
        }
      }
    }
  }
};
var listCustomersSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      status: {
        type: "string",
        enum: ["ACTIVE", "INACTIVE", "CANCELLED", "TRIAL"]
      },
      planId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              userId: { type: "string" },
              planId: { type: "string", nullable: true },
              status: { type: "string" },
              renewalDate: { type: "string", format: "date-time", nullable: true },
              trialEndsAt: { type: "string", format: "date-time", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" },
              user: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  email: { type: "string" },
                  phone: { type: "string", nullable: true }
                }
              },
              plan: {
                type: "object",
                nullable: true,
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  description: { type: "string", nullable: true },
                  price: { type: "number" },
                  interval: { type: "string" },
                  features: { type: "object", nullable: true }
                }
              },
              invoices: {
                type: "array",
                items: {
                  type: "object",
                  properties: {
                    id: { type: "string" },
                    amount: { type: "number" },
                    status: { type: "string" },
                    createdAt: { type: "string", format: "date-time" }
                  }
                }
              }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var deleteCustomerSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" }
  }
};
var updateCustomerPlanSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["planId"],
    properties: {
      planId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        planId: { type: "string", nullable: true },
        status: { type: "string" },
        renewalDate: { type: "string", format: "date-time", nullable: true },
        trialEndsAt: { type: "string", format: "date-time", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" },
            phone: { type: "string", nullable: true }
          }
        },
        plan: {
          type: "object",
          nullable: true,
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            description: { type: "string", nullable: true },
            price: { type: "number" },
            interval: { type: "string" },
            features: { type: "object", nullable: true }
          }
        }
      }
    }
  }
};
var cancelCustomerSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      reason: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        planId: { type: "string", nullable: true },
        status: { type: "string" },
        renewalDate: { type: "string", format: "date-time", nullable: true },
        trialEndsAt: { type: "string", format: "date-time", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var renewCustomerSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      renewalDate: { type: "string", format: "date-time" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        planId: { type: "string", nullable: true },
        status: { type: "string" },
        renewalDate: { type: "string", format: "date-time", nullable: true },
        trialEndsAt: { type: "string", format: "date-time", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var startTrialSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["trialDays"],
    properties: {
      trialDays: { type: "number", minimum: 1, maximum: 365 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        planId: { type: "string", nullable: true },
        status: { type: "string" },
        renewalDate: { type: "string", format: "date-time", nullable: true },
        trialEndsAt: { type: "string", format: "date-time", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var getCustomerInvoicesSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      status: {
        type: "string",
        enum: ["PENDING", "PAID", "FAILED"]
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        customer: {
          type: "object",
          properties: {
            id: { type: "string" },
            userId: { type: "string" },
            status: { type: "string" }
          }
        },
        invoices: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              customerId: { type: "string" },
              amount: { type: "number" },
              status: { type: "string" },
              gatewayPaymentId: { type: "string", nullable: true },
              paymentDate: { type: "string", format: "date-time", nullable: true },
              createdAt: { type: "string", format: "date-time" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getSubscriptionStatusSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        customer: {
          type: "object",
          properties: {
            id: { type: "string" },
            userId: { type: "string" },
            planId: { type: "string", nullable: true },
            status: { type: "string" },
            renewalDate: { type: "string", format: "date-time", nullable: true },
            trialEndsAt: { type: "string", format: "date-time", nullable: true },
            createdAt: { type: "string", format: "date-time" },
            updatedAt: { type: "string", format: "date-time" }
          }
        },
        subscription: {
          type: "object",
          properties: {
            isActive: { type: "boolean" },
            isTrial: { type: "boolean" },
            daysRemaining: { type: "number", nullable: true },
            nextBillingDate: { type: "string", format: "date-time", nullable: true },
            canUpgrade: { type: "boolean" },
            canDowngrade: { type: "boolean" },
            canCancel: { type: "boolean" }
          }
        },
        billing: {
          type: "object",
          properties: {
            currentPlan: {
              type: "object",
              nullable: true,
              properties: {
                id: { type: "string" },
                name: { type: "string" },
                price: { type: "number" },
                interval: { type: "string" }
              }
            },
            nextInvoice: {
              type: "object",
              nullable: true,
              properties: {
                amount: { type: "number" },
                dueDate: { type: "string", format: "date-time" }
              }
            },
            lastPayment: {
              type: "object",
              nullable: true,
              properties: {
                amount: { type: "number" },
                date: { type: "string", format: "date-time" },
                status: { type: "string" }
              }
            }
          }
        }
      }
    }
  }
};
var getCustomerStatsSchema = {
  response: {
    200: {
      type: "object",
      properties: {
        total: { type: "number" },
        active: { type: "number" },
        inactive: { type: "number" },
        cancelled: { type: "number" },
        trial: { type: "number" },
        totalRevenue: { type: "number" },
        averageRevenuePerCustomer: { type: "number" },
        churnRate: { type: "number" },
        conversionRate: { type: "number" }
      }
    }
  }
};
var updateCustomerStatusSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["status"],
    properties: {
      status: {
        type: "string",
        enum: ["ACTIVE", "INACTIVE", "CANCELLED", "TRIAL"]
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        planId: { type: "string", nullable: true },
        status: { type: "string" },
        renewalDate: { type: "string", format: "date-time", nullable: true },
        trialEndsAt: { type: "string", format: "date-time", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var CustomerSchemas = {
  create: createCustomerSchema,
  update: updateCustomerSchema,
  get: getCustomerSchema,
  delete: deleteCustomerSchema,
  list: listCustomersSchema,
  updatePlan: updateCustomerPlanSchema,
  cancel: cancelCustomerSchema,
  renew: renewCustomerSchema,
  startTrial: startTrialSchema,
  getInvoices: getCustomerInvoicesSchema,
  getSubscriptionStatus: getSubscriptionStatusSchema,
  getStats: getCustomerStatsSchema,
  updateStatus: updateCustomerStatusSchema
};

// src/features/customer/customer.routes.ts
init_auth_middleware();
async function CustomerRoutes(fastify2) {
  fastify2.post("/", {
    schema: CustomerSchemas.create,
    preHandler: [authMiddleware],
    handler: CustomerController.create
  });
  fastify2.get("/", {
    schema: CustomerSchemas.list,
    preHandler: [authMiddleware],
    handler: CustomerController.list
  });
  fastify2.get("/:id", {
    schema: CustomerSchemas.get,
    handler: CustomerController.get
  });
  fastify2.put("/:id", {
    schema: CustomerSchemas.update,
    preHandler: [authMiddleware],
    handler: CustomerController.update
  });
  fastify2.delete("/:id", {
    schema: CustomerSchemas.delete,
    preHandler: [authMiddleware],
    handler: CustomerController.delete
  });
  fastify2.delete("/:id/force", {
    schema: CustomerSchemas.delete,
    preHandler: [authMiddleware],
    handler: CustomerController.forceDelete
  });
  fastify2.get("/user/:userId", {
    schema: {
      params: {
        type: "object",
        required: ["userId"],
        properties: {
          userId: { type: "string" }
        }
      }
    },
    handler: CustomerController.getByUserId
  });
  fastify2.get("/active", {
    handler: CustomerController.getActive
  });
  fastify2.get("/trial", {
    preHandler: [authMiddleware],
    handler: CustomerController.getTrial
  });
  fastify2.get("/cancelled", {
    preHandler: [authMiddleware],
    handler: CustomerController.getCancelled
  });
  fastify2.get("/stats", {
    preHandler: [authMiddleware],
    handler: CustomerController.getStats
  });
  fastify2.get("/:id/invoices", {
    schema: CustomerSchemas.getInvoices,
    handler: CustomerController.getInvoices
  });
  fastify2.get("/:id/subscription-status", {
    schema: CustomerSchemas.getSubscriptionStatus,
    handler: CustomerController.getSubscriptionStatus
  });
  fastify2.patch("/:id/plan", {
    schema: CustomerSchemas.updatePlan,
    preHandler: [authMiddleware],
    handler: CustomerController.updatePlan
  });
  fastify2.patch("/:id/cancel", {
    schema: CustomerSchemas.cancel,
    preHandler: [authMiddleware],
    handler: CustomerController.cancel
  });
  fastify2.patch("/:id/renew", {
    schema: CustomerSchemas.renew,
    preHandler: [authMiddleware],
    handler: CustomerController.renew
  });
  fastify2.patch("/:id/trial", {
    schema: CustomerSchemas.startTrial,
    preHandler: [authMiddleware],
    handler: CustomerController.startTrial
  });
  fastify2.patch("/:id/status", {
    schema: CustomerSchemas.updateStatus,
    preHandler: [authMiddleware],
    handler: CustomerController.updateStatus
  });
}

// src/features/invoice/commands/invoice.commands.ts
init_prisma();
var InvoiceCommands = {
  async create(data) {
    const { customerId, ...createData } = data;
    const customer = await db.customer.findUnique({
      where: { id: customerId },
      include: {
        user: true,
        plan: true
      }
    });
    if (!customer) {
      throw new Error("Customer not found");
    }
    return await db.invoice.create({
      data: {
        ...createData,
        status: data.status || "PENDING" /* PENDING */,
        customer: { connect: { id: customerId } }
      },
      include: {
        customer: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
                email: true,
                phone: true
              }
            },
            plan: {
              select: {
                id: true,
                name: true,
                description: true,
                price: true,
                interval: true
              }
            }
          }
        }
      }
    });
  },
  async update(id, data) {
    const existingInvoice = await db.invoice.findUnique({
      where: { id }
    });
    if (!existingInvoice) {
      throw new Error("Invoice not found");
    }
    return await db.invoice.update({
      where: { id },
      data: {
        ...data
      },
      include: {
        customer: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
                email: true,
                phone: true
              }
            },
            plan: {
              select: {
                id: true,
                name: true,
                description: true,
                price: true,
                interval: true
              }
            }
          }
        }
      }
    });
  },
  async delete(id) {
    const invoice = await db.invoice.findUnique({
      where: { id }
    });
    if (!invoice) {
      throw new Error("Invoice not found");
    }
    return await db.invoice.delete({
      where: { id }
    });
  },
  async updateStatus(id, status, paymentDate, gatewayPaymentId) {
    const invoice = await db.invoice.findUnique({
      where: { id }
    });
    if (!invoice) {
      throw new Error("Invoice not found");
    }
    const updateData = { status };
    if (status === "PAID" /* PAID */) {
      updateData.paymentDate = paymentDate || /* @__PURE__ */ new Date();
      if (gatewayPaymentId) {
        updateData.gatewayPaymentId = gatewayPaymentId;
      }
    }
    return await db.invoice.update({
      where: { id },
      data: updateData,
      include: {
        customer: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
                email: true,
                phone: true
              }
            },
            plan: {
              select: {
                id: true,
                name: true,
                description: true,
                price: true,
                interval: true
              }
            }
          }
        }
      }
    });
  },
  async retryPayment(id, gateway, paymentMethod) {
    const invoice = await db.invoice.findUnique({
      where: { id },
      include: {
        customer: {
          include: {
            user: true,
            plan: true
          }
        }
      }
    });
    if (!invoice) {
      throw new Error("Invoice not found");
    }
    if (invoice.status === "PAID" /* PAID */) {
      throw new Error("Invoice is already paid");
    }
    try {
      const paymentSuccess = Math.random() > 0.3;
      if (paymentSuccess) {
        await db.invoice.update({
          where: { id },
          data: {
            status: "PAID" /* PAID */,
            paymentDate: /* @__PURE__ */ new Date(),
            gatewayPaymentId: `gateway_${Date.now()}`
          }
        });
        return {
          success: true,
          gatewayResponse: {
            paymentId: `gateway_${Date.now()}`,
            status: "completed"
          }
        };
      } else {
        await db.invoice.update({
          where: { id },
          data: {
            status: "FAILED" /* FAILED */
          }
        });
        return {
          success: false,
          error: "Payment failed"
        };
      }
    } catch (error) {
      await db.invoice.update({
        where: { id },
        data: {
          status: "FAILED" /* FAILED */
        }
      });
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },
  async markAsPaid(id, gatewayPaymentId) {
    return await this.updateStatus(id, "PAID" /* PAID */, /* @__PURE__ */ new Date(), gatewayPaymentId);
  },
  async markAsFailed(id) {
    return await this.updateStatus(id, "FAILED" /* FAILED */);
  }
};

// src/features/invoice/queries/invoice.queries.ts
init_prisma();
var InvoiceQueries = {
  async getById(id) {
    const invoice = await db.invoice.findUnique({
      where: { id },
      include: {
        customer: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
                email: true,
                phone: true
              }
            },
            plan: {
              select: {
                id: true,
                name: true,
                description: true,
                price: true,
                interval: true
              }
            }
          }
        }
      }
    });
    if (!invoice) {
      return null;
    }
    return invoice;
  },
  async list(params) {
    const { page = 1, limit = 10, customerId, status, startDate, endDate } = params;
    const skip = (page - 1) * limit;
    const where = {};
    if (customerId) {
      where.customerId = customerId;
    }
    if (status) {
      where.status = status;
    }
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) {
        where.createdAt.gte = new Date(startDate);
      }
      if (endDate) {
        where.createdAt.lte = new Date(endDate);
      }
    }
    const [invoices, total] = await Promise.all([
      db.invoice.findMany({
        where,
        skip,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          customer: {
            include: {
              user: {
                select: {
                  id: true,
                  name: true,
                  email: true,
                  phone: true
                }
              },
              plan: {
                select: {
                  id: true,
                  name: true,
                  description: true,
                  price: true,
                  interval: true
                }
              }
            }
          }
        }
      }),
      db.invoice.count({ where })
    ]);
    return {
      items: invoices,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getByCustomer(customerId, params) {
    const { page = 1, limit = 10, status } = params;
    const skip = (page - 1) * limit;
    const customer = await db.customer.findUnique({
      where: { id: customerId }
    });
    if (!customer) {
      throw new Error("Customer not found");
    }
    const where = {
      customerId
    };
    if (status) {
      where.status = status;
    }
    const [invoices, total] = await Promise.all([
      db.invoice.findMany({
        where,
        skip,
        take: limit,
        orderBy: { createdAt: "desc" }
      }),
      db.invoice.count({ where })
    ]);
    return {
      customer: {
        id: customer.id,
        userId: customer.userId,
        status: customer.status
      },
      invoices,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getPending() {
    const invoices = await db.invoice.findMany({
      where: { status: "PENDING" },
      orderBy: { createdAt: "asc" },
      include: {
        customer: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
                email: true,
                phone: true
              }
            },
            plan: {
              select: {
                id: true,
                name: true,
                description: true,
                price: true,
                interval: true
              }
            }
          }
        }
      }
    });
    return invoices;
  },
  async getFailed() {
    const invoices = await db.invoice.findMany({
      where: { status: "FAILED" },
      orderBy: { createdAt: "desc" },
      include: {
        customer: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
                email: true,
                phone: true
              }
            },
            plan: {
              select: {
                id: true,
                name: true,
                description: true,
                price: true,
                interval: true
              }
            }
          }
        }
      }
    });
    return invoices;
  },
  async getStats() {
    const [
      total,
      pending,
      paid,
      failed,
      amountData
    ] = await Promise.all([
      db.invoice.count(),
      db.invoice.count({ where: { status: "PENDING" } }),
      db.invoice.count({ where: { status: "PAID" } }),
      db.invoice.count({ where: { status: "FAILED" } }),
      db.invoice.aggregate({
        _sum: { amount: true },
        _avg: { amount: true }
      })
    ]);
    const [totalPaid, totalPending, totalFailed] = await Promise.all([
      db.invoice.aggregate({
        where: { status: "PAID" },
        _sum: { amount: true }
      }),
      db.invoice.aggregate({
        where: { status: "PENDING" },
        _sum: { amount: true }
      }),
      db.invoice.aggregate({
        where: { status: "FAILED" },
        _sum: { amount: true }
      })
    ]);
    const totalAmount = amountData._sum.amount ? Number(amountData._sum.amount) : 0;
    const totalPaidAmount = totalPaid._sum.amount ? Number(totalPaid._sum.amount) : 0;
    const totalPendingAmount = totalPending._sum.amount ? Number(totalPending._sum.amount) : 0;
    const totalFailedAmount = totalFailed._sum.amount ? Number(totalFailed._sum.amount) : 0;
    const averageAmount = amountData._avg.amount ? Number(amountData._avg.amount) : 0;
    const conversionRate = total > 0 ? paid / total * 100 : 0;
    return {
      total,
      pending,
      paid,
      failed,
      totalAmount,
      totalPaid: totalPaidAmount,
      totalPending: totalPendingAmount,
      totalFailed: totalFailedAmount,
      averageAmount,
      conversionRate
    };
  },
  async generatePdf(invoiceId) {
    const invoice = await db.invoice.findUnique({
      where: { id: invoiceId },
      include: {
        customer: {
          include: {
            user: true,
            plan: true
          }
        }
      }
    });
    if (!invoice) {
      throw new Error("Invoice not found");
    }
    const pdfData = {
      invoice: {
        id: invoice.id,
        amount: Number(invoice.amount),
        status: invoice.status,
        createdAt: invoice.createdAt,
        paymentDate: invoice.paymentDate
      },
      customer: {
        name: invoice.customer.user.name,
        email: invoice.customer.user.email,
        phone: invoice.customer.user.phone
      },
      plan: invoice.customer.plan ? {
        name: invoice.customer.plan.name,
        description: invoice.customer.plan.description,
        price: Number(invoice.customer.plan.price),
        interval: invoice.customer.plan.interval
      } : null
    };
    return {
      success: true,
      pdfData,
      message: "PDF data prepared for generation"
    };
  },
  async getOverdueInvoices() {
    const thirtyDaysAgo = /* @__PURE__ */ new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    const overdueInvoices = await db.invoice.findMany({
      where: {
        status: "PENDING",
        createdAt: {
          lt: thirtyDaysAgo
        }
      },
      orderBy: { createdAt: "asc" },
      include: {
        customer: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
                email: true,
                phone: true
              }
            }
          }
        }
      }
    });
    return overdueInvoices;
  },
  async getRevenueByPeriod(startDate, endDate) {
    const invoices = await db.invoice.findMany({
      where: {
        status: "PAID",
        paymentDate: {
          gte: startDate,
          lte: endDate
        }
      },
      include: {
        customer: {
          include: {
            plan: true
          }
        }
      }
    });
    const totalRevenue = invoices.reduce((sum, invoice) => sum + Number(invoice.amount), 0);
    const revenueByPlan = invoices.reduce((acc, invoice) => {
      if (invoice.customer.plan) {
        const planId = invoice.customer.plan.id;
        if (!acc[planId]) {
          acc[planId] = {
            plan: invoice.customer.plan,
            revenue: 0,
            count: 0
          };
        }
        acc[planId].revenue += Number(invoice.amount);
        acc[planId].count += 1;
      }
      return acc;
    }, {});
    return {
      totalRevenue,
      invoiceCount: invoices.length,
      revenueByPlan: Object.values(revenueByPlan)
    };
  }
};

// src/features/invoice/invoice.controller.ts
var InvoiceController = {
  // === CRUD BÁSICO ===
  async create(request, reply) {
    try {
      const { customerId, amount, status, gatewayPaymentId, paymentDate } = request.body;
      const result = await InvoiceCommands.create({
        customerId,
        amount,
        status,
        gatewayPaymentId,
        paymentDate: paymentDate ? new Date(paymentDate) : void 0
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Customer not found") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      const result = await InvoiceQueries.getById(id);
      if (!result) {
        return reply.status(404).send({
          error: "Invoice not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invoice not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      if (updateData.paymentDate) {
        updateData.paymentDate = new Date(updateData.paymentDate);
      }
      const result = await InvoiceCommands.update(id, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invoice not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      await InvoiceCommands.delete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invoice not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { page = 1, limit = 10, customerId, status, startDate, endDate } = request.query;
      const result = await InvoiceQueries.list({
        page,
        limit,
        customerId,
        status,
        startDate,
        endDate
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (QUERIES) ===
  async getByCustomer(request, reply) {
    try {
      const { customerId } = request.params;
      const { page = 1, limit = 10, status } = request.query;
      const result = await InvoiceQueries.getByCustomer(customerId, {
        page,
        limit,
        status
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Customer not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getPending(request, reply) {
    try {
      const result = await InvoiceQueries.getPending();
      return reply.send({ invoices: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getFailed(request, reply) {
    try {
      const result = await InvoiceQueries.getFailed();
      return reply.send({ invoices: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const result = await InvoiceQueries.getStats();
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getPdf(request, reply) {
    try {
      const { id } = request.params;
      const result = await InvoiceQueries.generatePdf(id);
      if (!result.success) {
        return reply.status(400).send({
          error: "Failed to generate PDF"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invoice not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getOverdue(request, reply) {
    try {
      const result = await InvoiceQueries.getOverdueInvoices();
      return reply.send({ invoices: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getRevenue(request, reply) {
    try {
      const { startDate, endDate } = request.query;
      const start = startDate ? new Date(startDate) : new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3);
      const end = endDate ? new Date(endDate) : /* @__PURE__ */ new Date();
      const result = await InvoiceQueries.getRevenueByPeriod(start, end);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (COMMANDS) ===
  async updateStatus(request, reply) {
    try {
      const { id } = request.params;
      const { status, paymentDate, gatewayPaymentId } = request.body;
      const result = await InvoiceCommands.updateStatus(
        id,
        status,
        paymentDate ? new Date(paymentDate) : void 0,
        gatewayPaymentId
      );
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invoice not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async retryPayment(request, reply) {
    try {
      const { id } = request.params;
      const { gateway, paymentMethod } = request.body;
      const retryResult = await InvoiceCommands.retryPayment(id, gateway, paymentMethod);
      const invoice = await InvoiceQueries.getById(id);
      return reply.send({
        invoice,
        retryResult
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invoice not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Invoice is already paid") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async sendEmail(request, reply) {
    try {
      const { id } = request.params;
      const { email, includePdf } = request.body;
      const invoice = await InvoiceQueries.getById(id);
      if (!invoice) {
        return reply.status(404).send({
          error: "Invoice not found"
        });
      }
      const emailResult = {
        success: true,
        messageId: `email_${Date.now()}`
      };
      return reply.send({
        invoice,
        emailResult
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invoice not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async markAsPaid(request, reply) {
    try {
      const { id } = request.params;
      const { gatewayPaymentId } = request.body;
      const result = await InvoiceCommands.markAsPaid(id, gatewayPaymentId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invoice not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async markAsFailed(request, reply) {
    try {
      const { id } = request.params;
      const result = await InvoiceCommands.markAsFailed(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invoice not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/invoice/invoice.schema.ts
var createInvoiceSchema = {
  body: {
    type: "object",
    required: ["customerId", "amount"],
    properties: {
      customerId: { type: "string", minLength: 1 },
      amount: { type: "number", minimum: 0.01 },
      status: {
        type: "string",
        enum: ["PENDING", "PAID", "FAILED"],
        default: "PENDING"
      },
      gatewayPaymentId: { type: "string" },
      paymentDate: { type: "string", format: "date-time" }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        customerId: { type: "string" },
        amount: { type: "number" },
        status: { type: "string" },
        gatewayPaymentId: { type: "string", nullable: true },
        paymentDate: { type: "string", format: "date-time", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        customer: {
          type: "object",
          properties: {
            id: { type: "string" },
            userId: { type: "string" },
            status: { type: "string" },
            user: {
              type: "object",
              properties: {
                id: { type: "string" },
                name: { type: "string" },
                email: { type: "string" },
                phone: { type: "string", nullable: true }
              }
            },
            plan: {
              type: "object",
              nullable: true,
              properties: {
                id: { type: "string" },
                name: { type: "string" },
                description: { type: "string", nullable: true },
                price: { type: "number" },
                interval: { type: "string" }
              }
            }
          }
        }
      }
    }
  }
};
var updateInvoiceSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      amount: { type: "number", minimum: 0.01 },
      status: {
        type: "string",
        enum: ["PENDING", "PAID", "FAILED"]
      },
      gatewayPaymentId: { type: "string" },
      paymentDate: { type: "string", format: "date-time" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        customerId: { type: "string" },
        amount: { type: "number" },
        status: { type: "string" },
        gatewayPaymentId: { type: "string", nullable: true },
        paymentDate: { type: "string", format: "date-time", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        customer: {
          type: "object",
          properties: {
            id: { type: "string" },
            userId: { type: "string" },
            status: { type: "string" },
            user: {
              type: "object",
              properties: {
                id: { type: "string" },
                name: { type: "string" },
                email: { type: "string" },
                phone: { type: "string", nullable: true }
              }
            },
            plan: {
              type: "object",
              nullable: true,
              properties: {
                id: { type: "string" },
                name: { type: "string" },
                description: { type: "string", nullable: true },
                price: { type: "number" },
                interval: { type: "string" }
              }
            }
          }
        }
      }
    }
  }
};
var getInvoiceSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        customerId: { type: "string" },
        amount: { type: "number" },
        status: { type: "string" },
        gatewayPaymentId: { type: "string", nullable: true },
        paymentDate: { type: "string", format: "date-time", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        customer: {
          type: "object",
          properties: {
            id: { type: "string" },
            userId: { type: "string" },
            status: { type: "string" },
            user: {
              type: "object",
              properties: {
                id: { type: "string" },
                name: { type: "string" },
                email: { type: "string" },
                phone: { type: "string", nullable: true }
              }
            },
            plan: {
              type: "object",
              nullable: true,
              properties: {
                id: { type: "string" },
                name: { type: "string" },
                description: { type: "string", nullable: true },
                price: { type: "number" },
                interval: { type: "string" }
              }
            }
          }
        }
      }
    }
  }
};
var listInvoicesSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      customerId: { type: "string" },
      status: {
        type: "string",
        enum: ["PENDING", "PAID", "FAILED"]
      },
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              customerId: { type: "string" },
              amount: { type: "number" },
              status: { type: "string" },
              gatewayPaymentId: { type: "string", nullable: true },
              paymentDate: { type: "string", format: "date-time", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              customer: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  userId: { type: "string" },
                  status: { type: "string" },
                  user: {
                    type: "object",
                    properties: {
                      id: { type: "string" },
                      name: { type: "string" },
                      email: { type: "string" },
                      phone: { type: "string", nullable: true }
                    }
                  },
                  plan: {
                    type: "object",
                    nullable: true,
                    properties: {
                      id: { type: "string" },
                      name: { type: "string" },
                      description: { type: "string", nullable: true },
                      price: { type: "number" },
                      interval: { type: "string" }
                    }
                  }
                }
              }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var deleteInvoiceSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" }
  }
};
var updateInvoiceStatusSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["status"],
    properties: {
      status: {
        type: "string",
        enum: ["PENDING", "PAID", "FAILED"]
      },
      paymentDate: { type: "string", format: "date-time" },
      gatewayPaymentId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        customerId: { type: "string" },
        amount: { type: "number" },
        status: { type: "string" },
        gatewayPaymentId: { type: "string", nullable: true },
        paymentDate: { type: "string", format: "date-time", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        customer: {
          type: "object",
          properties: {
            id: { type: "string" },
            userId: { type: "string" },
            status: { type: "string" }
          }
        }
      }
    }
  }
};
var retryPaymentSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      gateway: { type: "string" },
      paymentMethod: { type: "object" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        invoice: {
          type: "object",
          properties: {
            id: { type: "string" },
            customerId: { type: "string" },
            amount: { type: "number" },
            status: { type: "string" },
            gatewayPaymentId: { type: "string", nullable: true },
            paymentDate: { type: "string", format: "date-time", nullable: true },
            createdAt: { type: "string", format: "date-time" }
          }
        },
        retryResult: {
          type: "object",
          properties: {
            success: { type: "boolean" },
            gatewayResponse: { type: "object", nullable: true },
            error: { type: "string", nullable: true }
          }
        }
      }
    }
  }
};
var getInvoicePdfSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        success: { type: "boolean" },
        pdfData: { type: "object" },
        message: { type: "string" }
      }
    }
  }
};
var sendInvoiceEmailSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      email: { type: "string", format: "email" },
      includePdf: { type: "boolean", default: false }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        invoice: {
          type: "object",
          properties: {
            id: { type: "string" },
            customerId: { type: "string" },
            amount: { type: "number" },
            status: { type: "string" }
          }
        },
        emailResult: {
          type: "object",
          properties: {
            success: { type: "boolean" },
            messageId: { type: "string", nullable: true },
            error: { type: "string", nullable: true }
          }
        }
      }
    }
  }
};
var getCustomerInvoicesSchema2 = {
  params: {
    type: "object",
    required: ["customerId"],
    properties: {
      customerId: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      status: {
        type: "string",
        enum: ["PENDING", "PAID", "FAILED"]
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        customer: {
          type: "object",
          properties: {
            id: { type: "string" },
            userId: { type: "string" },
            status: { type: "string" }
          }
        },
        invoices: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              customerId: { type: "string" },
              amount: { type: "number" },
              status: { type: "string" },
              gatewayPaymentId: { type: "string", nullable: true },
              paymentDate: { type: "string", format: "date-time", nullable: true },
              createdAt: { type: "string", format: "date-time" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getInvoiceStatsSchema = {
  response: {
    200: {
      type: "object",
      properties: {
        total: { type: "number" },
        pending: { type: "number" },
        paid: { type: "number" },
        failed: { type: "number" },
        totalAmount: { type: "number" },
        totalPaid: { type: "number" },
        totalPending: { type: "number" },
        totalFailed: { type: "number" },
        averageAmount: { type: "number" },
        conversionRate: { type: "number" }
      }
    }
  }
};
var getOverdueInvoicesSchema = {
  response: {
    200: {
      type: "object",
      properties: {
        invoices: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              customerId: { type: "string" },
              amount: { type: "number" },
              status: { type: "string" },
              createdAt: { type: "string", format: "date-time" },
              customer: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  userId: { type: "string" },
                  user: {
                    type: "object",
                    properties: {
                      id: { type: "string" },
                      name: { type: "string" },
                      email: { type: "string" },
                      phone: { type: "string", nullable: true }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
};
var getRevenueSchema = {
  querystring: {
    type: "object",
    properties: {
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        totalRevenue: { type: "number" },
        invoiceCount: { type: "number" },
        revenueByPlan: {
          type: "array",
          items: {
            type: "object",
            properties: {
              plan: { type: "object" },
              revenue: { type: "number" },
              count: { type: "number" }
            }
          }
        }
      }
    }
  }
};
var markAsPaidSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      gatewayPaymentId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        customerId: { type: "string" },
        amount: { type: "number" },
        status: { type: "string" },
        gatewayPaymentId: { type: "string", nullable: true },
        paymentDate: { type: "string", format: "date-time", nullable: true },
        createdAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var markAsFailedSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        customerId: { type: "string" },
        amount: { type: "number" },
        status: { type: "string" },
        gatewayPaymentId: { type: "string", nullable: true },
        paymentDate: { type: "string", format: "date-time", nullable: true },
        createdAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var InvoiceSchemas = {
  create: createInvoiceSchema,
  update: updateInvoiceSchema,
  get: getInvoiceSchema,
  delete: deleteInvoiceSchema,
  list: listInvoicesSchema,
  updateStatus: updateInvoiceStatusSchema,
  retryPayment: retryPaymentSchema,
  getPdf: getInvoicePdfSchema,
  sendEmail: sendInvoiceEmailSchema,
  getByCustomer: getCustomerInvoicesSchema2,
  getStats: getInvoiceStatsSchema,
  getOverdue: getOverdueInvoicesSchema,
  getRevenue: getRevenueSchema,
  markAsPaid: markAsPaidSchema,
  markAsFailed: markAsFailedSchema
};

// src/features/invoice/invoice.routes.ts
init_auth_middleware();
async function InvoiceRoutes(fastify2) {
  fastify2.post("/", {
    schema: InvoiceSchemas.create,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: InvoiceController.create
  });
  fastify2.get("/", {
    schema: InvoiceSchemas.list,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: InvoiceController.list
  });
  fastify2.get("/:id", {
    schema: InvoiceSchemas.get,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: InvoiceController.get
  });
  fastify2.put("/:id", {
    schema: InvoiceSchemas.update,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: InvoiceController.update
  });
  fastify2.delete("/:id", {
    schema: InvoiceSchemas.delete,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: InvoiceController.delete
  });
  fastify2.get("/customer/:customerId", {
    schema: InvoiceSchemas.getByCustomer,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: InvoiceController.getByCustomer
  });
  fastify2.get("/pending", {
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: InvoiceController.getPending
  });
  fastify2.get("/failed", {
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: InvoiceController.getFailed
  });
  fastify2.get("/overdue", {
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: InvoiceController.getOverdue
  });
  fastify2.get("/stats", {
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: InvoiceController.getStats
  });
  fastify2.get("/revenue", {
    schema: InvoiceSchemas.getRevenue,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: InvoiceController.getRevenue
  });
  fastify2.get("/:id/pdf", {
    schema: InvoiceSchemas.getPdf,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: InvoiceController.getPdf
  });
  fastify2.patch("/:id/status", {
    schema: InvoiceSchemas.updateStatus,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: InvoiceController.updateStatus
  });
  fastify2.post("/:id/retry", {
    schema: InvoiceSchemas.retryPayment,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: InvoiceController.retryPayment
  });
  fastify2.post("/:id/send-email", {
    schema: InvoiceSchemas.sendEmail,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: InvoiceController.sendEmail
  });
  fastify2.patch("/:id/mark-paid", {
    schema: InvoiceSchemas.markAsPaid,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: InvoiceController.markAsPaid
  });
  fastify2.patch("/:id/mark-failed", {
    schema: InvoiceSchemas.markAsFailed,
    preHandler: [authMiddleware, storeContextMiddleware],
    handler: InvoiceController.markAsFailed
  });
}

// src/services/payment/abacate-pay.service.ts
var AbacatePayService = {
  config: {
    name: "Abacate Pay",
    version: "1.0.0",
    supportedCurrencies: ["BRL"],
    supportedMethods: ["pix", "credit_card", "debit_card", "boleto"],
    environment: process.env.ABACATE_PAY_ENV === "production" ? "production" : "sandbox",
    apiKey: process.env.ABACATE_PAY_API_KEY,
    secretKey: process.env.ABACATE_PAY_SECRET_KEY,
    webhookUrl: process.env.ABACATE_PAY_WEBHOOK_URL
  },
  async createPayment(data) {
    try {
      console.log("Creating payment with Abacate Pay:", data);
      const paymentId = `abacate_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const success = data.amount > 0 && data.amount < 1e4;
      return {
        success,
        paymentId: success ? paymentId : void 0,
        status: success ? "pending" : "failed",
        gatewayResponse: {
          payment_id: paymentId,
          status: success ? "pending" : "failed",
          amount: data.amount,
          currency: data.currency || "BRL",
          created_at: (/* @__PURE__ */ new Date()).toISOString()
        },
        error: success ? void 0 : "Payment amount exceeds limit"
      };
    } catch (error) {
      return {
        success: false,
        status: "failed",
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },
  async getPaymentStatus(paymentId) {
    try {
      console.log("Getting payment status from Abacate Pay:", paymentId);
      const statuses = ["pending", "completed", "failed", "cancelled"];
      const randomStatus = statuses[Math.floor(Math.random() * statuses.length)];
      return {
        paymentId,
        status: randomStatus,
        amount: Math.random() * 1e3,
        currency: "BRL",
        gatewayResponse: {
          payment_id: paymentId,
          status: randomStatus,
          amount: Math.random() * 1e3,
          currency: "BRL",
          updated_at: (/* @__PURE__ */ new Date()).toISOString()
        }
      };
    } catch (error) {
      return {
        paymentId,
        status: "failed",
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },
  async cancelPayment(paymentId) {
    try {
      console.log("Cancelling payment with Abacate Pay:", paymentId);
    } catch (error) {
      console.error("Error cancelling payment:", error);
      throw error;
    }
  },
  async refundPayment(data) {
    try {
      console.log("Processing refund with Abacate Pay:", data);
      const refundId = `refund_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      return {
        success: true,
        refundId,
        amount: data.amount,
        gatewayResponse: {
          refund_id: refundId,
          payment_id: data.paymentId,
          amount: data.amount,
          reason: data.reason,
          status: "processed",
          created_at: (/* @__PURE__ */ new Date()).toISOString()
        }
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },
  async handleWebhook(payload, signature) {
    try {
      if (signature && !this.verifySignature(payload, signature)) {
        return {
          success: false,
          eventType: "unknown",
          error: "Invalid signature"
        };
      }
      const eventType = this.mapEventType(payload.type);
      return {
        success: true,
        eventType,
        paymentId: payload.data?.payment_id,
        invoiceId: payload.data?.invoice_id,
        customerId: payload.data?.customer_id,
        status: payload.data?.status,
        gatewayResponse: payload
      };
    } catch (error) {
      return {
        success: false,
        eventType: "unknown",
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },
  async isAvailable() {
    try {
      return this.config.apiKey !== void 0 && this.config.secretKey !== void 0;
    } catch (error) {
      return false;
    }
  },
  getConfig() {
    return { ...this.config };
  },
  async verifySignature(payload, signature) {
    return true;
  },
  async mapEventType(abacateEventType) {
    const eventMap = {
      "payment.created": "payment.created",
      "payment.completed": "payment.completed",
      "payment.failed": "payment.failed",
      "payment.cancelled": "payment.cancelled",
      "payment.refunded": "payment.refunded",
      "invoice.created": "invoice.created",
      "invoice.paid": "invoice.paid",
      "invoice.failed": "invoice.failed"
    };
    return eventMap[abacateEventType] || "payment.created";
  },
  // Métodos específicos do Abacate Pay
  async generatePixPayment(data) {
    const paymentData = {
      ...data,
      paymentMethod: "pix"
    };
    return this.createPayment(paymentData);
  },
  async generateBoletoPayment(data) {
    const paymentData = {
      ...data,
      paymentMethod: "boleto"
    };
    return this.createPayment(paymentData);
  },
  async createSubscription(data) {
    console.log("Creating subscription with Abacate Pay:", data);
    const subscriptionId = `sub_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    return {
      success: true,
      paymentId: subscriptionId,
      status: "completed",
      gatewayResponse: {
        subscription_id: subscriptionId,
        customer_id: data.customerId,
        plan_id: data.planId,
        amount: data.amount,
        interval: data.interval,
        status: "active",
        created_at: (/* @__PURE__ */ new Date()).toISOString()
      }
    };
  }
};

// src/services/payment/stripe.service.ts
var StripeService = class {
  constructor() {
    this.config = {
      name: "Stripe",
      version: "2023-10-16",
      supportedCurrencies: ["USD", "EUR", "BRL", "GBP", "CAD", "AUD"],
      supportedMethods: ["card", "bank_transfer", "wallet", "buy_now_pay_later"],
      environment: process.env.STRIPE_ENV === "production" ? "production" : "sandbox",
      apiKey: process.env.STRIPE_API_KEY,
      secretKey: process.env.STRIPE_SECRET_KEY,
      webhookUrl: process.env.STRIPE_WEBHOOK_URL
    };
  }
  async createPayment(data) {
    try {
      console.log("Creating payment with Stripe:", data);
      const paymentId = `pi_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const success = data.amount > 0 && data.amount < 5e4;
      return {
        success,
        paymentId: success ? paymentId : void 0,
        status: success ? "pending" : "failed",
        gatewayResponse: {
          id: paymentId,
          object: "payment_intent",
          status: success ? "requires_payment_method" : "failed",
          amount: Math.round(data.amount * 100),
          // Stripe usa centavos
          currency: data.currency || "usd",
          created: Math.floor(Date.now() / 1e3)
        },
        error: success ? void 0 : "Payment amount exceeds limit"
      };
    } catch (error) {
      return {
        success: false,
        status: "failed",
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  async getPaymentStatus(paymentId) {
    try {
      console.log("Getting payment status from Stripe:", paymentId);
      const statuses = ["pending", "completed", "failed", "cancelled"];
      const randomStatus = statuses[Math.floor(Math.random() * statuses.length)];
      return {
        paymentId,
        status: randomStatus,
        amount: Math.random() * 1e3,
        currency: "usd",
        gatewayResponse: {
          id: paymentId,
          object: "payment_intent",
          status: randomStatus,
          amount: Math.round(Math.random() * 1e5),
          currency: "usd",
          updated: Math.floor(Date.now() / 1e3)
        }
      };
    } catch (error) {
      return {
        paymentId,
        status: "failed",
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  async cancelPayment(paymentId) {
    try {
      console.log("Cancelling payment with Stripe:", paymentId);
    } catch (error) {
      console.error("Error cancelling payment:", error);
      throw error;
    }
  }
  async refundPayment(data) {
    try {
      console.log("Processing refund with Stripe:", data);
      const refundId = `re_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      return {
        success: true,
        refundId,
        amount: data.amount,
        gatewayResponse: {
          id: refundId,
          object: "refund",
          payment_intent: data.paymentId,
          amount: data.amount ? Math.round(data.amount * 100) : void 0,
          reason: data.reason,
          status: "succeeded",
          created: Math.floor(Date.now() / 1e3)
        }
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  async handleWebhook(payload, signature) {
    try {
      if (signature && !this.verifySignature(payload, signature)) {
        return {
          success: false,
          eventType: "unknown",
          error: "Invalid signature"
        };
      }
      const eventType = this.mapEventType(payload.type);
      return {
        success: true,
        eventType,
        paymentId: payload.data?.object?.id,
        invoiceId: payload.data?.object?.metadata?.invoice_id,
        customerId: payload.data?.object?.customer,
        status: payload.data?.object?.status,
        gatewayResponse: payload
      };
    } catch (error) {
      return {
        success: false,
        eventType: "unknown",
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  async isAvailable() {
    try {
      return this.config.apiKey !== void 0 && this.config.secretKey !== void 0;
    } catch (error) {
      return false;
    }
  }
  getConfig() {
    return { ...this.config };
  }
  verifySignature(payload, signature) {
    return true;
  }
  mapEventType(stripeEventType) {
    const eventMap = {
      "payment_intent.created": "payment.created",
      "payment_intent.succeeded": "payment.completed",
      "payment_intent.payment_failed": "payment.failed",
      "payment_intent.canceled": "payment.cancelled",
      "charge.dispute.created": "payment.refunded",
      "invoice.created": "invoice.created",
      "invoice.payment_succeeded": "invoice.paid",
      "invoice.payment_failed": "invoice.failed",
      "customer.subscription.created": "subscription.created",
      "customer.subscription.updated": "subscription.updated",
      "customer.subscription.deleted": "subscription.cancelled"
    };
    return eventMap[stripeEventType] || "payment.created";
  }
  // Métodos específicos do Stripe
  async createPaymentIntent(data) {
    return this.createPayment(data);
  }
  async createCustomer(data) {
    console.log("Creating customer with Stripe:", data);
    const customerId = `cus_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    return {
      success: true,
      customerId
    };
  }
  async createSubscription(data) {
    console.log("Creating subscription with Stripe:", data);
    const subscriptionId = `sub_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    return {
      success: true,
      paymentId: subscriptionId,
      status: "completed",
      gatewayResponse: {
        id: subscriptionId,
        object: "subscription",
        customer: data.customerId,
        status: "active",
        current_period_start: Math.floor(Date.now() / 1e3),
        current_period_end: Math.floor(Date.now() / 1e3) + 30 * 24 * 60 * 60,
        created: Math.floor(Date.now() / 1e3)
      }
    };
  }
  async createSetupIntent(customerId) {
    console.log("Creating setup intent with Stripe:", customerId);
    const setupIntentId = `seti_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    return {
      success: true,
      paymentId: setupIntentId,
      status: "completed",
      gatewayResponse: {
        id: setupIntentId,
        object: "setup_intent",
        customer: customerId,
        status: "succeeded",
        created: Math.floor(Date.now() / 1e3)
      }
    };
  }
};

// src/services/payment/payment.service.ts
var PaymentService = {
  gateways: {
    "abacate-pay": AbacatePayService,
    stripe: StripeService
  },
  async processPayment(gatewayName, data) {
    const gateway = this.gateways[gatewayName];
    if (!gateway) {
      throw new Error(`Gateway '${gatewayName}' not found`);
    }
    return gateway.createPayment(data);
  },
  async getPaymentStatus(gatewayName, paymentId) {
    const gateway = this.gateways[gatewayName];
    if (!gateway) {
      throw new Error(`Gateway '${gatewayName}' not found`);
    }
    try {
      return await gateway.getPaymentStatus(paymentId);
    } catch (error) {
      throw new Error(`Error getting payment status via ${gatewayName}: ${error}`);
    }
  },
  async cancelPayment(gatewayName, paymentId) {
    const gateway = this.gateways[gatewayName];
    if (!gateway) {
      throw new Error(`Gateway '${gatewayName}' not found`);
    }
    return gateway.cancelPayment(paymentId);
  },
  async refundPayment(gatewayName, data) {
    const gateway = this.getGateway(gatewayName);
    if (!gateway) {
      return {
        success: false,
        error: `Gateway '${gatewayName}' not found`
      };
    }
    try {
      return await gateway.refundPayment(data);
    } catch (error) {
      console.error(`Error processing refund via ${gatewayName}:`, error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },
  async handleWebhook(gatewayName, payload, signature) {
    const gateway = this.getGateway(gatewayName);
    if (!gateway) {
      return {
        success: false,
        eventType: "unknown",
        error: `Gateway '${gatewayName}' not found`
      };
    }
    try {
      return await gateway.handleWebhook(payload, signature);
    } catch (error) {
      console.error(`Error handling webhook for ${gatewayName}:`, error);
      return {
        success: false,
        eventType: "unknown",
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },
  async retryFailedPayment(gatewayName, data, maxRetries = 3) {
    let attempts = 0;
    let lastError;
    while (attempts < maxRetries) {
      attempts++;
      const result = await this.processPayment(gatewayName, data);
      if (result.success) {
        return result;
      }
      lastError = result.error;
      if (attempts < maxRetries) {
        const delay = Math.pow(2, attempts) * 1e3;
        await new Promise((resolve) => setTimeout(resolve, delay));
      }
    }
    return {
      success: false,
      status: "failed",
      error: `Payment failed after ${maxRetries} attempts. Last error: ${lastError}`
    };
  },
  getGateway(gatewayName) {
    return this.gateways.get(gatewayName);
  },
  getAvailableGateways() {
    return Array.from(this.gateways.entries()).map(([name, gateway]) => ({
      name,
      config: gateway.getConfig()
    }));
  },
  async getGatewayHealth() {
    const healthChecks = await Promise.allSettled(
      Array.from(this.gateways.entries()).map(async ([name, gateway]) => {
        try {
          const available = await gateway.isAvailable();
          return { name, available };
        } catch (error) {
          return {
            name,
            available: false,
            error: error instanceof Error ? error.message : "Unknown error"
          };
        }
      })
    );
    return healthChecks.map(
      (result) => result.status === "fulfilled" ? result.value : {
        name: "unknown",
        available: false,
        error: "Health check failed"
      }
    );
  },
  // Método para determinar o melhor gateway baseado nos dados do pagamento
  async selectBestGateway(data) {
    const availableGateways = await this.getGatewayHealth();
    const workingGateways = availableGateways.filter((g) => g.available);
    if (workingGateways.length === 0) {
      return null;
    }
    if (data.currency === "BRL") {
      const abacatePay = workingGateways.find((g) => g.name === "abacate-pay");
      if (abacatePay) {
        return "abacate-pay";
      }
    }
    const stripe = workingGateways.find((g) => g.name === "stripe");
    if (stripe) {
      return "stripe";
    }
    return workingGateways[0]?.name || null;
  },
  // Método para processar pagamento com gateway automático
  async processPaymentAuto(data) {
    const selectedGateway = await this.selectBestGateway(data);
    if (!selectedGateway) {
      return {
        success: false,
        status: "failed",
        error: "No payment gateways available",
        gateway: "none"
      };
    }
    const result = await this.processPayment(selectedGateway, data);
    return {
      ...result,
      gateway: selectedGateway
    };
  }
};

// src/services/payment/webhook-handler.ts
var WebhookHandler = {
  async processWebhook(gatewayName, payload, signature) {
    try {
      const result = await PaymentService.handleWebhook(
        gatewayName,
        payload,
        signature
      );
      if (!result.success) {
        return {
          success: false,
          error: result.error
        };
      }
      const webhookEvent = {
        id: payload.id || `webhook_${Date.now()}`,
        type: result.eventType,
        data: {
          paymentId: result.paymentId,
          invoiceId: result.invoiceId,
          customerId: result.customerId,
          amount: payload.data?.object?.amount || payload.data?.amount,
          currency: payload.data?.object?.currency || payload.data?.currency,
          status: result.status,
          metadata: payload.data?.object?.metadata || payload.data?.metadata
        },
        createdAt: /* @__PURE__ */ new Date(),
        gateway: gatewayName
      };
      await WebhookHandler.processEvent(webhookEvent);
      return {
        success: true,
        event: webhookEvent
      };
    } catch (error) {
      console.error("Error processing webhook:", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },
  async processEvent(event) {
    try {
      console.log(`Processing webhook event: ${event.type}`, event);
      switch (event.type) {
        case "payment.completed":
          await WebhookHandler.handlePaymentCompleted(event);
          break;
        case "payment.failed":
          await WebhookHandler.handlePaymentFailed(event);
          break;
        case "payment.cancelled":
          await WebhookHandler.handlePaymentCancelled(event);
          break;
        case "payment.refunded":
          await WebhookHandler.handlePaymentRefunded(event);
          break;
        case "invoice.paid":
          await WebhookHandler.handleInvoicePaid(event);
          break;
        case "invoice.failed":
          await WebhookHandler.handleInvoiceFailed(event);
          break;
        case "subscription.created":
          await WebhookHandler.handleSubscriptionCreated(event);
          break;
        case "subscription.updated":
          await WebhookHandler.handleSubscriptionUpdated(event);
          break;
        case "subscription.cancelled":
          await WebhookHandler.handleSubscriptionCancelled(event);
          break;
        case "subscription.renewed":
          await WebhookHandler.handleSubscriptionRenewed(event);
          break;
        default:
          console.log(`Unhandled webhook event type: ${event.type}`);
      }
    } catch (error) {
      console.error(`Error processing event ${event.type}:`, error);
      throw error;
    }
  },
  async handlePaymentCompleted(event) {
    if (event.data.invoiceId) {
      console.log(`Updating invoice ${event.data.invoiceId} to PAID`);
    }
    if (event.data.customerId) {
      console.log(`Sending payment confirmation email to customer ${event.data.customerId}`);
    }
  },
  async handlePaymentFailed(event) {
    if (event.data.invoiceId) {
      console.log(`Updating invoice ${event.data.invoiceId} to FAILED`);
    }
    if (event.data.customerId) {
      console.log(`Sending payment failed email to customer ${event.data.customerId}`);
    }
  },
  async handlePaymentCancelled(event) {
    if (event.data.invoiceId) {
      console.log(`Updating invoice ${event.data.invoiceId} to CANCELLED`);
    }
  },
  async handlePaymentRefunded(event) {
    if (event.data.invoiceId) {
      console.log(`Processing refund for invoice ${event.data.invoiceId}`);
    }
  },
  async handleInvoicePaid(event) {
    if (event.data.invoiceId) {
      console.log(`Invoice ${event.data.invoiceId} marked as paid`);
    }
    if (event.data.customerId) {
      console.log(`Updating customer ${event.data.customerId} subscription status`);
    }
  },
  async handleInvoiceFailed(event) {
    if (event.data.invoiceId) {
      console.log(`Invoice ${event.data.invoiceId} failed`);
    }
  },
  async handleSubscriptionCreated(event) {
    if (event.data.customerId) {
      console.log(`Subscription created for customer ${event.data.customerId}`);
    }
  },
  async handleSubscriptionUpdated(event) {
    if (event.data.customerId) {
      console.log(`Subscription updated for customer ${event.data.customerId}`);
    }
  },
  async handleSubscriptionCancelled(event) {
    if (event.data.customerId) {
      console.log(`Subscription cancelled for customer ${event.data.customerId}`);
    }
  },
  async handleSubscriptionRenewed(event) {
    if (event.data.customerId) {
      console.log(`Subscription renewed for customer ${event.data.customerId}`);
    }
  },
  // Método para verificar a integridade do webhook
  async verifyWebhook(gatewayName, payload, signature) {
    try {
      const result = await PaymentService.handleWebhook(
        gatewayName,
        payload,
        signature
      );
      return result.success;
    } catch (error) {
      console.error("Error verifying webhook:", error);
      return false;
    }
  },
  // Método para listar todos os tipos de eventos suportados
  getSupportedEvents() {
    return [
      "payment.created",
      "payment.completed",
      "payment.failed",
      "payment.cancelled",
      "payment.refunded",
      "invoice.created",
      "invoice.paid",
      "invoice.failed",
      "subscription.created",
      "subscription.updated",
      "subscription.cancelled",
      "subscription.renewed"
    ];
  }
};

// src/features/webhook/webhook.service.ts
var WebhookService = {
  async processWebhook(gateway, payload, signature) {
    try {
      const availableGateways = PaymentService.getAvailableGateways();
      const gatewayExists = availableGateways.some((g) => g.name === gateway);
      if (!gatewayExists) {
        return {
          success: false,
          error: `Gateway '${gateway}' not supported`
        };
      }
      const result = await WebhookHandler.processWebhook(
        gateway,
        payload,
        signature
      );
      await WebhookService.logWebhook({
        gateway,
        eventType: result.event?.type || "unknown",
        eventId: result.event?.id,
        success: result.success,
        payload,
        response: result.event,
        error: result.error,
        processedAt: /* @__PURE__ */ new Date()
      });
      return {
        success: result.success,
        eventId: result.event?.id,
        eventType: result.event?.type,
        error: result.error
      };
    } catch (error) {
      await WebhookService.logWebhook({
        gateway,
        eventType: "error",
        success: false,
        payload,
        error: error instanceof Error ? error.message : "Unknown error",
        processedAt: /* @__PURE__ */ new Date()
      });
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },
  async verifyWebhook(gateway, payload, signature) {
    try {
      return await WebhookHandler.verifyWebhook(
        gateway,
        payload,
        signature
      );
    } catch (error) {
      console.error("Error verifying webhook:", error);
      return false;
    }
  },
  async getWebhookLogs(params) {
    const mockLogs = [
      {
        id: "log_1",
        gateway: "stripe",
        eventType: "payment.completed",
        eventId: "evt_123",
        success: true,
        payload: { type: "payment_intent.succeeded" },
        processedAt: new Date(Date.now() - 1e3 * 60 * 5),
        // 5 minutos atrás
        createdAt: new Date(Date.now() - 1e3 * 60 * 5)
      },
      {
        id: "log_2",
        gateway: "abacate-pay",
        eventType: "payment.failed",
        eventId: "evt_456",
        success: false,
        payload: { type: "payment_failed" },
        error: "Payment declined",
        processedAt: new Date(Date.now() - 1e3 * 60 * 10),
        // 10 minutos atrás
        createdAt: new Date(Date.now() - 1e3 * 60 * 10)
      }
    ];
    let filteredLogs = mockLogs;
    if (params.gateway) {
      filteredLogs = filteredLogs.filter((log) => log.gateway === params.gateway);
    }
    if (params.eventType) {
      filteredLogs = filteredLogs.filter((log) => log.eventType === params.eventType);
    }
    if (params.success !== void 0) {
      filteredLogs = filteredLogs.filter((log) => log.success === params.success);
    }
    if (params.startDate) {
      const startDate = new Date(params.startDate);
      filteredLogs = filteredLogs.filter((log) => log.processedAt >= startDate);
    }
    if (params.endDate) {
      const endDate = new Date(params.endDate);
      filteredLogs = filteredLogs.filter((log) => log.processedAt <= endDate);
    }
    const page = params.page || 1;
    const limit = params.limit || 10;
    const skip = (page - 1) * limit;
    const items = filteredLogs.slice(skip, skip + limit);
    const total = filteredLogs.length;
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getWebhookStats() {
    const mockStats = {
      total: 150,
      successful: 142,
      failed: 8,
      byGateway: {
        "stripe": {
          total: 100,
          successful: 95,
          failed: 5
        },
        "abacate-pay": {
          total: 50,
          successful: 47,
          failed: 3
        }
      },
      byEventType: {
        "payment.completed": 95,
        "payment.failed": 8,
        "payment.cancelled": 2,
        "invoice.paid": 45,
        "invoice.failed": 3
      },
      last24Hours: {
        total: 25,
        successful: 24,
        failed: 1
      }
    };
    return mockStats;
  },
  async getWebhookHealth() {
    try {
      const gatewayHealth = await PaymentService.getGatewayHealth();
      const gateways = gatewayHealth.map((gateway) => ({
        name: gateway.name,
        available: gateway.available,
        lastWebhook: new Date(Date.now() - Math.random() * 1e3 * 60 * 60),
        // Mock
        errorRate: Math.random() * 5
        // Mock: 0-5% error rate
      }));
      const availableGateways = gateways.filter((g) => g.available).length;
      const totalGateways = gateways.length;
      return {
        gateways,
        overall: {
          available: availableGateways > 0,
          totalGateways,
          availableGateways
        }
      };
    } catch (error) {
      console.error("Error getting webhook health:", error);
      return {
        gateways: [],
        overall: {
          available: false,
          totalGateways: 0,
          availableGateways: 0
        }
      };
    }
  },
  async getSupportedEvents() {
    return WebhookHandler.getSupportedEvents();
  },
  async retryFailedWebhook(webhookId) {
    try {
      console.log(`Retrying failed webhook: ${webhookId}`);
      return {
        success: true
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },
  async deleteWebhookLog(webhookId) {
    try {
      console.log(`Deleting webhook log: ${webhookId}`);
      return {
        success: true
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },
  async logWebhook(data) {
    console.log("Webhook logged:", {
      ...data,
      id: `webhook_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      createdAt: /* @__PURE__ */ new Date()
    });
  }
};

// src/features/webhook/webhook.controller.ts
var WebhookController = {
  async processAbacatePay(request, reply) {
    try {
      const { payload } = request.body;
      const signature = request.headers["x-abacate-signature"] || request.headers["x-signature"];
      const result = await WebhookService.processWebhook(
        "abacate-pay",
        payload,
        signature
      );
      if (!result.success) {
        return reply.status(400).send({
          error: result.error
        });
      }
      return reply.status(200).send({
        success: true,
        eventId: result.eventId,
        eventType: result.eventType,
        gateway: "abacate-pay",
        processedAt: /* @__PURE__ */ new Date()
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async processStripe(request, reply) {
    try {
      const payload = request.body;
      const signature = request.headers["stripe-signature"];
      const result = await WebhookService.processWebhook(
        "stripe",
        payload,
        signature
      );
      if (!result.success) {
        return reply.status(400).send({
          error: result.error
        });
      }
      return reply.status(200).send({
        success: true,
        eventId: result.eventId,
        eventType: result.eventType,
        gateway: "stripe",
        processedAt: /* @__PURE__ */ new Date()
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async processGeneric(request, reply) {
    try {
      const { gateway } = request.params;
      const payload = request.body;
      const signature = request.headers["x-signature"] || request.headers["x-hub-signature"];
      const result = await WebhookService.processWebhook(
        gateway,
        payload,
        signature
      );
      if (!result.success) {
        return reply.status(400).send({
          error: result.error
        });
      }
      return reply.status(200).send({
        success: true,
        eventId: result.eventId,
        eventType: result.eventType,
        gateway,
        processedAt: /* @__PURE__ */ new Date()
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getLogs(request, reply) {
    try {
      const { page = 1, limit = 10, gateway, eventType, success, startDate, endDate } = request.query;
      const result = await WebhookService.getWebhookLogs({
        page,
        limit,
        gateway,
        eventType,
        success,
        startDate,
        endDate
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const result = await WebhookService.getWebhookStats();
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getHealth(request, reply) {
    try {
      const result = await WebhookService.getWebhookHealth();
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getSupportedEvents(request, reply) {
    try {
      const result = await WebhookService.getSupportedEvents();
      return reply.send({
        events: result
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async retryFailed(request, reply) {
    try {
      const { id } = request.params;
      const result = await WebhookService.retryFailedWebhook(id);
      if (!result.success) {
        return reply.status(400).send({
          error: result.error
        });
      }
      return reply.send({
        success: true,
        message: "Webhook retry initiated"
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async deleteLog(request, reply) {
    try {
      const { id } = request.params;
      const result = await WebhookService.deleteWebhookLog(id);
      if (!result.success) {
        return reply.status(400).send({
          error: result.error
        });
      }
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/webhook/webhook.routes.ts
async function WebhookRoutes(fastify2) {
  fastify2.post("/abacate-pay", {
    config: {
      // Configurações específicas para webhooks
      rawBody: true
      // Para preservar o body original para verificação de assinatura
    },
    handler: WebhookController.processAbacatePay
  });
  fastify2.post("/stripe", {
    config: {
      rawBody: true
    },
    handler: WebhookController.processStripe
  });
  fastify2.post("/:gateway", {
    config: {
      rawBody: true
    },
    handler: WebhookController.processGeneric
  });
  fastify2.get("/logs", {
    schema: {
      querystring: {
        type: "object",
        properties: {
          page: { type: "number", minimum: 1, default: 1 },
          limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
          gateway: { type: "string" },
          eventType: { type: "string" },
          success: { type: "boolean" },
          startDate: { type: "string", format: "date" },
          endDate: { type: "string", format: "date" }
        }
      },
      response: {
        200: {
          type: "object",
          properties: {
            items: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  gateway: { type: "string" },
                  eventType: { type: "string" },
                  eventId: { type: "string", nullable: true },
                  success: { type: "boolean" },
                  payload: { type: "object" },
                  response: { type: "object", nullable: true },
                  error: { type: "string", nullable: true },
                  processedAt: { type: "string", format: "date-time" },
                  createdAt: { type: "string", format: "date-time" }
                }
              }
            },
            pagination: {
              type: "object",
              properties: {
                page: { type: "number" },
                limit: { type: "number" },
                total: { type: "number" },
                totalPages: { type: "number" }
              }
            }
          }
        }
      }
    },
    preHandler: [(init_auth_middleware(), __toCommonJS(auth_middleware_exports)).authMiddleware],
    handler: WebhookController.getLogs
  });
  fastify2.get("/stats", {
    schema: {
      response: {
        200: {
          type: "object",
          properties: {
            total: { type: "number" },
            successful: { type: "number" },
            failed: { type: "number" },
            byGateway: {
              type: "object",
              additionalProperties: {
                type: "object",
                properties: {
                  total: { type: "number" },
                  successful: { type: "number" },
                  failed: { type: "number" }
                }
              }
            },
            byEventType: {
              type: "object",
              additionalProperties: { type: "number" }
            },
            last24Hours: {
              type: "object",
              properties: {
                total: { type: "number" },
                successful: { type: "number" },
                failed: { type: "number" }
              }
            }
          }
        }
      }
    },
    preHandler: [(init_auth_middleware(), __toCommonJS(auth_middleware_exports)).authMiddleware],
    handler: WebhookController.getStats
  });
  fastify2.get("/health", {
    schema: {
      response: {
        200: {
          type: "object",
          properties: {
            gateways: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  name: { type: "string" },
                  available: { type: "boolean" },
                  lastWebhook: { type: "string", format: "date-time", nullable: true },
                  errorRate: { type: "number", nullable: true }
                }
              }
            },
            overall: {
              type: "object",
              properties: {
                available: { type: "boolean" },
                totalGateways: { type: "number" },
                availableGateways: { type: "number" }
              }
            }
          }
        }
      }
    },
    handler: WebhookController.getHealth
  });
  fastify2.get("/events", {
    schema: {
      response: {
        200: {
          type: "object",
          properties: {
            events: {
              type: "array",
              items: { type: "string" }
            }
          }
        }
      }
    },
    handler: WebhookController.getSupportedEvents
  });
  fastify2.post("/:id/retry", {
    schema: {
      params: {
        type: "object",
        required: ["id"],
        properties: {
          id: { type: "string" }
        }
      },
      response: {
        200: {
          type: "object",
          properties: {
            success: { type: "boolean" },
            message: { type: "string" }
          }
        }
      }
    },
    preHandler: [(init_auth_middleware(), __toCommonJS(auth_middleware_exports)).authMiddleware],
    handler: WebhookController.retryFailed
  });
  fastify2.delete("/:id/log", {
    schema: {
      params: {
        type: "object",
        required: ["id"],
        properties: {
          id: { type: "string" }
        }
      },
      response: {
        204: { type: "null" }
      }
    },
    preHandler: [(init_auth_middleware(), __toCommonJS(auth_middleware_exports)).authMiddleware],
    handler: WebhookController.deleteLog
  });
}

// src/features/crm/commands/crm.commands.ts
init_prisma();
var CrmCommands = {
  async create(data) {
    if (data.stageId) {
      const stage = await db.crmStage.findFirst({
        where: {
          id: data.stageId,
          storeId: data.storeId
        }
      });
      if (!stage) {
        throw new Error("Stage not found or does not belong to the same store");
      }
    }
    return await db.crmClient.create({
      data: {
        storeId: data.storeId,
        name: data.name,
        email: data.email,
        phone: data.phone,
        cpfCnpj: data.cpfCnpj,
        company: data.company,
        notes: data.notes,
        stageId: data.stageId
      },
      include: {
        stage: true
      }
    });
  },
  async update(id, data, storeId) {
    const client = await db.crmClient.findFirst({
      where: {
        id,
        storeId
      }
    });
    if (!client) {
      throw new Error("Client not found or does not belong to the store");
    }
    if (data.stageId) {
      const stage = await db.crmStage.findFirst({
        where: {
          id: data.stageId,
          storeId
        }
      });
      if (!stage) {
        throw new Error("Stage not found or does not belong to the same store");
      }
    }
    return await db.crmClient.update({
      where: { id },
      data,
      include: {
        stage: true
      }
    });
  },
  async delete(id, storeId) {
    const client = await db.crmClient.findFirst({
      where: {
        id,
        storeId
      }
    });
    if (!client) {
      throw new Error("Client not found or does not belong to the store");
    }
    return await db.crmClient.delete({
      where: { id }
    });
  },
  async transitionStage(clientId, stageId, storeId) {
    const client = await db.crmClient.findFirst({
      where: {
        id: clientId,
        storeId
      }
    });
    if (!client) {
      throw new Error("Client not found or does not belong to the store");
    }
    if (stageId) {
      const stage = await db.crmStage.findFirst({
        where: {
          id: stageId,
          storeId
        }
      });
      if (!stage) {
        throw new Error("Stage not found or does not belong to the same store");
      }
    }
    return await db.crmClient.update({
      where: { id: clientId },
      data: { stageId },
      include: {
        stage: true
      }
    });
  }
};

// src/features/crm/queries/crm.queries.ts
init_prisma();
var CrmQueries = {
  async getById(id, storeId) {
    return await db.crmClient.findFirst({
      where: {
        id,
        storeId
      },
      include: {
        stage: true
      }
    });
  },
  async list(params, storeId) {
    const { page = 1, limit = 10, search, stageId } = params;
    const skip = (Number(page) - 1) * Number(limit);
    const take = Number(limit);
    console.log("\u{1F50D} DEBUG list: params:", { page, limit, skip, take, search, stageId });
    const where = {
      storeId
    };
    if (stageId) {
      where.stageId = stageId;
    }
    if (search) {
      where.OR = [
        { name: { contains: search, mode: "insensitive" } },
        { email: { contains: search, mode: "insensitive" } },
        { phone: { contains: search, mode: "insensitive" } },
        { cpfCnpj: { contains: search, mode: "insensitive" } },
        { company: { contains: search, mode: "insensitive" } },
        { notes: { contains: search, mode: "insensitive" } }
      ];
    }
    const [items, total] = await Promise.all([
      db.crmClient.findMany({
        where,
        skip,
        take,
        orderBy: { createdAt: "desc" },
        include: {
          stage: true
        }
      }),
      db.crmClient.count({ where })
    ]);
    return {
      items,
      pagination: {
        page: Number(page),
        limit: Number(limit),
        total,
        totalPages: Math.ceil(total / Number(limit))
      }
    };
  },
  async listGroupedByStage(storeId) {
    console.log("\u{1F50D} DEBUG listGroupedByStage: Starting with storeId:", storeId);
    try {
      console.log("\u{1F4CA} Searching for stages...");
      const stages = await db.crmStage.findMany({
        where: { storeId },
        orderBy: { order: "asc" },
        include: {
          clients: {
            orderBy: { createdAt: "desc" }
          }
        }
      });
      console.log("\u2705 Found stages:", stages.length);
      console.log("\u{1F4CB} Stages data:", JSON.stringify(stages, null, 2));
      console.log("\u{1F4CA} Searching for clients without stage...");
      const clientsWithoutStage = await db.crmClient.findMany({
        where: {
          storeId,
          stageId: null
        },
        orderBy: { createdAt: "desc" }
      });
      console.log("\u2705 Found clients without stage:", clientsWithoutStage.length);
      const stagesWithClients = [...stages];
      if (clientsWithoutStage.length > 0) {
        console.log("\u{1F4DD} Adding virtual stage for clients without stage");
        stagesWithClients.push({
          id: null,
          name: "Sem Stage",
          color: "#6B7280",
          order: -1,
          createdAt: /* @__PURE__ */ new Date(),
          storeId,
          clients: clientsWithoutStage
        });
      }
      console.log("\u{1F4CA} Counting total clients...");
      const totalClients = await db.crmClient.count({
        where: { storeId }
      });
      console.log("\u2705 Total clients in store:", totalClients);
      const result = {
        stages: stagesWithClients,
        totalClients
      };
      console.log("\u{1F3AF} Final result:", JSON.stringify(result, null, 2));
      return result;
    } catch (error) {
      console.error("\u274C Error in listGroupedByStage:", error);
      throw error;
    }
  },
  async search(term, limit = 10, storeId) {
    return await db.crmClient.findMany({
      where: {
        storeId,
        OR: [
          { name: { contains: term, mode: "insensitive" } },
          { email: { contains: term, mode: "insensitive" } },
          { phone: { contains: term, mode: "insensitive" } },
          { cpfCnpj: { contains: term, mode: "insensitive" } },
          { company: { contains: term, mode: "insensitive" } },
          { notes: { contains: term, mode: "insensitive" } }
        ]
      },
      take: limit,
      orderBy: { createdAt: "desc" },
      include: {
        stage: true
      }
    });
  },
  async getStats(storeId) {
    const [totalClients, clientsByStage] = await Promise.all([
      db.crmClient.count({
        where: { storeId }
      }),
      db.crmStage.findMany({
        where: { storeId },
        include: {
          _count: {
            select: { clients: true }
          }
        },
        orderBy: { order: "asc" }
      })
    ]);
    const clientsWithoutStage = await db.crmClient.count({
      where: {
        storeId,
        stageId: null
      }
    });
    return {
      totalClients,
      clientsByStage: clientsByStage.map((stage) => ({
        stageId: stage.id,
        stageName: stage.name,
        clientsCount: stage._count.clients
      })),
      clientsWithoutStage
    };
  }
};

// src/features/crm/commands/crm.stage.commands.ts
init_prisma();
var CrmStageCommands = {
  async create(data) {
    return await db.crmStage.create({
      data: {
        storeId: data.storeId,
        name: data.name,
        color: data.color,
        order: data.order
      }
    });
  },
  async update(id, data, storeId) {
    const stage = await db.crmStage.findFirst({
      where: {
        id,
        storeId
      }
    });
    if (!stage) {
      throw new Error("Stage not found or does not belong to the store");
    }
    return await db.crmStage.update({
      where: { id },
      data
    });
  },
  async delete(id, storeId) {
    const stage = await db.crmStage.findFirst({
      where: {
        id,
        storeId
      }
    });
    if (!stage) {
      throw new Error("Stage not found or does not belong to the store");
    }
    const clientsCount = await db.crmClient.count({
      where: {
        stageId: id,
        storeId
      }
    });
    if (clientsCount > 0) {
      throw new Error("Cannot delete stage with clients. Move clients to another stage first.");
    }
    return await db.crmStage.delete({
      where: { id }
    });
  },
  async reorder(id, newOrder, storeId) {
    const stage = await db.crmStage.findFirst({
      where: {
        id,
        storeId
      }
    });
    if (!stage) {
      throw new Error("Stage not found or does not belong to the store");
    }
    return await db.crmStage.update({
      where: { id },
      data: { order: newOrder }
    });
  }
};

// src/features/crm/queries/crm.stage.queries.ts
init_prisma();
var CrmStageQueries = {
  async getById(id, storeId) {
    return await db.crmStage.findFirst({
      where: {
        id,
        storeId
      },
      include: {
        _count: {
          select: { clients: true }
        }
      }
    });
  },
  async list(storeId, params = {}) {
    const { page = 1, limit = 10 } = params;
    const skip = (page - 1) * limit;
    const [items, total] = await Promise.all([
      db.crmStage.findMany({
        where: { storeId },
        skip,
        take: limit,
        orderBy: { order: "asc" },
        include: {
          _count: {
            select: { clients: true }
          }
        }
      }),
      db.crmStage.count({
        where: { storeId }
      })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getNextOrder(storeId) {
    const lastStage = await db.crmStage.findFirst({
      where: { storeId },
      orderBy: { order: "desc" }
    });
    return lastStage ? lastStage.order + 1 : 1;
  },
  async getStats(storeId) {
    const [totalStages, stagesWithClients] = await Promise.all([
      db.crmStage.count({
        where: { storeId }
      }),
      db.crmStage.findMany({
        where: { storeId },
        include: {
          _count: {
            select: { clients: true }
          }
        },
        orderBy: { order: "asc" }
      })
    ]);
    const totalClients = stagesWithClients.reduce((sum, stage) => sum + stage._count.clients, 0);
    return {
      totalStages,
      totalClients,
      stagesWithClients: stagesWithClients.map((stage) => ({
        id: stage.id,
        name: stage.name,
        color: stage.color,
        order: stage.order,
        clientsCount: stage._count.clients
      }))
    };
  }
};

// src/features/crm/crm.controller.ts
var CrmController = {
  // === ENDPOINT DE TESTE TEMPORÁRIO ===
  async testGrouped(request, reply) {
    try {
      const storeId = request.store?.id;
      console.log("\u{1F9EA} TEST: storeId:", storeId);
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CrmQueries.listGroupedByStage(storeId);
      return reply.send({
        success: true,
        storeId,
        result
      });
    } catch (error) {
      console.error("\u274C TEST Error:", error);
      return reply.status(500).send({
        error: "Test failed",
        details: error.message
      });
    }
  },
  // === CRUD BÁSICO DE CLIENTES ===
  async createClient(request, reply) {
    try {
      const { name, email, phone, cpfCnpj, company, notes, stageId } = request.body;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CrmCommands.create({
        storeId,
        name,
        email,
        phone,
        cpfCnpj,
        company,
        notes,
        stageId
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Stage not found or does not belong to the same store") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getClient(request, reply) {
    try {
      const { id } = request.params;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CrmQueries.getById(id, storeId);
      if (!result) {
        return reply.status(404).send({
          error: "Client not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async updateClient(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CrmCommands.update(id, updateData, storeId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Client not found or does not belong to the store") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Stage not found or does not belong to the same store") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async deleteClient(request, reply) {
    try {
      const { id } = request.params;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      await CrmCommands.delete(id, storeId);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Client not found or does not belong to the store") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async listClients(request, reply) {
    try {
      const { page = 1, limit = 10, search, stageId, grouped } = request.query;
      const storeId = request.store?.id;
      console.log("\u{1F50D} DEBUG listClients:");
      console.log("- Query params:", { page, limit, search, stageId, grouped });
      console.log("- StoreId:", storeId);
      console.log("- Request user:", request.user);
      console.log("- Request store:", request.store);
      if (!storeId) {
        console.log("\u274C No storeId found");
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      if (grouped) {
        console.log("\u{1F4CA} Calling listGroupedByStage...");
        const result2 = await CrmQueries.listGroupedByStage(storeId);
        console.log("\u2705 listGroupedByStage result:", JSON.stringify(result2, null, 2));
        return reply.send(result2);
      }
      const result = await CrmQueries.list({
        page: Number(page),
        limit: Number(limit),
        search,
        stageId
      }, storeId);
      return reply.send(result);
    } catch (error) {
      console.error("\u274C Error in listClients:", error);
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async searchClients(request, reply) {
    try {
      const { q, limit = 10 } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CrmQueries.search(q, limit, storeId);
      return reply.send({ clients: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async transitionStage(request, reply) {
    try {
      const { id } = request.params;
      const { stageId } = request.body;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CrmCommands.transitionStage(id, stageId, storeId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Client not found or does not belong to the store") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Stage not found or does not belong to the same store") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CrmQueries.getStats(storeId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === CRUD BÁSICO DE STAGES ===
  async createStage(request, reply) {
    try {
      const { name, color, order } = request.body;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const finalOrder = order || await CrmStageQueries.getNextOrder(storeId);
      const result = await CrmStageCommands.create({
        storeId,
        name,
        color,
        order: finalOrder
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStage(request, reply) {
    try {
      const { id } = request.params;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CrmStageQueries.getById(id, storeId);
      if (!result) {
        return reply.status(404).send({
          error: "Stage not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async updateStage(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CrmStageCommands.update(id, updateData, storeId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Stage not found or does not belong to the store") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async deleteStage(request, reply) {
    try {
      const { id } = request.params;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      await CrmStageCommands.delete(id, storeId);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Stage not found or does not belong to the store") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Cannot delete stage with clients. Move clients to another stage first.") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async listStages(request, reply) {
    try {
      const { page = 1, limit = 10 } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CrmStageQueries.list(storeId, { page, limit });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async reorderStage(request, reply) {
    try {
      const { id } = request.params;
      const { order } = request.body;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CrmStageCommands.reorder(id, order, storeId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Stage not found or does not belong to the store") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStageStats(request, reply) {
    try {
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CrmStageQueries.getStats(storeId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/crm/crm.schema.ts
var createCrmClientSchema = {
  body: {
    type: "object",
    required: ["name"],
    properties: {
      name: { type: "string", minLength: 1 },
      email: { type: "string", format: "email" },
      phone: { type: "string" },
      cpfCnpj: { type: "string" },
      company: { type: "string" },
      notes: { type: "string" },
      stageId: { type: "string" }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: "string" },
        stageId: { type: "string" },
        name: { type: "string" },
        email: { type: "string" },
        phone: { type: "string" },
        cpfCnpj: { type: "string" },
        company: { type: "string" },
        notes: { type: "string" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        stage: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            color: { type: "string" },
            order: { type: "number" }
          }
        }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var updateCrmClientSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      name: { type: "string", minLength: 1 },
      email: { type: "string", format: "email" },
      phone: { type: "string" },
      cpfCnpj: { type: "string" },
      company: { type: "string" },
      notes: { type: "string" },
      stageId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: "string" },
        stageId: { type: "string" },
        name: { type: "string" },
        email: { type: "string" },
        phone: { type: "string" },
        cpfCnpj: { type: "string" },
        company: { type: "string" },
        notes: { type: "string" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        stage: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            color: { type: "string" },
            order: { type: "number" }
          }
        }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getCrmClientSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: "string" },
        stageId: { type: "string" },
        name: { type: "string" },
        email: { type: "string" },
        phone: { type: "string" },
        cpfCnpj: { type: "string" },
        company: { type: "string" },
        notes: { type: "string" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        stage: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            color: { type: "string" },
            order: { type: "number" }
          }
        }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var listCrmClientsSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      stageId: { type: "string" },
      grouped: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      oneOf: [
        {
          // Schema para grouped=true
          properties: {
            stages: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  id: { type: ["string", "null"] },
                  name: { type: "string" },
                  color: { type: "string" },
                  order: { type: "number" },
                  clients: {
                    type: "array",
                    items: {
                      type: "object",
                      properties: {
                        id: { type: "string" },
                        name: { type: "string" },
                        email: { type: "string" },
                        phone: { type: "string" },
                        company: { type: "string" },
                        createdAt: { type: "string", format: "date-time" }
                      }
                    }
                  }
                }
              }
            },
            totalClients: { type: "number" }
          }
        },
        {
          // Schema para grouped=false (padrão)
          properties: {
            items: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  storeId: { type: "string" },
                  stageId: { type: "string" },
                  name: { type: "string" },
                  email: { type: "string" },
                  phone: { type: "string" },
                  cpfCnpj: { type: "string" },
                  company: { type: "string" },
                  notes: { type: "string" },
                  createdAt: { type: "string", format: "date-time" },
                  updatedAt: { type: "string", format: "date-time" },
                  stage: {
                    type: "object",
                    properties: {
                      id: { type: "string" },
                      name: { type: "string" },
                      color: { type: "string" },
                      order: { type: "number" }
                    }
                  }
                }
              }
            },
            pagination: {
              type: "object",
              properties: {
                page: { type: "number" },
                limit: { type: "number" },
                total: { type: "number" },
                totalPages: { type: "number" }
              }
            }
          }
        }
      ]
    }
  }
};
var listCrmClientsGroupedSchema = {
  querystring: {
    type: "object",
    properties: {
      grouped: { type: "boolean", default: true }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        stages: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: ["string", "null"] },
              name: { type: "string" },
              color: { type: "string" },
              order: { type: "number" },
              clients: {
                type: "array",
                items: {
                  type: "object",
                  properties: {
                    id: { type: "string" },
                    name: { type: "string" },
                    email: { type: "string" },
                    phone: { type: "string" },
                    company: { type: "string" },
                    createdAt: { type: "string", format: "date-time" }
                  }
                }
              }
            }
          }
        },
        totalClients: { type: "number" }
      }
    }
  }
};
var deleteCrmClientSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var transitionStageSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["stageId"],
    properties: {
      stageId: { type: ["string", "null"] }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: "string" },
        stageId: { type: "string" },
        name: { type: "string" },
        stage: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            color: { type: "string" },
            order: { type: "number" }
          }
        }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var createCrmStageSchema = {
  body: {
    type: "object",
    required: ["name"],
    properties: {
      name: { type: "string", minLength: 1 },
      color: { type: "string" },
      order: { type: "number", minimum: 1 }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: "string" },
        name: { type: "string" },
        color: { type: "string" },
        order: { type: "number" },
        createdAt: { type: "string", format: "date-time" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var updateCrmStageSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      name: { type: "string", minLength: 1 },
      color: { type: "string" },
      order: { type: "number", minimum: 1 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: "string" },
        name: { type: "string" },
        color: { type: "string" },
        order: { type: "number" },
        createdAt: { type: "string", format: "date-time" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getCrmStageSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: "string" },
        name: { type: "string" },
        color: { type: "string" },
        order: { type: "number" },
        createdAt: { type: "string", format: "date-time" },
        _count: {
          type: "object",
          properties: {
            clients: { type: "number" }
          }
        }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var listCrmStagesSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              storeId: { type: "string" },
              name: { type: "string" },
              color: { type: "string" },
              order: { type: "number" },
              createdAt: { type: "string", format: "date-time" },
              _count: {
                type: "object",
                properties: {
                  clients: { type: "number" }
                }
              }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var deleteCrmStageSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var reorderCrmStageSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["order"],
    properties: {
      order: { type: "number", minimum: 1 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: "string" },
        name: { type: "string" },
        color: { type: "string" },
        order: { type: "number" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var CrmSchemas = {
  // Client schemas
  createClient: createCrmClientSchema,
  updateClient: updateCrmClientSchema,
  getClient: getCrmClientSchema,
  deleteClient: deleteCrmClientSchema,
  listClients: listCrmClientsSchema,
  listClientsGrouped: listCrmClientsGroupedSchema,
  transitionStage: transitionStageSchema,
  // Stage schemas
  createStage: createCrmStageSchema,
  updateStage: updateCrmStageSchema,
  getStage: getCrmStageSchema,
  deleteStage: deleteCrmStageSchema,
  listStages: listCrmStagesSchema,
  reorderStage: reorderCrmStageSchema
};

// src/features/crm/crm.routes.ts
async function CrmRoutes(fastify2) {
  fastify2.addHook("preHandler", authMiddleware);
  fastify2.addHook("preHandler", storeContextMiddleware);
  fastify2.get("/test-grouped", {
    handler: CrmController.testGrouped
  });
  fastify2.post("/clients", {
    schema: CrmSchemas.createClient,
    handler: CrmController.createClient
  });
  fastify2.get("/clients", {
    // schema: CrmSchemas.listClients, // Temporariamente desabilitado para debug
    handler: CrmController.listClients
  });
  fastify2.get("/clients/grouped", {
    schema: CrmSchemas.listClientsGrouped,
    handler: CrmController.listClients
  });
  fastify2.get("/clients/:id", {
    schema: CrmSchemas.getClient,
    handler: CrmController.getClient
  });
  fastify2.put("/clients/:id", {
    schema: CrmSchemas.updateClient,
    handler: CrmController.updateClient
  });
  fastify2.delete("/clients/:id", {
    schema: CrmSchemas.deleteClient,
    handler: CrmController.deleteClient
  });
  fastify2.patch("/clients/:id/stage", {
    schema: CrmSchemas.transitionStage,
    handler: CrmController.transitionStage
  });
  fastify2.get("/clients/search", {
    handler: CrmController.searchClients
  });
  fastify2.get("/clients/stats", {
    handler: CrmController.getStats
  });
  fastify2.post("/stages", {
    schema: CrmSchemas.createStage,
    handler: CrmController.createStage
  });
  fastify2.get("/stages", {
    schema: CrmSchemas.listStages,
    handler: CrmController.listStages
  });
  fastify2.get("/stages/:id", {
    schema: CrmSchemas.getStage,
    handler: CrmController.getStage
  });
  fastify2.put("/stages/:id", {
    schema: CrmSchemas.updateStage,
    handler: CrmController.updateStage
  });
  fastify2.delete("/stages/:id", {
    schema: CrmSchemas.deleteStage,
    handler: CrmController.deleteStage
  });
  fastify2.patch("/stages/:id/reorder", {
    schema: CrmSchemas.reorderStage,
    handler: CrmController.reorderStage
  });
  fastify2.get("/stages/stats", {
    handler: CrmController.getStageStats
  });
}

// src/features/user-preferences/commands/user-preferences.commands.ts
init_prisma();
var UserPreferencesCommands = {
  async create(data) {
    try {
      const user = await db.user.findUnique({
        where: { id: data.userId }
      });
      if (!user) {
        throw new Error("User not found");
      }
      const existingPreferences = await db.userPreferences.findUnique({
        where: { userId: data.userId }
      });
      if (existingPreferences) {
        throw new Error("User preferences already exist for this user");
      }
      const preferences = await db.userPreferences.create({
        data: {
          userId: data.userId,
          theme: data.theme || "light",
          primaryColor: data.primaryColor,
          sidebarCollapsed: data.sidebarCollapsed || false,
          compactMode: data.compactMode || false,
          language: data.language || "pt-BR",
          currency: data.currency || "BRL",
          timezone: data.timezone || "America/Sao_Paulo",
          dateFormat: data.dateFormat || "DD/MM/YYYY",
          timeFormat: data.timeFormat || "24h",
          numberFormat: data.numberFormat || "pt-BR",
          emailNotifications: data.emailNotifications !== void 0 ? data.emailNotifications : true,
          pushNotifications: data.pushNotifications !== void 0 ? data.pushNotifications : true,
          smsNotifications: data.smsNotifications || false,
          notificationTypes: data.notificationTypes,
          dashboardLayout: data.dashboardLayout,
          defaultPage: data.defaultPage,
          itemsPerPage: data.itemsPerPage || 20,
          defaultStoreId: data.defaultStoreId,
          autoRefresh: data.autoRefresh !== void 0 ? data.autoRefresh : true,
          refreshInterval: data.refreshInterval || 30,
          customSettings: data.customSettings
        },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      });
      return preferences;
    } catch (error) {
      throw new Error(`Failed to create user preferences: ${error.message}`);
    }
  },
  // ================================
  // UPDATE OPERATIONS
  // ================================
  async update(id, data) {
    try {
      const existingPreferences = await db.userPreferences.findUnique({
        where: { id }
      });
      if (!existingPreferences) {
        throw new Error("User preferences not found");
      }
      const updatedPreferences = await db.userPreferences.update({
        where: { id },
        data: {
          ...data,
          updatedAt: /* @__PURE__ */ new Date()
        },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      });
      return updatedPreferences;
    } catch (error) {
      throw new Error(`Failed to update user preferences: ${error.message}`);
    }
  },
  async updateByUserId(userId, data) {
    try {
      const user = await db.user.findUnique({
        where: { id: userId }
      });
      if (!user) {
        throw new Error("User not found");
      }
      const existingPreferences = await db.userPreferences.findUnique({
        where: { userId }
      });
      if (!existingPreferences) {
        return await UserPreferencesCommands.create({ ...data, userId });
      }
      const updatedPreferences = await db.userPreferences.update({
        where: { userId },
        data: {
          ...data,
          updatedAt: /* @__PURE__ */ new Date()
        },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      });
      return updatedPreferences;
    } catch (error) {
      throw new Error(`Failed to update user preferences: ${error.message}`);
    }
  },
  // ================================
  // DELETE OPERATIONS
  // ================================
  async delete(id) {
    try {
      const existingPreferences = await db.userPreferences.findUnique({
        where: { id }
      });
      if (!existingPreferences) {
        throw new Error("User preferences not found");
      }
      await db.userPreferences.delete({
        where: { id }
      });
      return { success: true, message: "User preferences deleted successfully" };
    } catch (error) {
      throw new Error(`Failed to delete user preferences: ${error.message}`);
    }
  },
  async deleteByUserId(userId) {
    try {
      const user = await db.user.findUnique({
        where: { id: userId }
      });
      if (!user) {
        throw new Error("User not found");
      }
      const existingPreferences = await db.userPreferences.findUnique({
        where: { userId }
      });
      if (!existingPreferences) {
        throw new Error("User preferences not found");
      }
      await db.userPreferences.delete({
        where: { userId }
      });
      return { success: true, message: "User preferences deleted successfully" };
    } catch (error) {
      throw new Error(`Failed to delete user preferences: ${error.message}`);
    }
  },
  // ================================
  // RESET OPERATIONS
  // ================================
  async resetToDefaults(id) {
    try {
      const existingPreferences = await db.userPreferences.findUnique({
        where: { id }
      });
      if (!existingPreferences) {
        throw new Error("User preferences not found");
      }
      const resetPreferences = await db.userPreferences.update({
        where: { id },
        data: {
          theme: "light",
          primaryColor: null,
          sidebarCollapsed: false,
          compactMode: false,
          language: "pt-BR",
          currency: "BRL",
          timezone: "America/Sao_Paulo",
          dateFormat: "DD/MM/YYYY",
          timeFormat: "24h",
          numberFormat: "pt-BR",
          emailNotifications: true,
          pushNotifications: true,
          smsNotifications: false,
          notificationTypes: null,
          dashboardLayout: null,
          defaultPage: null,
          itemsPerPage: 20,
          defaultStoreId: null,
          autoRefresh: true,
          refreshInterval: 30,
          customSettings: null,
          updatedAt: /* @__PURE__ */ new Date()
        },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      });
      return resetPreferences;
    } catch (error) {
      throw new Error(`Failed to reset user preferences: ${error.message}`);
    }
  },
  async resetToDefaultsByUserId(userId) {
    try {
      const user = await db.user.findUnique({
        where: { id: userId }
      });
      if (!user) {
        throw new Error("User not found");
      }
      const existingPreferences = await db.userPreferences.findUnique({
        where: { userId }
      });
      if (!existingPreferences) {
        throw new Error("User preferences not found");
      }
      const resetPreferences = await db.userPreferences.update({
        where: { userId },
        data: {
          theme: "light",
          primaryColor: null,
          sidebarCollapsed: false,
          compactMode: false,
          language: "pt-BR",
          currency: "BRL",
          timezone: "America/Sao_Paulo",
          dateFormat: "DD/MM/YYYY",
          timeFormat: "24h",
          numberFormat: "pt-BR",
          emailNotifications: true,
          pushNotifications: true,
          smsNotifications: false,
          notificationTypes: null,
          dashboardLayout: null,
          defaultPage: null,
          itemsPerPage: 20,
          defaultStoreId: null,
          autoRefresh: true,
          refreshInterval: 30,
          customSettings: null,
          updatedAt: /* @__PURE__ */ new Date()
        },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      });
      return resetPreferences;
    } catch (error) {
      throw new Error(`Failed to reset user preferences: ${error.message}`);
    }
  },
  // ================================
  // BULK OPERATIONS
  // ================================
  async bulkUpdate(filters, data) {
    try {
      const result = await db.userPreferences.updateMany({
        where: filters,
        data: {
          ...data,
          updatedAt: /* @__PURE__ */ new Date()
        }
      });
      return {
        success: true,
        count: result.count,
        message: `${result.count} user preferences updated successfully`
      };
    } catch (error) {
      throw new Error(`Failed to bulk update user preferences: ${error.message}`);
    }
  },
  async bulkDelete(filters) {
    try {
      const result = await db.userPreferences.deleteMany({
        where: filters
      });
      return {
        success: true,
        count: result.count,
        message: `${result.count} user preferences deleted successfully`
      };
    } catch (error) {
      throw new Error(`Failed to bulk delete user preferences: ${error.message}`);
    }
  }
};

// src/features/user-preferences/user-preferences.controller.ts
var UserPreferencesController = {
  // === CRUD BÁSICO ===
  async create(request, reply) {
    try {
      const preferencesData = request.body;
      if ("storeId" in preferencesData) {
        preferencesData.defaultStoreId = preferencesData.storeId;
        delete preferencesData.storeId;
      }
      const result = await UserPreferencesCommands.create(preferencesData);
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "User preferences already exist for this user") {
        return reply.status(409).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      const result = await UserPreferencesQueries.getById(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User preferences not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      if ("storeId" in updateData) {
        updateData.defaultStoreId = updateData.storeId;
        delete updateData.storeId;
      }
      const result = await UserPreferencesCommands.update(id, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User preferences not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      await UserPreferencesCommands.delete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "User preferences not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { page = 1, limit = 10, search, theme, language, currency } = request.query;
      const result = await UserPreferencesQueries.list({
        page,
        limit,
        search,
        theme,
        language,
        currency
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (QUERIES) ===
  async getByUserId(request, reply) {
    try {
      const userId = request.user?.id;
      if (!userId) {
        return reply.status(401).send({
          error: "User not authenticated"
        });
      }
      const result = await UserPreferencesQueries.getByUserId(userId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User preferences not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByUserIdOrCreate(request, reply) {
    try {
      const userId = request.user?.id;
      if (!userId) {
        return reply.status(401).send({
          error: "User not authenticated"
        });
      }
      const result = await UserPreferencesQueries.getByUserIdOrCreate(userId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async updateByUserId(request, reply) {
    try {
      const userId = request.user?.id;
      if (!userId) {
        return reply.status(401).send({
          error: "User not authenticated"
        });
      }
      const updateData = request.body;
      if ("storeId" in updateData) {
        updateData.defaultStoreId = updateData.storeId;
        delete updateData.storeId;
      }
      const result = await UserPreferencesCommands.updateByUserId(userId, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async deleteByUserId(request, reply) {
    try {
      const userId = request.user?.id;
      if (!userId) {
        return reply.status(401).send({
          error: "User not authenticated"
        });
      }
      await UserPreferencesCommands.deleteByUserId(userId);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found" || error.message === "User preferences not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByTheme(request, reply) {
    try {
      const { theme } = request.query;
      const result = await UserPreferencesQueries.getByTheme(theme);
      return reply.send({ preferences: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByLanguage(request, reply) {
    try {
      const { language } = request.query;
      const result = await UserPreferencesQueries.getByLanguage(language);
      return reply.send({ preferences: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByCurrency(request, reply) {
    try {
      const { currency } = request.query;
      const result = await UserPreferencesQueries.getByCurrency(currency);
      return reply.send({ preferences: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getWithCustomSettings(request, reply) {
    try {
      const result = await UserPreferencesQueries.getWithCustomSettings();
      return reply.send({ preferences: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const result = await UserPreferencesQueries.getStats();
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { q, limit = 10 } = request.query;
      const result = await UserPreferencesQueries.search(q, limit);
      return reply.send({ preferences: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNÇÕES ADICIONAIS (COMMANDS) ===
  async resetToDefaults(request, reply) {
    try {
      const { id } = request.params;
      const result = await UserPreferencesCommands.resetToDefaults(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User preferences not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async resetToDefaultsByUserId(request, reply) {
    try {
      const userId = request.user?.id;
      if (!userId) {
        return reply.status(401).send({
          error: "User not authenticated"
        });
      }
      const result = await UserPreferencesCommands.resetToDefaultsByUserId(userId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found" || error.message === "User preferences not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async validatePreferences(request, reply) {
    try {
      const preferencesData = request.body;
      const result = await UserPreferencesQueries.validatePreferences(preferencesData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/user-preferences/user-preferences.schema.ts
var createUserPreferencesSchema = {
  body: {
    type: "object",
    required: ["userId"],
    properties: {
      userId: {
        type: "string",
        description: "User ID"
      },
      theme: {
        type: "string",
        enum: ["light", "dark", "auto"],
        default: "light",
        description: "Theme preference"
      },
      primaryColor: {
        type: "string",
        pattern: "^#[0-9A-Fa-f]{6}$",
        description: "Primary color in hex format"
      },
      sidebarCollapsed: {
        type: "boolean",
        default: false,
        description: "Whether sidebar is collapsed"
      },
      compactMode: {
        type: "boolean",
        default: false,
        description: "Whether to use compact mode"
      },
      language: {
        type: "string",
        default: "pt-BR",
        description: "Language preference"
      },
      currency: {
        type: "string",
        default: "BRL",
        description: "Currency preference"
      },
      timezone: {
        type: "string",
        default: "America/Sao_Paulo",
        description: "Timezone preference"
      },
      dateFormat: {
        type: "string",
        enum: ["DD/MM/YYYY", "MM/DD/YYYY", "YYYY-MM-DD"],
        default: "DD/MM/YYYY",
        description: "Date format preference"
      },
      timeFormat: {
        type: "string",
        enum: ["12h", "24h"],
        default: "24h",
        description: "Time format preference"
      },
      numberFormat: {
        type: "string",
        default: "pt-BR",
        description: "Number format preference"
      },
      emailNotifications: {
        type: "boolean",
        default: true,
        description: "Email notifications enabled"
      },
      pushNotifications: {
        type: "boolean",
        default: true,
        description: "Push notifications enabled"
      },
      smsNotifications: {
        type: "boolean",
        default: false,
        description: "SMS notifications enabled"
      },
      notificationTypes: {
        type: "object",
        description: "Specific notification types configuration"
      },
      dashboardLayout: {
        type: "object",
        description: "Dashboard layout configuration"
      },
      defaultPage: {
        type: "string",
        description: "Default page to load"
      },
      itemsPerPage: {
        type: "integer",
        minimum: 5,
        maximum: 100,
        default: 20,
        description: "Number of items per page"
      },
      defaultStoreId: {
        type: "string",
        description: "Default store ID"
      },
      autoRefresh: {
        type: "boolean",
        default: true,
        description: "Auto refresh enabled"
      },
      refreshInterval: {
        type: "integer",
        minimum: 10,
        maximum: 300,
        default: 30,
        description: "Refresh interval in seconds"
      },
      customSettings: {
        type: "object",
        description: "Custom settings configuration"
      }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        theme: { type: "string" },
        language: { type: "string" },
        currency: { type: "string" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    409: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var updateUserPreferencesSchema = {
  params: {
    type: "object",
    properties: {
      id: {
        type: "string",
        description: "User preferences ID"
      }
    },
    required: ["id"]
  },
  body: {
    type: "object",
    properties: {
      theme: {
        type: "string",
        enum: ["light", "dark", "auto"],
        description: "Theme preference"
      },
      primaryColor: {
        type: "string",
        pattern: "^#[0-9A-Fa-f]{6}$",
        description: "Primary color in hex format"
      },
      sidebarCollapsed: {
        type: "boolean",
        description: "Whether sidebar is collapsed"
      },
      compactMode: {
        type: "boolean",
        description: "Whether to use compact mode"
      },
      language: {
        type: "string",
        description: "Language preference"
      },
      currency: {
        type: "string",
        description: "Currency preference"
      },
      timezone: {
        type: "string",
        description: "Timezone preference"
      },
      dateFormat: {
        type: "string",
        enum: ["DD/MM/YYYY", "MM/DD/YYYY", "YYYY-MM-DD"],
        description: "Date format preference"
      },
      timeFormat: {
        type: "string",
        enum: ["12h", "24h"],
        description: "Time format preference"
      },
      numberFormat: {
        type: "string",
        description: "Number format preference"
      },
      emailNotifications: {
        type: "boolean",
        description: "Email notifications enabled"
      },
      pushNotifications: {
        type: "boolean",
        description: "Push notifications enabled"
      },
      smsNotifications: {
        type: "boolean",
        description: "SMS notifications enabled"
      },
      notificationTypes: {
        type: "object",
        description: "Specific notification types configuration"
      },
      dashboardLayout: {
        type: "object",
        description: "Dashboard layout configuration"
      },
      defaultPage: {
        type: "string",
        description: "Default page to load"
      },
      itemsPerPage: {
        type: "integer",
        minimum: 5,
        maximum: 100,
        description: "Number of items per page"
      },
      defaultStoreId: {
        type: "string",
        description: "Default store ID"
      },
      autoRefresh: {
        type: "boolean",
        description: "Auto refresh enabled"
      },
      refreshInterval: {
        type: "integer",
        minimum: 10,
        maximum: 300,
        description: "Refresh interval in seconds"
      },
      customSettings: {
        type: "object",
        description: "Custom settings configuration"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        theme: { type: "string" },
        language: { type: "string" },
        currency: { type: "string" },
        updatedAt: { type: "string", format: "date-time" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getUserPreferencesSchema = {
  params: {
    type: "object",
    properties: {
      id: {
        type: "string",
        description: "User preferences ID"
      }
    },
    required: ["id"]
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        theme: { type: "string" },
        primaryColor: { type: "string" },
        sidebarCollapsed: { type: "boolean" },
        compactMode: { type: "boolean" },
        language: { type: "string" },
        currency: { type: "string" },
        timezone: { type: "string" },
        dateFormat: { type: "string" },
        timeFormat: { type: "string" },
        numberFormat: { type: "string" },
        emailNotifications: { type: "boolean" },
        pushNotifications: { type: "boolean" },
        smsNotifications: { type: "boolean" },
        notificationTypes: { type: "object" },
        dashboardLayout: { type: "object" },
        defaultPage: { type: "string" },
        itemsPerPage: { type: "integer" },
        defaultStoreId: { type: "string" },
        autoRefresh: { type: "boolean" },
        refreshInterval: { type: "integer" },
        customSettings: { type: "object" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" }
          }
        }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var updateUserPreferencesMeSchema = {
  body: {
    type: "object",
    properties: {
      theme: {
        type: "string",
        enum: ["light", "dark", "auto"],
        description: "Theme preference"
      },
      primaryColor: {
        type: "string",
        pattern: "^#[0-9A-Fa-f]{6}$",
        description: "Primary color in hex format"
      },
      sidebarCollapsed: {
        type: "boolean",
        description: "Whether sidebar is collapsed"
      },
      compactMode: {
        type: "boolean",
        description: "Whether to use compact mode"
      },
      language: {
        type: "string",
        description: "Language preference"
      },
      currency: {
        type: "string",
        description: "Currency preference"
      },
      timezone: {
        type: "string",
        description: "Timezone preference"
      },
      dateFormat: {
        type: "string",
        description: "Date format preference"
      },
      timeFormat: {
        type: "string",
        enum: ["12h", "24h"],
        description: "Time format preference"
      },
      numberFormat: {
        type: "string",
        description: "Number format preference"
      },
      emailNotifications: {
        type: "boolean",
        description: "Email notifications preference"
      },
      pushNotifications: {
        type: "boolean",
        description: "Push notifications preference"
      },
      smsNotifications: {
        type: "boolean",
        description: "SMS notifications preference"
      },
      notificationTypes: {
        type: "object",
        description: "Notification types configuration"
      },
      dashboardLayout: {
        type: "object",
        description: "Dashboard layout configuration"
      },
      defaultPage: {
        type: "string",
        description: "Default page preference"
      },
      itemsPerPage: {
        type: "number",
        minimum: 1,
        maximum: 100,
        description: "Items per page preference"
      },
      defaultStoreId: {
        type: "string",
        description: "Default store ID"
      },
      autoRefresh: {
        type: "boolean",
        description: "Auto refresh preference"
      },
      refreshInterval: {
        type: "number",
        minimum: 1e3,
        maximum: 3e5,
        description: "Refresh interval in milliseconds"
      },
      customSettings: {
        type: "object",
        description: "Custom settings configuration"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        theme: { type: "string" },
        primaryColor: { type: "string" },
        sidebarCollapsed: { type: "boolean" },
        compactMode: { type: "boolean" },
        language: { type: "string" },
        currency: { type: "string" },
        timezone: { type: "string" },
        dateFormat: { type: "string" },
        timeFormat: { type: "string" },
        numberFormat: { type: "string" },
        emailNotifications: { type: "boolean" },
        pushNotifications: { type: "boolean" },
        smsNotifications: { type: "boolean" },
        notificationTypes: { type: "object" },
        dashboardLayout: { type: "object" },
        defaultPage: { type: "string" },
        itemsPerPage: { type: "number" },
        defaultStoreId: { type: "string" },
        autoRefresh: { type: "boolean" },
        refreshInterval: { type: "number" },
        customSettings: { type: "object" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" }
          }
        }
      }
    },
    401: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getUserPreferencesMeSchema = {
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        theme: { type: "string" },
        primaryColor: { type: "string" },
        sidebarCollapsed: { type: "boolean" },
        compactMode: { type: "boolean" },
        language: { type: "string" },
        currency: { type: "string" },
        timezone: { type: "string" },
        dateFormat: { type: "string" },
        timeFormat: { type: "string" },
        numberFormat: { type: "string" },
        emailNotifications: { type: "boolean" },
        pushNotifications: { type: "boolean" },
        smsNotifications: { type: "boolean" },
        notificationTypes: { type: "object" },
        dashboardLayout: { type: "object" },
        defaultPage: { type: "string" },
        itemsPerPage: { type: "number" },
        defaultStoreId: { type: "string" },
        autoRefresh: { type: "boolean" },
        refreshInterval: { type: "number" },
        customSettings: { type: "object" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" }
          }
        }
      }
    },
    401: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var deleteUserPreferencesSchema = {
  params: {
    type: "object",
    properties: {
      id: {
        type: "string",
        description: "User preferences ID"
      }
    },
    required: ["id"]
  },
  response: {
    204: {
      type: "null"
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var listUserPreferencesSchema = {
  querystring: {
    type: "object",
    properties: {
      page: {
        type: "integer",
        minimum: 1,
        default: 1,
        description: "Page number"
      },
      limit: {
        type: "integer",
        minimum: 1,
        maximum: 100,
        default: 10,
        description: "Items per page"
      },
      search: {
        type: "string",
        description: "Search term"
      },
      theme: {
        type: "string",
        enum: ["light", "dark", "auto"],
        description: "Filter by theme"
      },
      language: {
        type: "string",
        description: "Filter by language"
      },
      currency: {
        type: "string",
        description: "Filter by currency"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        preferences: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              userId: { type: "string" },
              theme: { type: "string" },
              language: { type: "string" },
              currency: { type: "string" },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "integer" },
            limit: { type: "integer" },
            total: { type: "integer" },
            totalPages: { type: "integer" }
          }
        }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getUserPreferencesStatsSchema = {
  response: {
    200: {
      type: "object",
      properties: {
        totalPreferences: { type: "integer" },
        themeDistribution: {
          type: "object",
          properties: {
            light: { type: "integer" },
            dark: { type: "integer" },
            auto: { type: "integer" }
          }
        },
        languageDistribution: {
          type: "object",
          additionalProperties: { type: "integer" }
        },
        currencyDistribution: {
          type: "object",
          additionalProperties: { type: "integer" }
        },
        averageItemsPerPage: { type: "integer" },
        notificationsEnabled: { type: "integer" },
        notificationsDisabled: { type: "integer" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var searchUserPreferencesSchema = {
  querystring: {
    type: "object",
    properties: {
      q: {
        type: "string",
        description: "Search query"
      },
      limit: {
        type: "integer",
        minimum: 1,
        maximum: 50,
        default: 10,
        description: "Maximum number of results"
      }
    },
    required: ["q"]
  },
  response: {
    200: {
      type: "object",
      properties: {
        preferences: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              userId: { type: "string" },
              theme: { type: "string" },
              language: { type: "string" },
              currency: { type: "string" },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" }
            }
          }
        }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var validateUserPreferencesSchema = {
  body: {
    type: "object",
    properties: {
      theme: {
        type: "string",
        enum: ["light", "dark", "auto"]
      },
      dateFormat: {
        type: "string",
        enum: ["DD/MM/YYYY", "MM/DD/YYYY", "YYYY-MM-DD"]
      },
      timeFormat: {
        type: "string",
        enum: ["12h", "24h"]
      },
      itemsPerPage: {
        type: "integer",
        minimum: 5,
        maximum: 100
      },
      refreshInterval: {
        type: "integer",
        minimum: 10,
        maximum: 300
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        isValid: { type: "boolean" },
        errors: {
          type: "array",
          items: { type: "string" }
        },
        warnings: {
          type: "array",
          items: { type: "string" }
        }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};

// src/features/user-preferences/user-preferences.routes.ts
async function UserPreferencesRoutes(fastify2) {
  fastify2.addHook("preHandler", authMiddleware);
  fastify2.addHook("preHandler", storeContextMiddleware);
  fastify2.post("/", {
    schema: createUserPreferencesSchema,
    handler: UserPreferencesController.create
  });
  fastify2.get("/", {
    schema: listUserPreferencesSchema,
    handler: UserPreferencesController.list
  });
  fastify2.get("/:id", {
    schema: getUserPreferencesSchema,
    handler: UserPreferencesController.get
  });
  fastify2.put("/:id", {
    schema: updateUserPreferencesSchema,
    handler: UserPreferencesController.update
  });
  fastify2.delete("/:id", {
    schema: deleteUserPreferencesSchema,
    handler: UserPreferencesController.delete
  });
  fastify2.get("/me", {
    schema: getUserPreferencesMeSchema,
    handler: UserPreferencesController.getByUserId
  });
  fastify2.get("/me/or-create", {
    schema: getUserPreferencesMeSchema,
    handler: UserPreferencesController.getByUserIdOrCreate
  });
  fastify2.put("/me", {
    schema: updateUserPreferencesMeSchema,
    handler: UserPreferencesController.updateByUserId
  });
  fastify2.delete("/me", {
    schema: getUserPreferencesMeSchema,
    handler: UserPreferencesController.deleteByUserId
  });
  fastify2.get("/theme/:theme", {
    handler: UserPreferencesController.getByTheme
  });
  fastify2.get("/language/:language", {
    handler: UserPreferencesController.getByLanguage
  });
  fastify2.get("/currency/:currency", {
    handler: UserPreferencesController.getByCurrency
  });
  fastify2.get("/custom-settings", {
    handler: UserPreferencesController.getWithCustomSettings
  });
  fastify2.get("/stats", {
    schema: getUserPreferencesStatsSchema,
    handler: UserPreferencesController.getStats
  });
  fastify2.get("/search", {
    schema: searchUserPreferencesSchema,
    handler: UserPreferencesController.search
  });
  fastify2.patch("/:id/reset", {
    schema: getUserPreferencesSchema,
    handler: UserPreferencesController.resetToDefaults
  });
  fastify2.patch("/me/reset", {
    schema: getUserPreferencesMeSchema,
    handler: UserPreferencesController.resetToDefaultsByUserId
  });
  fastify2.post("/validate", {
    schema: validateUserPreferencesSchema,
    handler: UserPreferencesController.validatePreferences
  });
}

// src/server.ts
var fastify = (0, import_fastify.default)({
  logger: true,
  requestTimeout: 6e4,
  // 30 segundos para timeout de requisições
  keepAliveTimeout: 5e3,
  // 5 segundos para keep-alive
  bodyLimit: 1048576,
  // 1MB para limite do body
  maxParamLength: 200
  // Limite de caracteres para parâmetros de rota
});
fastify.register(import_cors.default, {
  origin: true,
  // Permite todas as origens em desenvolvimento
  credentials: true,
  // Permite cookies e headers de autenticação
  methods: ["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"],
  allowedHeaders: ["Content-Type", "Authorization", "X-Requested-With"]
});
fastify.register(prismaPlugin);
fastify.register(require("@fastify/static"), {
  root: require("path").join(process.cwd(), "src", "uploads"),
  prefix: "/uploads/",
  decorateReply: false
});
connectPrisma(fastify);
fastify.get("/health", async (request, reply) => {
  try {
    const prisma2 = request.server.prisma;
    await prisma2.$queryRaw`SELECT 1`;
    return reply.send({
      status: "ok",
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      uptime: process.uptime(),
      database: "connected"
    });
  } catch (error) {
    request.log.error(error);
    return reply.status(503).send({
      status: "error",
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      uptime: process.uptime(),
      database: "disconnected",
      error: "Database connection failed"
    });
  }
});
fastify.get("/llm/rag", {
  preHandler: [authMiddleware, storeContextMiddleware]
}, async (request, reply) => {
  try {
    const productId = "cmg4ixgh90005e8vgqdn5k6qz";
    const query = "Qual a \xFAltima movimenta\xE7\xE3o de entrada do produto?";
    const response = await queryRAG(productId, query);
    return reply.send(response);
  } catch (error) {
    console.error("Error in RAG:", error);
    return reply.status(500).send({ error: "RAG processing failed" });
  }
});
fastify.register(AuthRoutes, { prefix: "/auth" });
fastify.register(UserRoutes, { prefix: "/users" });
fastify.register(ProductRoutes, { prefix: "/products" });
fastify.register(SupplierRoutes, { prefix: "/suppliers" });
fastify.register(StoreRoutes, { prefix: "/stores" });
fastify.register(CategoryRoutes, { prefix: "/categories" });
fastify.register(MovementRoutes, { prefix: "/movements" });
fastify.register(PermissionRoutes, { prefix: "/permissions" });
fastify.register(ReportRoutes, { prefix: "/reports" });
fastify.register(NotificationRoutes, { prefix: "/notifications" });
fastify.register(ChatRoutes, { prefix: "/chat" });
fastify.register(RoadmapRoutes, { prefix: "/roadmaps" });
fastify.register(UploadRoutes, { prefix: "/uploads" });
fastify.register(QuoteRoutes, { prefix: "/quotes" });
fastify.register(PlanRoutes, { prefix: "/plans" });
fastify.register(CustomerRoutes, { prefix: "/customers" });
fastify.register(InvoiceRoutes, { prefix: "/invoices" });
fastify.register(WebhookRoutes, { prefix: "/webhooks" });
fastify.register(CrmRoutes, { prefix: "/crm" });
fastify.register(UserPreferencesRoutes, { prefix: "/preferences" });
var PORT = Number(process.env.PORT) || 3e3;
var HOST = "0.0.0.0";
fastify.listen({ port: PORT, host: HOST }).then(() => {
  fastify.log.info(`\u{1F680} Servidor rodando na porta ${PORT}`);
  console.log(`\u2705 Servidor rodando em http://${HOST}:${PORT}`);
}).catch((err) => {
  fastify.log.error(err);
  console.error("\u274C Falha ao iniciar o servidor:", err);
  process.exit(1);
});
