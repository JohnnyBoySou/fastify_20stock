import { fetchAuth } from "@/services/http/fetch";

// === INTERFACES PARA USER PREFERENCES ===

export interface UserPreferencesData {
  // Theme & UI Preferences
  theme?: 'light' | 'dark' | 'auto'
  primaryColor?: string
  sidebarCollapsed?: boolean
  compactMode?: boolean
  
  // Language & Localization
  language?: string // pt-BR, en-US, es-ES
  currency?: string // BRL, USD, EUR
  timezone?: string
  dateFormat?: string // DD/MM/YYYY, MM/DD/YYYY, YYYY-MM-DD
  timeFormat?: '12h' | '24h'
  numberFormat?: string // pt-BR, en-US
  
  // Notification Preferences
  emailNotifications?: boolean
  pushNotifications?: boolean
  smsNotifications?: boolean
  notificationTypes?: any // JSON com tipos específicos
  
  // Dashboard & Layout
  dashboardLayout?: any // JSON com layout personalizado
  defaultPage?: string
  itemsPerPage?: number
  
  // Business Preferences
  defaultStoreId?: string
  autoRefresh?: boolean
  refreshInterval?: number
  
  // Advanced Settings
  customSettings?: any // JSON com configurações personalizadas
}

export interface UserPreferencesResponse {
  id: string
  userId: string
  theme: string
  primaryColor?: string
  sidebarCollapsed: boolean
  compactMode: boolean
  language: string
  currency: string
  timezone: string
  dateFormat: string
  timeFormat: string
  numberFormat: string
  emailNotifications: boolean
  pushNotifications: boolean
  smsNotifications: boolean
  notificationTypes?: any
  dashboardLayout?: any
  defaultPage?: string
  itemsPerPage: number
  defaultStoreId?: string
  autoRefresh: boolean
  refreshInterval: number
  customSettings?: any
  createdAt: Date
  updatedAt: Date
}

export interface UserPreferencesListResponse {
  preferences: UserPreferencesResponse[]
  pagination: {
    page: number
    limit: number
    total: number
    totalPages: number
  }
}

export interface CreateUserPreferencesRequest {
  userId: string
  theme?: 'light' | 'dark' | 'auto'
  primaryColor?: string
  sidebarCollapsed?: boolean
  compactMode?: boolean
  language?: string
  currency?: string
  timezone?: string
  dateFormat?: string
  timeFormat?: '12h' | '24h'
  numberFormat?: string
  emailNotifications?: boolean
  pushNotifications?: boolean
  smsNotifications?: boolean
  notificationTypes?: any
  dashboardLayout?: any
  defaultPage?: string
  itemsPerPage?: number
  defaultStoreId?: string
  autoRefresh?: boolean
  refreshInterval?: number
  customSettings?: any
}

export interface UpdateUserPreferencesRequest {
  theme?: 'light' | 'dark' | 'auto'
  primaryColor?: string
  sidebarCollapsed?: boolean
  compactMode?: boolean
  language?: string
  currency?: string
  timezone?: string
  dateFormat?: string
  timeFormat?: '12h' | '24h'
  numberFormat?: string
  emailNotifications?: boolean
  pushNotifications?: boolean
  smsNotifications?: boolean
  notificationTypes?: any
  dashboardLayout?: any
  defaultPage?: string
  itemsPerPage?: number
  defaultStoreId?: string
  autoRefresh?: boolean
  refreshInterval?: number
  customSettings?: any
}

export interface UserPreferencesStats {
  totalPreferences: number
  themeDistribution: {
    light: number
    dark: number
    auto: number
  }
  languageDistribution: {
    [key: string]: number
  }
  currencyDistribution: {
    [key: string]: number
  }
  averageItemsPerPage: number
  notificationsEnabled: number
  notificationsDisabled: number
}

export interface UserPreferencesValidation {
  isValid: boolean
  errors: string[]
  warnings: string[]
}

export interface UserPreferencesFilters {
  page?: number
  limit?: number
  search?: string
  theme?: string
  language?: string
  currency?: string
  timezone?: string
  hasCustomSettings?: boolean
  notificationsEnabled?: boolean
}

const URI = "/user-preferences";

export const UserPreferencesService = {
  // === CRUD BÁSICO ===
  create: (params: CreateUserPreferencesRequest): Promise<UserPreferencesResponse> => 
    fetchAuth(URI, { method: "POST", data: params as unknown as Record<string, unknown> }) as Promise<UserPreferencesResponse>,
  
  list: (params?: UserPreferencesFilters): Promise<UserPreferencesListResponse> => 
    fetchAuth(URI, { method: "GET", params }) as Promise<UserPreferencesListResponse>,
  
  get: (id: string): Promise<UserPreferencesResponse> => 
    fetchAuth(`${URI}/${id}`, { method: "GET" }) as Promise<UserPreferencesResponse>,
  
  update: (id: string, params: UpdateUserPreferencesRequest): Promise<UserPreferencesResponse> => 
    fetchAuth(`${URI}/${id}`, { method: "PUT", data: params as unknown as Record<string, unknown> }) as Promise<UserPreferencesResponse>,
  
  delete: (id: string): Promise<void> => 
    fetchAuth(`${URI}/${id}`, { method: "DELETE" }) as Promise<void>,

  // === FUNÇÕES ESPECÍFICAS POR USUÁRIO ===
  getByUserId: (userId: string): Promise<UserPreferencesResponse> => 
    fetchAuth(`${URI}/user/${userId}`, { method: "GET" }) as Promise<UserPreferencesResponse>,
  
  getByUserIdOrCreate: (userId: string): Promise<UserPreferencesResponse> => 
    fetchAuth(`${URI}/user/${userId}/or-create`, { method: "GET" }) as Promise<UserPreferencesResponse>,
  
  updateByUserId: (userId: string, params: UpdateUserPreferencesRequest): Promise<UserPreferencesResponse> => 
    fetchAuth(`${URI}/user/${userId}`, { method: "PUT", data: params as unknown as Record<string, unknown> }) as Promise<UserPreferencesResponse>,
  
  deleteByUserId: (userId: string): Promise<void> => 
    fetchAuth(`${URI}/user/${userId}`, { method: "DELETE" }) as Promise<void>,

  // === CONSULTAS ESPECÍFICAS ===
  getByTheme: (theme: string): Promise<{ preferences: UserPreferencesResponse[] }> => 
    fetchAuth(`${URI}/theme/${theme}`, { method: "GET" }) as Promise<{ preferences: UserPreferencesResponse[] }>,
  
  getByLanguage: (language: string): Promise<{ preferences: UserPreferencesResponse[] }> => 
    fetchAuth(`${URI}/language/${language}`, { method: "GET" }) as Promise<{ preferences: UserPreferencesResponse[] }>,
  
  getByCurrency: (currency: string): Promise<{ preferences: UserPreferencesResponse[] }> => 
    fetchAuth(`${URI}/currency/${currency}`, { method: "GET" }) as Promise<{ preferences: UserPreferencesResponse[] }>,
  
  getWithCustomSettings: (): Promise<{ preferences: UserPreferencesResponse[] }> => 
    fetchAuth(`${URI}/custom-settings`, { method: "GET" }) as Promise<{ preferences: UserPreferencesResponse[] }>,
  
  getStats: (): Promise<UserPreferencesStats> => 
    fetchAuth(`${URI}/stats`, { method: "GET" }) as Promise<UserPreferencesStats>,
  
  search: (q: string, limit?: number): Promise<{ preferences: UserPreferencesResponse[] }> => 
    fetchAuth(`${URI}/search`, { method: "GET", params: { q, limit } }) as Promise<{ preferences: UserPreferencesResponse[] }>,

  // === FUNÇÕES DE RESET ===
  resetToDefaults: (id: string): Promise<UserPreferencesResponse> => 
    fetchAuth(`${URI}/${id}/reset`, { method: "PATCH" }) as Promise<UserPreferencesResponse>,
  
  resetToDefaultsByUserId: (userId: string): Promise<UserPreferencesResponse> => 
    fetchAuth(`${URI}/user/${userId}/reset`, { method: "PATCH" }) as Promise<UserPreferencesResponse>,

  // === VALIDAÇÃO ===
  validatePreferences: (params: UserPreferencesData): Promise<UserPreferencesValidation> => 
    fetchAuth(`${URI}/validate`, { method: "POST", data: params as unknown as Record<string, unknown> }) as Promise<UserPreferencesValidation>,

  // === UTILITÁRIOS PARA FRONTEND ===
  
  // Obter preferências do usuário atual (com fallback para padrões)
  getCurrentUserPreferences: async (userId: string): Promise<UserPreferencesResponse> => {
    try {
      return await UserPreferencesService.getByUserId(userId);
    } catch (error) {
      // Se não encontrar, cria com configurações padrão
      return await UserPreferencesService.getByUserIdOrCreate(userId);
    }
  },

  // Atualizar preferência específica
  updatePreference: async (userId: string, key: keyof UserPreferencesData, value: any): Promise<UserPreferencesResponse> => {
    const updateData = { [key]: value } as UpdateUserPreferencesRequest;
    return await UserPreferencesService.updateByUserId(userId, updateData);
  },

  // Alternar tema
  toggleTheme: async (userId: string): Promise<UserPreferencesResponse> => {
    const current = await UserPreferencesService.getByUserId(userId);
    const newTheme = current.theme === 'light' ? 'dark' : 'light';
    return await UserPreferencesService.updatePreference(userId, 'theme', newTheme);
  },

  // Alternar sidebar
  toggleSidebar: async (userId: string): Promise<UserPreferencesResponse> => {
    const current = await UserPreferencesService.getByUserId(userId);
    return await UserPreferencesService.updatePreference(userId, 'sidebarCollapsed', !current.sidebarCollapsed);
  },

  // Alternar modo compacto
  toggleCompactMode: async (userId: string): Promise<UserPreferencesResponse> => {
    const current = await UserPreferencesService.getByUserId(userId);
    return await UserPreferencesService.updatePreference(userId, 'compactMode', !current.compactMode);
  },

  // Alternar notificações por email
  toggleEmailNotifications: async (userId: string): Promise<UserPreferencesResponse> => {
    const current = await UserPreferencesService.getByUserId(userId);
    return await UserPreferencesService.updatePreference(userId, 'emailNotifications', !current.emailNotifications);
  },

  // Alternar notificações push
  togglePushNotifications: async (userId: string): Promise<UserPreferencesResponse> => {
    const current = await UserPreferencesService.getByUserId(userId);
    return await UserPreferencesService.updatePreference(userId, 'pushNotifications', !current.pushNotifications);
  },

  // Definir idioma
  setLanguage: async (userId: string, language: string): Promise<UserPreferencesResponse> => {
    return await UserPreferencesService.updatePreference(userId, 'language', language);
  },

  // Definir moeda
  setCurrency: async (userId: string, currency: string): Promise<UserPreferencesResponse> => {
    return await UserPreferencesService.updatePreference(userId, 'currency', currency);
  },

  // Definir timezone
  setTimezone: async (userId: string, timezone: string): Promise<UserPreferencesResponse> => {
    return await UserPreferencesService.updatePreference(userId, 'timezone', timezone);
  },

  // Definir formato de data
  setDateFormat: async (userId: string, dateFormat: string): Promise<UserPreferencesResponse> => {
    return await UserPreferencesService.updatePreference(userId, 'dateFormat', dateFormat);
  },

  // Definir formato de hora
  setTimeFormat: async (userId: string, timeFormat: '12h' | '24h'): Promise<UserPreferencesResponse> => {
    return await UserPreferencesService.updatePreference(userId, 'timeFormat', timeFormat);
  },

  // Definir itens por página
  setItemsPerPage: async (userId: string, itemsPerPage: number): Promise<UserPreferencesResponse> => {
    return await UserPreferencesService.updatePreference(userId, 'itemsPerPage', itemsPerPage);
  },

  // Definir página padrão
  setDefaultPage: async (userId: string, defaultPage: string): Promise<UserPreferencesResponse> => {
    return await UserPreferencesService.updatePreference(userId, 'defaultPage', defaultPage);
  },

  // Definir loja padrão
  setDefaultStore: async (userId: string, defaultStoreId: string): Promise<UserPreferencesResponse> => {
    return await UserPreferencesService.updatePreference(userId, 'defaultStoreId', defaultStoreId);
  },

  // Configurar auto refresh
  setAutoRefresh: async (userId: string, autoRefresh: boolean, refreshInterval?: number): Promise<UserPreferencesResponse> => {
    const updateData: UpdateUserPreferencesRequest = { autoRefresh };
    if (refreshInterval !== undefined) {
      updateData.refreshInterval = refreshInterval;
    }
    return await UserPreferencesService.updateByUserId(userId, updateData);
  },

  // Atualizar configurações personalizadas
  updateCustomSettings: async (userId: string, customSettings: any): Promise<UserPreferencesResponse> => {
    return await UserPreferencesService.updatePreference(userId, 'customSettings', customSettings);
  },

  // Atualizar layout do dashboard
  updateDashboardLayout: async (userId: string, dashboardLayout: any): Promise<UserPreferencesResponse> => {
    return await UserPreferencesService.updatePreference(userId, 'dashboardLayout', dashboardLayout);
  },

  // Atualizar tipos de notificação
  updateNotificationTypes: async (userId: string, notificationTypes: any): Promise<UserPreferencesResponse> => {
    return await UserPreferencesService.updatePreference(userId, 'notificationTypes', notificationTypes);
  },

  // Obter configurações padrão
  getDefaultPreferences: (): UserPreferencesData => ({
    theme: 'light',
    primaryColor: '#3b82f6',
    sidebarCollapsed: false,
    compactMode: false,
    language: 'pt-BR',
    currency: 'BRL',
    timezone: 'America/Sao_Paulo',
    dateFormat: 'DD/MM/YYYY',
    timeFormat: '24h',
    numberFormat: 'pt-BR',
    emailNotifications: true,
    pushNotifications: true,
    smsNotifications: false,
    notificationTypes: {},
    dashboardLayout: {},
    defaultPage: 'dashboard',
    itemsPerPage: 10,
    autoRefresh: true,
    refreshInterval: 30000,
    customSettings: {}
  }),

  // Validar configurações antes de salvar
  validateBeforeSave: async (preferences: UserPreferencesData): Promise<UserPreferencesValidation> => {
    return await UserPreferencesService.validatePreferences(preferences);
  },

  // === KEYS PARA CACHE (React Query) ===
  keys: {
    list: (page: number) => ["user-preferences", "list", page.toString()],
    single: (id: string) => ["user-preferences", "single", id],
    byUserId: (userId: string) => ["user-preferences", "byUserId", userId],
    byUserIdOrCreate: (userId: string) => ["user-preferences", "byUserIdOrCreate", userId],
    byTheme: (theme: string) => ["user-preferences", "byTheme", theme],
    byLanguage: (language: string) => ["user-preferences", "byLanguage", language],
    byCurrency: (currency: string) => ["user-preferences", "byCurrency", currency],
    withCustomSettings: ["user-preferences", "withCustomSettings"],
    stats: ["user-preferences", "stats"],
    search: (q: string) => ["user-preferences", "search", q],
    validate: ["user-preferences", "validate"],
    create: ["user-preferences"],
    update: ["user-preferences"],
    delete: ["user-preferences"],
    reset: ["user-preferences", "reset"],
  }
};