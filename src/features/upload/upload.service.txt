import { fetchAuth } from "@/services/http/fetch";

// === INTERFACES PARA UPLOAD ===

export interface Upload {
    id: string;
    url: string;
    name?: string;
    type?: string;
    size?: number;
    createdAt: string;
    updatedAt: string;
}

export interface UploadListResponse {
    uploads: Upload[];
    pagination: {
        page: number;
        limit: number;
        total: number;
        totalPages: number;
    };
}

export interface CreateUploadRequest {
    name?: string;
    type?: string;
    size?: number;
}

export interface UpdateUploadRequest {
    name?: string;
    type?: string;
    size?: number;
}

export interface AttachMediaRequest {
    entityType: 'product' | 'supplier' | 'user' | 'store';
    entityId: string;
    isPrimary?: boolean;
}

export interface DetachMediaRequest {
    entityType: 'product' | 'supplier' | 'user' | 'store';
    entityId: string;
}

export interface MediaAttachment {
    id: string;
    mediaId: string;
    entityType: string;
    entityId: string;
    isPrimary?: boolean;
    createdAt: string;
    media: Upload;
}

export interface EntityMediaResponse {
    media: MediaAttachment[];
}

export interface PrimaryMediaResponse {
    media: Upload;
}

export interface UploadStats {
    total: number;
    byType: Record<string, number>;
    totalSize: number;
    recentCount: number;
}

export interface MediaUsage {
    usage: Array<{
        entityType: string;
        entityId: string;
        isPrimary?: boolean;
        createdAt: string;
    }>;
}

export interface BulkDeleteRequest {
    ids: string[];
}

export interface BulkDeleteResponse {
    deleted: number;
    failed: number;
}

const URI = "/uploads";

export const UploadService = {
    // === CRUD B√ÅSICO ===
    create: (params: CreateUploadRequest): Promise<Upload> => 
        fetchAuth(URI, { method: "POST", data: params as unknown as Record<string, unknown> }) as Promise<Upload>,
    
    list: (params?: { 
        page?: number; 
        limit?: number; 
        search?: string; 
        type?: string;
        entityType?: 'product' | 'supplier' | 'user' | 'store';
        entityId?: string;
    }): Promise<UploadListResponse> => 
        fetchAuth(URI, { method: "GET", params }) as Promise<UploadListResponse>,
    
    get: (id: string): Promise<Upload> => 
        fetchAuth(`${URI}/${id}`, { method: "GET" }) as Promise<Upload>,
    
    update: (id: string, params: UpdateUploadRequest): Promise<Upload> => 
        fetchAuth(`${URI}/${id}`, { method: "PUT", data: params as unknown as Record<string, unknown> }) as Promise<Upload>,
    
    delete: (id: string): Promise<void> => 
        fetchAuth(`${URI}/${id}`, { method: "DELETE" }) as Promise<void>,

    // === CONSULTAS ESPEC√çFICAS ===
    getByType: (type: string): Promise<{ uploads: Upload[] }> => 
        fetchAuth(`${URI}/type/${type}`, { method: "GET" }) as Promise<{ uploads: Upload[] }>,
    
    getRecent: (limit?: number): Promise<{ uploads: Upload[] }> => 
        fetchAuth(`${URI}/recent`, { method: "GET", params: { limit } }) as Promise<{ uploads: Upload[] }>,
    
    getStats: (): Promise<UploadStats> => 
        fetchAuth(`${URI}/stats`, { method: "GET" }) as Promise<UploadStats>,
    
    search: (q: string, limit?: number): Promise<{ uploads: Upload[] }> => 
        fetchAuth(`${URI}/search`, { method: "GET", params: { q, limit } }) as Promise<{ uploads: Upload[] }>,
    
    getUnused: (limit?: number): Promise<{ uploads: Upload[] }> => 
        fetchAuth(`${URI}/unused`, { method: "GET", params: { limit } }) as Promise<{ uploads: Upload[] }>,

    // === GEST√ÉO DE ANEXOS ===
    attachMedia: (id: string, params: AttachMediaRequest): Promise<MediaAttachment> => 
        fetchAuth(`${URI}/${id}/attach`, { method: "POST", data: params as unknown as Record<string, unknown> }) as Promise<MediaAttachment>,
    
    detachMedia: (id: string, params: DetachMediaRequest): Promise<{ success: boolean }> => 
        fetchAuth(`${URI}/${id}/detach`, { method: "POST", data: params as unknown as Record<string, unknown> }) as Promise<{ success: boolean }>,
    
    setPrimaryMedia: (id: string, params: DetachMediaRequest): Promise<{ success: boolean }> => 
        fetchAuth(`${URI}/${id}/set-primary`, { method: "PATCH", data: params as unknown as Record<string, unknown> }) as Promise<{ success: boolean }>,
    
    getEntityMedia: (entityType: string, entityId: string): Promise<EntityMediaResponse> => 
        fetchAuth(`${URI}/entity/${entityType}/${entityId}`, { method: "GET" }) as Promise<EntityMediaResponse>,
    
    getPrimaryMedia: (entityType: string, entityId: string): Promise<PrimaryMediaResponse> => 
        fetchAuth(`${URI}/entity/${entityType}/${entityId}/primary`, { method: "GET" }) as Promise<PrimaryMediaResponse>,

    // === INFORMA√á√ïES DE USO ===
    getMediaUsage: (id: string): Promise<MediaUsage> => 
        fetchAuth(`${URI}/${id}/usage`, { method: "GET" }) as Promise<MediaUsage>,

    // === OPERA√á√ïES EM LOTE ===
    bulkDelete: (params: BulkDeleteRequest): Promise<BulkDeleteResponse> => 
        fetchAuth(`${URI}/bulk-delete`, { method: "POST", data: params as unknown as Record<string, unknown> }) as Promise<BulkDeleteResponse>,

    // === UTILIT√ÅRIOS PARA FRONTEND ===
    
    // Upload de arquivo com progress
    uploadFile: async (file: File, onProgress?: (progress: number) => void): Promise<Upload> => {
        const formData = new FormData();
        formData.append('file', file);
        
        // Simular progresso (voc√™ pode implementar progresso real aqui)
        if (onProgress) {
            onProgress(0);
            setTimeout(() => onProgress(50), 500);
            setTimeout(() => onProgress(100), 1000);
        }
        
        return fetchAuth(`${URI}/upload`, { 
            method: "POST", 
            data: formData,
            headers: {
                'Content-Type': 'multipart/form-data'
            }
        }) as Promise<Upload>;
    },

    // Upload m√∫ltiplos arquivos
    uploadMultipleFiles: async (files: File[], onProgress?: (progress: number) => void): Promise<Upload[]> => {
        const uploadPromises = files.map((file, index) => 
            UploadService.uploadFile(file, (progress) => {
                if (onProgress) {
                    const totalProgress = ((index + progress / 100) / files.length) * 100;
                    onProgress(totalProgress);
                }
            })
        );
        
        return Promise.all(uploadPromises);
    },

    // Obter URL de preview
    getPreviewUrl: (upload: Upload): string => {
        return upload.url;
    },

    // Verificar se √© imagem
    isImage: (upload: Upload): boolean => {
        if (!upload.type) return false;
        return upload.type.startsWith('image/');
    },

    // Verificar se √© v√≠deo
    isVideo: (upload: Upload): boolean => {
        if (!upload.type) return false;
        return upload.type.startsWith('video/');
    },

    // Verificar se √© documento
    isDocument: (upload: Upload): boolean => {
        if (!upload.type) return false;
        const documentTypes = [
            'application/pdf',
            'application/msword',
            'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
            'application/vnd.ms-excel',
            'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
            'text/plain'
        ];
        return documentTypes.includes(upload.type);
    },

    // Formatar tamanho do arquivo
    formatFileSize: (bytes?: number): string => {
        if (!bytes) return '0 B';
        
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(1024));
        return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i];
    },

    // Obter √≠cone baseado no tipo
    getFileIcon: (upload: Upload): string => {
        if (!upload.type) return 'üìÑ';
        
        if (upload.type.startsWith('image/')) return 'üñºÔ∏è';
        if (upload.type.startsWith('video/')) return 'üé•';
        if (upload.type.startsWith('audio/')) return 'üéµ';
        if (upload.type === 'application/pdf') return 'üìï';
        if (upload.type.includes('word')) return 'üìù';
        if (upload.type.includes('excel') || upload.type.includes('spreadsheet')) return 'üìä';
        if (upload.type.includes('powerpoint') || upload.type.includes('presentation')) return 'üìΩÔ∏è';
        if (upload.type.includes('zip') || upload.type.includes('rar')) return 'üì¶';
        
        return 'üìÑ';
    },

    // === KEYS PARA CACHE (React Query) ===
    keys: {
        list: (page: number) => ["uploads", "list", page.toString()],
        single: (id: string) => ["upload", "single", id],
        create: ["uploads"],
        update: ["upload"],
        delete: ["upload"],
        search: (q: string) => ["uploads", "search", q],
        stats: ["uploads", "stats"],
        recent: ["uploads", "recent"],
        byType: (type: string) => ["uploads", "byType", type],
        unused: ["uploads", "unused"],
        entityMedia: (entityType: string, entityId: string) => ["uploads", "entityMedia", entityType, entityId],
        primaryMedia: (entityType: string, entityId: string) => ["uploads", "primaryMedia", entityType, entityId],
        mediaUsage: (id: string) => ["uploads", "mediaUsage", id],
        bulkDelete: ["uploads", "bulkDelete"],
    }
};